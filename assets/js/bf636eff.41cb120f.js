"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[2369],{933:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/materialization-new-bbe45dcc13bded994190ac75f86dc01f.svg"},4684:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/materialization-13219c2248a49327c4c97340d0216bed.gif"},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var i=t(96540);const a={},o=i.createContext(a);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:n},e.children)}},49935:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"concepts/materialization","title":"Materializations","description":"A materialization is how Flow pushes data to an external destination.","source":"@site/docs/concepts/materialization.md","sourceDirName":"concepts","slug":"/concepts/materialization","permalink":"/concepts/materialization","draft":false,"unlisted":false,"editUrl":"https://github.com/estuary/flow/edit/master/site/docs/concepts/materialization.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Collections","permalink":"/concepts/collections"},"next":{"title":"Connectors","permalink":"/concepts/connectors"}}');var a=t(74848),o=t(28453);const s={sidebar_position:4},r="Materializations",l={},c=[{value:"Discovery",id:"discovery",level:2},{value:"Specification",id:"specification",level:2},{value:"How continuous materialization works",id:"how-continuous-materialization-works",level:2},{value:"Projected fields",id:"projected-fields",level:2},{value:"Partition selectors",id:"partition-selectors",level:2},{value:"Destination-specific performance",id:"destination-specific-performance",level:2},{value:"Delta updates",id:"delta-updates",level:2},{value:"Delta updates for every binding in a Materialization",id:"delta-updates-for-every-binding-in-a-materialization",level:3},{value:"Using <code>sourceCapture</code> to synchronize capture and materialization bindings",id:"using-sourcecapture-to-synchronize-capture-and-materialization-bindings",level:2},{value:"Schema and Table Names in Destinations",id:"schema-and-table-names-in-destinations",level:2},{value:"Schema Naming Hierarchy",id:"schema-naming-hierarchy",level:3},{value:"Target Resource Naming Convention Options",id:"target-resource-naming-convention-options",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"materializations",children:"Materializations"})}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.strong,{children:"materialization"})," is how Flow pushes data to an external destination."]}),"\n",(0,a.jsxs)(n.p,{children:["Materializations are a type of Flow ",(0,a.jsx)(n.strong,{children:"task"}),".\nThey connect to an external destination system,\nor ",(0,a.jsx)(n.strong,{children:"endpoint"}),", and bind one or more Flow collections to resources at the endpoint, such as database tables."]}),"\n",(0,a.jsxs)(n.p,{children:["As documents added to the bound collections,\nthe materialization continuously pushes it to the destination resources, where it is reflected with very low latency.\nMaterializations can process ",(0,a.jsx)(n.a,{href:"/concepts/collections#documents",children:"documents"})," up to 16 MB in size."]}),"\n",(0,a.jsxs)(n.p,{children:["Materializations are the conceptual inverse of ",(0,a.jsx)(n.a,{href:"/concepts/captures",children:"captures"}),"."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(933).A+"",width:"960",height:"540"})}),"\n",(0,a.jsxs)(n.p,{children:["You define and configure materializations in ",(0,a.jsx)(n.strong,{children:"Flow specifications"}),"."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"/guides/create-dataflow#create-a-materialization",children:"See the guide to create a materialization"})}),"\n",(0,a.jsx)(n.h2,{id:"discovery",children:"Discovery"}),"\n",(0,a.jsxs)(n.p,{children:["Materializations use real-time ",(0,a.jsx)(n.a,{href:"/concepts/connectors",children:"connectors"})," to connect to many endpoint types."]}),"\n",(0,a.jsxs)(n.p,{children:["When you use a materialization connector in the Flow web app,\nFlow helps you configure it through the ",(0,a.jsx)(n.strong,{children:"discovery"})," workflow."]}),"\n",(0,a.jsxs)(n.p,{children:["To begin discovery, you tell Flow the connector you'd like to use, basic information about the endpoint,\nand the collection(s) you'd like to materialize there.\nFlow maps the collection(s) to one or more ",(0,a.jsx)(n.strong,{children:"resources"})," \u2014 tables, data streams, or the equivalent \u2014\nthrough one or more ",(0,a.jsx)(n.strong,{children:"bindings"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"You may then modify the generated configuration as needed before publishing the materialization."}),"\n",(0,a.jsx)(n.h2,{id:"specification",children:"Specification"}),"\n",(0,a.jsx)(n.p,{children:"Materializations are defined in Flow specification files per the following format:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"# A set of materializations to include in the catalog.\n# Optional, type: object\nmaterializations:\n  # The name of the materialization.\n  acmeCo/example/database-views:\n    # Endpoint defines how to connect to the destination of the materialization.\n    # Required, type: object\n    endpoint:\n      # This endpoint uses a connector provided as a Docker image.\n      connector:\n        # Docker image that implements the materialization connector.\n        image: ghcr.io/estuary/materialize-postgres:dev\n        # File that provides the connector's required configuration.\n        # Configuration may also be presented inline.\n        config: path/to/connector-config.yaml\n\n    # Bindings define how one or more collections map to materialized endpoint resources.\n    # A single materialization may include many collections and endpoint resources,\n    # each defined as a separate binding.\n    # Required, type: object\n    bindings:\n      - # Source collection read by this binding.\n        # Required, type: object or string\n        source:\n          # Name of the collection to be read.\n          # Required.\n          name: acmeCo/example/collection\n          # Lower bound date-time for documents which should be processed.\n          # Source collection documents published before this date-time are filtered.\n          # `notBefore` is *only* a filter. Updating its value will not cause Flow\n          # to re-process documents that have already been read.\n          # Optional. Default is to process all documents.\n          notBefore: 2023-01-23T01:00:00Z\n          # Upper bound date-time for documents which should be processed.\n          # Source collection documents published after this date-time are filtered.\n          # Like `notBefore`, `notAfter` is *only* a filter. Updating its value will\n          # not cause Flow to re-process documents that have already been read.\n          # Optional. Default is to process all documents.\n          notAfter: 2023-01-23T02:00:00Z\n\n        # The resource is additional configuration required by the endpoint\n        # connector to identify and materialize a specific endpoint resource.\n        # The structure and meaning of this configuration is defined by\n        # the specific connector.\n        # Required, type: object\n        resource:\n          # The materialize-postgres connector expects a `table` key\n          # which names a table to materialize into.\n          table: example_table\n\n        # Priority applied to documents processed by this binding.\n        # When all bindings are of equal priority, documents are processed\n        # in order of their associated publishing time.\n        #\n        # However, when one binding has a higher priority than others,\n        # then *all* ready documents are processed through the binding\n        # before *any* documents of other bindings are processed.\n        #\n        # Optional. Default: 0, integer >= 0\n        priority: 0\n\n    # A sourceCapture allows bindings to be managed automatically based on the\n    # bindings of the given capture. As new bindings are added to the capture,\n    # they will automatically be added to the materialization. This property\n    # is optional.\n    sourceCapture: acmeCo/example/a-capture\n"})}),"\n",(0,a.jsx)(n.h2,{id:"how-continuous-materialization-works",children:"How continuous materialization works"}),"\n",(0,a.jsxs)(n.p,{children:["Flow materializations are ",(0,a.jsx)(n.strong,{children:"continuous materialized views"}),".\nThey maintain a representation of the collection within the endpoint system\nthat is updated in near real-time. It's indexed on the\n",(0,a.jsx)(n.a,{href:"/concepts/collections#keys",children:"collection key"}),".\nAs the materialization runs, it ensures that all collection documents\nand their accumulated ",(0,a.jsx)(n.a,{href:"../#reductions",children:"reductions"})," are reflected in this\nmanaged endpoint resource."]}),"\n",(0,a.jsx)(n.p,{children:"When you first publish a materialization,\nFlow back-fills the endpoint resource with the historical documents of the collection.\nOnce caught up, Flow applies new collection documents using incremental and low-latency updates."}),"\n",(0,a.jsx)(n.p,{children:"As collection documents arrive, Flow:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reads"})," previously materialized documents from the endpoint for the relevant keys"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reduces"})," new documents into these read documents"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Writes"})," updated documents back into the endpoint resource, indexed by their keys"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"For example, consider a collection and its materialization:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"\ncollections:\n  acmeCo/colors:\n    key: [/color]\n    schema:\n      type: object\n      required: [color, total]\n      reduce: {strategy: merge}\n      properties:\n        color: {enum: [red, blue, purple]}\n        total:\n          type: integer\n          reduce: {strategy: sum}\n\nmaterializations:\n  acmeCo/example/database-views:\n    endpoint: ...\n    bindings:\n      - source: acmeCo/colors\n        resource: { table: colors }\n"})}),"\n",(0,a.jsx)(n.p,{children:"Suppose documents are periodically added to the collection:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{"color": "red", "total": 1}\n{"color": "blue", "total": 2}\n{"color": "blue", "total": 3}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Its materialization into a database table will have a single row for each unique color.\nAs documents arrive in the collection, the row ",(0,a.jsx)(n.code,{children:"total"})," is updated within the\nmaterialized table so that it reflects the overall count:"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(4684).A+"",width:"769",height:"322"})}),"\n",(0,a.jsxs)(n.p,{children:["Flow does ",(0,a.jsx)(n.em,{children:"not"}),' keep separate internal copies of collection or reduction states,\nas some other systems do. The endpoint resource is the one and only place\nwhere state "lives" within a materialization. This makes materializations very\nefficient and scalable to operate. They are able to maintain ',(0,a.jsx)(n.em,{children:"very"})," large tables\nstored in highly scaled storage systems like OLAP data warehouses."]}),"\n",(0,a.jsx)(n.h2,{id:"projected-fields",children:"Projected fields"}),"\n",(0,a.jsxs)(n.p,{children:["Many endpoint systems are document-oriented and can directly work\nwith collections of JSON documents.\nOthers are table-oriented and require an up-front declaration\nof columns and types to be most useful, such as a SQL ",(0,a.jsx)(n.code,{children:"CREATE TABLE"})," definition."]}),"\n",(0,a.jsxs)(n.p,{children:["Flow uses collection ",(0,a.jsx)(n.a,{href:"/concepts/advanced/projections",children:"projections"})," to relate locations within\na hierarchical JSON document to equivalent named fields.\nA materialization can in turn select a subset of available projected fields\nwhere, for example, each field becomes a column in a SQL table created by\nthe connector."]}),"\n",(0,a.jsxs)(n.p,{children:["It would be tedious to explicitly list projections for every materialization,\nthough you certainly can if desired.\nInstead, Flow and the materialization connector ",(0,a.jsx)(n.em,{children:"negotiate"})," a recommended field selection\non your behalf, which can be fine-tuned.\nFor example, a SQL database connector will typically ",(0,a.jsx)(n.em,{children:"require"})," that fields\ncomprising the primary key be included, and will ",(0,a.jsx)(n.em,{children:"recommend"})," that scalar\nvalues be included, but will by default exclude document locations that\ndon't have native SQL representations, such as locations which can have\nmultiple JSON types or are arrays or maps."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"materializations:\n  acmeCo/example/database-views:\n    endpoint: ...\n    bindings:\n      - source: acmeCo/example/collection\n        resource: { table: example_table }\n\n        # Select (or exclude) projections of the collection for materialization as fields.\n        # If not provided, the recommend fields of the endpoint connector are used.\n        # Optional, type: object\n        fields:\n          # Whether to include fields that are recommended by the endpoint connector.\n          # If false, then fields can still be added using `include`.\n          # Required, type: boolean\n          recommended: true\n\n          # Fields to exclude. This is useful for deselecting a subset of recommended fields.\n          # Default: [], type: array\n          exclude: [myField, otherField]\n\n          # Fields to require. This can supplement recommended fields, or can\n          # designate explicit fields to use if recommended fields are disabled.\n          #\n          # Values of this map are used to customize connector behavior on a per-field basis.\n          # They are passed directly to the connector and are not interpreted by Flow.\n          # Consult your connector's documentation for details of what customizations are available.\n          # This is an advanced feature and is not commonly used.\n          #\n          # default: {}, type: object\n          require:  {goodField: {}, greatField: {}}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"partition-selectors",children:"Partition selectors"}),"\n",(0,a.jsxs)(n.p,{children:["Partition selectors let you materialize only a subset of a collection that has\n",(0,a.jsx)(n.a,{href:"/concepts/advanced/projections#logical-partitions",children:"logical partitions"}),".\nFor example, you might have a large collection that is logically partitioned\non each of your customers:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"collections:\n  acmeCo/anvil/orders:\n    key: [/id]\n    schema: orders.schema.yaml\n    projections:\n      customer:\n        location: /order/customer\n        partition: true\n"})}),"\n",(0,a.jsx)(n.p,{children:"A large customer asks if you can provide an up-to-date accounting of their orders.\nThis can be accomplished with a partition selector:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'materializations:\n  acmeCo/example/database-views:\n    endpoint: ...\n    bindings:\n      # The source can be specified as an object, which allows setting a partition selector.\n      - source:\n          name: acmeCo/anvil/orders\n          # Process partitions where "Coyote" is the customer.\n          partitions:\n            include:\n              customer: [Coyote]\n        resource: { table: coyote_orders }\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"/concepts/advanced/projections#partition-selectors",children:"Learn more about partition selectors"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"destination-specific-performance",children:"Destination-specific performance"}),"\n",(0,a.jsx)(n.p,{children:"Flow processes updates in transactions, as quickly as the destination endpoint can handle them.\nThis might be milliseconds in the case of a fast key/value store,\nor many minutes in the case of an OLAP warehouse."}),"\n",(0,a.jsx)(n.p,{children:"If the endpoint is also transactional, Flow integrates its internal transactions\nwith those of the endpoint for integrated end-to-end \u201cexactly once\u201d semantics."}),"\n",(0,a.jsx)(n.p,{children:"The materialization is sensitive to back pressure from the endpoint.\nAs a database gets busy, Flow adaptively batches and combines documents to consolidate updates:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"In a given transaction, Flow reduces all incoming documents on the collection key.\nMultiple documents combine and result in a single endpoint read and write during the transaction."}),"\n",(0,a.jsx)(n.li,{children:"As a target database becomes busier or slower, transactions become larger.\nFlow does more reduction work within each transaction, and each endpoint read or write\naccounts for an increasing volume of collection documents."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This allows you to safely materialize a collection with a high rate of changes into a small database,\nso long as the cardinality of the materialization is of reasonable size."}),"\n",(0,a.jsx)(n.h2,{id:"delta-updates",children:"Delta updates"}),"\n",(0,a.jsxs)(n.p,{children:["As described ",(0,a.jsx)(n.a,{href:"#how-continuous-materialization-works",children:"above"}),", Flow's standard materialization\nmechanism involves querying the target system for data state before reducing new documents\ndirectly into it."]}),"\n",(0,a.jsx)(n.p,{children:"For these standard updates to work, the endpoint must be a stateful system, like a relational database.\nHowever, other systems \u2014 like Webhooks and Pub/Sub \u2014 may also be endpoints.\nNone of these typically provide a state representation that Flow can query.\nThey are write-only in nature, so Flow cannot use their endpoint state\nto help it fully reduce collection documents on their keys.\nEven some stateful systems are incompatible with Flow's standard updates due to their unique\ndesign and architecture."}),"\n",(0,a.jsxs)(n.p,{children:["For all of these endpoints, Flow offers a ",(0,a.jsx)(n.strong,{children:"delta-updates"}),' mode.\nWhen using delta updates, Flow does not attempt to maintain\nfull reductions of each unique collection key.\nInstead, Flow locally reduces documents within each transaction\n(this is often called a "combine"), and then materializes one\n',(0,a.jsx)(n.em,{children:"delta"})," document per key to the endpoint."]}),"\n",(0,a.jsx)(n.p,{children:"In other words, when delta updates are used, Flow sends information about data changes by key,\nand further reduction is left up to the endpoint system.\nSome systems may reduce documents similar to Flow; others use a different\nmechanism; still others may not perform reductions at all."}),"\n",(0,a.jsxs)(n.p,{children:["A given endpoint may support standard updates, delta updates, or both.\nThis depends on the ",(0,a.jsx)(n.a,{href:"/reference/Connectors/materialization-connectors/",children:"materialization connector"}),". Expect that a connector will use\nstandard updates only unless otherwise noted in its documentation."]}),"\n",(0,a.jsx)(n.h3,{id:"delta-updates-for-every-binding-in-a-materialization",children:"Delta updates for every binding in a Materialization"}),"\n",(0,a.jsx)(n.p,{children:"When configuring a materialization, you can set delta updates as the materialization mechanism\nfor every binding. Afterwards, you are able to modify this setting individually for each binding\nfor further customization."}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["This functionality is only supported for Materialization connectors that have the ",(0,a.jsx)(n.code,{children:"x-delta-updates"}),"\nfield implemented. Consult the individual connector documentation for details."]})}),"\n",(0,a.jsxs)(n.h2,{id:"using-sourcecapture-to-synchronize-capture-and-materialization-bindings",children:["Using ",(0,a.jsx)(n.code,{children:"sourceCapture"})," to synchronize capture and materialization bindings"]}),"\n",(0,a.jsxs)(n.p,{children:["In some cases, you just want a destination system to always reflects the source\nsystem as closely as possible, even as the source system changes over time. The\n",(0,a.jsx)(n.code,{children:"sourceCapture"})," property of a materialization allows you to do exactly that.\nIf you set a ",(0,a.jsx)(n.code,{children:"sourceCapture"})," on your materialization, then the bindings of the\nmaterialization will be automatically kept in sync with the bindings of the\ncapture. As bindings are added to the capture, they will be automatically added\nto the materialization. This works regardless of whether the bindings were added\nto the capture manually or automatically. Bindings that are removed from the\ncapture are ",(0,a.jsx)(n.em,{children:"not"})," removed from the materialization."]}),"\n",(0,a.jsx)(n.h2,{id:"schema-and-table-names-in-destinations",children:"Schema and Table Names in Destinations"}),"\n",(0,a.jsxs)(n.p,{children:["If your destination doesn't have a concept of schemas (a grouping of tables), by default\nwe will prefix the table name with the source schema name, for example schema ",(0,a.jsx)(n.code,{children:"anvils"})," table\n",(0,a.jsx)(n.code,{children:"orders"})," will be configured as ",(0,a.jsx)(n.code,{children:"anvils_orders"}),". You may modify the destination table name in the\nbinding configuration when editing your materialization."]}),"\n",(0,a.jsx)(n.p,{children:"If your destination does support schemas, the below applies:"}),"\n",(0,a.jsx)(n.h3,{id:"schema-naming-hierarchy",children:"Schema Naming Hierarchy"}),"\n",(0,a.jsx)(n.p,{children:"There are several chances to set or update schema names for your materialization bindings.\nFrom lowest priority in the hierarchy to highest priority (overwriting lower-priority settings),\nthese are:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Materialization Default"})}),"\n",(0,a.jsx)(n.p,{children:"The default schema name can be set at the materialization level in the Endpoint Config, ensuring that all new bindings within that materialization automatically inherit the default schema name."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Naming Convention"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"#target-resource-naming-convention-options",children:"target resource naming convention"})," can be set in a materialization's Source Collections section.\nThis option provides general rules for schema and table names for all newly-added bindings.\nIf the ",(0,a.jsx)(n.strong,{children:"Mirror Schemas"})," option is chosen, it will override the materialization's default schema."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Manual Overrides"})}),"\n",(0,a.jsxs)(n.p,{children:["You can manually configure schema names for each binding, overriding the default schema if needed.\nTo do so, set the ",(0,a.jsx)(n.strong,{children:"Alternative Schema"})," field in the binding's Resource Configuration."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"target-resource-naming-convention-options",children:"Target Resource Naming Convention Options"}),"\n",(0,a.jsxs)(n.p,{children:["Materializations with a concept of schema additionally include a choice between several schema naming conventions.\nThese options, under ",(0,a.jsx)(n.strong,{children:"Collection Settings"}),", provide different default naming behaviors for tables and schemas.\nSelecting or changing the naming convention will only apply to new (not existing) bindings on the materialization."]}),"\n",(0,a.jsx)(n.p,{children:"Target resource naming conventions include:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Prefix Schema"})}),"\n",(0,a.jsx)(n.p,{children:"Always prefixes the table name with the second-to-last part of the collection name, regardless of what the schema is. If the schema field remains empty, the default is used."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Prefix Non-Default Schema"})}),"\n",(0,a.jsxs)(n.p,{children:["Prefixes the table name with the second-to-last part of the collection name ",(0,a.jsx)(n.strong,{children:"only if it's not the default schema"})," (such as ",(0,a.jsx)(n.code,{children:"public"})," or ",(0,a.jsx)(n.code,{children:"dbo"}),"). The schema itself is left unspecified."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Mirror Schemas"})}),"\n",(0,a.jsx)(n.p,{children:"Sets the schema name to the second-to-last part of the collection name, and uses the last part as the table name."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Use Table Name Only"})}),"\n",(0,a.jsx)(n.p,{children:"Only uses the last part of the collection name as the table name. If the schema is left empty, the default schema is used."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"For example, consider how the different naming conventions affect the final table and schema names for these collections:"}),"\n",(0,a.jsxs)("table",{children:[(0,a.jsxs)("tr",{children:[(0,a.jsx)("th",{}),(0,a.jsxs)("th",{children:["Collection: ",(0,a.jsx)("code",{children:"acmeCo/anvils/orders"})]}),(0,a.jsxs)("th",{children:["Collection: ",(0,a.jsx)("code",{children:"acmeCo/public/orders"})]})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{rowspan:"2",children:(0,a.jsx)("b",{children:"Prefix schema"})}),(0,a.jsxs)("td",{children:["Table: ",(0,a.jsx)("code",{children:"anvils_orders"})]}),(0,a.jsxs)("td",{children:["Table: ",(0,a.jsx)("code",{children:"public_orders"})]})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"Schema: default"}),(0,a.jsx)("td",{children:"Schema: default"})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{rowspan:"2",children:(0,a.jsx)("b",{children:"Prefix non-default schema"})}),(0,a.jsxs)("td",{children:["Table: ",(0,a.jsx)("code",{children:"anvils_orders"})]}),(0,a.jsxs)("td",{children:["Table: ",(0,a.jsx)("code",{children:"orders"})]})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"Schema: default"}),(0,a.jsx)("td",{children:"Schema: default"})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{rowspan:"2",children:(0,a.jsx)("b",{children:"Mirror schemas"})}),(0,a.jsxs)("td",{children:["Table: ",(0,a.jsx)("code",{children:"orders"})]}),(0,a.jsxs)("td",{children:["Table: ",(0,a.jsx)("code",{children:"orders"})]})]}),(0,a.jsxs)("tr",{children:[(0,a.jsxs)("td",{children:["Schema: ",(0,a.jsx)("code",{children:"anvils"})]}),(0,a.jsxs)("td",{children:["Schema: ",(0,a.jsx)("code",{children:"public"})]})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{rowspan:"2",children:(0,a.jsx)("b",{children:"Use table name only"})}),(0,a.jsxs)("td",{children:["Table: ",(0,a.jsx)("code",{children:"orders"})]}),(0,a.jsxs)("td",{children:["Table: ",(0,a.jsx)("code",{children:"orders"})]})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"Schema: default"}),(0,a.jsx)("td",{children:"Schema: default"})]})]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);