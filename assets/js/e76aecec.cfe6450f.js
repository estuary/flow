"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[4920],{16472:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"concepts/derivations","title":"Derivations","description":"At times, the collections generated by a capture may not be suitable for your needs.","source":"@site/docs/concepts/derivations.md","sourceDirName":"concepts","slug":"/concepts/derivations","permalink":"/concepts/derivations","draft":false,"unlisted":false,"editUrl":"https://github.com/estuary/flow/edit/master/site/docs/concepts/derivations.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Connectors","permalink":"/concepts/connectors"},"next":{"title":"Web application","permalink":"/concepts/web-app"}}');var s=t(74848),i=t(28453),r=t(36573);const o={sidebar_position:6},l="Derivations",c={},d=[{value:"Specification",id:"specification",level:2},{value:"Supported Languages",id:"supported-languages",level:2},{value:"SQLite",id:"sqlite",level:2},{value:"SQL Lambdas",id:"sql-lambdas",level:3},{value:"Document Mapping",id:"document-mapping",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Migrations",id:"migrations",level:3},{value:"Performance",id:"performance",level:3},{value:"TypeScript",id:"typescript",level:2},{value:"Modules",id:"modules",level:3},{value:"State",id:"state",level:3},{value:"Transformations",id:"transformations",level:2},{value:"Sources",id:"sources",level:3},{value:"Shuffles",id:"shuffles",level:3},{value:"shuffle: key",id:"shuffle-key",level:4},{value:"shuffle: any",id:"shuffle-any",level:4},{value:"shuffle: lambda",id:"shuffle-lambda",level:4},{value:"Lambdas",id:"lambdas",level:3},{value:"Processing order",id:"processing-order",level:3},{value:"Read delay",id:"read-delay",level:3},{value:"Read priority",id:"read-priority",level:3},{value:"Internal State",id:"internal-state",level:2},{value:"Where to accumulate?",id:"where-to-accumulate",level:2},{value:"Accumulate in Internal Task State",id:"accumulate-in-internal-task-state",level:3},{value:"Accumulate in a Database",id:"accumulate-in-a-database",level:3}];function h(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"derivations",children:"Derivations"})}),"\n",(0,s.jsxs)(n.p,{children:["At times, the collections generated by a ",(0,s.jsx)(n.a,{href:"../#captures",children:"capture"})," may not be suitable for your needs.\nFor instance, you might want to filter certain documents or add calculations to them.\nPerhaps you need to unpack an array nested inside or aggregate data from many documents.\nAlternatively, you might need to merge across several collections using a common key,\nor employ business logic to arrive at a real-time decision.\nWith Flow derivations, you can perform a wide range of transformations,\nfrom a simple remapping to complicated, self-referential, and stateful transaction processing."]}),"\n",(0,s.jsxs)(n.p,{children:["In essence, a derivation is a ",(0,s.jsx)(n.a,{href:"../#collections",children:"collection"}),"\nthat is constructed from applying transformations to one or more sourced collections.\nDerivations operate continuously, keeping up with updates to the source collections as they happen."]}),"\n",(0,s.jsx)(n.p,{children:"A derivation consists of three primary elements:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A collection that stores the output."}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.a,{href:"../#tasks",children:"catalog task"})," that applies transformations to source documents\nas they become available and writes the resulting documents into the derived collection."]}),"\n",(0,s.jsxs)(n.li,{children:["An ",(0,s.jsx)(n.a,{href:"#internal-state",children:"internal task state"})," which enables aggregations, joins, and windowing."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Today, Flow enables you to write derivations using either\n",(0,s.jsx)(n.a,{href:"#sqlite",children:"SQLite"})," or ",(0,s.jsx)(n.a,{href:"#typescript",children:"TypeScript"}),".\nAdditional language support is in the works."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["If you would like a a more hands-on approach to learn derivations, check out ",(0,s.jsx)(n.a,{href:"/getting-started/tutorials/derivations_acmebank",children:"this"})," tutorial!"]})}),"\n",(0,s.jsx)(n.h2,{id:"specification",children:"Specification"}),"\n",(0,s.jsxs)(n.p,{children:["A derivation is specified as a regular ",(0,s.jsx)(n.a,{href:"../#collections",children:"collection"}),"\nwith an additional ",(0,s.jsx)(n.code,{children:"derive"})," stanza:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'collections:\n  # The unique name of the derivation.\n  acmeCo/my/derivation:\n    schema: my-schema.yaml\n    key: [/key]\n\n    # Presence of a `derive` stanza makes this collection a derivation.\n    # Type: object\n    derive:\n      # Connector which this derivation uses.\n      # One of `typescript` or `sqlite`.\n      using:\n        # Derivation is using the SQLite connector.\n        # Optional, type: object\n        sqlite:\n          # SQL migrations to apply as inline SQL or file references.\n          # If a referenced file does not exist\n          # a stub can be generated using `flowctl generate`.\n          # Optional, type: array of strings\n          migrations:\n            - CREATE TABLE foobar (id INTEGER PRIMARY KEY NOT NULL);\n            - ../path/to/other/migration.sql\n\n        # Derivation is using the TypeScript connector.\n        # Optional, type: object\n        typescript:\n          # TypeScript module implementing this derivation,\n          # as inline TypeScript or a relative file reference.\n          # If a referenced file does not exist\n          # a stub can be generated using `flowctl generate`.\n          module: acmeModule.ts\n\n      # The array of transformations that build this derived collection.\n      transform:\n        # Unique name of the transformation, containing only Unicode\n        # Letters, Numbers, `-`, or `_` (no spaces or other punctuation).\n        - name: myTransformName\n          # Source collection read by this transformation.\n          # Required, type: object or string.\n          source:\n            # Name of the collection to be read.\n            # Required.\n            name: acmeCo/my/source/collection\n            # Partition selector of the source collection.\n            # Optional. Default is to read all partitions.\n            partitions: {}\n            # Lower bound date-time for documents which should be processed.\n            # Source collection documents published before this date-time are filtered.\n            # `notBefore` is *only* a filter. Updating its value will not cause Flow\n            # to re-process documents that have already been read.\n            # Optional. Default is to process all documents.\n            notBefore: 2023-01-23T01:00:00Z\n            # Upper bound date-time for documents which should be processed.\n            # Source collection documents published after this date-time are filtered.\n            # Like `notBefore`, `notAfter` is *only* a filter. Updating its value will\n            # not cause Flow to re-process documents that have already been read.\n            # Optional. Default is to process all documents.\n            notAfter: 2023-01-23T02:00:00Z\n\n          # Lambda of this transform, with a meaning which depends\n          # on the derivation connector:\n          # * SQLite derivation lambdas are blocks of SQL code.\n          # * TypeScript does not use `lambda`, as implementations\n          #   are provided by the derivation\'s TypeScript module.\n          # Lambdas can be either inline or a relative file reference.\n          lambda: SELECT $foo, $bar;\n          # Delay applied to sourced documents before being processed\n          # by this transformation.\n          # Default: No delay, pattern: ^\\\\d+(s|m|h)$\n          readDelay: "48h"\n          # Key by which source documents are shuffled to task shards.\n          # Optional, type: object.\n          # If not set, the source collection key is used.\n          shuffle:\n            # Composite key of JSON pointers which are extracted from\n            # source documents.\n            key: [/shuffle/key/one, /shuffle/key/two]\n          # Priority applied to documents of this transformation\n          # relative to other transformations of the derivation.\n          # Default: 0, integer >= 0\n          priority: 0\n'})}),"\n",(0,s.jsx)(n.h2,{id:"supported-languages",children:"Supported Languages"}),"\n",(0,s.jsxs)(n.p,{children:["As with captures and materializations,\nFlow derivations are built around a plug-able ",(0,s.jsx)(n.a,{href:"../#connectors",children:"connectors"})," architecture.\nDerivation connectors encapsulate the details of ",(0,s.jsx)(n.em,{children:"how"})," documents are transformed,\nand integrate with Flow's runtime through a common protocol."]}),"\n",(0,s.jsxs)(n.p,{children:["At present, Flow supports transformations in SQL using ",(0,s.jsx)(n.a,{href:"#sqlite",children:"SQLite"}),", and ",(0,s.jsx)(n.a,{href:"#typescript",children:"TypeScript"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"sqlite",children:"SQLite"}),"\n",(0,s.jsx)(n.p,{children:"Flow's SQLite connector lets you write plain SQL which\nis evaluated with each source collection document:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"derive:\n  using:\n    sqlite: {}\n  transforms:\n    - name: fromOrders\n      source: acmeCo/orders\n      shuffle: any\n      lambda:\n        SELECT $customer,\n        DATE($timestamp) AS date,\n        PRINTF('$%.2f', $item_price + $sales_tax) AS cost;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Given an input document:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "customer": "Wile E. Coyote",\n  "timestamp": "2023-04-17T16:45:31Z",\n  "item_price": 11.5,\n  "sales_tax": 0.8\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"The derivation will produce an output document like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "customer": "Wile E. Coyote",\n  "date": "2023-04-17",\n  "cost": "$12.30"\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["SQLite derivations run within the context of a persistent,\nmanaged ",(0,s.jsx)(n.a,{href:"https://sqlite.org/",children:"SQLite database"}),".\nMost anything you can do within SQLite,\nyou can do within a SQLite derivation."]}),"\n",(0,s.jsx)(n.h3,{id:"sql-lambdas",children:"SQL Lambdas"}),"\n",(0,s.jsx)(n.p,{children:"Lambdas are blocks of one or more SQL statements.\nThey can be defined inline within a Flow specification,\nor they can be provided as a relative file reference to a file of SQL."}),"\n",(0,s.jsxs)(n.p,{children:["Your SQL lambda code can include any number of statements,\nand your statements are evaluated in the context of your applied\ndatabase ",(0,s.jsx)(n.a,{href:"#migrations",children:"migrations"}),".\nUse regular ",(0,s.jsx)(n.code,{children:"INSERT"}),", ",(0,s.jsx)(n.code,{children:"UPDATE"}),", and ",(0,s.jsx)(n.code,{children:"DELETE"})," statements\nin your SQL blocks to manipulate your internal tables as required."]}),"\n",(0,s.jsxs)(n.p,{children:["Any rows which are returned by SQL statements,\nsuch as ",(0,s.jsx)(n.code,{children:"SELECT"})," and also variations like ",(0,s.jsx)(n.code,{children:"INSERT ... RETURNING"}),",\nare ",(0,s.jsx)(n.a,{href:"#document-mapping",children:"mapped into documents"})," that are published\ninto your derived collection.\nPublished documents must conform to your collection schema\nor your derivation task will stop due to the schema violation."]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["The SQLite connector wraps your lambdas in an enclosing transaction.\nDo ",(0,s.jsx)(n.strong,{children:"not"})," include ",(0,s.jsx)(n.code,{children:"BEGIN"})," or ",(0,s.jsx)(n.code,{children:"COMMIT"})," statements in your lambdas.\nYou may use a ",(0,s.jsx)(n.a,{href:"https://www.sqlite.org/lang_savepoint.html",children:"SAVEPOINT"})," or ",(0,s.jsx)(n.code,{children:"ROLLBACK TO"}),"."]})}),"\n",(0,s.jsx)(n.h3,{id:"document-mapping",children:"Document Mapping"}),"\n",(0,s.jsx)(n.p,{children:"In most cases, each named output column of your query becomes\na top-level property of its corresponding document."}),"\n",(0,s.jsxs)(n.p,{children:["When you directly select a ",(0,s.jsx)(n.code,{children:"$parameter"})," its corresponding field name is used.\nFor example, a projection with field name ",(0,s.jsx)(n.code,{children:"my-field"})," would be queried as\n",(0,s.jsx)(n.code,{children:"SELECT $my_field;"})," and map into a document like ",(0,s.jsx)(n.code,{children:'{"my-field":"value"}'}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A named column such as ",(0,s.jsx)(n.code,{children:"SELECT $x * 100 AS foo;"}),",\nmaps to a property using the provided name: ",(0,s.jsx)(n.code,{children:'{"foo": 200}'}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Your selected columns may included nested JSON documents,\nsuch as ",(0,s.jsx)(n.code,{children:"SELECT 'hello' AS greeting, JSON_ARRAY(1, 'two', 3) AS items;"}),".\nThe connector looks for SQLite TEXT values which can be parsed\ninto JSON arrays or objects and embeds them into the mapped document:\n",(0,s.jsx)(n.code,{children:'{"greeting": "hello", "items": [1, "two", 3]}'}),".\nIf parsing fails, the raw string is used instead."]}),"\n",(0,s.jsxs)(n.p,{children:["If you would like to select all columns of the input collection,\nrather than ",(0,s.jsx)(n.code,{children:"select *"}),", use ",(0,s.jsx)(n.code,{children:"select JSON($flow_document)"}),", e.g.\n",(0,s.jsx)(n.code,{children:"select JSON($flow_document where $status = open;"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["As a special case if your query selects a ",(0,s.jsx)(n.em,{children:"single"})," column\nhaving a name that begins with ",(0,s.jsx)(n.code,{children:"json"})," or ",(0,s.jsx)(n.code,{children:"JSON"}),",\nas is common when working with SQLite's ",(0,s.jsx)(n.a,{href:"https://www.sqlite.org/json1.html",children:"JSON functions"}),",\nthen that column will become the output document.\nFor example ",(0,s.jsx)(n.code,{children:"SELECT JSON_OBJECT('a', 1, 'b', JSON('true'));"})," maps into document ",(0,s.jsx)(n.code,{children:'{"a": 1, "b": true}'}),".\nThis can be used to build documents with dynamic top-level properties."]}),"\n",(0,s.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["Your SQL lambda will execute with every source document of the collection it transforms.\nTo access locations within the document, you utilize ",(0,s.jsx)(n.code,{children:"$parameter"})," placeholders\nin your SQL code, which bind to ",(0,s.jsx)(n.a,{href:"../#projections",children:"projections"})," of the source document.\nYou can use both your defined projections\nas well as projections which are statically inferred from your source collection's schema."]}),"\n",(0,s.jsx)(n.p,{children:"You can access projected fields that are top-level\nas well as those which are nested within a source document.\nConsider the following schematized document:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{"top-level": true, "object": {"foo": 42}, "arr": ["bar"]}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In your SQL code, you can use parameters like ",(0,s.jsx)(n.code,{children:"$top_level"}),", ",(0,s.jsx)(n.code,{children:"$object$foo"}),", or ",(0,s.jsx)(n.code,{children:"$arr$0"}),".\nIf you're unsure of what parameter to use for a given field,\ntry typing something approximate and Flow will suggest the appropriate ",(0,s.jsx)(n.code,{children:"$parameter"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"migrations",children:"Migrations"}),"\n",(0,s.jsxs)(n.p,{children:["The SQLite connector offers a managed, persistent SQLite database\nthat can accommodate any number of tables, indices, views, triggers, and other schema,\nas defined by your database migrations.\nTo add a migration, simply append it to the ",(0,s.jsx)(n.code,{children:"migrations"})," array,\neither as a block of inline SQL statements\nor as a relative path to a file of SQL statements:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"derive:\n  using:\n    sqlite:\n      migrations:\n        - CREATE TABLE foo (thing INTEGER NOT NULL);\n          CREATE INDEX idx_foo_thing foo (thing);\n        - ../path/to/another/migration.sql\n        - ALTER TABLE foo ADD COLUMN other_thing TEXT NOT NULL;\n        - https://example.com/yet/another/migration.sql\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsx)(n.p,{children:"You cannot change an existing migration once it has been published.\nInstead, add a new migration which applies your desired schema."})}),"\n",(0,s.jsxs)(n.p,{children:["The tables and other schema you create through database migrations\nare the ",(0,s.jsx)(n.a,{href:"#internal-state",children:"internal state"})," of your derivation.\nThey don't directly cause any documents to be published into your derived collection,\nbut changes made to tables in one SQL lambda execution are immediately visible to others.\nChanges are also durable and transactional:\na Flow derivation transaction commits new documents to the derived collection\nin lockstep with committing changes made to your task tables."]}),"\n",(0,s.jsx)(n.p,{children:"Flow is responsible for the persistence and replication of your SQLite database,\nand the SQLite connector tracks and will apply your migrations as needed."}),"\n",(0,s.jsx)(n.h3,{id:"performance",children:"Performance"}),"\n",(0,s.jsxs)(n.p,{children:["Your observed performance will ",(0,s.jsx)(n.em,{children:"of course"})," depend on the specifics of your use case,\nincluding the size of your task states\nand the complexity of your source documents and transformations."]}),"\n",(0,s.jsxs)(n.p,{children:["Generally speaking, SQLite is very performant\nand Flow's SQLite connector strives to drive it as efficiently as possible.\nReal-world use cases are observed to process many ",(0,s.jsx)(n.strong,{children:"tens\nof thousands"})," of documents per second on a single core."]}),"\n",(0,s.jsx)(n.p,{children:"Flow can also scale your task without downtime\nby creating point-in-time clones of the database\nthat subdivide the overall workload and storage of the task.\nOnce created, these subdivisions process in parallel across\nmultiple physical machines to enhance performance."}),"\n",(0,s.jsx)(n.h2,{id:"typescript",children:"TypeScript"}),"\n",(0,s.jsxs)(n.p,{children:["Flow's TypeScript derivation connector transforms your source documents\nby executing methods of a TypeScript class which you implement.\nTypeScript derivations are executed using ",(0,s.jsx)(n.a,{href:"https://deno.land/",children:"Deno"}),"\nand let you take advantage of the broad ecosystem of\navailable third-party JavaScript and TypeScript libraries,\nas well as native code compiled to WASM."]}),"\n",(0,s.jsx)(n.p,{children:"TypeScript derivations are strongly typed:\nFlow maps the JSON schemas of your source and output collections\ninto corresponding TypeScript types,\nwhich are type-checked as you develop and test your derivation.\nThis helps catch a wide variety of potential bugs and avoid accidental violations of your collection data contracts."}),"\n",(0,s.jsx)(n.h3,{id:"modules",children:"Modules"}),"\n",(0,s.jsx)(n.p,{children:"The bulk of a TypeScript derivation lives in its associated module,\nwhich is a TypeScript source file that exports the class that implements your derivation."}),"\n",(0,s.jsx)(n.p,{children:"Each derivation also has an accompanying, generated interfaces module.\nInterface modules are managed by Flow and are purely advisory:\nthey're generated to improve your development experience,\nbut any changes you make are ignored."}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"flowctl generate --source path/to/my/derivation.flow.yaml"})," CLI command\nwill generate interface modules under paths like\n",(0,s.jsx)(n.code,{children:"flow_generated/typescript/acmeCo/my-derivation.ts"}),",\nunder the top-level directory under ",(0,s.jsx)(n.code,{children:"--source"})," having a ",(0,s.jsx)(n.code,{children:"flow.yaml"})," or ",(0,s.jsx)(n.code,{children:"flow.json"})," file."]}),"\n",(0,s.jsxs)(n.p,{children:["It will also generate a ",(0,s.jsx)(n.code,{children:"deno.json"})," file in your top-level directory,\nwhich is designed to work with developer tooling like\n",(0,s.jsx)(n.a,{href:"https://marketplace.visualstudio.com/items?itemName=denoland.vscode-deno",children:"VSCode's Deno extension"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/getting-started/tutorials/derivations_acmebank#current-account-balances",children:"See the Current Account Balances tutorial for a concrete example of modules"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"state",children:"State"}),"\n",(0,s.jsxs)(n.p,{children:["The abstract ",(0,s.jsx)(n.code,{children:"IDerivation"})," class generated within the interfaces module\nincludes additional, experimental methods which can be used for\npersisting and recovering internal state of the connector."]}),"\n",(0,s.jsx)(n.p,{children:"Consult the generated implementation and feel free to reach out to support\nif you'd like more information on building stateful TypeScript derivations."}),"\n",(0,s.jsx)(n.h2,{id:"transformations",children:"Transformations"}),"\n",(0,s.jsxs)(n.p,{children:["A transformation binds a ",(0,s.jsx)(n.a,{href:"#sources",children:"source"})," collection to a derivation,\ncausing its documents to be read and processed by the derivation connector."]}),"\n",(0,s.jsxs)(n.p,{children:["Read source documents are first ",(0,s.jsx)(n.a,{href:"#shuffles",children:"shuffled"})," on a ",(0,s.jsx)(n.strong,{children:"shuffle key"}),"\nto co-locate the processing of documents that have equal shuffle keys.\nThe transformation then processes documents by invoking ",(0,s.jsx)(n.strong,{children:"lambdas"}),":\nuser-defined functions that accept documents as arguments,\nreturn documents in response,\nand potentially update internal task state."]}),"\n",(0,s.jsx)(n.p,{children:"A derivation may have many transformations,\nand each transformation has a long-lived and stable name.\nEach transformation independently reads documents from its\nsource collection and tracks its own read progress.\nMore than one transformation can read from the same source collection,\nand transformations may also source from their own derivation,\nenabling cyclic data-flows and graph algorithms."}),"\n",(0,s.jsx)(n.p,{children:"Transformations may be added to or removed from a derivation at any time.\nThis makes it possible to, for example, add a new collection into an\nexisting multi-way join, or gracefully migrate to a new source\ncollection without incurring downtime.\nHowever, renaming a running transformation is not possible.\nIf attempted, the old transformation is dropped and\na new transformation under the new name is created,\nwhich begins reading its source collection all over again."}),"\n",(0,s.jsx)(r.A,{chart:"\n\tgraph LR;\n    d[Derivation];\n    t[Transformation];\n    s[Internal State];\n    l[Lambda];\n    c[Sourced Collection];\n    o[Derived Collection];\n    d-- has many --\x3et;\n    d-- has one --\x3es;\n    d-- has one --\x3eo;\n    c-- reads from --\x3et;\n    t-- invokes --\x3el;\n    l-- updates --\x3es;\n    s-- queries --\x3el;\n    l-- publishes to --\x3eo;\n"}),"\n",(0,s.jsx)(n.h3,{id:"sources",children:"Sources"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"source"})," of a transformation is a collection.\nAs documents are published into the source collection,\nthey are continuously read and processed by the transformation."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.a,{href:"/concepts/advanced/projections#partition-selectors",children:"partition selector"})," may be provided\nto process only a subset of the source collection's logical partitions.\nSelectors are efficient: only partitions that match the selector are read,\nand Flow can cheaply skip over partitions that don't."]}),"\n",(0,s.jsx)(n.p,{children:"Derivations re-validate their source documents against\nthe source collection's schema as they are read.\nThis is because collection schemas may evolve over time,\nand could have inadvertently become incompatible with\nhistorical documents of the source collection.\nUpon a schema error, the derivation will pause and\ngive you an opportunity to correct the problem."}),"\n",(0,s.jsx)(n.h3,{id:"shuffles",children:"Shuffles"}),"\n",(0,s.jsx)(n.p,{children:"As each source document is read, it's shuffled \u2014 or equivalently, mapped \u2014\non an extracted key."}),"\n",(0,s.jsx)(n.p,{children:"If you're familiar with data shuffles in tools like MapReduce,\nApache Spark, or Flink, the concept is very similar.\nFlow catalog tasks scale out into multiple shards,\neach running in parallel on different physical machines,\nwhere each shard processes a subset of source documents."}),"\n",(0,s.jsx)(n.p,{children:"Shuffles let Flow identify the shard that should process a particular\nsource document, in order to co-locate that processing with other\ndocuments it may need to know about."}),"\n",(0,s.jsxs)(n.p,{children:["For example, transforms of the\n",(0,s.jsx)(n.a,{href:"/getting-started/tutorials/derivations_acmebank#approving-transfers",children:"Approving Transfers example"}),"\nshuffle on either ",(0,s.jsx)(n.code,{children:"/sender"})," or ",(0,s.jsx)(n.code,{children:"/recipient"})," in order to\nprocess documents that debit or credit accounts on the specific shard\nthat is uniquely responsible for maintaining the balance of a given account."]}),"\n",(0,s.jsx)(r.A,{chart:"\n\tgraph LR;\n    subgraph s1 [Source Partitions]\n      p1>acmeBank/transfers/part-1];\n      p2>acmeBank/transfers/part-2];\n    end\n    subgraph s2 [Derivation Task Shards]\n      t1([derivation/shard-1]);\n      t2([derivation/shard-2]);\n    end\n    p1-- sender: alice --\x3et1;\n    p1-- recipient: bob --\x3et2;\n    p2-- recipient: alice --\x3et1;\n    p2-- sender: bob --\x3et2;\n"}),"\n",(0,s.jsxs)(n.p,{children:["Flow offers three modes for configuring document shuffles: ",(0,s.jsx)(n.code,{children:"key"}),", ",(0,s.jsx)(n.code,{children:"any"}),", and ",(0,s.jsx)(n.code,{children:"lambda"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"shuffle-key",children:"shuffle: key"}),"\n",(0,s.jsx)(n.p,{children:"Shuffle keys are defined as an array of JSON pointers to locations\nthat should be extracted from your source documents.\nThis array forms the composite key over which your documents are shuffled:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"transforms:\n  - name: fromOrders\n    source: acmeCo/orders\n    shuffle:\n      key: [/item/product_id, /customer_id]\n    # Flow guarantees that the same shard will process the user's lambda\n    # for all instances of a specific (product ID, customer ID) tuple.\n    lambda: ...\n"})}),"\n",(0,s.jsx)(n.p,{children:"If a derivation has more than one transformation,\nthe shuffle keys of all transformations must align with one another\nin terms of the extracted key types (string vs integer)\nas well as the number of components in a composite key."}),"\n",(0,s.jsxs)(n.p,{children:["For example, one transformation couldn't shuffle transfers on ",(0,s.jsx)(n.code,{children:"[/id]"}),"\nwhile another shuffles on ",(0,s.jsx)(n.code,{children:"[/sender]"}),", because ",(0,s.jsx)(n.code,{children:"sender"})," is a string and\n",(0,s.jsx)(n.code,{children:"id"})," an integer."]}),"\n",(0,s.jsxs)(n.p,{children:["Similarly mixing a shuffle of ",(0,s.jsx)(n.code,{children:"[/sender]"})," alongside ",(0,s.jsx)(n.code,{children:"[/sender, /recipient]"}),"\nis prohibited because the keys have different numbers of components."]}),"\n",(0,s.jsx)(n.h4,{id:"shuffle-any",children:"shuffle: any"}),"\n",(0,s.jsxs)(n.p,{children:["If your lambda doesn't rely on any task state then it may not matter which\ntask shard processes a given source document.\nIn these instances you can use ",(0,s.jsx)(n.code,{children:"shuffle: any"}),", which allows source documents\nto be processed by any available task shard."]}),"\n",(0,s.jsx)(n.p,{children:"This is common for transformation lambdas which perform basic filtering\nor mapping of source documents and which don't require any joined task state."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"transforms:\n  - name: fromOrders\n    source: acmeCo/orders\n    shuffle: any\n    # The user's lambda is a pure function and can be evaluated by any available shard.\n    lambda:\n      SELECT $customer_id, $item_price WHERE $item_price > 100;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"shuffle-lambda",children:"shuffle: lambda"}),"\n",(0,s.jsx)(n.admonition,{title:"Warning",type:"info",children:(0,s.jsx)(n.p,{children:"Computed shuffles are in active development and are not yet functional."})}),"\n",(0,s.jsx)(n.p,{children:"Your source documents may not always contain an appropriate value to shuffle upon.\nFor instance, you might want to shuffle on product ID and order date,\nbut your source documents contain only an order timestamp field."}),"\n",(0,s.jsxs)(n.p,{children:["You can use ",(0,s.jsx)(n.code,{children:"shuffle: lambda"})," to define a function that maps your\nsource document into the appropriate shuffle key:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"transforms:\n  - name: fromOrders\n    source: acmeCo/orders\n    shuffle:\n      lambda: SELECT $product_id, DATE($order_timestamp);\n    # Flow guarantees that the same shard will process the user's lambda\n    # for all instances of a specific (product ID, date) tuple.\n    lambda: ...\n"})}),"\n",(0,s.jsx)(n.p,{children:"Your shuffle lambda must return exactly one row, and its columns and\ntypes must align with the other shuffles of your derivation transformations."}),"\n",(0,s.jsxs)(n.p,{children:["Flow must know the types of your composite shuffle key.\nIn most cases it will infer these types from the ",(0,s.jsx)(n.code,{children:"shuffle: key"})," of another transformation.\nIf you have no ",(0,s.jsx)(n.code,{children:"shuffle: key"})," transformations, Flow will ask that you explicitly tell it your shuffle types:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"derive:\n  using:\n    sqlite: {}\n  shuffleKeyTypes: [integer, string]\n  transforms:\n    - name: fromOrders\n      source: acmeCo/orders\n      shuffle:\n        lambda: SELECT $product_id, DATE($order_timestamp);\n      lambda: ...\n"})}),"\n",(0,s.jsx)(n.h3,{id:"lambdas",children:"Lambdas"}),"\n",(0,s.jsx)(n.p,{children:"Lambdas are user-defined functions that are invoked by transformations.\nThey accept documents as arguments\nand return transformed documents in response.\nLambdas can update internal task state,\npublish documents into the derived collection,\nor both."}),"\n",(0,s.jsx)(n.p,{children:'Lambdas are "serverless": Flow manages the execution\nand scaling of your transformation lambdas on your behalf.'}),"\n",(0,s.jsx)(n.h3,{id:"processing-order",children:"Processing order"}),"\n",(0,s.jsx)(n.p,{children:"Transformations may simultaneously read from many source collections,\nor even read from the same source collection multiple times."}),"\n",(0,s.jsxs)(n.p,{children:["Roughly speaking, the derivation will globally process transformations and\ntheir source documents in the time-based order in which the source documents\nwere originally written to their source collections.\nThis means that a derivation started a month ago\nand a new copy of the derivation started today,\nwill process documents in the same order and arrive at the same result.\nDerivations are ",(0,s.jsx)(n.strong,{children:"repeatable"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"More precisely, processing order is stable for each individual shuffle key,\nthough different shuffle keys may process in different orders if more than\none task shard is used."}),"\n",(0,s.jsxs)(n.p,{children:["Processing order can be attenuated through a ",(0,s.jsx)(n.a,{href:"#read-delay",children:"read delay"}),"\nor differentiated ",(0,s.jsx)(n.a,{href:"#read-priority",children:"read priority"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"read-delay",children:"Read delay"}),"\n",(0,s.jsx)(n.p,{children:"A transformation can define a read delay, which will hold back the processing\nof its source documents until the time delay condition is met.\nFor example, a read delay of 15 minutes would mean that a source document\ncannot be processed until it was published at least 15 minutes ago.\nIf the derivation is working through a historical backlog of source documents,\nthan a delayed transformation will respect its ordering delay relative\nto the publishing times of other historical documents also being read."}),"\n",(0,s.jsxs)(n.p,{children:["Event-driven workflows are a great fit for reacting to events as they occur,\nbut aren\u2019t terribly good at taking action when something ",(0,s.jsx)(n.em,{children:"hasn\u2019t"})," happened:"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A user adds a product to their cart, but then doesn\u2019t complete a purchase."}),"\n",(0,s.jsx)(n.li,{children:"A temperature sensor stops producing its expected, periodic measurements."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"A common pattern for tackling these workflows in Flow is to\nread a source collection without a delay and update an internal state.\nThen, read a collection with a read delay\nand determine whether the desired action has happened or not.\nFor example, source from a collection of sensor readings\nand index the last timestamp of each sensor.\nThen, source the same collection again with a read delay:\nif the register timestamp isn't more recent\nthan the delayed source reading,\nthe sensor failed to produce a measurement."}),"\n",(0,s.jsx)(n.p,{children:"Flow read delays are very efficient and scale better\nthan managing very large numbers of fine-grain timers."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/getting-started/tutorials/derivations_acmebank#grouped-windows-of-transfers",children:"See Grouped Windows of Transfers for an example using a read delay"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/estuary/flow/blob/master/examples/citi-bike/idle-bikes.flow.yaml",children:'Learn more from the Citi Bike "idle bikes" example'})}),"\n",(0,s.jsx)(n.h3,{id:"read-priority",children:"Read priority"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes it's necessary for ",(0,s.jsx)(n.em,{children:"all"})," documents of a source collection\nto be processed by a transformation before ",(0,s.jsx)(n.em,{children:"any"})," documents of some\nother source collection are processed, regardless of their\nrelative publishing time.\nFor example, a collection may have corrections that should be\napplied before the historical data of another collection\nis re-processed."]}),"\n",(0,s.jsxs)(n.p,{children:["Transformation priorities allow you to express the relative\nprocessing priority of a derivation's various transformations.\nWhen priorities are not equal, ",(0,s.jsx)(n.em,{children:"all"})," available source documents\nof a higher-priority transformation\nare processed before ",(0,s.jsx)(n.em,{children:"any"})," source documents\nof a lower-priority transformation."]}),"\n",(0,s.jsx)(n.h2,{id:"internal-state",children:"Internal State"}),"\n",(0,s.jsx)(n.p,{children:"Derivation tasks often require an internal state,\nperhaps to hold a partial aggregation or join result.\nInternal state is not a direct part of the output of a derivation.\nInstead, transformation lambdas query and update internal state\nas they process source documents and return derived documents."}),"\n",(0,s.jsx)(n.p,{children:"For SQLite derivations,\nthe entire SQLite database is the internal state of the task.\nTypeScript derivations can use in-memory states with a\nrecovery and checkpoint mechanism.\nEstuary intends to offer additional mechanisms for\nautomatic internal state snapshot and recovery in the future."}),"\n",(0,s.jsx)(n.p,{children:"The exact nature of internal task states vary,\nbut under the hood they're backed by a replicated\nembedded RocksDB instance which is co-located\nwith the task shard execution contexts that Flow manages.\nAs contexts are assigned and re-assigned,\ntheir state databases travel with them."}),"\n",(0,s.jsxs)(n.p,{children:["If a task shard needs to be scaled out,\nFlow is able to perform an ",(0,s.jsx)(n.a,{href:"../advanced/shards/#shard-splits",children:"online split"}),",\nwhich cheaply clones its state database into two new databases\n\u2014 and paired shards \u2014 which are re-assigned to other machines."]}),"\n",(0,s.jsx)(n.h2,{id:"where-to-accumulate",children:"Where to accumulate?"}),"\n",(0,s.jsxs)(n.p,{children:["Derivation collection schemas may have\n",(0,s.jsx)(n.a,{href:"/concepts/schemas#reductions",children:"reduction"})," annotations,\nand lambdas can be combined with reductions in interesting ways.\nYou may be familiar with ",(0,s.jsx)(n.code,{children:"map"})," and ",(0,s.jsx)(n.code,{children:"reduce"})," functions\nbuilt into languages like\n",(0,s.jsx)(n.a,{href:"https://book.pythontips.com/en/latest/map_filter.html",children:"Python"}),",\n",(0,s.jsx)(n.a,{href:"https://www.freecodecamp.org/news/javascript-map-reduce-and-filter-explained-with-examples/",children:"JavaScript"}),',\nand many others\nor have used tools like MapReduce or Spark.\nIn functional terms, lambdas you write within Flow are "mappers,"\nand reductions are always done\nby the Flow runtime using your schema annotations.']}),"\n",(0,s.jsxs)(n.p,{children:["This means that, when you implement a derivation,\nyou get to choose where ",(0,s.jsx)(n.strong,{children:"accumulation"})," will happen:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Your lambdas can update and query aggregates stored in ",(0,s.jsx)(n.a,{href:"#internal-state",children:"internal task state"}),".\n",(0,s.jsx)(n.a,{href:"/getting-started/tutorials/derivations_acmebank#approving-transfers",children:"Approving Transfers"})," is an example that maintains account balances in a SQLite table."]}),"\n",(0,s.jsxs)(n.li,{children:["Or, your lambdas can compute ",(0,s.jsx)(n.em,{children:"changes"})," of an aggregate, which are then reduced by Flow using reduction annotations.\n",(0,s.jsx)(n.a,{href:"/getting-started/tutorials/derivations_acmebank#current-account-balances",children:"Current Account Balances"})," is an example that combines a lambda with a reduce annotation."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These two approaches can produce equivalent results,\nbut they do so in very different ways."}),"\n",(0,s.jsx)(n.h3,{id:"accumulate-in-internal-task-state",children:"Accumulate in Internal Task State"}),"\n",(0,s.jsx)(n.p,{children:"You can accumulate using the internal state of your derivation:\nfor instance, by using an internal table within your SQLite derivation.\nYou then write lambdas which update that state,\nor query it to publish derived documents."}),"\n",(0,s.jsx)(n.p,{children:"For example, consider a collection that\u2019s summing a value:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Time"}),(0,s.jsx)(n.th,{children:"State"}),(0,s.jsx)(n.th,{children:"Lambdas"}),(0,s.jsx)(n.th,{children:"Derived Document"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"T0"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"0"})}),(0,s.jsx)(n.td,{children:"UPDATE val = val + 5; SELECT val;"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"5"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"T1"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"5"})}),(0,s.jsx)(n.td,{children:"UPDATE val = val - 1; SELECT val;"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"4"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"T2"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"4"})}),(0,s.jsx)(n.td,{children:"UPDATE val = val + 2; SELECT val;"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"6"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"T3"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"6"})}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Using a derivation's internal state is a great solution if you expect to\nmaterialize the derived collection into a non-transactional store.\nThat's because its documents are complete statements of the current answer,\nand can be correctly applied to systems that support only at-least-once semantics."}),"\n",(0,s.jsx)(n.p,{children:"They\u2019re also well-suited for materializations into endpoints that aren't stateful,\nsuch as Pub/Sub systems or Webhooks."}),"\n",(0,s.jsx)(n.h3,{id:"accumulate-in-a-database",children:"Accumulate in a Database"}),"\n",(0,s.jsxs)(n.p,{children:["To accumulate in your materialization endpoint, such as a database,\nyou define a derivation with a reducible schema\nand implement lambdas which publish the ",(0,s.jsx)(n.em,{children:"changes"})," to a current answer.\nThe Flow runtime then uses your reduction annotations\nto combine the documents published into your derived collection."]}),"\n",(0,s.jsx)(n.p,{children:"Later, when the collection is materialized, your reduction annotations\nare applied again to reduce each collection document into a final,\nfully-reduced value for each collection key\nthat's kept up to date in the materialized table."}),"\n",(0,s.jsxs)(n.p,{children:["A key insight is that the database is\nthe ",(0,s.jsx)(n.em,{children:"only"})," stateful system in this scenario.\nThe derivation itself is stateless, with lambdas that are pure functions,\nwhich is typically extremely performant."]}),"\n",(0,s.jsx)(n.p,{children:"Returning to our summing example:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Time"}),(0,s.jsx)(n.th,{children:"DB"}),(0,s.jsx)(n.th,{children:"Lambdas"}),(0,s.jsx)(n.th,{children:"Derived Document"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"T0"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"0"})}),(0,s.jsx)(n.td,{children:"SELECT 5;"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"5"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"T1"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"5"})}),(0,s.jsx)(n.td,{children:"SELECT -1;"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"-1"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"T2"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"4"})}),(0,s.jsx)(n.td,{children:"SELECT 2;"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"2"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"T3"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"6"})}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"This works especially well when materializing into a transactional database.\nFlow couples its processing transactions with corresponding database transactions,\nensuring end-to-end \u201cexactly once\u201d semantics."}),"\n",(0,s.jsxs)(n.p,{children:["When materializing into a non-transactional store,\nFlow is only able to provide weaker \u201cat least once\u201d semantics;\nit\u2019s possible that a document may be combined into a database value more than once.\nWhether that\u2019s a concern depends a bit on the task at hand.\nSome reductions like ",(0,s.jsx)(n.code,{children:"merge"}),' can be applied repeatedly without changing the result,\nwhile in other use cases approximations are acceptable.\nFor the summing example above,\n"at-least-once" semantics could give an incorrect result.']}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/estuary/flow/tree/master/examples/derive-patterns",children:"Learn more in the derivation pattern examples of Flow's repository"})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},36573:(e,n,t)=>{t.d(n,{A:()=>r});var a=t(96540),s=t(22279),i=t(74848);s.A.initialize({startOnLoad:!0});const r=e=>{let{chart:n}=e;return(0,a.useEffect)((()=>{s.A.contentLoaded()}),[]),(0,i.jsx)("div",{className:"mermaid",children:n})}}}]);