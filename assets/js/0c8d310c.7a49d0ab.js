"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[5795],{25229:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>u});const a=JSON.parse('{"id":"getting-started/tutorials/derivations_acmebank","title":"Implementing Derivations for AcmeBank","description":"The following tutorial sections use an illustrative example","source":"@site/docs/getting-started/tutorials/derivations_acmebank.md","sourceDirName":"getting-started/tutorials","slug":"/getting-started/tutorials/derivations_acmebank","permalink":"/getting-started/tutorials/derivations_acmebank","draft":false,"unlisted":false,"editUrl":"https://github.com/estuary/flow/edit/master/site/docs/getting-started/tutorials/derivations_acmebank.md","tags":[],"version":"current","frontMatter":{"id":"derivations_acmebank","title":"Implementing Derivations for AcmeBank"},"sidebar":"tutorialSidebar","previous":{"title":"Create a real-time materialized view in PostgreSQL","permalink":"/getting-started/tutorials/continuous-materialized-view"},"next":{"title":"Log into Estuary Using SSO","permalink":"/getting-started/sso-setup"}}');var r=t(74848),s=t(28453),i=t(65537),o=t(79329);t(36573);const c={id:"derivations_acmebank",title:"Implementing Derivations for AcmeBank"},l="Implementing Derivations for AcmeBank",d={},u=[{value:"Filtering Large Transfers",id:"filtering-large-transfers",level:2},{value:"Finding New Account Pairs",id:"finding-new-account-pairs",level:2},{value:"Grouped Windows of Transfers",id:"grouped-windows-of-transfers",level:2},{value:"Approving Transfers",id:"approving-transfers",level:2},{value:"Current Account Balances",id:"current-account-balances",level:2}];function m(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{Head:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t,{children:(0,r.jsx)("meta",{property:"og:image",content:"https://storage.googleapis.com/estuary-marketing-strapi-uploads/uploads//architecture_6bbaf2c5a6/architecture_6bbaf2c5a6.png"})}),"\n","\n",(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"implementing-derivations-for-acmebank",children:"Implementing Derivations for AcmeBank"})}),"\n",(0,r.jsx)(n.p,{children:"The following tutorial sections use an illustrative example\nto introduce you to derivations, how you might use them, and their common components.\nWe'll discuss each component in depth in subsequent sections of this page,\nbut we recommend you start here to get your bearings."}),"\n",(0,r.jsxs)(n.p,{children:["Suppose you have an application through which users send one another\nsome amount of currency, like in-game tokens or dollars or digital kittens.\nYou have a ",(0,r.jsx)(n.code,{children:"transfers"})," collection of user-requested transfers,\neach sending funds from one account to another:"]}),"\n",(0,r.jsxs)(i.A,{children:[(0,r.jsx)(o.A,{value:"transfers.flow.yaml",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:"file=./derivations_acmebank_assets/transfers.flow.yaml",children:"collections:\n  # Collection of \ud83d\udcb2 transfers between accounts:\n  #   {id: 123, sender: alice, recipient: bob, amount: 32.50}\n  acmeBank/transfers:\n    schema: transfers.schema.yaml\n    key: [/id]\n"})})}),(0,r.jsx)(o.A,{value:"transfers.schema.yaml",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:"file=./derivations_acmebank_assets/transfers.schema.yaml",children:"type: object\nproperties:\n  id: { type: integer }\n  sender: { type: string }\n  recipient: { type: string }\n  amount: { type: number }\nrequired: [id, sender, recipient, amount]\n"})})})]}),"\n",(0,r.jsx)(n.p,{children:"There are many views over this data that you might require,\nsuch as summaries of sender or receiver activity,\nor current account balances within your application."}),"\n",(0,r.jsx)(n.h2,{id:"filtering-large-transfers",children:"Filtering Large Transfers"}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["This section introduces SQLite derivations, SQL lambda blocks and ",(0,r.jsx)(n.code,{children:"$parameters"}),"."]})}),"\n",(0,r.jsx)(n.p,{children:"Your compliance department has reached out, and they require an understanding\nof the last large transfer (if any) made by each user account."}),"\n",(0,r.jsxs)(n.p,{children:["You create a SQL derivation to help them out.\nThe ",(0,r.jsx)(n.code,{children:"transfers"})," collection is keyed on the transfer ",(0,r.jsx)(n.code,{children:"/id"}),",\nso you'll need to re-key your derivation on the ",(0,r.jsx)(n.code,{children:"/sender"})," account.\nYou also need to filter out transfers that aren't large enough."]}),"\n",(0,r.jsx)(n.p,{children:"Putting this all together:"}),"\n",(0,r.jsxs)(i.A,{children:[(0,r.jsx)(o.A,{value:"last-large-send.flow.yaml",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:"file=./derivations_acmebank_assets/last-large-send.flow.yaml",children:"collections:\n  acmeBank/last-large-send:\n    schema: transfers.schema.yaml\n    key: [/sender]\n\n    derive:\n      using:\n        sqlite: {}\n      transforms:\n        - name: filterTransfers\n          source: acmeBank/transfers\n          shuffle: any\n          lambda: SELECT $id, $sender, $recipient, $amount WHERE $amount > 100;\n"})})}),(0,r.jsx)(o.A,{value:"last-large-send-test.flow.yaml",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:"file=./derivations_acmebank_assets/last-large-send-test.flow.yaml",children:"tests:\n  acmeBank/tests/last-large-send:\n    - ingest:\n        collection: acmeBank/transfers\n        description: Initial set of transfers amongst users\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 125.10 }\n          - { id: 2, sender: bob, recipient: alice, amount: 10.22 }\n          - { id: 3, sender: carol, recipient: bob, amount: 327.00 }\n    - ingest:\n        collection: acmeBank/transfers\n        description: Alice and Carol later send additional transfers.\n        documents:\n          - { id: 4, sender: alice, recipient: carol, amount: 32.50 }\n          - { id: 5, sender: carol, recipient: alice, amount: 226.73 }\n    - verify:\n        collection: acmeBank/last-large-send\n        description:\n          Expect the most-recent of Carol's large transfers is tracked,\n          along with Alice's only large transfer.\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 125.10 }\n          - { id: 5, sender: carol, recipient: alice, amount: 226.73 }\n"})})})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"derive: using: sqlite: {}"})," tells Flow that collection\n",(0,r.jsx)(n.code,{children:"acmeBank/last-large-send"})," is derived using Flow's SQLite derivation connector."]}),"\n",(0,r.jsxs)(n.p,{children:["This derivation has just one transform, which sources from the ",(0,r.jsx)(n.code,{children:"transfers"})," collection.\nAs source documents become available, they're evaluated by the SQL ",(0,r.jsx)(n.code,{children:"lambda"}),"\nand its ",(0,r.jsx)(n.code,{children:"SELECT"})," output is published to the derived collection.\nYour SQL queries access locations of source documents through ",(0,r.jsx)(n.a,{href:"/concepts/derivations#parameters",children:"$parameter"})," bindings."]}),"\n",(0,r.jsx)(n.p,{children:"The compliance department then materializes this collection to their preferred destination,\nfor an always up-to-date view indexed by each account."}),"\n",(0,r.jsx)(n.h2,{id:"finding-new-account-pairs",children:"Finding New Account Pairs"}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"This section introduces SQLite migrations and internal task tables."})}),"\n",(0,r.jsx)(n.p,{children:"The fraud team needs your help: they have a new process they must run\nthe first time some sending account sends funds to a receiving account.\nThey would like to see only those transfers which reflect a new account pair of (sender, recipient).\nTo tackle this you need to know which account pairs have been seen before."}),"\n",(0,r.jsxs)(n.p,{children:["SQLite derivations run within the context of a persistent, managed SQLite database.\nYou can apply database ",(0,r.jsx)(n.a,{href:"/concepts/derivations#migrations",children:"migrations"})," that create whatever tables, triggers, or views you might need.\nThen, the statements of your SQL lambda code can ",(0,r.jsx)(n.code,{children:"INSERT"}),", ",(0,r.jsx)(n.code,{children:"UPDATE"}),", or ",(0,r.jsx)(n.code,{children:"DELETE"}),"\nfrom those tables, query from them, or any other operation supported by SQLite.\nThe tables and other schema you create through your migrations\nare the ",(0,r.jsx)(n.a,{href:"/concepts/derivations#internal-state",children:"internal state"})," of your task."]}),"\n",(0,r.jsxs)(i.A,{children:[(0,r.jsx)(o.A,{value:"first-send.flow.yaml",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:"file=./derivations_acmebank_assets/first-send.flow.yaml",children:"collections:\n  acmeBank/first-send:\n    schema: transfers.schema.yaml\n    key: [/id]\n\n    derive:\n      using:\n        sqlite:\n          migrations:\n            - CREATE TABLE seen_pairs (\n              sender    TEXT NOT NULL,\n              recipient TEXT NOT NULL,\n              PRIMARY KEY (sender, recipient)\n              );\n\n      transforms:\n        - name: fromTransfers\n          source: acmeBank/transfers\n          shuffle:\n            key: [/sender, /recipient]\n          lambda:\n            INSERT INTO seen_pairs (sender, recipient) VALUES ($sender, $recipient)\n            ON CONFLICT DO NOTHING\n            RETURNING $id, $sender, $recipient, $amount;\n"})})}),(0,r.jsx)(o.A,{value:"first-send-test.flow.yaml",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:"file=./derivations_acmebank_assets/first-send-test.flow.yaml",children:"tests:\n  acmeBank/tests/first-send:\n    - ingest:\n        collection: acmeBank/transfers\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 10.25 }\n          - { id: 2, sender: alice, recipient: bob, amount: 13.40 }\n          - { id: 3, sender: carol, recipient: alice, amount: 12.50 }\n          - { id: 4, sender: alice, recipient: carol, amount: 16.96 }\n          - { id: 5, sender: carol, recipient: alice, amount: 2.36 }\n          - { id: 6, sender: alice, recipient: carol, amount: 7.13 }\n\n    - verify:\n        collection: acmeBank/first-send\n        description: Expect to see only the first interaction of each account pair.\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 10.25 }\n          - { id: 3, sender: carol, recipient: alice, amount: 12.50 }\n          - { id: 4, sender: alice, recipient: carol, amount: 16.96 }\n"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["This time, the derivation attempts to ",(0,r.jsx)(n.code,{children:"INSERT"})," into the ",(0,r.jsx)(n.code,{children:"seen_pairs"})," table,\nand uses SQLite's ",(0,r.jsx)(n.a,{href:"https://www.sqlite.org/lang_returning.html",children:"RETURNING"}),"\nsyntax to only publish documents for rows which were successfully inserted."]}),"\n",(0,r.jsxs)(n.p,{children:["You can evolve the internal SQLite tables of your derivation as needed,\nby appending SQL blocks which perform a database migration to the ",(0,r.jsx)(n.code,{children:"migrations"})," array.\nAny migrations appended to the list are automatically applied by Flow."]}),"\n",(0,r.jsx)(n.h2,{id:"grouped-windows-of-transfers",children:"Grouped Windows of Transfers"}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"This section introduces delayed reads, and applies them to implement a custom window policy."})}),"\n",(0,r.jsxs)(n.p,{children:["The fraud team is back, and now needs to know the ",(0,r.jsx)(n.em,{children:"other"}),"\ntransfers which an account has made in the last day.\nThey want you to enrich each transfer with the grouping of all\ntransfers initiated by that account in the prior 24 hours."]}),"\n",(0,r.jsx)(n.p,{children:'You may have encountered "windowing" in other tools for stream processing.\nSome systems even require that you define a window policy in order to function.\nFlow does not use windows, but sometimes you do want a time-bound grouping of recent events.'}),"\n",(0,r.jsxs)(n.p,{children:["All collection documents contain a wall-clock timestamp of when they were published.\nThe transforms of a derivation will generally process source documents in ascending wall-time order.\nYou can augment this behavior by using a ",(0,r.jsx)(n.a,{href:"/concepts/derivations#read-delay",children:"read delay"})," to refine the relative order in which\nsource documents are read, which is useful for implementing arbitrary window policies:"]}),"\n",(0,r.jsxs)(i.A,{children:[(0,r.jsx)(o.A,{value:"grouped.flow.yaml",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:"file=./derivations_acmebank_assets/grouped.flow.yaml title=grouped.flow.yaml",children:"collections:\n  acmeBank/grouped-transfers:\n    schema:\n      # Enrich transfer with a window of *other* transfers.\n      $ref: transfers.schema.yaml\n      required: [window]\n      properties:\n        window: { type: array }\n    key: [/id]\n\n    derive:\n      using:\n        sqlite:\n          migrations:\n            - CREATE TABLE transfers (\n              id        INTEGER PRIMARY KEY NOT NULL,\n              sender    TEXT NOT NULL,\n              recipient TEXT NOT NULL,\n              amount    REAL NOT NULL\n              );\n              CREATE INDEX idx_transfers_sender ON transfers (sender);\n      transforms:\n        - name: enrichAndAddToWindow\n          source: acmeBank/transfers\n          shuffle: { key: [/sender] }\n          lambda: enrichAndAddToWindow.sql\n\n        - name: removeFromWindow\n          source: acmeBank/transfers\n          shuffle: { key: [/sender] }\n          readDelay: 24h\n          lambda: DELETE FROM transfers WHERE id = $id;\n"})})}),(0,r.jsx)(o.A,{value:"enrichAndAddToWindow.sql",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",metastring:"file=./derivations_acmebank_assets/enrichAndAddToWindow.sql title=enrichAndAddToWindow.sql",children:"-- Enrich the transfer with a nested array of other transfers in the window.\nWITH w AS (\n    SELECT JSON_GROUP_ARRAY(JSON_OBJECT(\n        'id', id,\n        'recipient', recipient,\n        'amount', amount\n    )) AS window\n    FROM transfers WHERE sender = $sender\n)\nSELECT $id, $sender, $recipient, $amount, w.window FROM w;\n\n-- Add the current transfer to the window.\nINSERT INTO transfers (id, sender, recipient, amount)\nVALUES ($id, $sender, $recipient, $amount);\n"})})}),(0,r.jsx)(o.A,{value:"grouped-test.flow.yaml",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:"file=./derivations_acmebank_assets/grouped-test.flow.yaml title=grouped-test.flow.yaml",children:"tests:\n  acmeBank/tests/grouped-transfers:\n    - ingest:\n        description: Initial transfers.\n        collection: acmeBank/transfers\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 6.45 }\n          - { id: 2, sender: bob, recipient: carol, amount: 9.72 }\n          - { id: 3, sender: bob, recipient: alice, amount: 12.50 }\n\n    - verify:\n        description: Expect transfers were enriched with their current window.\n          Note that a verify step will advance test time forward until all\n          source documents have been read by all transforms,\n          meaning that the window has been reset.\n        collection: acmeBank/grouped-transfers\n        documents:\n          - { amount: 6.45, id: 1, sender: alice, recipient: bob, window: [] }\n          - { amount: 9.72, id: 2, sender: bob, recipient: carol, window: [] }\n          - {\n              id: 3,\n              sender: bob,\n              recipient: alice,\n              amount: 12.5,\n              window: [{ id: 2, recipient: carol, amount: 9.72 }],\n            }\n\n    - ingest:\n        collection: acmeBank/transfers\n        documents:\n          - { id: 4, sender: alice, recipient: bob, amount: 1.96 }\n          - { id: 5, sender: alice, recipient: carol, amount: 2.36 }\n          - { id: 6, sender: bob, recipient: alice, amount: 7.13 }\n          - { id: 7, sender: alice, recipient: bob, amount: 2.57 }\n\n    - verify:\n        collection: acmeBank/grouped-transfers\n        documents:\n          - { id: 1 }\n          - { id: 2 }\n          - { id: 3 }\n          - { id: 4, amount: 1.96, sender: alice, recipient: bob, window: [] }\n          - {\n              id: 5,\n              amount: 2.36,\n              sender: alice,\n              recipient: carol,\n              window: [{ id: 4, amount: 1.96, recipient: bob }],\n            }\n          - { id: 6, sender: bob, recipient: alice, amount: 7.13, window: [] }\n          - {\n              id: 7,\n              amount: 2.57,\n              sender: alice,\n              recipient: bob,\n              window:\n                [\n                  { id: 4, amount: 1.96, recipient: bob },\n                  { id: 5, amount: 2.36, recipient: carol },\n                ],\n            }\n"})})})]}),"\n",(0,r.jsx)(n.h2,{id:"approving-transfers",children:"Approving Transfers"}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"This section expands usage of SQLite task tables and introduces a recursive data flow."})}),"\n",(0,r.jsxs)(n.p,{children:["Your users don't always check if they have sufficient funds before starting a transfer,\nand account overdrafts are becoming common.\nThe product team has tapped you to fix this\nby enriching each transfer with an ",(0,r.jsx)(n.strong,{children:"approve"})," or ",(0,r.jsx)(n.strong,{children:"deny"})," outcome\nbased on the account balance of the sender."]}),"\n",(0,r.jsx)(n.p,{children:"To do this, you first need to track the sender's current account balance.\nClearly an account balance is debited when it's used to sends funds.\nIt's also credited when it receives funds."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"But there's a catch"}),":\nan account can only be credited for funds received from ",(0,r.jsx)(n.strong,{children:"approved"})," transfers!\nThis implies you need a collection of transfer outcomes\nin order to derive your collection of transfer outcomes \ud83e\udd2f."]}),"\n",(0,r.jsxs)(n.p,{children:["This is an example of a self-referential, recursive data-flow.\nYou may have used tools which require that data flow in a Directed Acyclic Graph (DAG).\nFlow does ",(0,r.jsx)(n.em,{children:"not"})," require that your data flows are acyclic,\nand it also supports a derivation that reads from itself,\nwhich lets you tackle this task:"]}),"\n",(0,r.jsxs)(i.A,{children:[(0,r.jsx)(o.A,{value:"outcomes.flow.yaml",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:"file=./derivations_acmebank_assets/outcomes.flow.yaml title=outcomes.flow.yaml",children:"collections:\n  acmeBank/transfer-outcomes:\n    schema:\n      # Enrich transfer schema with outcome and the sender's balance.\n      $ref: transfers.schema.yaml\n      required: [outcome, sender_balance]\n      properties:\n        outcome:\n          description: Transfer was approved, or denied for insufficient funds.\n          enum: [approve, deny]\n        sender_balance: { type: number }\n    key: [/id]\n\n    derive:\n      using:\n        sqlite:\n          migrations:\n            - CREATE TABLE current_balances (\n              account TEXT PRIMARY KEY NOT NULL,\n              balance REAL NOT NULL\n              );\n\n      transforms:\n        - name: debitSender\n          source: acmeBank/transfers\n          # Shuffle on the sender, as we'll debit their balance.\n          shuffle: { key: [/sender] }\n          lambda: debitSender.sql\n\n        - name: creditRecipient\n          # When a transfer is approved, we've debited the sender but still need to\n          # credit the recipient. Read approved transfers from ourselves to do so.\n          source:\n            name: acmeBank/transfer-outcomes\n            partitions:\n              include:\n                outcome: [approve]\n          shuffle: { key: [/recipient] }\n          lambda:\n            INSERT INTO current_balances (account, balance) VALUES ($recipient, $amount)\n            ON CONFLICT DO UPDATE SET balance = balance + $amount;\n\n    # Partition output based on the transfer outcome.\n    projections:\n      outcome:\n        location: /outcome\n        partition: true\n"})})}),(0,r.jsx)(o.A,{value:"debitSender.sql",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",metastring:"file=./derivations_acmebank_assets/debitSender.sql title=debitSender.sql",children:"-- Debit the sender if they have an account with sufficient funds.\nUPDATE current_balances\nSET balance = balance - $amount\nWHERE account = $sender AND balance >= $amount;\n\n-- Publish the transfer enriched with outcome and sender balance.\n-- Use SQLite's CHANGES() function to check if the prior UPDATE matched any rows.\n-- Or, a special sweep account 'DEPOSIT' is always approved.\nWITH t AS (SELECT $id, $sender, $recipient, $amount)\nSELECT t.*,\n    CASE WHEN CHANGES() OR $sender = 'DEPOSIT'\n        THEN 'approve' ELSE 'deny' END AS outcome,\n    COALESCE(b.balance, 0) AS sender_balance\nFROM t\nLEFT OUTER JOIN current_balances b ON $sender = b.account;\n"})})}),(0,r.jsx)(o.A,{value:"outcomes-test.flow.yaml",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:"file=./derivations_acmebank_assets/outcomes-test.flow.yaml title=outcomes-test.flow.yaml",children:"tests:\n  acmeBank/tests/transfer-outcomes:\n    - ingest:\n        description: Initial deposits.\n        collection: acmeBank/transfers\n        documents:\n          - { id: 1, sender: DEPOSIT, recipient: Alice, amount: 20 }\n          - { id: 2, sender: DEPOSIT, recipient: Bob, amount: 20 }\n\n    - ingest:\n        description: Transfers between users.\n        collection: acmeBank/transfers\n        documents:\n          - { id: 3, sender: Alice, recipient: Bob, amount: 32.50 }\n          - { id: 4, sender: Bob, recipient: Carol, amount: 10.75 }\n\n    - verify:\n        description: Expect transfers were enriched with outcome and balance.\n        collection: acmeBank/transfer-outcomes\n        documents:\n          - {\n              id: 1,\n              sender: DEPOSIT,\n              recipient: Alice,\n              amount: 20,\n              outcome: approve,\n            }\n          - {\n              id: 2,\n              sender: DEPOSIT,\n              recipient: Bob,\n              amount: 20,\n              outcome: approve,\n            }\n          - {\n              id: 3,\n              sender: Alice,\n              recipient: Bob,\n              amount: 32.50,\n              outcome: deny,\n            }\n          - {\n              id: 4,\n              sender: Bob,\n              recipient: Carol,\n              amount: 10.75,\n              outcome: approve,\n              sender_balance: 9.25,\n            }\n"})})})]}),"\n",(0,r.jsx)(n.h2,{id:"current-account-balances",children:"Current Account Balances"}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"This section introduces TypeScript derivations and reduction annotations."})}),"\n",(0,r.jsx)(n.p,{children:"Your product team is back, and they want a database table\nkeyed by account that contains its up-to-date current balance."}),"\n",(0,r.jsxs)(n.p,{children:["As shown in the previous section, you could create\na task table which aggregates each account balance,\nand then ",(0,r.jsx)(n.code,{children:"SELECT"})," the current balance after every transfer.\nFor most use cases, this is a ",(0,r.jsx)(n.strong,{children:"great"})," place to start.\nFor interest and variety, you'll solve this problem using TypeScript."]}),"\n",(0,r.jsxs)(n.p,{children:["TypeScript derivations require a ",(0,r.jsx)(n.code,{children:"module"})," which you write.\nYou don't know how to write that module yet,\nso first implement the derivation specification in ",(0,r.jsx)(n.code,{children:"balances.flow.yaml"}),".\nNext run the ",(0,r.jsx)(n.code,{children:"flowctl generate"})," command, which generates two files:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A module stub for you to fill out."}),"\n",(0,r.jsx)(n.li,{children:"A file of TypeScript interfaces which are used by your module."}),"\n"]}),"\n",(0,r.jsxs)(i.A,{children:[(0,r.jsx)(o.A,{value:"balances.flow.yaml",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:"title=balances.flow.yaml file=./derivations_acmebank_assets/balances.flow.yaml",children:"collections:\n  acmeBank/balances:\n    schema: balances.schema.yaml\n    key: [/user]\n\n    derive:\n      using:\n        typescript:\n          module: balances.ts\n      transforms:\n        - name: fromOutcomes\n          source:\n            name: acmeBank/transfer-outcomes\n            partitions:\n              include:\n                outcome: [approve]\n          shuffle: any\n"})})}),(0,r.jsx)(o.A,{value:"Module Stub",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:"title=balances.ts file=./derivations_acmebank_assets/balances-stub.ts",children:"import { IDerivation, Document, SourceFromOutcomes } from 'flow/acmeBank/balances.ts';\n\n// Implementation for derivation acmeBank/balances.\nexport class Derivation extends IDerivation {\n    fromOutcomes(_read: { doc: SourceFromOutcomes }): Document[] {\n        throw new Error(\"Not implemented\"); // \ud83d\udc48 Your implementation goes here.\n    }\n}\n"})})}),(0,r.jsx)(o.A,{value:"Interfaces",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:"file=./derivations_acmebank_assets/flow_generated/typescript/acmeBank/balances.ts title=flow/acmeBank/balances.ts",children:'\n// Generated for published documents of derived collection acmeBank/balances.\nexport type Document = {\n    balance: number;\n    user: string;\n};\n\n\n// Generated for read documents of sourced collection acmeBank/transfer-outcomes.\nexport type SourceFromOutcomes = {\n    amount: number;\n    id: number;\n    outcome: /* Transfer was approved, or denied for insufficient funds. */ "approve" | "deny";\n    recipient: string;\n    sender: string;\n    sender_balance: number;\n};\n\n\nexport abstract class IDerivation {\n    // Construct a new Derivation instance from a Request.Open message.\n    constructor(_open: { state: unknown }) { }\n\n    // flush awaits any remaining documents to be published and returns them.\n    // deno-lint-ignore require-await\n    async flush(): Promise<Document[]> {\n        return [];\n    }\n\n    // reset is called only when running catalog tests, and must reset any internal state.\n    async reset() { }\n\n    // startCommit is notified of a runtime commit in progress, and returns an optional\n    // connector state update to be committed.\n    startCommit(_startCommit: { runtimeCheckpoint: unknown }): { state?: { updated: unknown, mergePatch: boolean } } {\n        return {};\n    }\n\n    abstract fromOutcomes(read: { doc: SourceFromOutcomes }): Document[];\n}\n'})})})]}),"\n",(0,r.jsx)(n.p,{children:"Next fill out the body of your TypeScript module and write a test:"}),"\n",(0,r.jsxs)(i.A,{children:[(0,r.jsx)(o.A,{value:"balances.ts",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:"title=balances.ts file=./derivations_acmebank_assets/balances.ts",children:"import { IDerivation, Document, SourceFromOutcomes } from 'flow/acmeBank/balances.ts';\n\n// Implementation for derivation acmeBank/balances.\nexport class Derivation extends IDerivation {\n    fromOutcomes(read: { doc: SourceFromOutcomes }): Document[] {\n        const doc = read.doc;\n        return [\n            // Debit the sender.\n            { user: doc.sender, balance: -doc.amount },\n            // Credit the recipient.\n            { user: doc.recipient, balance: doc.amount },\n        ];\n    }\n}\n"})})}),(0,r.jsx)(o.A,{value:"balances-test.flow.yaml",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:"title=balances-test.flow.yaml file=./derivations_acmebank_assets/balances-test.flow.yaml",children:"tests:\n  acmeBank/tests/balances:\n    - ingest:\n        collection: acmeBank/transfers\n        description: Initial deposits into user accounts.\n        documents:\n          - { id: 1, sender: DEPOSIT, recipient: alice, amount: 100 }\n          - { id: 2, sender: DEPOSIT, recipient: bob, amount: 100 }\n          - { id: 3, sender: DEPOSIT, recipient: carol, amount: 100 }\n\n    - ingest:\n        collection: acmeBank/transfers\n        description: Transfers between users, and a withdraw.\n        documents:\n          - { id: 4, sender: alice, recipient: bob, amount: 20 }\n          - { id: 5, sender: bob, recipient: carol, amount: 40 }\n          - { id: 6, sender: carol, recipient: alice, amount: 90 }\n          - { id: 7, sender: bob, recipient: DEPOSIT, amount: 40 }\n\n    - verify:\n        collection: acmeBank/balances\n        description: Verify expected balances.\n        documents:\n          - { user: DEPOSIT, balance: -260 }\n          - { user: alice, balance: 170 }\n          - { user: bob, balance: 40 }\n          - { user: carol, balance: 50 }\n"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["One piece is still missing.\nYour TypeScript module is publishing the ",(0,r.jsx)(n.strong,{children:"change"})," in account balance for each transfer.\nThat's not the same thing as the ",(0,r.jsx)(n.strong,{children:"current"})," balance for each account."]}),"\n",(0,r.jsxs)(n.p,{children:["You can ask Flow to sum up the balance changes into a current account balance\nthrough ",(0,r.jsx)(n.a,{href:"/concepts/schemas#reductions",children:"reduction annotations"}),".\nHere's the balances schema, with ",(0,r.jsx)(n.code,{children:"reduce"})," annotations for summing the account balance:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:"title=balances.schema.yaml file=./derivations_acmebank_assets/balances.schema.yaml",children:"type: object\nrequired: [user, balance]\nreduce: { strategy: merge }\nproperties:\n  user: { type: string }\n  balance:\n    type: number\n    reduce: { strategy: sum }\n"})}),"\n",(0,r.jsx)(n.p,{children:"This section has more moving parts that the previous SQL-based examples.\nYou might be wondering, why bother? Fair question!\nThis is just an illustrative example, after all."}),"\n",(0,r.jsx)(n.p,{children:"While they're more verbose, TypeScript derivations do have certain advantages:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["TypeScript derivations are strongly typed, and those checks often catch meaningful bugs and defects ",(0,r.jsx)(n.strong,{children:"before"})," they're deployed.\nYour derivation modules also play nicely with VSCode and other developer tooling."]}),"\n",(0,r.jsx)(n.li,{children:"TypeScript derivations can use third-party libraries, as well as your native code compiled to WASM."}),"\n",(0,r.jsx)(n.li,{children:"TypeScript can be easier when working with nested or complex document structures."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Reduction annotations also have some benefits over task state (like SQLite tables):"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Internal task state is managed by Flow.\nIf it grows to be large (say, you have ",(0,r.jsx)(n.strong,{children:"a lot"})," of accounts),\nthen your task must be scaled and could require performance tuning.\nReduction annotations, on the other hand, require ",(0,r.jsx)(n.em,{children:"no"})," internal state and are extremely efficient."]}),"\n",(0,r.jsx)(n.li,{children:"Certain aggregations, such as recursive merging of tree-like structures,\nare much simpler to express through reduction annotations vs implementing yourself."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"/concepts/derivations#where-to-accumulate",children:'See "Where to Accumulate?" for more discussion'}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},36573:(e,n,t)=>{t.d(n,{A:()=>i});var a=t(96540),r=t(22279),s=t(74848);r.A.initialize({startOnLoad:!0});const i=e=>{let{chart:n}=e;return(0,a.useEffect)((()=>{r.A.contentLoaded()}),[]),(0,s.jsx)("div",{className:"mermaid",children:n})}},65537:(e,n,t)=>{t.d(n,{A:()=>j});var a=t(96540),r=t(34164),s=t(65627),i=t(56347),o=t(50372),c=t(30604),l=t(11861),d=t(78749);function u(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function m(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??function(e){return u(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}(t);return function(e){const n=(0,l.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function h(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function p(e){let{queryString:n=!1,groupId:t}=e;const r=(0,i.W6)(),s=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,c.aZ)(s),(0,a.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(r.location.search);n.set(s,e),r.replace({...r.location,search:n.toString()})}),[s,r])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,s=m(e),[i,c]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!h({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:s}))),[l,u]=p({queryString:t,groupId:r}),[f,b]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,s]=(0,d.Dv)(t);return[r,(0,a.useCallback)((e=>{t&&s.set(e)}),[t,s])]}({groupId:r}),g=(()=>{const e=l??f;return h({value:e,tabValues:s})?e:null})();(0,o.A)((()=>{g&&c(g)}),[g]);return{selectedValue:i,selectValue:(0,a.useCallback)((e=>{if(!h({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);c(e),u(e),b(e)}),[u,b,s]),tabValues:s}}var b=t(9136);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var y=t(74848);function w(e){let{className:n,block:t,selectedValue:a,selectValue:i,tabValues:o}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,s.a_)(),d=e=>{const n=e.currentTarget,t=c.indexOf(n),r=o[t].value;r!==a&&(l(n),i(r))},u=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;n=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(e.currentTarget)-1;n=c[t]??c[c.length-1];break}}n?.focus()};return(0,y.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:o.map((e=>{let{value:n,label:t,attributes:s}=e;return(0,y.jsx)("li",{role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>{c.push(e)},onKeyDown:u,onClick:d,...s,className:(0,r.A)("tabs__item",g.tabItem,s?.className,{"tabs__item--active":a===n}),children:t??n},n)}))})}function v(e){let{lazy:n,children:t,selectedValue:s}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===s));return e?(0,a.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,y.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==s})))})}function x(e){const n=f(e);return(0,y.jsxs)("div",{className:(0,r.A)("tabs-container",g.tabList),children:[(0,y.jsx)(w,{...n,...e}),(0,y.jsx)(v,{...n,...e})]})}function j(e){const n=(0,b.A)();return(0,y.jsx)(x,{...e,children:u(e.children)},String(n))}},79329:(e,n,t)=>{t.d(n,{A:()=>i});t(96540);var a=t(34164);const r={tabItem:"tabItem_Ymn6"};var s=t(74848);function i(e){let{children:n,hidden:t,className:i}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,i),hidden:t,children:n})}}}]);