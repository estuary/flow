// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Request {
    #[prost(message, optional, tag = "1")]
    pub spec: ::core::option::Option<request::Spec>,
    #[prost(message, optional, tag = "2")]
    pub validate: ::core::option::Option<request::Validate>,
    #[prost(message, optional, tag = "3")]
    pub apply: ::core::option::Option<request::Apply>,
    #[prost(message, optional, tag = "4")]
    pub open: ::core::option::Option<request::Open>,
    #[prost(message, optional, tag = "5")]
    pub load: ::core::option::Option<request::Load>,
    #[prost(message, optional, tag = "6")]
    pub flush: ::core::option::Option<request::Flush>,
    #[prost(message, optional, tag = "7")]
    pub store: ::core::option::Option<request::Store>,
    #[prost(message, optional, tag = "8")]
    pub start_commit: ::core::option::Option<request::StartCommit>,
    #[prost(message, optional, tag = "9")]
    pub acknowledge: ::core::option::Option<request::Acknowledge>,
    /// Reserved for internal use.
    #[prost(bytes = "bytes", tag = "100")]
    pub internal: ::prost::bytes::Bytes,
}
/// Nested message and enum types in `Request`.
pub mod request {
    /// Spec requests the specification definition of this connector.
    /// Notably this includes its configuration JSON schemas.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Spec {
        /// Connector type addressed by this request.
        #[prost(
            enumeration = "super::super::flow::materialization_spec::ConnectorType",
            tag = "1"
        )]
        pub connector_type: i32,
        /// Connector configuration, as an encoded JSON object.
        /// This may be a partial specification (for example, a Docker image),
        /// providing only enough information to fetch the remainder of the
        /// specification schema.
        #[prost(string, tag = "2")]
        pub config_json: ::prost::alloc::string::String,
    }
    /// Validate a materialization configuration and proposed bindings.
    /// Validate is run out-of-band with ongoing capture invocations.
    /// It's purpose is to confirm that the proposed configuration
    /// is likely to succeed if applied and run, or to report any
    /// potential issues for the user to address.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Validate {
        /// Name of the materialization being validated.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Connector type addressed by this request.
        #[prost(
            enumeration = "super::super::flow::materialization_spec::ConnectorType",
            tag = "2"
        )]
        pub connector_type: i32,
        /// Connector configuration, as an encoded JSON object.
        #[prost(string, tag = "3")]
        pub config_json: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "4")]
        pub bindings: ::prost::alloc::vec::Vec<validate::Binding>,
        /// Last MaterializationSpec which was validated and published.
        /// Note that this MaterializationSpec may not have been applied.
        #[prost(message, optional, tag = "5")]
        pub last_materialization: ::core::option::Option<
            super::super::flow::MaterializationSpec,
        >,
        /// Version of the last validated MaterializationSpec.
        #[prost(string, tag = "6")]
        pub last_version: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `Validate`.
    pub mod validate {
        /// Bindings of endpoint resources and collections from which they would be
        /// materialized. Bindings are ordered and unique on the bound collection name.
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Binding {
            /// JSON-encoded object which specifies the endpoint resource to be materialized.
            #[prost(string, tag = "1")]
            pub resource_config_json: ::prost::alloc::string::String,
            /// Collection to be materialized.
            #[prost(message, optional, tag = "2")]
            pub collection: ::core::option::Option<
                super::super::super::flow::CollectionSpec,
            >,
            /// Projection configuration, keyed by the projection field name,
            /// with JSON-encoded and driver-defined configuration objects.
            #[prost(btree_map = "string, string", tag = "3")]
            pub field_config_json_map: ::prost::alloc::collections::BTreeMap<
                ::prost::alloc::string::String,
                ::prost::alloc::string::String,
            >,
            /// Backfill counter for this binding.
            #[prost(uint32, tag = "4")]
            pub backfill: u32,
        }
    }
    /// Apply an updated materialization specification to its endpoint,
    /// in preparation for an Open of a materialization session.
    /// Apply is run by the leader shard of a materialization task
    /// (having key_begin: 0) while the materialization is quiescent.
    /// Apply may be called multiple times for a given `version` and
    /// `last_version`, even if a prior call succeeded from the connector's
    /// perspective, so implementations must be idempotent. However, the next
    /// session will not Open until it's preceding Apply has durably completed.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Apply {
        /// Materialization to be applied.
        #[prost(message, optional, tag = "1")]
        pub materialization: ::core::option::Option<
            super::super::flow::MaterializationSpec,
        >,
        /// Version of the MaterializationSpec being applied.
        #[prost(string, tag = "2")]
        pub version: ::prost::alloc::string::String,
        /// Last CaptureSpec which was successfully applied.
        #[prost(message, optional, tag = "4")]
        pub last_materialization: ::core::option::Option<
            super::super::flow::MaterializationSpec,
        >,
        /// Version of the last applied MaterializationSpec.
        #[prost(string, tag = "5")]
        pub last_version: ::prost::alloc::string::String,
        /// Last-persisted connector checkpoint state from a previous session.
        /// The Apply RPC may use this state to perform a post-commit apply
        /// of files staged under the `last_materialization` specification.
        #[prost(string, tag = "6")]
        pub state_json: ::prost::alloc::string::String,
    }
    /// Open a materialization stream.
    ///
    /// If the Flow recovery log is authoritative:
    /// The driver is given its last committed checkpoint state in this request.
    /// It MAY return a runtime checkpoint in its opened response -- perhaps an older
    /// Flow checkpoint which was previously embedded within its driver checkpoint.
    ///
    /// If the remote store is authoritative:
    /// The driver MUST fence off other streams of this materialization that
    /// overlap the provided [key_begin, key_end) range, such that those streams
    /// cannot issue further commits. The driver MUST return its stored runtime
    /// checkpoint for this materialization and range \[key_begin, key_end\]
    /// in its Opened response.
    ///
    /// After Open, the runtime will send only Load, Flush, Store,
    /// StartCommit, and Acknowledge.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Open {
        /// Materialization to be transacted.
        #[prost(message, optional, tag = "1")]
        pub materialization: ::core::option::Option<
            super::super::flow::MaterializationSpec,
        >,
        /// Version of the opened MaterializationSpec.
        /// The driver may want to require that this match the version last
        /// provided to a successful Apply RPC. It's possible that it won't,
        /// due to expected propagation races in Flow's distributed runtime.
        #[prost(string, tag = "2")]
        pub version: ::prost::alloc::string::String,
        /// Range of documents to be processed by this session.
        #[prost(message, optional, tag = "3")]
        pub range: ::core::option::Option<super::super::flow::RangeSpec>,
        /// Last-persisted connector checkpoint state from a previous session.
        #[prost(string, tag = "4")]
        pub state_json: ::prost::alloc::string::String,
    }
    /// Load a document identified by its key. The given key may have never before been stored,
    /// but a given key will be sent in a transaction Load just one time.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Load {
        /// Index of the Open binding for which this document is to be loaded.
        #[prost(uint32, tag = "1")]
        pub binding: u32,
        /// key tuple, as an array of key components.
        /// Ordering matches `keys` of the materialization's field selection.
        #[prost(string, tag = "2")]
        pub key_json: ::prost::alloc::string::String,
        /// Packed tuple of the document key to load.
        #[prost(bytes = "bytes", tag = "3")]
        pub key_packed: ::prost::bytes::Bytes,
    }
    /// Flush loads. No further Loads will be sent in this transaction,
    /// and the runtime will await the connectors's remaining Loaded
    /// responses followed by one Flushed response.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Flush {}
    /// Store documents updated by the current transaction.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Store {
        /// Index of the Open binding for which this document is to be stored.
        #[prost(uint32, tag = "1")]
        pub binding: u32,
        /// Key tuple, as an array of key components.
        /// Ordering matches `keys` of the materialization's field selection.
        #[prost(string, tag = "2")]
        pub key_json: ::prost::alloc::string::String,
        /// Packed FoundationDB tuple of the document key to store.
        #[prost(bytes = "bytes", tag = "3")]
        pub key_packed: ::prost::bytes::Bytes,
        /// Values tuple, as an array of value components.
        /// Ordering matches `values` of the materialization's field selection.
        #[prost(string, tag = "4")]
        pub values_json: ::prost::alloc::string::String,
        /// Packed FoundationDB tuple of the document values to store.
        #[prost(bytes = "bytes", tag = "5")]
        pub values_packed: ::prost::bytes::Bytes,
        /// JSON document to store.
        #[prost(string, tag = "6")]
        pub doc_json: ::prost::alloc::string::String,
        /// Exists is true if this document has previously been loaded or stored.
        #[prost(bool, tag = "7")]
        pub exists: bool,
        /// Delete is true if this document is being deleted, which also implies `exists`.
        #[prost(bool, tag = "8")]
        pub delete: bool,
    }
    /// Mark the end of the Store phase, and if the remote store is authoritative,
    /// instruct it to start committing its transaction.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StartCommit {
        /// Flow runtime checkpoint to commit with this transaction.
        #[prost(message, optional, tag = "1")]
        pub runtime_checkpoint: ::core::option::Option<
            ::proto_gazette::consumer::Checkpoint,
        >,
    }
    /// Acknowledge to the connector that the previous transaction
    /// has committed to the Flow runtime's recovery log.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Acknowledge {}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Response {
    #[prost(message, optional, tag = "1")]
    pub spec: ::core::option::Option<response::Spec>,
    #[prost(message, optional, tag = "2")]
    pub validated: ::core::option::Option<response::Validated>,
    #[prost(message, optional, tag = "3")]
    pub applied: ::core::option::Option<response::Applied>,
    #[prost(message, optional, tag = "4")]
    pub opened: ::core::option::Option<response::Opened>,
    #[prost(message, optional, tag = "5")]
    pub loaded: ::core::option::Option<response::Loaded>,
    #[prost(message, optional, tag = "6")]
    pub flushed: ::core::option::Option<response::Flushed>,
    #[prost(message, optional, tag = "7")]
    pub started_commit: ::core::option::Option<response::StartedCommit>,
    #[prost(message, optional, tag = "8")]
    pub acknowledged: ::core::option::Option<response::Acknowledged>,
    /// Reserved for internal use.
    #[prost(bytes = "bytes", tag = "100")]
    pub internal: ::prost::bytes::Bytes,
}
/// Nested message and enum types in `Response`.
pub mod response {
    /// Spec responds to Request.Spec.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Spec {
        /// Protocol version must be 3032023.
        #[prost(uint32, tag = "1")]
        pub protocol: u32,
        /// JSON schema of the connector's configuration.
        #[prost(string, tag = "2")]
        pub config_schema_json: ::prost::alloc::string::String,
        /// JSON schema of the connector's resource configuration.
        /// Schemas must use specific annotations to communicate the expected
        /// locations of injected platform variables:
        /// - `x-collection-name: true`, a string location for a resource name (required).
        /// - `x-schema-name: true`, a string location for a resource schema (optional).
        /// - `x-delta-updates: true`, a boolean location for enabling delta-updates mode (optional).
        #[prost(string, tag = "3")]
        pub resource_config_schema_json: ::prost::alloc::string::String,
        /// URL for connector's documentation.
        #[prost(string, tag = "4")]
        pub documentation_url: ::prost::alloc::string::String,
        /// Optional OAuth2 configuration.
        #[prost(message, optional, tag = "5")]
        pub oauth2: ::core::option::Option<super::super::flow::OAuth2>,
    }
    /// Validated responds to Request.Validate.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Validated {
        #[prost(message, repeated, tag = "1")]
        pub bindings: ::prost::alloc::vec::Vec<validated::Binding>,
    }
    /// Nested message and enum types in `Validated`.
    pub mod validated {
        /// Constraint constrains the use of a flow.Projection within a materialization.
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Constraint {
            #[prost(enumeration = "constraint::Type", tag = "2")]
            pub r#type: i32,
            /// User-facing reason for the given constraint. The control-plane will
            /// supply additional context as to the collection, binding and field.
            ///
            /// Connectors are strongly encouraged to supply a rationale
            /// for constraints other than FIELD_OPTIONAL.
            #[prost(string, tag = "3")]
            pub reason: ::prost::alloc::string::String,
            /// Some endpoints are unable to represent various field names due to
            /// technical limitations on length, character set, or case sensitivity.
            /// For these cases, the connector should provide a "folded" field name to
            /// be used instead. Examples of folds include:
            /// - Lower-casing
            /// - Replacing `/` with `_`
            /// - Mapping Unicode to ASCII via <https://en.wikipedia.org/wiki/Punycode>
            ///
            /// Folds may be lossy and result in duplicated folded field values.
            /// That's okay. The control plane will ensure at most one field is
            /// selected among a set of fields having identical folds.
            #[prost(string, tag = "4")]
            pub folded_field: ::prost::alloc::string::String,
        }
        /// Nested message and enum types in `Constraint`.
        pub mod constraint {
            /// Type encodes a constraint type for this flow.Projection.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Type {
                Invalid = 0,
                /// A field with this specific name MUST be present.
                ///
                /// Connectors should return FIELD_REQUIRED for field names that have
                /// special meaning to the function of the connector. For example, a
                /// Slack connector might require a "text" field which is the body of
                /// Slack messages to author.
                ///
                /// Connectors may return FIELD_REQUIRED constraints for fields which
                /// were not present in the presented collection projections, in which
                /// case the control plane will generate a suitable user-facing error.
                FieldRequired = 1,
                /// A field projection with this location pointer must be present.
                ///
                /// Connectors may return LOCATION_REQUIRED for the root JSON document
                /// pointer within a standard materialization that stores the document
                /// as a single column. Or alternatively, a connector may require
                /// all top-level document properties and store each as separate
                /// columns, which are merged together again in Loaded responses.
                LocationRequired = 2,
                /// DEPRECATED. LOCATION_RECOMMENDED is equivalent to FIELD_OPTIONAL.
                LocationRecommended = 3,
                /// This field projection may be included in the materialization.
                ///
                /// Connectors must return FIELD_OPTIONAL for all fields which they
                /// are capable of supporting.
                FieldOptional = 4,
                /// This field projection cannot participate in the materialization.
                /// This condition is permanent and cannot be resolved with a backfill.
                ///
                /// Connectors must return FIELD_FORBIDDEN for fields having
                /// unsupported types, such as JSON `null`.
                FieldForbidden = 5,
                /// This field projection cannot participate in the materialization.
                /// However, a backfill of the binding would clear this condition
                /// and the field could again participate.
                ///
                /// Connectors must return UNSATISFIABLE for fields which would be
                /// FIELD_OPTIONAL if (and only if) the binding were to be backfilled.
                /// A common use is for fields that map to an existing SQL column having
                /// an incompatible type which cannot be migrated automatically.
                Unsatisfiable = 6,
            }
            impl Type {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Type::Invalid => "INVALID",
                        Type::FieldRequired => "FIELD_REQUIRED",
                        Type::LocationRequired => "LOCATION_REQUIRED",
                        Type::LocationRecommended => "LOCATION_RECOMMENDED",
                        Type::FieldOptional => "FIELD_OPTIONAL",
                        Type::FieldForbidden => "FIELD_FORBIDDEN",
                        Type::Unsatisfiable => "UNSATISFIABLE",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "INVALID" => Some(Self::Invalid),
                        "FIELD_REQUIRED" => Some(Self::FieldRequired),
                        "LOCATION_REQUIRED" => Some(Self::LocationRequired),
                        "LOCATION_RECOMMENDED" => Some(Self::LocationRecommended),
                        "FIELD_OPTIONAL" => Some(Self::FieldOptional),
                        "FIELD_FORBIDDEN" => Some(Self::FieldForbidden),
                        "UNSATISFIABLE" => Some(Self::Unsatisfiable),
                        _ => None,
                    }
                }
            }
        }
        /// Validation responses for each binding of the request, and matching the
        /// request ordering. Each Binding must have a unique resource_path.
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Binding {
            /// Constraints imposed by the connector, keyed by field name.
            /// Projections of the CollectionSpec which are missing from
            /// constraints are implicitly forbidden.
            #[prost(btree_map = "string, message", tag = "1")]
            pub constraints: ::prost::alloc::collections::BTreeMap<
                ::prost::alloc::string::String,
                Constraint,
            >,
            /// Components of the resource path which fully qualify the resource
            /// identified by this binding.
            /// - For an RDBMS, this might be \[\]{dbname, schema, table}.
            /// - For Kafka, this might be \[\]{topic}.
            /// - For Redis, this might be \[\]{key_prefix}.
            #[prost(string, repeated, tag = "2")]
            pub resource_path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// Materialize combined delta updates of documents rather than full
            /// reductions.
            ///
            /// When set, the Flow runtime will not attempt to load documents via
            /// Request.Load, and also disables re-use of cached documents
            /// stored in prior transactions. Each stored document is exclusively
            /// combined from updates processed by the runtime within the current
            /// transaction only.
            ///
            /// This is appropriate for drivers over streams, WebHooks, and append-only
            /// files.
            ///
            /// For example, given a collection which reduces a sum count for each key,
            /// its materialization will produce a stream of delta updates to the count,
            /// such that a reader of the stream will arrive at the correct total count.
            #[prost(bool, tag = "3")]
            pub delta_updates: bool,
            /// Serialization policy to use for this binding.
            #[prost(message, optional, tag = "4")]
            pub ser_policy: ::core::option::Option<super::super::super::flow::SerPolicy>,
        }
    }
    /// Applied responds to Request.Apply.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Applied {
        /// Human-readable description of the action that the connector took.
        /// If empty, this Apply is to be considered a "no-op".
        #[prost(string, tag = "1")]
        pub action_description: ::prost::alloc::string::String,
        /// Optional *transactional* update to ConnectorState.
        /// This update commits atomically with the Flow recovery log checkpoint
        /// which marks the current specification as having been applied.
        #[prost(message, optional, tag = "2")]
        pub state: ::core::option::Option<super::super::flow::ConnectorState>,
    }
    /// Opened responds to Request.Open.
    /// After Opened, the connector sends only Loaded, Flushed,
    /// StartedCommit, and Acknowledged as per the materialization
    /// protocol.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Opened {
        /// Flow runtime checkpoint to begin processing from.
        /// If empty, the most recent checkpoint of the Flow recovery log is used.
        ///
        /// Or, a driver may send the value \[\]byte{0xf8, 0xff, 0xff, 0xff, 0xf, 0x1}
        /// to explicitly begin processing from a zero-valued checkpoint, effectively
        /// rebuilding the materialization from scratch. This sentinel is a trivial
        /// encoding of the max-value 2^29-1 protobuf tag with boolean true.
        #[prost(message, optional, tag = "1")]
        pub runtime_checkpoint: ::core::option::Option<
            ::proto_gazette::consumer::Checkpoint,
        >,
    }
    /// Loaded responds to Request.Load.
    /// It returns documents of requested keys which have previously been stored.
    /// Keys not found in the store MUST be omitted. Documents may be in any order,
    /// both within and across Loaded response messages, but a document of a given
    /// key MUST be sent at most one time in a Transaction.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Loaded {
        /// Index of the Open binding for which this document was loaded.
        #[prost(uint32, tag = "1")]
        pub binding: u32,
        /// Loaded JSON document.
        #[prost(string, tag = "2")]
        pub doc_json: ::prost::alloc::string::String,
    }
    /// Flushed responds to a Request.Flush.
    /// The driver will send no further Loaded responses.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Flushed {
        /// Optional update to ConnectorState.
        /// This update is durably written before the connector receives a following
        /// Store or StartCommit request.
        #[prost(message, optional, tag = "1")]
        pub state: ::core::option::Option<super::super::flow::ConnectorState>,
    }
    /// StartedCommit responds to a Request.StartCommit.
    /// The driver has processed all Store requests, it has started to commit its
    /// transaction (if it has one), and it is now ready for the runtime to start
    /// committing to its own recovery log.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StartedCommit {
        /// Optional *transactional* update to ConnectorState.
        /// This update commits atomically with the Flow recovery log checkpoint.
        #[prost(message, optional, tag = "1")]
        pub state: ::core::option::Option<super::super::flow::ConnectorState>,
    }
    /// Notify the runtime that the previous transaction has committed.
    /// On receipt, the runtime may begin to flush, store, and commit a
    /// next (pipelined) transaction.
    ///
    /// Acknowledged is _not_ a direct response to Request.Acknowledge,
    /// and Acknowledge vs Acknowledged may be written in either order.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Acknowledged {
        /// Optional *non-transactional* update to ConnectorState.
        /// This update is not transactional and the connector must tolerate a future,
        /// duplicate Request.Acknowledge of this same checkpoint and connector state,
        /// even after having previously responded with Acknowledged and a (discarded)
        /// connector state update.
        #[prost(message, optional, tag = "1")]
        pub state: ::core::option::Option<super::super::flow::ConnectorState>,
    }
}
/// Extra messages used by connectors
/// TODO(johnny): Do we still need this?
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Extra {}
/// Nested message and enum types in `Extra`.
pub mod extra {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ValidateExistingProjectionRequest {
        #[prost(message, optional, tag = "1")]
        pub existing_binding: ::core::option::Option<
            super::super::flow::materialization_spec::Binding,
        >,
        #[prost(message, optional, tag = "2")]
        pub proposed_binding: ::core::option::Option<super::request::validate::Binding>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ValidateBindingAgainstConstraints {
        #[prost(message, optional, tag = "1")]
        pub binding: ::core::option::Option<
            super::super::flow::materialization_spec::Binding,
        >,
        #[prost(btree_map = "string, message", tag = "2")]
        pub constraints: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            super::response::validated::Constraint,
        >,
    }
}
