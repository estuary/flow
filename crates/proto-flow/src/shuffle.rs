// This file is @generated by prost-build.
/// Member represents a participant in the shuffle topology (e.x. a task shard).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Member {
    /// Key and r-clock document range owned by this member.
    #[prost(message, optional, tag = "1")]
    pub range: ::core::option::Option<super::flow::RangeSpec>,
    /// Address of this member, as a gRPC endpoint.
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
}
/// Task identifies what we're performing shuffles for.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Task {
    #[prost(oneof = "task::Task", tags = "2, 3, 4")]
    pub task: ::core::option::Option<task::Task>,
}
/// Nested message and enum types in `Task`.
pub mod task {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Task {
        /// Derivation for which we're performing shuffles.
        #[prost(message, tag = "2")]
        Derivation(super::super::flow::collection_spec::Derivation),
        /// Materialization for which we're performing shuffles.
        #[prost(message, tag = "3")]
        Materialization(super::super::flow::MaterializationSpec),
        /// Single collection for which we're performing shuffles (ad-hoc read).
        #[prost(message, tag = "4")]
        Collection(super::super::flow::CollectionSpec),
    }
}
/// JournalTag associates a journal name with a stable integer tag.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct JournalTag {
    /// Name of the journal.
    #[prost(string, tag = "1")]
    pub journal_name: ::prost::alloc::string::String,
    /// Tag assigned to this journal.
    #[prost(uint32, tag = "2")]
    pub journal_tag: u32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct JournalProducer {
    /// Journal tag of the producer.
    #[prost(uint32, tag = "1")]
    pub journal_tag: u32,
    /// Producer ID extracted from document UUID.
    #[prost(fixed64, tag = "2")]
    pub producer_id: u64,
    /// Clock of the last ACK seen from this producer.
    #[prost(fixed64, tag = "3")]
    pub last_ack: u64,
    /// Document offset:
    ///
    /// * When positive, the producer has an uncommitted transaction
    ///   which begins at this offset.
    /// * When negative, the producer last committed with an
    ///   ACK which ends at the byte prior to this offset.
    /// * When zero, the producer is committed but the last offset is unknown.
    #[prost(int64, tag = "4")]
    pub offset: i64,
}
/// SessionRequest is sent by the coordinator to manage the shuffle session.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionRequest {
    #[prost(message, optional, tag = "1")]
    pub open: ::core::option::Option<session_request::Open>,
    #[prost(message, optional, tag = "2")]
    pub next_checkpoint: ::core::option::Option<session_request::NextCheckpoint>,
}
/// Nested message and enum types in `SessionRequest`.
pub mod session_request {
    /// Open initiates a new shuffle session.
    /// Sent once at the start of the Session RPC.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Open {
        /// Unique identifier for this session instance.
        /// Used to correlate Slice and Queue RPCs, and to name queue files.
        #[prost(fixed64, tag = "1")]
        pub session_id: u64,
        /// Task for which we're performing shuffles.
        #[prost(message, optional, tag = "2")]
        pub task: ::core::option::Option<super::Task>,
        /// Members participating in this shuffle session.
        #[prost(message, repeated, tag = "3")]
        pub members: ::prost::alloc::vec::Vec<super::Member>,
        /// Previously assigned journal tags to resume from.
        #[prost(message, repeated, tag = "4")]
        pub resume_tags: ::prost::alloc::vec::Vec<super::JournalTag>,
        /// Last fully-committed checkpoint for reads of this task.
        #[prost(message, repeated, tag = "5")]
        pub last_commit: ::prost::alloc::vec::Vec<super::JournalProducer>,
        /// If set, this is a checkpoint delta atop last_commit that was prepared but not
        /// committed before failure, and which must be read through on startup.
        /// When ready, this checkpoint will be the first NextCheckpoint response.
        #[prost(message, repeated, tag = "6")]
        pub read_through: ::prost::alloc::vec::Vec<super::JournalProducer>,
    }
    /// NextCheckpoint requests the next available checkpoint delta.
    /// This is a blocking poll: the Session responds when progress is
    /// available. The client initiates polls at times of their choosing
    /// (e.g., after completing processing of the previous checkpoint).
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct NextCheckpoint {}
}
/// SessionResponse is sent by the Session to the coordinator.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionResponse {
    #[prost(message, optional, tag = "1")]
    pub opened: ::core::option::Option<session_response::Opened>,
    #[prost(message, optional, tag = "2")]
    pub next_checkpoint: ::core::option::Option<session_response::NextCheckpoint>,
}
/// Nested message and enum types in `SessionResponse`.
pub mod session_response {
    /// Opened confirms the Session is ready.
    /// Sent after all Slices have responded Opened.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Opened {}
    /// NextCheckpoint provides the next transaction extent to process.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NextCheckpoint {
        /// Delta checkpoint having the frontier of transactions ready to process.
        /// All documents in this checkpoint extent have been flushed to
        /// member queue files and are ready for dequeue and processing.
        ///
        /// This is a sparse update containing only JournalProducers with
        /// progress since the last checkpoint. The client must merge this
        /// into their base checkpoint.
        #[prost(message, repeated, tag = "1")]
        pub delta_checkpoint: ::prost::alloc::vec::Vec<super::JournalProducer>,
    }
}
/// SliceRequest is sent by the Session to each member's Slice RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SliceRequest {
    #[prost(message, optional, tag = "1")]
    pub open: ::core::option::Option<slice_request::Open>,
    #[prost(message, optional, tag = "2")]
    pub journal_tags: ::core::option::Option<slice_request::JournalTags>,
    #[prost(message, optional, tag = "3")]
    pub start_read: ::core::option::Option<slice_request::StartRead>,
    #[prost(message, optional, tag = "4")]
    pub stop_read: ::core::option::Option<slice_request::StopRead>,
}
/// Nested message and enum types in `SliceRequest`.
pub mod slice_request {
    /// Open initiates the Slice.
    /// The Slice opens Queue RPCs to all members before responding Opened.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Open {
        /// Session ID from SessionRequest.Open.
        #[prost(fixed64, tag = "1")]
        pub session_id: u64,
        /// Task for which we're performing shuffles.
        #[prost(message, optional, tag = "2")]
        pub task: ::core::option::Option<super::Task>,
        /// Members participating in this shuffle session.
        /// Must be the same members and order as Session.Open.
        #[prost(message, repeated, tag = "3")]
        pub members: ::prost::alloc::vec::Vec<super::Member>,
        /// Index of this member within the members list.
        #[prost(uint32, tag = "4")]
        pub member_index: u32,
    }
    /// JournalTags is broadcast to notify all Slices of new
    /// journal tag assignments.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct JournalTags {
        /// Assigned journal tags for this Slice.
        #[prost(message, repeated, tag = "1")]
        pub tags: ::prost::alloc::vec::Vec<super::JournalTag>,
    }
    /// StartRead instructs the Slice to begin reading a journal.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StartRead {
        /// Binding index within the task (derivation transform or
        /// materialization binding).
        #[prost(uint32, tag = "1")]
        pub binding: u32,
        /// Tag of the journal to read.
        #[prost(uint32, tag = "2")]
        pub journal_tag: u32,
        /// Checkpoint state for this journal from last_commit.
        /// The Slice reads from the earliest offset of all uncommitted
        /// producers, or the latest offset of all committed producers,
        /// or zero if there are no producers.
        #[prost(message, repeated, tag = "3")]
        pub checkpoint: ::prost::alloc::vec::Vec<super::JournalProducer>,
    }
    /// StopRead instructs the Slice to stop reading a journal.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct StopRead {
        /// Journal tag previously provided in StartRead.
        #[prost(uint32, tag = "1")]
        pub journal_tag: u32,
    }
}
/// SliceResponse is sent by each Slice back to the Session.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SliceResponse {
    #[prost(message, optional, tag = "1")]
    pub opened: ::core::option::Option<slice_response::Opened>,
    #[prost(message, optional, tag = "2")]
    pub progress_delta: ::core::option::Option<slice_response::ProgressDelta>,
}
/// Nested message and enum types in `SliceResponse`.
pub mod slice_response {
    /// Opened confirms the Slice is ready.
    /// Sent after all Queue RPCs have responded Opened.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Opened {}
    /// ProgressDelta reports read progress across all journals since the last flush.
    /// Sent after completion of each Flush (all Queue RPCs responded Flushed),
    /// guaranteeing all documents up to this point are available across queues.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProgressDelta {
        #[prost(message, repeated, tag = "1")]
        pub journal_producers: ::prost::alloc::vec::Vec<super::JournalProducer>,
        #[prost(message, repeated, tag = "2")]
        pub causal_hints: ::prost::alloc::vec::Vec<progress_delta::CausalHint>,
    }
    /// Nested message and enum types in `ProgressDelta`.
    pub mod progress_delta {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CausalHint {
            /// Journal tag of the hinted journal.
            #[prost(uint32, tag = "1")]
            pub journal_tag: u32,
            /// Producer ID extracted from document UUID.
            #[prost(fixed64, tag = "2")]
            pub producer_id: u64,
            /// Clock of the expected ACK for this producer.
            #[prost(fixed64, tag = "3")]
            pub last_ack: u64,
        }
    }
}
/// QueueRequest is sent by Slices to each member's Queue.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueueRequest {
    #[prost(message, optional, tag = "1")]
    pub open: ::core::option::Option<queue_request::Open>,
    #[prost(message, optional, tag = "2")]
    pub enqueue: ::core::option::Option<queue_request::Enqueue>,
    #[prost(message, optional, tag = "3")]
    pub flush: ::core::option::Option<queue_request::Flush>,
}
/// Nested message and enum types in `QueueRequest`.
pub mod queue_request {
    /// Open initiates the Queue RPC.
    /// Multiple Slices open Queue RPCs to the same member, and the Queue
    /// task joins these streams and processes documents in merged order.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Open {
        /// Session ID for correlating streams from the same session.
        /// Combined with member_index to deterministically name the queue file.
        #[prost(fixed64, tag = "1")]
        pub session_id: u64,
        /// Total number of members (and thus Slices) in the session.
        /// Queue joins over this many incoming Slice streams.
        #[prost(uint32, tag = "2")]
        pub member_count: u32,
        /// Index of the source Slice member within the session's member list.
        #[prost(uint32, tag = "3")]
        pub slice_member_index: u32,
        /// Index of the target Queue member within the session's member list.
        #[prost(uint32, tag = "4")]
        pub queue_member_index: u32,
    }
    /// Enqueue sends a document to be written to the queue.
    /// The Queue merges across Slice streams, ordering by (priority, clock).
    ///
    /// ACK documents (identifiable via uuid_parts.node flags) may be sent
    /// to multiple Queues based on the tracked key/r-clock extent of the
    /// producer's prior documents.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Enqueue {
        /// Tag of the document's source journal.
        #[prost(uint32, tag = "1")]
        pub journal_tag: u32,
        /// Binding index for this document.
        #[prost(uint32, tag = "2")]
        pub binding: u32,
        /// UUID of the document.
        /// Contains producer ID, clock, and flags (e.g. ACK).
        #[prost(message, optional, tag = "3")]
        pub uuid_parts: ::core::option::Option<super::super::flow::UuidParts>,
        /// Packed shuffle key of the document.
        #[prost(bytes = "bytes", tag = "4")]
        pub packed_key: ::prost::bytes::Bytes,
        /// Priority of this document's binding.
        /// Queue orders documents by (priority DESC, clock ASC).
        #[prost(uint32, tag = "5")]
        pub priority: u32,
        /// Document content as JSON bytes.
        #[prost(bytes = "bytes", tag = "6")]
        pub doc_json: ::prost::bytes::Bytes,
    }
    /// Flush requests a durability barrier.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Flush {
        /// Sequence number for correlating Flush with Flushed response.
        /// Allows pipelining if we later want multiple in-flight flushes.
        #[prost(uint64, tag = "1")]
        pub seq: u64,
    }
}
/// QueueResponse is sent by the Queue back to each Slice.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueueResponse {
    #[prost(message, optional, tag = "1")]
    pub opened: ::core::option::Option<queue_response::Opened>,
    #[prost(message, optional, tag = "2")]
    pub flushed: ::core::option::Option<queue_response::Flushed>,
}
/// Nested message and enum types in `QueueResponse`.
pub mod queue_response {
    /// Opened confirms the Queue is ready to receive documents.
    /// Sent after the Queue has joined over the member's queue file.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Opened {}
    /// Flushed confirms all preceding documents are durable on disk.
    /// Only after receiving Flushed from ALL Queues can a Slice safely
    /// report ProgressDelta to the Session.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Flushed {
        /// Sequence number from the corresponding Flush request.
        #[prost(uint64, tag = "1")]
        pub seq: u64,
    }
}
