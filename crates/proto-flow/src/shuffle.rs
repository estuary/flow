// This file is @generated by prost-build.
/// Member represents a participant in the shuffle topology (e.x. a task shard).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Member {
    /// Key and r-clock document range owned by this member.
    #[prost(message, optional, tag = "1")]
    pub range: ::core::option::Option<super::flow::RangeSpec>,
    /// gRPC endpoint of this member.
    #[prost(string, tag = "2")]
    pub endpoint: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollectionPartitions {
    /// Collection specification.
    #[prost(message, optional, tag = "1")]
    pub collection: ::core::option::Option<super::flow::CollectionSpec>,
    /// Partition selector for filtering source collection journals.
    #[prost(message, optional, tag = "2")]
    pub partition_selector: ::core::option::Option<::proto_gazette::broker::LabelSelector>,
}
/// Task which we're performing shuffles for.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Task {
    #[prost(oneof = "task::Task", tags = "1, 2, 3")]
    pub task: ::core::option::Option<task::Task>,
}
/// Nested message and enum types in `Task`.
pub mod task {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Task {
        /// Partitions of a single collection (ad-hoc read).
        #[prost(message, tag = "1")]
        CollectionPartitions(super::CollectionPartitions),
        /// Derivation for which we're performing shuffles.
        /// The collection's `derivation` field must be set.
        #[prost(message, tag = "2")]
        Derivation(super::super::flow::CollectionSpec),
        /// Materialization for which we're performing shuffles.
        #[prost(message, tag = "3")]
        Materialization(super::super::flow::MaterializationSpec),
    }
}
/// When appending to Journals, independent producers author transactions
/// spanning one or more journals. When reading, we track the progress of each
/// producer to understand the status of its transactions. JournalProducer
/// represents the progress of a tuple (journal name, binding index, producer ID).
/// A binding is the context under which a task is reading a journal, and there
/// may be multiple such contexts per journal which read independently.
///
/// JournalProducer uses a delta-encoding scheme to efficiently represent
/// the progression of journal names across a sequence of instances.
/// Given a known preceding journal name string, an instance encodes how many
/// right-most bytes to truncate, followed by a suffix to append, to reconstruct
/// the present value. In the common case where a journal name is the same
/// (only the producer ID has changed), then related fields are their defaults
/// and are omitted from the encoded protobuf stream.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct JournalProducer {
    /// Number of bytes to truncate from the preceding name.
    /// Must align with a UTF-8 code point boundary.
    /// Negative values (e.x. -1) discard the entire preceding name.
    #[prost(int32, tag = "1")]
    pub journal_name_truncate_delta: i32,
    /// Suffix to append to the preceding, truncated name.
    #[prost(string, tag = "2")]
    pub journal_name_suffix: ::prost::alloc::string::String,
    /// Binding index of this JournalProducer.
    /// When persisting across sessions, this should be mapped via the task's
    /// `journal_read_suffix` to ensure stability across task versions.
    #[prost(uint32, tag = "3")]
    pub binding: u32,
    /// Producer ID of the JournalProducer, extracted from a document UUID.
    #[prost(fixed64, tag = "4")]
    pub producer_id: u64,
    /// Clock of the last ACK seen from this producer.
    #[prost(fixed64, tag = "5")]
    pub last_ack: u64,
    /// Document offset:
    ///
    /// * When positive, the producer has an uncommitted transaction
    ///   which begins at this offset.
    /// * When negative, the producer last committed with an
    ///   ACK which ends at the byte prior to this offset.
    /// * When zero, the producer is committed but the last offset is unknown.
    #[prost(int64, tag = "6")]
    pub offset: i64,
}
/// JournalProducerChunk is a portion of a sequence of JournalProducers, where the
/// entire sequence is ordered on ascending (journal name, binding index, producer ID).
///
/// A final empty chunk represents end-of-sequence.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JournalProducerChunk {
    #[prost(message, repeated, tag = "1")]
    pub chunk: ::prost::alloc::vec::Vec<JournalProducer>,
}
/// SessionRequest is sent by the Coordinator to manage the shuffle session.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionRequest {
    #[prost(message, optional, tag = "1")]
    pub open: ::core::option::Option<session_request::Open>,
    /// The last-committed checkpoint which the session is resuming from.
    /// It's streamed by the Coordinator after reading SessionResponse.Opened.
    #[prost(message, optional, tag = "2")]
    pub last_commit_chunk: ::core::option::Option<JournalProducerChunk>,
    /// A read-through checkpoint delta (atop the last commit), that was prepared
    /// but not yet committed during the previous session.
    ///
    /// If non-empty, the read-through checkpoint must be read through on startup
    /// and will be the first "next checkpoint" response.
    #[prost(message, optional, tag = "3")]
    pub read_through_chunk: ::core::option::Option<JournalProducerChunk>,
    #[prost(message, optional, tag = "4")]
    pub next_checkpoint: ::core::option::Option<session_request::NextCheckpoint>,
}
/// Nested message and enum types in `SessionRequest`.
pub mod session_request {
    /// Open initiates a new shuffle session.
    /// Sent once at the start of the Session RPC.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Open {
        /// Unique identifier for this session instance.
        /// Used to correlate Slice and Queue RPCs, and to name queue files.
        #[prost(fixed64, tag = "1")]
        pub session_id: u64,
        /// Task for which we're performing shuffles.
        #[prost(message, optional, tag = "2")]
        pub task: ::core::option::Option<super::Task>,
        /// Members participating in this shuffle session.
        #[prost(message, repeated, tag = "3")]
        pub members: ::prost::alloc::vec::Vec<super::Member>,
    }
    /// NextCheckpoint requests the next available checkpoint delta.
    /// This is a blocking request: the Session only responds when progress is
    /// available. The client requests a next checkpoint at times of its choosing
    /// (e.g., after completing processing of the previous checkpoint).
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct NextCheckpoint {}
}
/// SessionResponse is sent by the Session to the Coordinator.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionResponse {
    #[prost(message, optional, tag = "1")]
    pub opened: ::core::option::Option<session_response::Opened>,
    /// The next checkpoint delta (atop the last commit) which reflects the extents
    /// of a transaction which is ready to be processed. It's sent in response to
    /// SessionRequest.NextCheckpoint, and is never empty (though the Session may
    /// block indefinitely until progress is available).
    #[prost(message, optional, tag = "2")]
    pub next_checkpoint_chunk: ::core::option::Option<JournalProducerChunk>,
}
/// Nested message and enum types in `SessionResponse`.
pub mod session_response {
    /// Opened confirms the Session is ready.
    /// Sent after all Slices have responded Opened.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Opened {}
}
/// SliceRequest is sent by the Session to each member's Slice RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SliceRequest {
    #[prost(message, optional, tag = "1")]
    pub open: ::core::option::Option<slice_request::Open>,
    #[prost(message, optional, tag = "2")]
    pub start: ::core::option::Option<slice_request::Start>,
    #[prost(message, optional, tag = "3")]
    pub start_read: ::core::option::Option<slice_request::StartRead>,
}
/// Nested message and enum types in `SliceRequest`.
pub mod slice_request {
    /// Open initiates the Slice.
    /// The Slice opens Queue RPCs to all members before responding Opened.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Open {
        /// Session ID from SessionRequest.Open.
        #[prost(fixed64, tag = "1")]
        pub session_id: u64,
        /// Task for which we're performing shuffles.
        #[prost(message, optional, tag = "2")]
        pub task: ::core::option::Option<super::Task>,
        /// Members participating in this shuffle session.
        /// Must be the same members and order as Session.Open.
        #[prost(message, repeated, tag = "3")]
        pub members: ::prost::alloc::vec::Vec<super::Member>,
        /// Index of this member within the members list.
        #[prost(uint32, tag = "4")]
        pub member_index: u32,
    }
    /// Start is sent after all Slices have responded Opened and the Session has
    /// received the last-committed & read-through checkpoints from the Coordinator.
    /// On receipt, Slices start listing watches and may send SliceResponse.ListingAdded.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Start {}
    /// StartRead instructs the Slice to begin reading a journal.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StartRead {
        /// Binding index within the task (derivation transform or
        /// materialization binding).
        #[prost(uint32, tag = "1")]
        pub binding: u32,
        /// Journal to be read.
        #[prost(message, optional, tag = "2")]
        pub spec: ::core::option::Option<::proto_gazette::broker::JournalSpec>,
        /// Etcd revision at which the journal was created.
        #[prost(int64, tag = "3")]
        pub create_revision: i64,
        /// Etcd revision at which the journal was last modified.
        #[prost(int64, tag = "4")]
        pub mod_revision: i64,
        /// Current route of the journal, as an initial advisory hint.
        #[prost(message, optional, tag = "5")]
        pub route: ::core::option::Option<::proto_gazette::broker::Route>,
        /// Producers of this Journal as-of the last-committed checkpoint.
        #[prost(message, repeated, tag = "6")]
        pub checkpoint: ::prost::alloc::vec::Vec<super::JournalProducer>,
    }
}
/// SliceResponse is sent by each Slice back to the Session.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SliceResponse {
    #[prost(message, optional, tag = "1")]
    pub opened: ::core::option::Option<slice_response::Opened>,
    #[prost(message, optional, tag = "2")]
    pub listing_added: ::core::option::Option<slice_response::ListingAdded>,
    #[prost(message, optional, tag = "3")]
    pub progress_delta: ::core::option::Option<slice_response::ProgressDelta>,
}
/// Nested message and enum types in `SliceResponse`.
pub mod slice_response {
    /// Opened confirms the Slice is ready.
    /// Sent after all Queue RPCs have responded Opened.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Opened {}
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListingAdded {
        /// Binding index of the listing.
        #[prost(uint32, tag = "1")]
        pub binding: u32,
        /// Journal which was added to the listing.
        #[prost(message, optional, tag = "2")]
        pub spec: ::core::option::Option<::proto_gazette::broker::JournalSpec>,
        /// Etcd revision at which the journal was created.
        #[prost(int64, tag = "3")]
        pub create_revision: i64,
        /// Etcd revision at which the journal was last modified.
        #[prost(int64, tag = "4")]
        pub mod_revision: i64,
        /// Current route of the journal, as an initial advisory hint.
        #[prost(message, optional, tag = "5")]
        pub route: ::core::option::Option<::proto_gazette::broker::Route>,
    }
    /// ProgressDelta reports read progress across all journals since the last flush.
    /// Sent after completion of each Flush (all Queue RPCs responded Flushed),
    /// guaranteeing all documents up to this point are available across queues.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProgressDelta {
        #[prost(message, repeated, tag = "1")]
        pub journal_producers: ::prost::alloc::vec::Vec<super::JournalProducer>,
        #[prost(message, repeated, tag = "2")]
        pub causal_hints: ::prost::alloc::vec::Vec<progress_delta::CausalHint>,
    }
    /// Nested message and enum types in `ProgressDelta`.
    pub mod progress_delta {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CausalHint {
            /// The hinted journal.
            #[prost(string, tag = "1")]
            pub journal: ::prost::alloc::string::String,
            /// Producer ID extracted from document UUID.
            #[prost(fixed64, tag = "2")]
            pub producer_id: u64,
            /// Clock of the expected ACK for this producer.
            #[prost(fixed64, tag = "3")]
            pub last_ack: u64,
        }
    }
}
/// QueueRequest is sent by Slices to each member's Queue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueueRequest {
    #[prost(message, optional, tag = "1")]
    pub open: ::core::option::Option<queue_request::Open>,
    #[prost(message, optional, tag = "2")]
    pub enqueue: ::core::option::Option<queue_request::Enqueue>,
    #[prost(message, optional, tag = "3")]
    pub flush: ::core::option::Option<queue_request::Flush>,
}
/// Nested message and enum types in `QueueRequest`.
pub mod queue_request {
    /// Open initiates the Queue RPC.
    /// Multiple Slices open Queue RPCs to the same member, and the Queue
    /// task joins these streams and processes documents in merged order.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Open {
        /// Session ID for correlating streams from the same session.
        /// Combined with member_index to deterministically name the queue file.
        #[prost(fixed64, tag = "1")]
        pub session_id: u64,
        /// Members participating in this shuffle session.
        /// Must be the same members and order as Session.Open.
        #[prost(message, repeated, tag = "2")]
        pub members: ::prost::alloc::vec::Vec<super::Member>,
        /// Index of the source Slice member within the session's member list.
        #[prost(uint32, tag = "3")]
        pub slice_member_index: u32,
        /// Index of the target Queue member within the session's member list.
        #[prost(uint32, tag = "4")]
        pub queue_member_index: u32,
    }
    /// Enqueue sends a document to be written to the queue.
    /// The Queue merges across Slice streams, ordering by (priority, clock).
    ///
    /// ACK documents (identifiable via uuid_parts.node flags) may be sent
    /// to multiple Queues based on the tracked key/r-clock extent of the
    /// producer's prior documents.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Enqueue {
        /// Document's source journal.
        #[prost(string, tag = "1")]
        pub journal: ::prost::alloc::string::String,
        /// Binding index for this document.
        #[prost(uint32, tag = "2")]
        pub binding: u32,
        /// UUID of the document.
        /// Contains producer ID, clock, and flags (e.g. ACK).
        #[prost(message, optional, tag = "3")]
        pub uuid_parts: ::core::option::Option<super::super::flow::UuidParts>,
        /// Packed shuffle key of the document.
        #[prost(bytes = "bytes", tag = "4")]
        pub packed_key: ::prost::bytes::Bytes,
        /// Priority of this document's binding.
        /// Queue orders documents by (priority DESC, clock ASC).
        #[prost(uint32, tag = "5")]
        pub priority: u32,
        /// Document content as JSON bytes.
        #[prost(bytes = "bytes", tag = "6")]
        pub doc_json: ::prost::bytes::Bytes,
    }
    /// Flush requests a durability barrier.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Flush {
        /// Sequence number for correlating Flush with Flushed response.
        /// Allows pipelining if we later want multiple in-flight flushes.
        #[prost(uint64, tag = "1")]
        pub seq: u64,
    }
}
/// QueueResponse is sent by the Queue back to each Slice.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueueResponse {
    #[prost(message, optional, tag = "1")]
    pub opened: ::core::option::Option<queue_response::Opened>,
    #[prost(message, optional, tag = "2")]
    pub flushed: ::core::option::Option<queue_response::Flushed>,
}
/// Nested message and enum types in `QueueResponse`.
pub mod queue_response {
    /// Opened confirms the Queue is ready to receive documents.
    /// Sent after the Queue has joined over the member's queue file.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Opened {}
    /// Flushed confirms all preceding documents are durable on disk.
    /// Only after receiving Flushed from ALL Queues can a Slice safely
    /// report ProgressDelta to the Session.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Flushed {
        /// Sequence number from the corresponding Flush request.
        #[prost(uint64, tag = "1")]
        pub seq: u64,
    }
}
