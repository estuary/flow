// This file is @generated by prost-build.
/// RecordedOp records states changes occuring within a local file-system.
/// Next tag: 12.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordedOp {
    /// Monotonically-increasing sequence number of this operation.
    #[prost(int64, tag = "1")]
    pub seq_no: i64,
    /// Previous FSM checksum to which this operation should be applied (eg, the
    /// expected checksum arrived at after applying the previous operation.
    #[prost(fixed32, tag = "2")]
    pub checksum: u32,
    /// Author is the unique ID of the Recorder which wrote this RecordedOp.
    /// Each Recorder randomly generates an Author ID at startup, and thereafter
    /// applies it to all operations it records.
    #[prost(fixed32, tag = "3")]
    pub author: u32,
    /// First and last byte offset (exclusive) of this RecordedOp, and the journal
    /// addressed by those offsets.
    ///
    /// These are meta-fields: they're not literally serialized into written messages.
    /// The offsets of a particular message will also vary over its lifetime:
    /// * When first recorded, the offsets at which the write will land within the journal
    ///    cannot be known ahead of time, and Recorders use an approximate lower bound
    ///    as |first_offset|.
    /// * During playback, players have the benefit of inspecting the committed log and
    ///    attach exact byte offsets as they deserialized RecordedOps.
    #[prost(int64, tag = "9")]
    pub first_offset: i64,
    #[prost(int64, tag = "10")]
    pub last_offset: i64,
    #[prost(string, tag = "11")]
    pub log: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub create: ::core::option::Option<recorded_op::Create>,
    #[prost(message, optional, tag = "5")]
    pub link: ::core::option::Option<recorded_op::Link>,
    #[prost(message, optional, tag = "6")]
    pub unlink: ::core::option::Option<recorded_op::Link>,
    #[prost(message, optional, tag = "7")]
    pub write: ::core::option::Option<recorded_op::Write>,
    /// Property indicates a property file has been created or updated.
    /// DEPRECATED. Properties are no longer created,
    /// but will still be applied from a written log.
    #[prost(message, optional, tag = "8")]
    pub property: ::core::option::Option<Property>,
}
/// Nested message and enum types in `RecordedOp`.
pub mod recorded_op {
    /// Create a new "File Node" (Fnode), initially linked to |path|. Fnodes play
    /// a similar role to Posix inodes: they identify a specific file object while
    /// being invariant to (and spanning across) its current or future path links.
    /// The assigned Fnode ID is the |seq_no| of this RecordedOp.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Create {
        /// Filesystem path of this file, relative to the common base directory.
        #[prost(string, tag = "1")]
        pub path: ::prost::alloc::string::String,
    }
    /// Link or unlink an Fnode to a filesystem path.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Link {
        /// Fnode being linked or unlinked.
        #[prost(int64, tag = "1")]
        pub fnode: i64,
        /// Filesystem path being un/linked, relative to the common base directory.
        #[prost(string, tag = "2")]
        pub path: ::prost::alloc::string::String,
    }
    /// Write indicates |length| bytes should be written at |offset| to |fnode|.
    /// In a serialization stream, we expect |length| raw bytes of content to
    /// immediately follow this operation.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Write {
        /// Fnode being written to.
        #[prost(int64, tag = "1")]
        pub fnode: i64,
        /// Byte-offset within the file to which this write is applied.
        #[prost(int64, tag = "2")]
        pub offset: i64,
        /// Length of the write.
        #[prost(int64, tag = "3")]
        pub length: i64,
    }
}
/// Property is a small file which rarely changes, and is thus managed
/// outside of regular Fnode tracking. See FSM.Properties.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Property {
    /// Filesystem path of this property, relative to the common base directory.
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// Complete file content of this property.
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
}
/// Segment is a contiguous chunk of recovery log written by a single Author.
/// Recorders track Segments they have written, for use in providing hints to
/// future readers of the log. A key point to understand is that Gazette append
/// semantics mean that Recorders *cannot know* exactly what offsets their writes
/// are applied to in the log, nor guarantee that their operations are not being
/// interleaved with those of other writers. Log Players are aware of these
/// limitations, and use Segments to resolve conflicts of possible interpretation
/// of the log. Segments produced by a Player are exact, since Players observe all
/// recorded operations at their exact offsets.
/// Next tag: 8.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Segment {
    /// Author which wrote RecordedOps of this Segment.
    #[prost(fixed32, tag = "1")]
    pub author: u32,
    /// First (lowest) sequence number of RecordedOps within this Segment.
    #[prost(int64, tag = "2")]
    pub first_seq_no: i64,
    /// First byte offset of the Segment, where |first_seq_no| is recorded.
    /// If this Segment was produced by a Recorder, this is guaranteed only to be a
    /// lower-bound (eg, a Player reading at this offset may encounter irrelevant
    /// operations prior to the RecordedOp indicated by the tuple
    /// (|author|, |first_seq_no|, |first_checksum|). If a Player produced the Segment,
    /// first_offset is exact.
    #[prost(int64, tag = "3")]
    pub first_offset: i64,
    /// Checksum of the RecordedOp having |first_seq_no|.
    #[prost(fixed32, tag = "4")]
    pub first_checksum: u32,
    /// Last (highest, inclusive) sequence number of RecordedOps within this Segment.
    #[prost(int64, tag = "5")]
    pub last_seq_no: i64,
    /// Last offset (exclusive) of the Segment. Zero means the offset is not known
    /// (eg, because the Segment was produced by a Recorder).
    #[prost(int64, tag = "6")]
    pub last_offset: i64,
    /// Log is the Journal holding this Segment's data, and to which offsets are relative.
    #[prost(string, tag = "7")]
    pub log: ::prost::alloc::string::String,
}
/// FnodeSegments captures log Segments containing all RecordedOps of the Fnode.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FnodeSegments {
    /// Fnode being hinted.
    #[prost(int64, tag = "1")]
    pub fnode: i64,
    /// Segments of the Fnode in the log. Currently, FSM tracks only a single
    /// Segment per Fnode per Author & Log. A specific implication of this is that Fnodes
    /// modified over long periods of time will result in Segments spanning large
    /// chunks of the log. For best performance, Fnodes should be opened & written
    /// once, and then never be modified again (this is RocksDB's behavior).
    /// If supporting this case is desired, FSM will have to be a bit smarter about
    /// not extending Segments which gap over significant portions of the log
    /// (eg, there's a trade-off to make over size of the hinted manifest, vs
    /// savings incurred on playback by being able to skip portions of the log).
    #[prost(message, repeated, tag = "2")]
    pub segments: ::prost::alloc::vec::Vec<Segment>,
}
/// FSMHints represents a manifest of Fnodes which were still live (eg, having
/// remaining links) at the time the FSMHints were produced, as well as any
/// Properties. It allows a Player of the log to identify minimal Segments which
/// must be read to recover all Fnodes, and also contains sufficient metadata for
/// a Player to resolve all possible conflicts it could encounter while reading
/// the log, to arrive at a consistent view of file state which exactly matches
/// that of the Recorder producing the FSMHints.
/// Next tag: 4.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FsmHints {
    /// Log is the implied recovery log of any contained |live_nodes| Segments
    /// which omit a |log| value. This implied behavior is both for backward-
    /// compatibility (Segments didn't always have a |log| field) and also for
    /// compacting the representation in the common case of Segments mostly or
    /// entirely addressing a single log.
    #[prost(string, tag = "1")]
    pub log: ::prost::alloc::string::String,
    /// Live Fnodes and their Segments as-of the generation of these FSMHints.
    #[prost(message, repeated, tag = "2")]
    pub live_nodes: ::prost::alloc::vec::Vec<FnodeSegments>,
    /// Property files and contents as-of the generation of these FSMHints.
    #[prost(message, repeated, tag = "3")]
    pub properties: ::prost::alloc::vec::Vec<Property>,
}
