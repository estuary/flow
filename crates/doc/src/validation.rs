use super::{walker::walk_document, Annotation, AsNode, SerPolicy};
use std::pin::Pin;

// Specialize json templates for the Flow `Annotation` type.
pub type Schema = json::schema::Schema<Annotation>;
pub type SchemaIndexBuilder<'sm> = json::schema::index::IndexBuilder<'sm, Annotation>;
pub type SchemaIndex<'sm> = json::schema::index::Index<'sm, Annotation>;
pub type FullContext = json::validator::FullContext;
pub type SpanContext = json::validator::SpanContext;
pub type RawValidator<'sm> = json::validator::Validator<'sm, Annotation, SpanContext>;
pub type Outcome<'sm> = (
    json::validator::Outcome<'sm, Annotation>,
    json::validator::SpanContext,
);

// Re-export build_schema for lower-level usages.
pub use json::schema::build::build_schema;

// Build an already-bundled Schema.
pub fn build_bundle(bundle: &[u8]) -> Result<Schema, json::schema::build::Error> {
    let mut schema = build_schema(
        url::Url::parse("schema://bundle").unwrap(),
        &serde_json::from_slice(bundle).map_err(json::schema::build::Error::FormatErr)?,
    )?;

    // Tweak scope to remove a synthetic resource pointer that was previously
    // embedded in the $id during schema bundling, so that any errors
    // generated by this schema have a relate-able error scope for the user.
    // We tweak only the outer / top-level Schema instance and not its children,
    // which is not fully correct because those children will still have `ptr=...`
    // in their `curi` fields.
    // TODO(johnny): Per JSON-Schema spec $id is not allowed to have a fragment,
    // but perhaps we should relax this restriction for our implementation?
    for (key, value) in schema.curi.query_pairs() {
        if key != "ptr" {
            continue;
        }
        let fragment = value.to_string();
        schema.curi.set_fragment(Some(&fragment));
        schema.curi.set_query(None);
        break;
    }

    Ok(schema)
}

// Validator wraps a json::Validator and manages ownership of the schemas under validation.
pub struct Validator {
    // Careful, order matters! Fields are dropped in declaration order.
    inner: json::validator::Validator<'static, Annotation, SpanContext>,
    index: Pin<Box<SchemaIndex<'static>>>,
    schemas: Pin<Box<[Schema]>>,
}

impl Validator {
    pub fn new(schema: Schema) -> Result<Self, json::schema::index::Error> {
        Self::new_from_iter(std::iter::once(schema))
    }

    pub fn new_from_iter<I>(it: I) -> Result<Self, json::schema::index::Error>
    where
        I: IntoIterator<Item = Schema>,
    {
        let schemas: Vec<Schema> = it.into_iter().collect();
        let schemas: Pin<Box<[Schema]>> = Pin::new(schemas.into_boxed_slice());

        // Safety: we manually keep owned schemas alongside the associated index and validator,
        // and ensure they're dropped last.
        let schemas_static =
            unsafe { std::mem::transmute::<&'_ [Schema], &'static [Schema]>(&schemas) };

        let mut index = SchemaIndexBuilder::new();
        for schema in schemas_static {
            index.add(schema)?;
        }
        index.verify_references()?;

        // Safety: we manually keep the owned index alongside the associated validator,
        // and drop it before the validator.
        let index = Box::pin(index.into_index());
        let index_static =
            unsafe { std::mem::transmute::<&'_ SchemaIndex, &'static SchemaIndex>(&index) };

        Ok(Self {
            inner: json::validator::Validator::new(index_static),
            index,
            schemas,
        })
    }

    /// Fetch the SchemaIndex of this Validator.
    pub fn schema_index(&self) -> &SchemaIndex<'static> {
        &self.index
    }

    /// Fetch the Schemas indexed by this Validator.
    pub fn schemas(&self) -> &[Schema] {
        &self.schemas
    }

    /// Validate validates the given document against the given schema.
    /// If schema is None, than the root_curi() of this Validator is validated.
    pub fn validate<'doc, 'v, N: AsNode>(
        &'v mut self,
        schema: Option<&'v url::Url>,
        document: &'doc N,
    ) -> Result<Validation<'static, 'v>, json::schema::index::Error> {
        let effective_schema = match schema {
            Some(schema) => schema,
            None if self.schemas.len() == 1 => &self.schemas[0].curi,
            None => {
                panic!("root_curi() may only be used with Validators having a single root schema")
            }
        };
        self.inner.prepare(effective_schema)?;

        let root = json::Location::Root;
        let span = walk_document(document, &mut self.inner, &root, 0);

        Ok(Validation {
            schema: effective_schema,
            span,
            validator: &mut self.inner,
        })
    }
}

/// Validation represents the outcome of a document validation.
#[must_use]
pub struct Validation<'schema, 'tmp> {
    /// Schema which was validated.
    schema: &'tmp url::Url,
    /// Walked document span.
    span: json::Span,
    /// Validator which holds the validation outcome.
    // Note use of Validator in a loop requires that we separate these lifetimes.
    validator: &'tmp mut RawValidator<'schema>,
}

// Valid is a validation known to have had a valid outcome.
pub struct Valid<'schema, 'tmp> {
    /// Validator which holds the validation outcome.
    validator: &'tmp mut RawValidator<'schema>,
}

// Invalid is a validation known to have had an invalid outcome.
pub struct Invalid<'schema, 'tmp> {
    /// Schema which was validated.
    schema: &'tmp url::Url,
    /// Walked document span.
    span: json::Span,
    /// Validator which holds the validation outcome.
    validator: &'tmp mut RawValidator<'schema>,
}

impl<'schema, 'tmp> Validation<'schema, 'tmp> {
    /// Validate is a lower-level API for verifying a given document against the given schema.
    /// You probably want to use Validator::validate() instead of this function.
    pub fn validate<'doc, N: AsNode>(
        validator: &'tmp mut RawValidator<'schema>,
        schema: &'tmp url::Url,
        document: &'doc N,
    ) -> Result<Self, json::schema::index::Error> {
        validator.prepare(schema)?;

        let root = json::Location::Root;
        let span = walk_document(document, validator, &root, 0);

        Ok(Self {
            schema,
            span,
            validator,
        })
    }

    #[inline(always)]
    pub fn outcomes(&self) -> &[Outcome<'schema>] {
        self.validator.outcomes()
    }

    /// Ok splits a Validation into either Valid or Invalid.
    #[inline]
    pub fn ok(self) -> Result<Valid<'schema, 'tmp>, Invalid<'schema, 'tmp>> {
        let Self {
            schema,
            span,
            validator,
        } = self;

        if validator.invalid() {
            Err(Invalid {
                schema,
                span,
                validator,
            })
        } else {
            Ok(Valid { validator })
        }
    }
}

impl<'schema, 'tmp> Valid<'schema, 'tmp> {
    #[inline(always)]
    pub fn outcomes(&self) -> &[Outcome<'schema>] {
        self.validator.outcomes()
    }
}

impl<'schema, 'tmp> Invalid<'schema, 'tmp> {
    #[inline(always)]
    pub fn outcomes(&self) -> &[Outcome<'schema>] {
        self.validator.outcomes()
    }

    pub fn revalidate_with_context<'doc, N>(self, document: &'doc N) -> FailedValidation
    where
        N: AsNode,
    {
        let Self {
            schema,
            validator,
            span: _,
        } = self;

        // Repeat the validation, but this time with FullContext for better error generation.
        let mut full_validator =
            json::validator::Validator::<Annotation, FullContext>::new(validator.schema_index());
        full_validator.prepare(schema).unwrap();

        let root = json::Location::Root;
        let _span = walk_document(document, &mut full_validator, &root, 0);

        FailedValidation {
            // TODO: It might be a good idea to add a field on `FailedValidation` to indicate
            // whether the document serialized here has been truncated.
            document: serde_json::to_value(SerPolicy::debug().on(document)).unwrap(),
            basic_output: json::validator::build_basic_output(full_validator.outcomes()),
        }
    }
}

impl<'schema, 'tmp> std::fmt::Debug for Invalid<'schema, 'tmp> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut builder = f.debug_struct("Invalid");
        builder.field("schema", &self.schema);
        builder.field("span", &self.span);
        builder.field("outcomes", &self.validator.outcomes());
        builder.finish()
    }
}

#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize, serde::Deserialize)]
pub struct FailedValidation {
    pub basic_output: serde_json::Value,
    pub document: serde_json::Value,
}

impl std::fmt::Display for FailedValidation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        serde_json::to_string_pretty(self).unwrap().fmt(f)
    }
}
impl std::error::Error for FailedValidation {}
