"""Repository rule for importing system libraries via environment variables.

This allows us to import system libraries provided by Nix (or other package managers)
into Bazel as cc_import targets, making dependencies explicit in BUILD files.
"""

def _system_library_repository_impl(repository_ctx):
    """Implementation of system_library_repository rule.

    This creates a repository with a cc_import target for a system library,
    using library paths discovered from pkg-config.
    """

    libname = repository_ctx.attr.libname
    pkg_config_name = repository_ctx.attr.pkg_config_name or libname

    # Use pkg-config to get library information
    # Get library paths with --libs-only-L
    libs_result = repository_ctx.execute(["pkg-config", "--libs-only-L", pkg_config_name])
    if libs_result.return_code != 0:
        fail("pkg-config failed for {}: {}".format(pkg_config_name, libs_result.stderr))

    # Get include paths with --cflags-only-I
    cflags_result = repository_ctx.execute(["pkg-config", "--cflags-only-I", pkg_config_name])
    if cflags_result.return_code != 0:
        fail("pkg-config failed for {}: {}".format(pkg_config_name, cflags_result.stderr))

    # Parse library directory from -L flags
    lib_dirs = []
    for flag in libs_result.stdout.strip().split(" "):
        if flag.startswith("-L"):
            lib_dirs.append(flag[2:])

    if not lib_dirs:
        fail("No library directories found from pkg-config for {}".format(pkg_config_name))

    lib_dir = lib_dirs[0]  # Use the first library directory

    # Parse include directories from -I flags
    include_dirs = []
    for flag in cflags_result.stdout.strip().split(" "):
        if flag.startswith("-I"):
            include_dirs.append(flag[2:])

    include_dir = include_dirs[0] if include_dirs else None

    # Build the cc_import rule
    hdrs_clause = ""
    if include_dir:
        hdrs_clause = """    hdrs = glob(["include/**/*.h"]),
    includes = ["include"],"""

    # Create a symlink to the library directory for easier access
    repository_ctx.symlink(lib_dir, "lib")
    if include_dir:
        repository_ctx.symlink(include_dir, "include")

    # Determine which library type to use
    # Check if static library exists (we'll check at build time via the file reference)
    # For now, prefer shared library if available since Nix packages often only provide those
    library_clause = """    shared_library = "lib/lib{libname}.so",""".format(libname = libname)

    # Add linkopts for runtime library path (needed for shared libraries)
    # This ensures the binary can find the shared library at runtime
    linkopts_clause = """    linkopts = [
        "-L{lib_dir}",
        "-l{libname}",
        "-Wl,-rpath,{lib_dir}",
    ],""".format(lib_dir = lib_dir, libname = libname)

    # Generate BUILD file
    # The target name is simply the library name (repository names are set by the caller)
    build_content = """# Generated by system_library_repository rule
# Library: {libname}
# Lib dir: {lib_dir}
{include_comment}

cc_import(
    name = "{libname}",
{hdrs_clause}
{library_clause}
{linkopts_clause}
    alwayslink = True,
    visibility = ["//visibility:public"],
)
""".format(
        libname = libname,
        lib_dir = lib_dir,
        include_comment = "# Include dir: {}".format(include_dir) if include_dir else "",
        hdrs_clause = hdrs_clause,
        library_clause = library_clause,
        linkopts_clause = linkopts_clause,
    )

    repository_ctx.file("BUILD.bazel", build_content)

system_library_repository = repository_rule(
    implementation = _system_library_repository_impl,
    attrs = {
        "libname": attr.string(
            doc = "The name of the library (without 'lib' prefix or extension)",
            mandatory = True,
        ),
        "pkg_config_name": attr.string(
            doc = "The pkg-config package name (defaults to libname if not specified)",
        ),
    },
    environ = ["PKG_CONFIG_PATH"],  # Needs PKG_CONFIG_PATH to find .pc files
    local = True,  # Don't cache across machines
    doc = """
    Creates a repository with a cc_import target for a system library.

    The library paths are discovered using pkg-config, which queries the
    .pc files provided by the system package manager (e.g., Nix).

    Example:
        system_library_repository(
            name = "liburing",
            libname = "uring",
            pkg_config_name = "liburing",  # Optional, defaults to "uring"
        )

    Then in BUILD files:
        rust_library(
            name = "my_lib",
            deps = ["@liburing//:uring"],
        )
    """,
)
