$defs:
  tempSensor:
    description: "A sensor that produces temperature readings"
    type: object
    properties:
      id:
        type: integer
        description: "The unique id of this sensor"
      locationName:
        type: string
        description: "Human readable name of the sensor location"
        examples: ["Behind the couch"]
      location:
        $ref: https://geojson.org/schema/Point.json
        description: "The precise geographic location of the sensor"
    required: [id, locationName]

  tempReading:
    description: "A reading of a temperature from a sensor"
    type: object
    properties:
      sensorId:
        type: integer
        description: "The id of the sensor that produced the reading"
      timestamp:
        type: string
        format: timestamp
        description: "An RFC-3339 formatted string holding the time of the reading"
      tempC:
        type: number
        description: "The temperature in degrees celcius"
    required: [sensorId, timestamp, tempC]

  averageTemps:
    description: "Average temperature information for a particular sensor"
    type: object
    properties:
      sensorId: { type: integer }
      # locationName may be null if we've received readings before the corresponding sensor
      # documents. That's OK because we'll later update the locationName once it becomes known.
      numReadings:
        type: integer
        reduce: { strategy: sum }
      totalC:
        type: number
        reduce: { strategy: sum }
      minTempC:
        type: number
        reduce: { strategy: minimize }
      maxTempC:
        type: number
        reduce: { strategy: maximize }
      lastReading:
        type: string
        format: timestamp
        description: "Timestamp of the most recent reading for this named location"
        # Since our timestamps are in RFC 3339 format, the lexicographic comparison done by
        # maximize will pick the most recent time.
        reduce: { strategy: maximize }
    # Sets the reduc strategy for the top-level object. This is needed for reduction strategies in
    # child properties to take effect.
    reduce: { strategy: merge }
    required: [sensorId, numReadings, totalC, minTempC, maxTempC, lastReading]

  avgTempsWithLocation:
    description: "Average temperature with location added"
    type: object
    $ref: schemas.yaml#/$defs/tempToLocationRegister
    properties:
      sensorId: { type: integer }
      # locationName may be null if we've received readings before the corresponding sensor
      # documents. That's OK because we'll later update the locationName once it becomes known.
    required: [sensorId]

  tempToLocationRegister:
    type: object
    properties:
      numReadings:
        type: integer
      totalC:
        type: number
      minTempC:
        type: number
      maxTempC:
        type: number
      avgC:
        type: number
      lastReading:
        type: string
        format: timestamp
        description: "Timestamp of the most recent reading for this named location"
        # Since our timestamps are in RFC 3339 format, the lexicographic comparison done by
        # maximize will pick the most recent time.
      locationName: { type: [string, "null"] }
      location:
        $ref: https://geojson.org/schema/Point.json
        description: "The precise geographic location of the sensor"
    reduce: { strategy: merge }
