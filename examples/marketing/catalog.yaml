nodeDependencies:
  moment: "^2.24"

collections:
  - name: marketing/campaigns
    schema: schemas.yaml#/$defs/campaign
    key: [/campaign_id]
    fixtures: [fixtures/campaigns.yaml]

  - name: marketing/offer/views
    schema: schemas.yaml#/$defs/view
    key: [/view_id]
    fixtures: [fixtures/offer-views.yaml]

  - name: marketing/offer/clicks
    schema: schemas.yaml#/$defs/click
    key: [/click_id]
    fixtures: [fixtures/offer-clicks.yaml]

  - name: marketing/purchases
    schema: schemas.yaml#/$defs/purchase
    key: [/purchase_id]
    fixtures: [fixtures/purchases.yaml]

  - name: marketing/views-with-campaign
    schema: schemas.yaml#/$defs/view-with-campaign
    key: [/view_id]
    fixtures: [fixtures/views-with-campaign.yaml]

    derivation:
      register:
        schema:
          oneOf:
            - $ref: schemas.yaml#/$defs/campaign
            - const: null
      transform:
        indexCampaigns:
          # Index the campaign on its id. We broadcast out to 4 processors because
          # there are relatively few of these, and we can spread out the load of any
          # particularly "hot" campaign IDs.
          source:
            name: marketing/campaigns
          # As we don't specify a "shuffle" key, the source key "/campaign_id" is used by default.
          update:
            # Index the latest campaign.
            nodeJS: return [source];
        # Enrich each view event by joining with its present campaign.
        joinViewWithIndexedCampaign:
          source:
            name: marketing/offer/views
          shuffle: [/campaign_id]
          publish:
            # Join the view with a previously indexed campaign.
            nodeJS: "return [{ ...source, campaign: register }];"

  - name: marketing/clicks-with-views
    schema: schemas.yaml#/$defs/click-with-view
    key: [/click_id]
    fixtures: [fixtures/clicks-with-views.yaml]

    derivation:
      register:
        schema:
          oneOf:
            - $ref: schemas.yaml#/$defs/view-with-campaign
            - const: null
      transform:
        # Index each view with a 2-day TTL relative to the view's timestamp.
        indexViews:
          source:
            name: marketing/views-with-campaign
          update:
            nodeJS: return [source];
        # Enrich clicks by adding its indexed `view`.
        joinClickWithIndexedViews:
          source:
            name: marketing/offer/clicks
          shuffle: [/view_id]
          publish:
            nodeJS: "return [{ ...source, view: register }]"

  - name: marketing/purchases-with-offers
    # Example of using inline schemas, which can reference external schemas.
    schema:
      description: Purchase event joined with prior offer views and clicks.
      $ref: "schemas.yaml#/$defs/purchase"
      properties:
        views:
          type: array
          items:
            $ref: "schemas.yaml#/$defs/view-with-campaign"
        clicks:
          type: array
          items:
            $ref: "schemas.yaml#/$defs/click-with-view"
      required: [views, clicks]
    key: [/purchase_id]
    fixtures: [fixtures/purchases-with-offers.yaml]
    projections:
      first_view_time: "/views/0/timestamp"
      first_click_time: "/clicks/0/timestamp"

    derivation:
      # This derivation indexes a windowed history of clicks and views
      # for the given user.
      register:
        schema:
          $defs:
            # A bounded map which is keyed on a timestamp, and retains a limited
            # number of elements. The first value written with a given timestamp
            # is retained.
            boundedTimestampMap:
              type: object
              reduce:
                strategy: merge
                #limit: 20
                #eviction:
                #  drop: smallest
              additionalProperties:
                # Only the first record of a given time interval is kept.
                reduce:
                  strategy: firstWriteWins
          type: object
          properties:
            lastSeen: {type: string, format: date-time}
            views:
              allOf:
                - $ref: "#/$defs/boundedTimestampMap"
                - additionalProperties:
                    $ref: schemas.yaml#/$defs/view-with-campaign
            clicks:
              allOf:
                - $ref: "#/$defs/boundedTimestampMap"
                - additionalProperties:
                    $ref: schemas.yaml#/$defs/click-with-view
          required: ["views", "clicks"]
          #expiration:
          #  # Retain for 30 days after the last observation of the user.
          #  key: "/lastSeen"
          #  delta: "720h"

        initial: {"views": {}, "clicks": {}}

      transform:
        # Index views of the user. Only the first view of a UTC day is retained.
        indexViews:
          source:
            name: marketing/views-with-campaign
          shuffle: [/user_id]
          update:
            nodeJS: |
              let day = moment.utc(source.timestamp).format('YYYY-MM-DD');
              return [{
                lastSeen: source.timestamp,
                views: { [day]: source },
                clicks: {},
              }];

        # Index clicks of the user. Only the first click of a given hour is retained.
        indexClicks:
          source:
            name: marketing/clicks-with-views
          shuffle: [/user_id]
          update:
            nodeJS: |
              let hour = moment.utc(source.timestamp).format('YYYY-MM-DD-HH');
              return [{
                lastSeen: source.timestamp,
                views: {},
                clicks: { [hour]: source },
              }];

        # Enrich purchase events by joining with all indexed views and clicks.
        joinPurchaseWithViewsAndClicks:
          source:
            name: marketing/purchases
          shuffle: [/user_id]
          publish:
            nodeJS: |
              return [{
                ...source,
                views: Object.values(register.views),
                clicks: Object.values(register.clicks),
              }]

materializations:
  testPostgres:
    collection: marketing/purchases-with-offers
    postgres:
      uri: "postgresql://dev-postgres.estuary.test:5432/marketing"
      table: purchases_with_offers

