#!/bin/bash

# This script generates a SQL migration, which updates the ops catalog template.
# The intended usage for each environment is:
# Locally: ./ops-catalog/generate-migration.sh local | psql 'postgresql://postgres:postgres@localhost:5432/postgres'
# In production: ./ops-catalog/generate-migration.sh prod | psql <prod-postgres-url>
# The required positional argument identifies the specific flow.yaml file to bundle as the template
# for the reporting materialization. This will be either `template-materialization-local.flow.yaml`
# or `template-materialization-prod.flow.yaml`.

set -o errexit
set -o pipefail
set -o nounset

ENVIRONMENT="$1";
if [[ -z "$ENVIRONMENT" ]]; then
	echo "missing required positional argument of 'prod' or 'local'" 1>&2
	exit 1
fi

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
MATERIALIZATION_TEMPLATE_FILENAME="${SCRIPT_DIR}/template-materialization-${ENVIRONMENT}.flow.yaml"
# Run the bundled catalogs through sed to escape any single quotes that may be present.
# For postgres, this is done by doubling the single quote character (replace ' with '').
BUNDLED_TENANT="$(flowctl raw bundle --source "${SCRIPT_DIR}/template-tenant.flow.yaml" | sed "s/'/''/g")"
BUNDLED_LEVEL_1_DERIVATION="$(flowctl raw bundle --source "${SCRIPT_DIR}/template-level-1-derivation.flow.yaml" | sed "s/'/''/g")"
BUNDLED_LEVEL_2_DERIVATION="$(flowctl raw bundle --source "${SCRIPT_DIR}/template-level-2-derivation.flow.yaml" | sed "s/'/''/g")"
BUNDLED_MATERIALIZATION="$(flowctl raw bundle --source "$MATERIALIZATION_TEMPLATE_FILENAME" | sed "s/'/''/g")"


cat << EOF
-- This migration was generated by ops-catalog/generate-migration.sh
-- It updates the ops catalog templates that are used by agent when
-- provisioning new tenants, and also re-publishes the ops catalogs
-- for all existing tenants.
begin;

do \$\$
declare
	new_draft_id flowid := internal.id_generator();
	publication_id flowid := internal.id_generator();
	ops_user_id uuid;
	current_tenant tenants;
	tenant_count integer;
	current_l1_stat_rollup integer;
	tenant_spec jsonb;
	l1_derivation_specs jsonb = '{}';
	l2_derivation_spec jsonb;
	materialization_spec jsonb;
begin

	-- Identify user which owns ops specifications.
	select id into strict ops_user_id from auth.users where email = 'support@estuary.dev';

	-- Update the ops catalog templates.
	update ops_catalog_template set bundled_catalog = '${BUNDLED_TENANT}' where template_type = 'tenant';
	update ops_catalog_template set bundled_catalog = '${BUNDLED_LEVEL_1_DERIVATION}' where template_type = 'l1_derivation';
	update ops_catalog_template set bundled_catalog = '${BUNDLED_LEVEL_2_DERIVATION}' where template_type = 'l2_derivation';
	update ops_catalog_template set bundled_catalog = '${BUNDLED_MATERIALIZATION}' where template_type = 'materialization';

	-- There must be at least one tenant in the system to proceed. This is a guard for local
	-- development when first starting the local stack.
	select count(*)
	into strict tenant_count
	from tenants;
	if tenant_count = 0 then
		return;
	end if;

	-- Create a draft of ops changes.
	insert into drafts (id, user_id, detail) values
	(new_draft_id, ops_user_id, 're-publishing ops catalog');

	-- Queue a publication of the draft.
	insert into publications (id, user_id, draft_id) values
	(publication_id, ops_user_id, new_draft_id);

	-- Handle the tenant-specific specs for each tenant.
	for current_tenant in
		select * from tenants
	loop
		select replace(bundled_catalog::text, 'TENANT', rtrim(current_tenant.tenant, '/'))::jsonb
		into strict tenant_spec
		from ops_catalog_template
		where template_type = 'tenant';

		-- Draft a deletion for all currently-live ops catalog specs for this tenant.
		insert into draft_specs (draft_id, catalog_name, spec_type, spec)
		select new_draft_id, catalog_name, null, null
		from live_specs
		where catalog_name like ('ops/' || current_tenant.tenant || '%');

		-- Upsert the tenant-specific draft specs.
		insert into draft_specs (draft_id, catalog_name, spec_type, spec)
		select new_draft_id, "key", 'capture'::catalog_spec_type, "value"
		from jsonb_each(jsonb_extract_path(tenant_spec, 'captures'))
		union all
		select new_draft_id, "key", 'collection'::catalog_spec_type, "value"
		from jsonb_each(jsonb_extract_path(tenant_spec, 'collections'))
		union all
		select new_draft_id, "key", 'materialization'::catalog_spec_type, "value"
		from jsonb_each(jsonb_extract_path(tenant_spec, 'materializations'))
		on conflict (draft_id, catalog_name)
		do update set spec_type = excluded.spec_type, spec = excluded.spec;
	end loop;

	-- Now handle the non-tenant-specific specs for the ops catalog.

	-- Compute all of the level 1 derivation specs.
	for current_l1_stat_rollup in
		select distinct l1_stat_rollup from tenants
	loop
		l1_derivation_specs := l1_derivation_specs || internal.create_l1_derivation_spec(current_l1_stat_rollup)::jsonb;
	end loop;

	-- Compute the single level 2 derivation spec.
	l2_derivation_spec := internal.create_l2_derivation_spec();

	-- Compute the single reporting materialization spec.
	select bundled_catalog::jsonb -> 'materializations'
	into strict materialization_spec
	from ops_catalog_template
	where template_type = 'materialization';

	-- Upsert the non-tenant-specific draft specs.
	insert into draft_specs (draft_id, catalog_name, spec_type, spec)
	select new_draft_id, "key", 'collection'::catalog_spec_type, "value"
	from jsonb_each(l1_derivation_specs || l2_derivation_spec)
	union all
	select new_draft_id, "key", 'materialization'::catalog_spec_type, "value"
	from jsonb_each(materialization_spec)
	on conflict (draft_id, catalog_name)
	do update set spec_type = excluded.spec_type, spec = excluded.spec;
	return;

end \$\$
language plpgsql;

commit;
EOF

