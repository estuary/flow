(self.webpackChunksite=self.webpackChunksite||[]).push([[2536],{5162:(e,n,t)=>{"use strict";t.d(n,{Z:()=>i});var a=t(7294),r=t(6010);const o={tabItem:"tabItem_Ymn6"};function i(e){let{children:n,hidden:t,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(o.tabItem,i),hidden:t},n)}},4866:(e,n,t)=>{"use strict";t.d(n,{Z:()=>v});var a=t(7462),r=t(7294),o=t(6010),i=t(2466),s=t(6550),l=t(1980),c=t(7392),d=t(12);function u(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}function m(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=n??u(t);return function(e){const n=(0,c.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function h(e){let{queryString:n=!1,groupId:t}=e;const a=(0,s.k6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,l._X)(o),(0,r.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(a.location.search);n.set(o,e),a.replace({...a.location,search:n.toString()})}),[o,a])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,o=m(e),[i,s]=(0,r.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:o}))),[l,c]=h({queryString:t,groupId:a}),[u,f]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[a,o]=(0,d.Nk)(t);return[a,(0,r.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:a}),k=(()=>{const e=l??u;return p({value:e,tabValues:o})?e:null})();(0,r.useLayoutEffect)((()=>{k&&s(k)}),[k]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);s(e),c(e),f(e)}),[c,f,o]),tabValues:o}}var k=t(2389);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){let{className:n,block:t,selectedValue:s,selectValue:l,tabValues:c}=e;const d=[],{blockElementScrollPositionUntilNextRender:u}=(0,i.o5)(),m=e=>{const n=e.currentTarget,t=d.indexOf(n),a=c[t].value;a!==s&&(u(n),l(a))},p=e=>{let n=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const t=d.indexOf(e.currentTarget)+1;n=d[t]??d[0];break}case"ArrowLeft":{const t=d.indexOf(e.currentTarget)-1;n=d[t]??d[d.length-1];break}}n?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":t},n)},c.map((e=>{let{value:n,label:t,attributes:i}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,key:n,ref:e=>d.push(e),onKeyDown:p,onClick:m},i,{className:(0,o.Z)("tabs__item",y.tabItem,i?.className,{"tabs__item--active":s===n})}),t??n)})))}function g(e){let{lazy:n,children:t,selectedValue:a}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=o.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},o.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==a}))))}function w(e){const n=f(e);return r.createElement("div",{className:(0,o.Z)("tabs-container",y.tabList)},r.createElement(b,(0,a.Z)({},e,n)),r.createElement(g,(0,a.Z)({},e,n)))}function v(e){const n=(0,k.Z)();return r.createElement(w,(0,a.Z)({key:String(n)},e))}},1504:(e,n,t)=>{"use strict";t.d(n,{Z:()=>o});var a=t(7294),r=t(2764);r.Z.initialize({startOnLoad:!0});const o=e=>{let{chart:n}=e;return(0,a.useEffect)((()=>{r.Z.contentLoaded()}),[]),a.createElement("div",{className:"mermaid"},n)}},9596:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>f,frontMatter:()=>l,metadata:()=>d,toc:()=>m});var a=t(7462),r=(t(7294),t(3905)),o=t(4866),i=t(5162),s=t(1504);const l={sidebar_position:6},c="Derivations",d={unversionedId:"concepts/derivations",id:"concepts/derivations",title:"Derivations",description:"At times, the collections generated by a capture may not be suitable for your needs.",source:"@site/docs/concepts/derivations.md",sourceDirName:"concepts",slug:"/concepts/derivations",permalink:"/pr-preview/pr-1169/concepts/derivations",draft:!1,editUrl:"https://github.com/estuary/flow/edit/master/site/docs/concepts/derivations.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Connectors",permalink:"/pr-preview/pr-1169/concepts/connectors"},next:{title:"Web application",permalink:"/pr-preview/pr-1169/concepts/web-app"}},u={},m=[{value:"Tutorial",id:"tutorial",level:2},{value:"Introducing AcmeBank",id:"introducing-acmebank",level:3},{value:"Filtering Large Transfers",id:"filtering-large-transfers",level:3},{value:"Finding New Account Pairs",id:"finding-new-account-pairs",level:3},{value:"Grouped Windows of Transfers",id:"grouped-windows-of-transfers",level:3},{value:"Approving Transfers",id:"approving-transfers",level:3},{value:"Current Account Balances",id:"current-account-balances",level:3},{value:"Specification",id:"specification",level:2},{value:"Supported Languages",id:"supported-languages",level:2},{value:"SQLite",id:"sqlite",level:2},{value:"SQL Lambdas",id:"sql-lambdas",level:3},{value:"Document Mapping",id:"document-mapping",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Migrations",id:"migrations",level:3},{value:"Performance",id:"performance",level:3},{value:"TypeScript",id:"typescript",level:2},{value:"Modules",id:"modules",level:3},{value:"State",id:"state",level:3},{value:"Transformations",id:"transformations",level:2},{value:"Sources",id:"sources",level:3},{value:"Shuffles",id:"shuffles",level:3},{value:"shuffle: key",id:"shuffle-key",level:4},{value:"shuffle: any",id:"shuffle-any",level:4},{value:"shuffle: lambda",id:"shuffle-lambda",level:4},{value:"Lambdas",id:"lambdas",level:3},{value:"Processing order",id:"processing-order",level:3},{value:"Read delay",id:"read-delay",level:3},{value:"Read priority",id:"read-priority",level:3},{value:"Internal State",id:"internal-state",level:2},{value:"Where to accumulate?",id:"where-to-accumulate",level:2},{value:"Accumulate in Internal Task State",id:"accumulate-in-internal-task-state",level:3},{value:"Accumulate in a Database",id:"accumulate-in-a-database",level:3}],p={toc:m},h="wrapper";function f(e){let{components:n,...t}=e;return(0,r.kt)(h,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"derivations"},"Derivations"),(0,r.kt)("p",null,"At times, the collections generated by a ",(0,r.kt)("a",{parentName:"p",href:"../#captures"},"capture")," may not be suitable for your needs.\nFor instance, you might want to filter certain documents or add calculations to them.\nPerhaps you need to unpack an array nested inside or aggregate data from many documents.\nAlternatively, you might need to merge across several collections using a common key,\nor employ business logic to arrive at a real-time decision.\nWith Flow derivations, you can perform a wide range of transformations,\nfrom a simple remapping to complicated, self-referential, and stateful transaction processing."),(0,r.kt)("p",null,"In essence, a derivation is a ",(0,r.kt)("a",{parentName:"p",href:"../#collections"},"collection"),"\nthat is constructed from applying transformations to one or more sourced collections.\nDerivations operate continuously, keeping up with updates to the source collections as they happen."),(0,r.kt)("p",null,"A derivation consists of three primary elements:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A collection that stores the output."),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("a",{parentName:"li",href:"../#tasks"},"catalog task")," that applies transformations to source documents\nas they become available and writes the resulting documents into the derived collection."),(0,r.kt)("li",{parentName:"ul"},"An ",(0,r.kt)("a",{parentName:"li",href:"#internal-state"},"internal task state")," which enables aggregations, joins, and windowing.")),(0,r.kt)("p",null,"Today, Flow enables you to write derivations using either\n",(0,r.kt)("a",{parentName:"p",href:"#sqlite"},"SQLite")," or ",(0,r.kt)("a",{parentName:"p",href:"#typescript"},"TypeScript"),".\nAdditional language support is in the works."),(0,r.kt)("h2",{id:"tutorial"},"Tutorial"),(0,r.kt)("h3",{id:"introducing-acmebank"},"Introducing AcmeBank"),(0,r.kt)("p",null,"The following tutorial sections use an illustrative example\nto introduce you to derivations, how you might use them, and their common components.\nWe'll discuss each component in depth in subsequent sections of this page,\nbut we recommend you start here to get your bearings."),(0,r.kt)("p",null,"Suppose you have an application through which users send one another\nsome amount of currency, like in-game tokens or dollars or digital kittens.\nYou have a ",(0,r.kt)("inlineCode",{parentName:"p"},"transfers")," collection of user-requested transfers,\neach sending funds from one account to another:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"transfers.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/transfers.flow.yaml",file:"./bank/transfers.flow.yaml"},"collections:\n  # Collection of \ud83d\udcb2 transfers between accounts:\n  #   {id: 123, sender: alice, recipient: bob, amount: 32.50}\n  acmeBank/transfers:\n    schema: transfers.schema.yaml\n    key: [/id]\n"))),(0,r.kt)(i.Z,{value:"transfers.schema.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/transfers.schema.yaml",file:"./bank/transfers.schema.yaml"},"type: object\nproperties:\n  id: { type: integer }\n  sender: { type: string }\n  recipient: { type: string }\n  amount: { type: number }\nrequired: [id, sender, recipient, amount]\n")))),(0,r.kt)("p",null,"There are many views over this data that you might require,\nsuch as summaries of sender or receiver activity,\nor current account balances within your application."),(0,r.kt)("h3",{id:"filtering-large-transfers"},"Filtering Large Transfers"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"This section introduces SQLite derivations, SQL lambda blocks and ",(0,r.kt)("inlineCode",{parentName:"p"},"$parameters"),".")),(0,r.kt)("p",null,"Your compliance department has reached out, and they require an understanding\nof the last large transfer (if any) made by each user account."),(0,r.kt)("p",null,"You create a SQL derivation to help them out.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"transfers")," collection is keyed on the transfer ",(0,r.kt)("inlineCode",{parentName:"p"},"/id"),",\nso you'll need to re-key your derivation on the ",(0,r.kt)("inlineCode",{parentName:"p"},"/sender")," account.\nYou also need to filter out transfers that aren't large enough."),(0,r.kt)("p",null,"Putting this all together:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"last-large-send.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/last-large-send.flow.yaml",file:"./bank/last-large-send.flow.yaml"},"collections:\n  acmeBank/last-large-send:\n    schema: transfers.schema.yaml\n    key: [/sender]\n\n    derive:\n      using:\n        sqlite: {}\n      transforms:\n        - name: filterTransfers\n          source: acmeBank/transfers\n          shuffle: any\n          lambda: SELECT $id, $sender, $recipient, $amount WHERE $amount > 100;\n"))),(0,r.kt)(i.Z,{value:"last-large-send-test.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/last-large-send-test.flow.yaml",file:"./bank/last-large-send-test.flow.yaml"},"tests:\n  acmeBank/tests/last-large-send:\n    - ingest:\n        collection: acmeBank/transfers\n        description: Initial set of transfers amongst users\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 125.10 }\n          - { id: 2, sender: bob, recipient: alice, amount: 10.22 }\n          - { id: 3, sender: carol, recipient: bob, amount: 327.00 }\n    - ingest:\n        collection: acmeBank/transfers\n        description: Alice and Carol later send additional transfers.\n        documents:\n          - { id: 4, sender: alice, recipient: carol, amount: 32.50 }\n          - { id: 5, sender: carol, recipient: alice, amount: 226.73 }\n    - verify:\n        collection: acmeBank/last-large-send\n        description:\n          Expect the most-recent of Carol's large transfers is tracked,\n          along with Alice's only large transfer.\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 125.10 }\n          - { id: 5, sender: carol, recipient: alice, amount: 226.73 }\n")))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"derive: using: sqlite: {}")," tells Flow that collection\n",(0,r.kt)("inlineCode",{parentName:"p"},"acmeBank/last-large-send")," is derived using Flow's SQLite derivation connector."),(0,r.kt)("p",null,"This derivation has just one transform, which sources from the ",(0,r.kt)("inlineCode",{parentName:"p"},"transfers")," collection.\nAs source documents become available, they're evaluated by the SQL ",(0,r.kt)("inlineCode",{parentName:"p"},"lambda"),"\nand its ",(0,r.kt)("inlineCode",{parentName:"p"},"SELECT")," output is published to the derived collection.\nYour SQL queries access locations of source documents through ",(0,r.kt)("a",{parentName:"p",href:"#parameters"},"$parameter")," bindings."),(0,r.kt)("p",null,"The compliance department then materializes this collection to their preferred destination,\nfor an always up-to-date view indexed by each account."),(0,r.kt)("h3",{id:"finding-new-account-pairs"},"Finding New Account Pairs"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"This section introduces SQLite migrations and internal task tables.")),(0,r.kt)("p",null,"The fraud team needs your help: they have a new process they must run\nthe first time some sending account sends funds to a receiving account.\nThey would like to see only those transfers which reflect a new account pair of (sender, recipient).\nTo tackle this you need to know which account pairs have been seen before."),(0,r.kt)("p",null,"SQLite derivations run within the context of a persistent, managed SQLite database.\nYou can apply database ",(0,r.kt)("a",{parentName:"p",href:"#migrations"},"migrations")," that create whatever tables, triggers, or views you might need.\nThen, the statements of your SQL lambda code can ",(0,r.kt)("inlineCode",{parentName:"p"},"INSERT"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"UPDATE"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"DELETE"),"\nfrom those tables, query from them, or any other operation supported by SQLite.\nThe tables and other schema you create through your migrations\nare the ",(0,r.kt)("a",{parentName:"p",href:"#internal-state"},"internal state")," of your task."),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"first-send.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/first-send.flow.yaml",file:"./bank/first-send.flow.yaml"},"collections:\n  acmeBank/first-send:\n    schema: transfers.schema.yaml\n    key: [/id]\n\n    derive:\n      using:\n        sqlite:\n          migrations:\n            - CREATE TABLE seen_pairs (\n              sender    TEXT NOT NULL,\n              recipient TEXT NOT NULL,\n              PRIMARY KEY (sender, recipient)\n              );\n\n      transforms:\n        - name: fromTransfers\n          source: acmeBank/transfers\n          shuffle:\n            key: [/sender, /recipient]\n          lambda:\n            INSERT INTO seen_pairs (sender, recipient) VALUES ($sender, $recipient)\n            ON CONFLICT DO NOTHING\n            RETURNING $id, $sender, $recipient, $amount;\n"))),(0,r.kt)(i.Z,{value:"first-send-test.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/first-send-test.flow.yaml",file:"./bank/first-send-test.flow.yaml"},"tests:\n  acmeBank/tests/first-send:\n    - ingest:\n        collection: acmeBank/transfers\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 10.25 }\n          - { id: 2, sender: alice, recipient: bob, amount: 13.40 }\n          - { id: 3, sender: carol, recipient: alice, amount: 12.50 }\n          - { id: 4, sender: alice, recipient: carol, amount: 16.96 }\n          - { id: 5, sender: carol, recipient: alice, amount: 2.36 }\n          - { id: 6, sender: alice, recipient: carol, amount: 7.13 }\n\n    - verify:\n        collection: acmeBank/first-send\n        description: Expect to see only the first interaction of each account pair.\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 10.25 }\n          - { id: 3, sender: carol, recipient: alice, amount: 12.50 }\n          - { id: 4, sender: alice, recipient: carol, amount: 16.96 }\n")))),(0,r.kt)("p",null,"This time, the derivation attempts to ",(0,r.kt)("inlineCode",{parentName:"p"},"INSERT")," into the ",(0,r.kt)("inlineCode",{parentName:"p"},"seen_pairs")," table,\nand uses SQLite's ",(0,r.kt)("a",{parentName:"p",href:"https://www.sqlite.org/lang_returning.html"},"RETURNING"),"\nsyntax to only publish documents for rows which were successfully inserted."),(0,r.kt)("p",null,"You can evolve the internal SQLite tables of your derivation as needed,\nby appending SQL blocks which perform a database migration to the ",(0,r.kt)("inlineCode",{parentName:"p"},"migrations")," array.\nAny migrations appended to the list are automatically applied by Flow."),(0,r.kt)("h3",{id:"grouped-windows-of-transfers"},"Grouped Windows of Transfers"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"This section introduces delayed reads, and applies them to implement a custom window policy.")),(0,r.kt)("p",null,"The fraud team is back, and now needs to know the ",(0,r.kt)("em",{parentName:"p"},"other"),"\ntransfers which an account has made in the last day.\nThey want you to enrich each transfer with the grouping of all\ntransfers initiated by that account in the prior 24 hours."),(0,r.kt)("p",null,'You may have encountered "windowing" in other tools for stream processing.\nSome systems even require that you define a window policy in order to function.\nFlow does not use windows, but sometimes you do want a time-bound grouping of recent events.'),(0,r.kt)("p",null,"All collection documents contain a wall-clock timestamp of when they were published.\nThe transforms of a derivation will generally process source documents in ascending wall-time order.\nYou can augment this behavior by using a ",(0,r.kt)("a",{parentName:"p",href:"#read-delay"},"read delay")," to refine the relative order in which\nsource documents are read, which is useful for implementing arbitrary window policies:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"grouped.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/grouped.flow.yaml title=grouped.flow.yaml",file:"./bank/grouped.flow.yaml",title:"grouped.flow.yaml"},"collections:\n  acmeBank/grouped-transfers:\n    schema:\n      # Enrich transfer with a window of *other* transfers.\n      $ref: transfers.schema.yaml\n      required: [window]\n      properties:\n        window: { type: array }\n    key: [/id]\n\n    derive:\n      using:\n        sqlite:\n          migrations:\n            - CREATE TABLE transfers (\n              id        INTEGER PRIMARY KEY NOT NULL,\n              sender    TEXT NOT NULL,\n              recipient TEXT NOT NULL,\n              amount    REAL NOT NULL\n              );\n              CREATE INDEX idx_transfers_sender ON transfers (sender);\n      transforms:\n        - name: enrichAndAddToWindow\n          source: acmeBank/transfers\n          shuffle: { key: [/sender] }\n          lambda: enrichAndAddToWindow.sql\n\n        - name: removeFromWindow\n          source: acmeBank/transfers\n          shuffle: { key: [/sender] }\n          readDelay: 24h\n          lambda: DELETE FROM transfers WHERE id = $id;\n"))),(0,r.kt)(i.Z,{value:"enrichAndAddToWindow.sql",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql",metastring:"file=./bank/enrichAndAddToWindow.sql title=enrichAndAddToWindow.sql",file:"./bank/enrichAndAddToWindow.sql",title:"enrichAndAddToWindow.sql"},"-- Enrich the transfer with a nested array of other transfers in the window.\nWITH w AS (\n    SELECT JSON_GROUP_ARRAY(JSON_OBJECT(\n        'id', id,\n        'recipient', recipient,\n        'amount', amount\n    )) AS window\n    FROM transfers WHERE sender = $sender\n)\nSELECT $id, $sender, $recipient, $amount, w.window FROM w;\n\n-- Add the current transfer to the window.\nINSERT INTO transfers (id, sender, recipient, amount)\nVALUES ($id, $sender, $recipient, $amount);\n"))),(0,r.kt)(i.Z,{value:"grouped-test.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/grouped-test.flow.yaml title=grouped-test.flow.yaml",file:"./bank/grouped-test.flow.yaml",title:"grouped-test.flow.yaml"},"tests:\n  acmeBank/tests/grouped-transfers:\n    - ingest:\n        description: Initial transfers.\n        collection: acmeBank/transfers\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 6.45 }\n          - { id: 2, sender: bob, recipient: carol, amount: 9.72 }\n          - { id: 3, sender: bob, recipient: alice, amount: 12.50 }\n\n    - verify:\n        description: Expect transfers were enriched with their current window.\n          Note that a verify step will advance test time forward until all\n          source documents have been read by all transforms,\n          meaning that the window has been reset.\n        collection: acmeBank/grouped-transfers\n        documents:\n          - { amount: 6.45, id: 1, sender: alice, recipient: bob, window: [] }\n          - { amount: 9.72, id: 2, sender: bob, recipient: carol, window: [] }\n          - {\n              id: 3,\n              sender: bob,\n              recipient: alice,\n              amount: 12.5,\n              window: [{ id: 2, recipient: carol, amount: 9.72 }],\n            }\n\n    - ingest:\n        collection: acmeBank/transfers\n        documents:\n          - { id: 4, sender: alice, recipient: bob, amount: 1.96 }\n          - { id: 5, sender: alice, recipient: carol, amount: 2.36 }\n          - { id: 6, sender: bob, recipient: alice, amount: 7.13 }\n          - { id: 7, sender: alice, recipient: bob, amount: 2.57 }\n\n    - verify:\n        collection: acmeBank/grouped-transfers\n        documents:\n          - { id: 1 }\n          - { id: 2 }\n          - { id: 3 }\n          - { id: 4, amount: 1.96, sender: alice, recipient: bob, window: [] }\n          - {\n              id: 5,\n              amount: 2.36,\n              sender: alice,\n              recipient: carol,\n              window: [{ id: 4, amount: 1.96, recipient: bob }],\n            }\n          - { id: 6, sender: bob, recipient: alice, amount: 7.13, window: [] }\n          - {\n              id: 7,\n              amount: 2.57,\n              sender: alice,\n              recipient: bob,\n              window:\n                [\n                  { id: 4, amount: 1.96, recipient: bob },\n                  { id: 5, amount: 2.36, recipient: carol },\n                ],\n            }\n")))),(0,r.kt)("h3",{id:"approving-transfers"},"Approving Transfers"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"This section expands usage of SQLite task tables and introduces a recursive data flow.")),(0,r.kt)("p",null,"Your users don't always check if they have sufficient funds before starting a transfer,\nand account overdrafts are becoming common.\nThe product team has tapped you to fix this\nby enriching each transfer with an ",(0,r.kt)("strong",{parentName:"p"},"approve")," or ",(0,r.kt)("strong",{parentName:"p"},"deny")," outcome\nbased on the account balance of the sender."),(0,r.kt)("p",null,"To do this, you first need to track the sender's current account balance.\nClearly an account balance is debited when it's used to sends funds.\nIt's also credited when it receives funds."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"But there's a catch"),":\nan account can only be credited for funds received from ",(0,r.kt)("strong",{parentName:"p"},"approved")," transfers!\nThis implies you need a collection of transfer outcomes\nin order to derive your collection of transfer outcomes \ud83e\udd2f."),(0,r.kt)("p",null,"This is an example of a self-referential, recursive data-flow.\nYou may have used tools which require that data flow in a Directed Acyclic Graph (DAG).\nFlow does ",(0,r.kt)("em",{parentName:"p"},"not")," require that your data flows are acyclic,\nand it also supports a derivation that reads from itself,\nwhich lets you tackle this task:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"outcomes.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/outcomes.flow.yaml title=outcomes.flow.yaml",file:"./bank/outcomes.flow.yaml",title:"outcomes.flow.yaml"},"collections:\n  acmeBank/transfer-outcomes:\n    schema:\n      # Enrich transfer schema with outcome and the sender's balance.\n      $ref: transfers.schema.yaml\n      required: [outcome, sender_balance]\n      properties:\n        outcome:\n          description: Transfer was approved, or denied for insufficient funds.\n          enum: [approve, deny]\n        sender_balance: { type: number }\n    key: [/id]\n\n    derive:\n      using:\n        sqlite:\n          migrations:\n            - CREATE TABLE current_balances (\n              account TEXT PRIMARY KEY NOT NULL,\n              balance REAL NOT NULL\n              );\n\n      transforms:\n        - name: debitSender\n          source: acmeBank/transfers\n          # Shuffle on the sender, as we'll debit their balance.\n          shuffle: { key: [/sender] }\n          lambda: debitSender.sql\n\n        - name: creditRecipient\n          # When a transfer is approved, we've debited the sender but still need to\n          # credit the recipient. Read approved transfers from ourselves to do so.\n          source:\n            name: acmeBank/transfer-outcomes\n            partitions:\n              include:\n                outcome: [approve]\n          shuffle: { key: [/recipient] }\n          lambda:\n            INSERT INTO current_balances (account, balance) VALUES ($recipient, $amount)\n            ON CONFLICT DO UPDATE SET balance = balance + $amount;\n\n    # Partition output based on the transfer outcome.\n    projections:\n      outcome:\n        location: /outcome\n        partition: true\n"))),(0,r.kt)(i.Z,{value:"debitSender.sql",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql",metastring:"file=./bank/debitSender.sql title=debitSender.sql",file:"./bank/debitSender.sql",title:"debitSender.sql"},"-- Debit the sender if they have an account with sufficient funds.\nUPDATE current_balances\nSET balance = balance - $amount\nWHERE account = $sender AND balance >= $amount;\n\n-- Publish the transfer enriched with outcome and sender balance.\n-- Use SQLite's CHANGES() function to check if the prior UPDATE matched any rows.\n-- Or, a special sweep account 'DEPOSIT' is always approved.\nWITH t AS (SELECT $id, $sender, $recipient, $amount)\nSELECT t.*,\n    CASE WHEN CHANGES() OR $sender = 'DEPOSIT'\n        THEN 'approve' ELSE 'deny' END AS outcome,\n    COALESCE(b.balance, 0) AS sender_balance\nFROM t\nLEFT OUTER JOIN current_balances b ON $sender = b.account;\n"))),(0,r.kt)(i.Z,{value:"outcomes-test.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/outcomes-test.flow.yaml title=outcomes-test.flow.yaml",file:"./bank/outcomes-test.flow.yaml",title:"outcomes-test.flow.yaml"},"tests:\n  acmeBank/tests/transfer-outcomes:\n    - ingest:\n        description: Initial deposits.\n        collection: acmeBank/transfers\n        documents:\n          - { id: 1, sender: DEPOSIT, recipient: Alice, amount: 20 }\n          - { id: 2, sender: DEPOSIT, recipient: Bob, amount: 20 }\n\n    - ingest:\n        description: Transfers between users.\n        collection: acmeBank/transfers\n        documents:\n          - { id: 3, sender: Alice, recipient: Bob, amount: 32.50 }\n          - { id: 4, sender: Bob, recipient: Carol, amount: 10.75 }\n\n    - verify:\n        description: Expect transfers were enriched with outcome and balance.\n        collection: acmeBank/transfer-outcomes\n        documents:\n          - {\n              id: 1,\n              sender: DEPOSIT,\n              recipient: Alice,\n              amount: 20,\n              outcome: approve,\n            }\n          - {\n              id: 2,\n              sender: DEPOSIT,\n              recipient: Bob,\n              amount: 20,\n              outcome: approve,\n            }\n          - {\n              id: 3,\n              sender: Alice,\n              recipient: Bob,\n              amount: 32.50,\n              outcome: deny,\n            }\n          - {\n              id: 4,\n              sender: Bob,\n              recipient: Carol,\n              amount: 10.75,\n              outcome: approve,\n              sender_balance: 9.25,\n            }\n")))),(0,r.kt)("h3",{id:"current-account-balances"},"Current Account Balances"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"This section introduces TypeScript derivations and reduction annotations.")),(0,r.kt)("p",null,"Your product team is back, and they want a database table\nkeyed by account that contains its up-to-date current balance."),(0,r.kt)("p",null,"As shown in the previous section, you could create\na task table which aggregates each account balance,\nand then ",(0,r.kt)("inlineCode",{parentName:"p"},"SELECT")," the current balance after every transfer.\nFor most use cases, this is a ",(0,r.kt)("strong",{parentName:"p"},"great")," place to start.\nFor interest and variety, you'll solve this problem using TypeScript."),(0,r.kt)("p",null,"TypeScript derivations require a ",(0,r.kt)("inlineCode",{parentName:"p"},"module")," which you write.\nYou don't know how to write that module yet,\nso first implement the derivation specification in ",(0,r.kt)("inlineCode",{parentName:"p"},"balances.flow.yaml"),".\nNext run the ",(0,r.kt)("inlineCode",{parentName:"p"},"flowctl generate")," command, which generates two files:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A module stub for you to fill out."),(0,r.kt)("li",{parentName:"ul"},"A file of TypeScript interfaces which are used by your module.")),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"balances.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"title=balances.flow.yaml file=./bank/balances.flow.yaml",title:"balances.flow.yaml",file:"./bank/balances.flow.yaml"},"collections:\n  acmeBank/balances:\n    schema: balances.schema.yaml\n    key: [/user]\n\n    derive:\n      using:\n        typescript:\n          module: balances.ts\n      transforms:\n        - name: fromOutcomes\n          source:\n            name: acmeBank/transfer-outcomes\n            partitions:\n              include:\n                outcome: [approve]\n          shuffle: any\n"))),(0,r.kt)(i.Z,{value:"Module Stub",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"title=balances.ts file=./bank/balances-stub.ts",title:"balances.ts",file:"./bank/balances-stub.ts"},"import { IDerivation, Document, SourceFromOutcomes } from 'flow/acmeBank/balances.ts';\n\n// Implementation for derivation acmeBank/balances.\nexport class Derivation extends IDerivation {\n    fromOutcomes(_read: { doc: SourceFromOutcomes }): Document[] {\n        throw new Error(\"Not implemented\"); // \ud83d\udc48 Your implementation goes here.\n    }\n}\n"))),(0,r.kt)(i.Z,{value:"Interfaces",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"file=./bank/flow_generated/typescript/acmeBank/balances.ts title=flow/acmeBank/balances.ts",file:"./bank/flow_generated/typescript/acmeBank/balances.ts",title:"flow/acmeBank/balances.ts"},'\n// Generated for published documents of derived collection acmeBank/balances.\nexport type Document = {\n    balance: number;\n    user: string;\n};\n\n\n// Generated for read documents of sourced collection acmeBank/transfer-outcomes.\nexport type SourceFromOutcomes = {\n    amount: number;\n    id: number;\n    outcome: /* Transfer was approved, or denied for insufficient funds. */ "approve" | "deny";\n    recipient: string;\n    sender: string;\n    sender_balance: number;\n};\n\n\nexport abstract class IDerivation {\n    // Construct a new Derivation instance from a Request.Open message.\n    constructor(_open: { state: unknown }) { }\n\n    // flush awaits any remaining documents to be published and returns them.\n    // deno-lint-ignore require-await\n    async flush(): Promise<Document[]> {\n        return [];\n    }\n\n    // reset is called only when running catalog tests, and must reset any internal state.\n    async reset() { }\n\n    // startCommit is notified of a runtime commit in progress, and returns an optional\n    // connector state update to be committed.\n    startCommit(_startCommit: { runtimeCheckpoint: unknown }): { state?: { updated: unknown, mergePatch: boolean } } {\n        return {};\n    }\n\n    abstract fromOutcomes(read: { doc: SourceFromOutcomes }): Document[];\n}\n')))),(0,r.kt)("p",null,"Next fill out the body of your TypeScript module and write a test:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"balances.ts",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"title=balances.ts file=./bank/balances.ts",title:"balances.ts",file:"./bank/balances.ts"},"import { IDerivation, Document, SourceFromOutcomes } from 'flow/acmeBank/balances.ts';\n\n// Implementation for derivation acmeBank/balances.\nexport class Derivation extends IDerivation {\n    fromOutcomes(read: { doc: SourceFromOutcomes }): Document[] {\n        const doc = read.doc;\n        return [\n            // Debit the sender.\n            { user: doc.sender, balance: -doc.amount },\n            // Credit the recipient.\n            { user: doc.recipient, balance: doc.amount },\n        ];\n    }\n}\n"))),(0,r.kt)(i.Z,{value:"balances-test.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"title=balances-test.flow.yaml file=./bank/balances-test.flow.yaml",title:"balances-test.flow.yaml",file:"./bank/balances-test.flow.yaml"},"tests:\n  acmeBank/tests/balances:\n    - ingest:\n        collection: acmeBank/transfers\n        description: Initial deposits into user accounts.\n        documents:\n          - { id: 1, sender: DEPOSIT, recipient: alice, amount: 100 }\n          - { id: 2, sender: DEPOSIT, recipient: bob, amount: 100 }\n          - { id: 3, sender: DEPOSIT, recipient: carol, amount: 100 }\n\n    - ingest:\n        collection: acmeBank/transfers\n        description: Transfers between users, and a withdraw.\n        documents:\n          - { id: 4, sender: alice, recipient: bob, amount: 20 }\n          - { id: 5, sender: bob, recipient: carol, amount: 40 }\n          - { id: 6, sender: carol, recipient: alice, amount: 90 }\n          - { id: 7, sender: bob, recipient: DEPOSIT, amount: 40 }\n\n    - verify:\n        collection: acmeBank/balances\n        description: Verify expected balances.\n        documents:\n          - { user: DEPOSIT, balance: -260 }\n          - { user: alice, balance: 170 }\n          - { user: bob, balance: 40 }\n          - { user: carol, balance: 50 }\n")))),(0,r.kt)("p",null,"One piece is still missing.\nYour TypeScript module is publishing the ",(0,r.kt)("strong",{parentName:"p"},"change")," in account balance for each transfer.\nThat's not the same thing as the ",(0,r.kt)("strong",{parentName:"p"},"current")," balance for each account."),(0,r.kt)("p",null,"You can ask Flow to sum up the balance changes into a current account balance\nthrough ",(0,r.kt)("a",{parentName:"p",href:"/pr-preview/pr-1169/concepts/schemas#reductions"},"reduction annotations"),".\nHere's the balances schema, with ",(0,r.kt)("inlineCode",{parentName:"p"},"reduce")," annotations for summing the account balance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"title=balances.schema.yaml file=./bank/balances.schema.yaml",title:"balances.schema.yaml",file:"./bank/balances.schema.yaml"},"type: object\nrequired: [user, balance]\nreduce: { strategy: merge }\nproperties:\n  user: { type: string }\n  balance:\n    type: number\n    reduce: { strategy: sum }\n")),(0,r.kt)("p",null,"This section has more moving parts that the previous SQL-based examples.\nYou might be wondering, why bother? Fair question!\nThis is just an illustrative example, after all."),(0,r.kt)("p",null,"While they're more verbose, TypeScript derivations do have certain advantages:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"TypeScript derivations are strongly typed, and those checks often catch meaningful bugs and defects ",(0,r.kt)("strong",{parentName:"li"},"before")," they're deployed.\nYour derivation modules also play nicely with VSCode and other developer tooling."),(0,r.kt)("li",{parentName:"ul"},"TypeScript derivations can use third-party libraries, as well as your native code compiled to WASM."),(0,r.kt)("li",{parentName:"ul"},"TypeScript can be easier when working with nested or complex document structures.")),(0,r.kt)("p",null,"Reduction annotations also have some benefits over task state (like SQLite tables):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Internal task state is managed by Flow.\nIf it grows to be large (say, you have ",(0,r.kt)("strong",{parentName:"li"},"a lot")," of accounts),\nthen your task must be scaled and could require performance tuning.\nReduction annotations, on the other hand, require ",(0,r.kt)("em",{parentName:"li"},"no")," internal state and are extremely efficient."),(0,r.kt)("li",{parentName:"ul"},"Certain aggregations, such as recursive merging of tree-like structures,\nare much simpler to express through reduction annotations vs implementing yourself.")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#where-to-accumulate"},'See "Where to Accumulate?" for more discussion'),"."),(0,r.kt)("h2",{id:"specification"},"Specification"),(0,r.kt)("p",null,"A derivation is specified as a regular ",(0,r.kt)("a",{parentName:"p",href:"../#collections"},"collection"),"\nwith an additional ",(0,r.kt)("inlineCode",{parentName:"p"},"derive")," stanza:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'collections:\n  # The unique name of the derivation.\n  acmeCo/my/derivation:\n    schema: my-schema.yaml\n    key: [/key]\n\n    # Presence of a `derive` stanza makes this collection a derivation.\n    # Type: object\n    derive:\n      # Connector which this derivation uses.\n      # One of `typescript` or `sqlite`.\n      using:\n        # Derivation is using the SQLite connector.\n        # Optional, type: object\n        sqlite:\n          # SQL migrations to apply as inline SQL or file references.\n          # If a referenced file does not exist\n          # a stub can be generated using `flowctl generate`.\n          # Optional, type: array of strings\n          migrations:\n            - CREATE TABLE foobar (id INTEGER PRIMARY KEY NOT NULL);\n            - ../path/to/other/migration.sql\n\n        # Derivation is using the TypeScript connector.\n        # Optional, type: object\n        typescript:\n          # TypeScript module implementing this derivation,\n          # as inline TypeScript or a relative file reference.\n          # If a referenced file does not exist\n          # a stub can be generated using `flowctl generate`.\n          module: acmeModule.ts\n\n      # The array of transformations that build this derived collection.\n      transform:\n        # Unique name of the transformation, containing only Unicode\n        # Letters, Numbers, `-`, or `_` (no spaces or other punctuation).\n        - name: myTransformName\n          # Source collection read by this transformation.\n          # Required, type: object or string.\n          source:\n            # Name of the collection to be read.\n            # Required.\n            name: acmeCo/my/source/collection\n            # Partition selector of the source collection.\n            # Optional. Default is to read all partitions.\n            partitions: {}\n            # Lower bound date-time for documents which should be processed. \n            # Source collection documents published before this date-time are filtered.\n            # `notBefore` is *only* a filter. Updating its value will not cause Flow\n            # to re-process documents that have already been read.\n            # Optional. Default is to process all documents.\n            notBefore: 2023-01-23T01:00:00Z\n            # Upper bound date-time for documents which should be processed.\n            # Source collection documents published after this date-time are filtered.\n            # Like `notBefore`, `notAfter` is *only* a filter. Updating its value will\n            # not cause Flow to re-process documents that have already been read.\n            # Optional. Default is to process all documents.\n            notAfter: 2023-01-23T02:00:00Z\n\n          # Lambda of this transform, with a meaning which depends\n          # on the derivation connector:\n          # * SQLite derivation lambdas are blocks of SQL code.\n          # * TypeScript does not use `lambda`, as implementations\n          #   are provided by the derivation\'s TypeScript module.\n          # Lambdas can be either inline or a relative file reference.\n          lambda: SELECT $foo, $bar;\n          # Delay applied to sourced documents before being processed\n          # by this transformation.\n          # Default: No delay, pattern: ^\\\\d+(s|m|h)$\n          readDelay: "48h"\n          # Key by which source documents are shuffled to task shards.\n          # Optional, type: object.\n          # If not set, the source collection key is used.\n          shuffle:\n            # Composite key of JSON pointers which are extracted from\n            # source documents.\n            key: [/shuffle/key/one, /shuffle/key/two]\n          # Priority applied to documents of this transformation\n          # relative to other transformations of the derivation.\n          # Default: 0, integer >= 0\n          priority: 0\n')),(0,r.kt)("h2",{id:"supported-languages"},"Supported Languages"),(0,r.kt)("p",null,"As with captures and materializations,\nFlow derivations are built around a plug-able ",(0,r.kt)("a",{parentName:"p",href:"../#connectors"},"connectors")," architecture.\nDerivation connectors encapsulate the details of ",(0,r.kt)("em",{parentName:"p"},"how")," documents are transformed,\nand integrate with Flow's runtime through a common protocol."),(0,r.kt)("p",null,"At present, Flow supports transformations in SQL using ",(0,r.kt)("a",{parentName:"p",href:"#sqlite"},"SQLite"),", and ",(0,r.kt)("a",{parentName:"p",href:"#typescript"},"TypeScript"),"."),(0,r.kt)("h2",{id:"sqlite"},"SQLite"),(0,r.kt)("p",null,"Flow's SQLite connector lets you write plain SQL which\nis evaluated with each source collection document:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"derive:\n  using:\n    sqlite: {}\n  transforms:\n    - name: fromOrders\n      source: acmeCo/orders\n      shuffle: any\n      lambda:\n        SELECT $customer,\n        DATE($timestamp) AS date,\n        PRINTF('$%.2f', $item_price + $sales_tax) AS cost;\n")),(0,r.kt)("p",null,"Given an input document:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "customer": "Wile E. Coyote",\n  "timestamp": "2023-04-17T16:45:31Z",\n  "item_price": 11.5,\n  "sales_tax": 0.8\n}\n')),(0,r.kt)("p",null,"The derivation will produce an output document like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "customer": "Wile E. Coyote",\n  "date": "2023-04-17",\n  "cost": "$12.30"\n}\n')),(0,r.kt)("p",null,"SQLite derivations run within the context of a persistent,\nmanaged ",(0,r.kt)("a",{parentName:"p",href:"https://sqlite.org/"},"SQLite database"),".\nMost anything you can do within SQLite,\nyou can do within a SQLite derivation."),(0,r.kt)("h3",{id:"sql-lambdas"},"SQL Lambdas"),(0,r.kt)("p",null,"Lambdas are blocks of one or more SQL statements.\nThey can be defined inline within a Flow specification,\nor they can be provided as a relative file reference to a file of SQL."),(0,r.kt)("p",null,"Your SQL lambda code can include any number of statements,\nand your statements are evaluated in the context of your applied\ndatabase ",(0,r.kt)("a",{parentName:"p",href:"#migrations"},"migrations"),".\nUse regular ",(0,r.kt)("inlineCode",{parentName:"p"},"INSERT"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"UPDATE"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"DELETE")," statements\nin your SQL blocks to manipulate your internal tables as required."),(0,r.kt)("p",null,"Any rows which are returned by SQL statements,\nsuch as ",(0,r.kt)("inlineCode",{parentName:"p"},"SELECT")," and also variations like ",(0,r.kt)("inlineCode",{parentName:"p"},"INSERT ... RETURNING"),",\nare ",(0,r.kt)("a",{parentName:"p",href:"#document-mapping"},"mapped into documents")," that are published\ninto your derived collection.\nPublished documents must conform to your collection schema\nor your derivation task will stop due to the schema violation."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The SQLite connector wraps your lambdas in an enclosing transaction.\nDo ",(0,r.kt)("strong",{parentName:"p"},"not")," include ",(0,r.kt)("inlineCode",{parentName:"p"},"BEGIN")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"COMMIT")," statements in your lambdas.\nYou may use a ",(0,r.kt)("a",{parentName:"p",href:"https://www.sqlite.org/lang_savepoint.html"},"SAVEPOINT")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"ROLLBACK TO"),".")),(0,r.kt)("h3",{id:"document-mapping"},"Document Mapping"),(0,r.kt)("p",null,"In most cases, each named output column of your query becomes\na top-level property of its corresponding document."),(0,r.kt)("p",null,"When you directly select a ",(0,r.kt)("inlineCode",{parentName:"p"},"$parameter")," its corresponding field name is used.\nFor example, a projection with field name ",(0,r.kt)("inlineCode",{parentName:"p"},"my-field")," would be queried as\n",(0,r.kt)("inlineCode",{parentName:"p"},"SELECT $my_field;")," and map into a document like ",(0,r.kt)("inlineCode",{parentName:"p"},'{"my-field":"value"}'),"."),(0,r.kt)("p",null,"A named column such as ",(0,r.kt)("inlineCode",{parentName:"p"},"SELECT $x * 100 AS foo;"),",\nmaps to a property using the provided name: ",(0,r.kt)("inlineCode",{parentName:"p"},'{"foo": 200}'),"."),(0,r.kt)("p",null,"Your selected columns may included nested JSON documents,\nsuch as ",(0,r.kt)("inlineCode",{parentName:"p"},"SELECT 'hello' AS greeting, JSON_ARRAY(1, 'two', 3) AS items;"),".\nThe connector looks for SQLite TEXT values which can be parsed\ninto JSON arrays or objects and embeds them into the mapped document:\n",(0,r.kt)("inlineCode",{parentName:"p"},'{"greeting": "hello", "items": [1, "two", 3]}'),".\nIf parsing fails, the raw string is used instead."),(0,r.kt)("p",null,"As a special case if your query selects a ",(0,r.kt)("em",{parentName:"p"},"single")," column\nhaving a name that begins with ",(0,r.kt)("inlineCode",{parentName:"p"},"json")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"JSON"),",\nas is common when working with SQLite's ",(0,r.kt)("a",{parentName:"p",href:"https://www.sqlite.org/json1.html"},"JSON functions"),",\nthen that column will become the output document.\nFor example ",(0,r.kt)("inlineCode",{parentName:"p"},"SELECT JSON_OBJECT('a', 1, 'b', JSON('true'));")," maps into document ",(0,r.kt)("inlineCode",{parentName:"p"},'{"a": 1, "b": true}'),".\nThis can be used to build documents with dynamic top-level properties."),(0,r.kt)("h3",{id:"parameters"},"Parameters"),(0,r.kt)("p",null,"Your SQL lambda will execute with every source document of the collection it transforms.\nTo access locations within the document, you utilize ",(0,r.kt)("inlineCode",{parentName:"p"},"$parameter")," placeholders\nin your SQL code, which bind to ",(0,r.kt)("a",{parentName:"p",href:"../#projections"},"projections")," of the source document.\nYou can use both your defined projections\nas well as projections which are statically inferred from your source collection's schema."),(0,r.kt)("p",null,"You can access projected fields that are top-level\nas well as those which are nested within a source document.\nConsider the following schematized document:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"top-level": true, "object": {"foo": 42}, "arr": ["bar"]}\n')),(0,r.kt)("p",null,"In your SQL code, you can use parameters like ",(0,r.kt)("inlineCode",{parentName:"p"},"$top_level"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"$object$foo"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"$arr$0"),".\nIf you're unsure of what parameter to use for a given field,\ntry typing something approximate and Flow will suggest the appropriate ",(0,r.kt)("inlineCode",{parentName:"p"},"$parameter"),"."),(0,r.kt)("h3",{id:"migrations"},"Migrations"),(0,r.kt)("p",null,"The SQLite connector offers a managed, persistent SQLite database\nthat can accommodate any number of tables, indices, views, triggers, and other schema,\nas defined by your database migrations.\nTo add a migration, simply append it to the ",(0,r.kt)("inlineCode",{parentName:"p"},"migrations")," array,\neither as a block of inline SQL statements\nor as a relative path to a file of SQL statements:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"derive:\n  using:\n    sqlite:\n      migrations:\n        - CREATE TABLE foo (thing INTEGER NOT NULL);\n          CREATE INDEX idx_foo_thing foo (thing);\n        - ../path/to/another/migration.sql\n        - ALTER TABLE foo ADD COLUMN other_thing TEXT NOT NULL;\n        - https://example.com/yet/another/migration.sql\n")),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"You cannot change an existing migration once it has been published.\nInstead, add a new migration which applies your desired schema.")),(0,r.kt)("p",null,"The tables and other schema you create through database migrations\nare the ",(0,r.kt)("a",{parentName:"p",href:"#internal-state"},"internal state")," of your derivation.\nThey don't directly cause any documents to be published into your derived collection,\nbut changes made to tables in one SQL lambda execution are immediately visible to others.\nChanges are also durable and transactional:\na Flow derivation transaction commits new documents to the derived collection\nin lockstep with committing changes made to your task tables."),(0,r.kt)("p",null,"Flow is responsible for the persistence and replication of your SQLite database,\nand the SQLite connector tracks and will apply your migrations as needed."),(0,r.kt)("h3",{id:"performance"},"Performance"),(0,r.kt)("p",null,"Your observed performance will ",(0,r.kt)("em",{parentName:"p"},"of course")," depend on the specifics of your use case,\nincluding the size of your task states\nand the complexity of your source documents and transformations."),(0,r.kt)("p",null,"Generally speaking, SQLite is very performant\nand Flow's SQLite connector strives to drive it as efficiently as possible.\nReal-world use cases are observed to process many ",(0,r.kt)("strong",{parentName:"p"},"tens\nof thousands")," of documents per second on a single core."),(0,r.kt)("p",null,"Flow can also scale your task without downtime\nby creating point-in-time clones of the database\nthat subdivide the overall workload and storage of the task.\nOnce created, these subdivisions process in parallel across\nmultiple physical machines to enhance performance."),(0,r.kt)("h2",{id:"typescript"},"TypeScript"),(0,r.kt)("p",null,"Flow's TypeScript derivation connector transforms your source documents\nby executing methods of a TypeScript class which you implement.\nTypeScript derivations are executed using ",(0,r.kt)("a",{parentName:"p",href:"https://deno.land/"},"Deno"),"\nand let you take advantage of the broad ecosystem of\navailable third-party JavaScript and TypeScript libraries,\nas well as native code compiled to WASM."),(0,r.kt)("p",null,"TypeScript derivations are strongly typed:\nFlow maps the JSON schemas of your source and output collections\ninto corresponding TypeScript types,\nwhich are type-checked as you develop and test your derivation.\nThis helps catch a wide variety of potential bugs and avoid accidental violations of your collection data contracts."),(0,r.kt)("h3",{id:"modules"},"Modules"),(0,r.kt)("p",null,"The bulk of a TypeScript derivation lives in its associated module,\nwhich is a TypeScript source file that exports the class that implements your derivation."),(0,r.kt)("p",null,"Each derivation also has an accompanying, generated interfaces module.\nInterface modules are managed by Flow and are purely advisory:\nthey're generated to improve your development experience,\nbut any changes you make are ignored."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"flowctl generate --source path/to/my/derivation.flow.yaml")," CLI command\nwill generate interface modules under paths like\n",(0,r.kt)("inlineCode",{parentName:"p"},"flow_generated/typescript/acmeCo/my-derivation.ts"),",\nunder the top-level directory under ",(0,r.kt)("inlineCode",{parentName:"p"},"--source")," having a ",(0,r.kt)("inlineCode",{parentName:"p"},"flow.yaml")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"flow.json")," file."),(0,r.kt)("p",null,"It will also generate a ",(0,r.kt)("inlineCode",{parentName:"p"},"deno.json")," file in your top-level directory,\nwhich is designed to work with developer tooling like\n",(0,r.kt)("a",{parentName:"p",href:"https://marketplace.visualstudio.com/items?itemName=denoland.vscode-deno"},"VSCode's Deno extension"),"."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#current-account-balances"},"See the Current Account Balances tutorial for a concrete example of modules"),"."),(0,r.kt)("h3",{id:"state"},"State"),(0,r.kt)("p",null,"The abstract ",(0,r.kt)("inlineCode",{parentName:"p"},"IDerivation")," class generated within the interfaces module\nincludes additional, experimental methods which can be used for\npersisting and recovering internal state of the connector."),(0,r.kt)("p",null,"Consult the generated implementation and feel free to reach out to support\nif you'd like more information on building stateful TypeScript derivations."),(0,r.kt)("h2",{id:"transformations"},"Transformations"),(0,r.kt)("p",null,"A transformation binds a ",(0,r.kt)("a",{parentName:"p",href:"#sources"},"source")," collection to a derivation,\ncausing its documents to be read and processed by the derivation connector."),(0,r.kt)("p",null,"Read source documents are first ",(0,r.kt)("a",{parentName:"p",href:"#shuffles"},"shuffled")," on a ",(0,r.kt)("strong",{parentName:"p"},"shuffle key"),"\nto co-locate the processing of documents that have equal shuffle keys.\nThe transformation then processes documents by invoking ",(0,r.kt)("strong",{parentName:"p"},"lambdas"),":\nuser-defined functions that accept documents as arguments,\nreturn documents in response,\nand potentially update internal task state."),(0,r.kt)("p",null,"A derivation may have many transformations,\nand each transformation has a long-lived and stable name.\nEach transformation independently reads documents from its\nsource collection and tracks its own read progress.\nMore than one transformation can read from the same source collection,\nand transformations may also source from their own derivation,\nenabling cyclic data-flows and graph algorithms."),(0,r.kt)("p",null,"Transformations may be added to or removed from a derivation at any time.\nThis makes it possible to, for example, add a new collection into an\nexisting multi-way join, or gracefully migrate to a new source\ncollection without incurring downtime.\nHowever, renaming a running transformation is not possible.\nIf attempted, the old transformation is dropped and\na new transformation under the new name is created,\nwhich begins reading its source collection all over again."),(0,r.kt)(s.Z,{chart:"\n\tgraph LR;\n    d[Derivation];\n    t[Transformation];\n    s[Internal State];\n    l[Lambda];\n    c[Sourced Collection];\n    o[Derived Collection];\n    d-- has many --\x3et;\n    d-- has one --\x3es;\n    d-- has one --\x3eo;\n    c-- reads from --\x3et;\n    t-- invokes --\x3el;\n    l-- updates --\x3es;\n    s-- queries --\x3el;\n    l-- publishes to --\x3eo;\n",mdxType:"Mermaid"}),(0,r.kt)("h3",{id:"sources"},"Sources"),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"source")," of a transformation is a collection.\nAs documents are published into the source collection,\nthey are continuously read and processed by the transformation."),(0,r.kt)("p",null,"A ",(0,r.kt)("a",{parentName:"p",href:"/pr-preview/pr-1169/concepts/advanced/projections#partition-selectors"},"partition selector")," may be provided\nto process only a subset of the source collection's logical partitions.\nSelectors are efficient: only partitions that match the selector are read,\nand Flow can cheaply skip over partitions that don't."),(0,r.kt)("p",null,"Derivations re-validate their source documents against\nthe source collection's schema as they are read.\nThis is because collection schemas may evolve over time,\nand could have inadvertently become incompatible with\nhistorical documents of the source collection.\nUpon a schema error, the derivation will pause and\ngive you an opportunity to correct the problem."),(0,r.kt)("h3",{id:"shuffles"},"Shuffles"),(0,r.kt)("p",null,"As each source document is read, it's shuffled \u2014 or equivalently, mapped \u2014\non an extracted key."),(0,r.kt)("p",null,"If you're familiar with data shuffles in tools like MapReduce,\nApache Spark, or Flink, the concept is very similar.\nFlow catalog tasks scale out into multiple shards,\neach running in parallel on different physical machines,\nwhere each shard processes a subset of source documents."),(0,r.kt)("p",null,"Shuffles let Flow identify the shard that should process a particular\nsource document, in order to co-locate that processing with other\ndocuments it may need to know about."),(0,r.kt)("p",null,"For example, transforms of the\n",(0,r.kt)("a",{parentName:"p",href:"#approving-transfers"},"Approving Transfers example"),"\nshuffle on either ",(0,r.kt)("inlineCode",{parentName:"p"},"/sender")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"/recipient")," in order to\nprocess documents that debit or credit accounts on the specific shard\nthat is uniquely responsible for maintaining the balance of a given account."),(0,r.kt)(s.Z,{chart:"\n\tgraph LR;\n    subgraph s1 [Source Partitions]\n      p1>acmeBank/transfers/part-1];\n      p2>acmeBank/transfers/part-2];\n    end\n    subgraph s2 [Derivation Task Shards]\n      t1([derivation/shard-1]);\n      t2([derivation/shard-2]);\n    end\n    p1-- sender: alice --\x3et1;\n    p1-- recipient: bob --\x3et2;\n    p2-- recipient: alice --\x3et1;\n    p2-- sender: bob --\x3et2;\n",mdxType:"Mermaid"}),(0,r.kt)("p",null,"Flow offers three modes for configuring document shuffles: ",(0,r.kt)("inlineCode",{parentName:"p"},"key"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"any"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"lambda"),"."),(0,r.kt)("h4",{id:"shuffle-key"},"shuffle: key"),(0,r.kt)("p",null,"Shuffle keys are defined as an array of JSON pointers to locations\nthat should be extracted from your source documents.\nThis array forms the composite key over which your documents are shuffled:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"transforms:\n  - name: fromOrders\n    source: acmeCo/orders\n    shuffle:\n      key: [/item/product_id, /customer_id]\n    # Flow guarantees that the same shard will process the user's lambda\n    # for all instances of a specific (product ID, customer ID) tuple.\n    lambda: ...\n")),(0,r.kt)("p",null,"If a derivation has more than one transformation,\nthe shuffle keys of all transformations must align with one another\nin terms of the extracted key types (string vs integer)\nas well as the number of components in a composite key."),(0,r.kt)("p",null,"For example, one transformation couldn't shuffle transfers on ",(0,r.kt)("inlineCode",{parentName:"p"},"[/id]"),"\nwhile another shuffles on ",(0,r.kt)("inlineCode",{parentName:"p"},"[/sender]"),", because ",(0,r.kt)("inlineCode",{parentName:"p"},"sender")," is a string and\n",(0,r.kt)("inlineCode",{parentName:"p"},"id")," an integer."),(0,r.kt)("p",null,"Similarly mixing a shuffle of ",(0,r.kt)("inlineCode",{parentName:"p"},"[/sender]")," alongside ",(0,r.kt)("inlineCode",{parentName:"p"},"[/sender, /recipient]"),"\nis prohibited because the keys have different numbers of components."),(0,r.kt)("h4",{id:"shuffle-any"},"shuffle: any"),(0,r.kt)("p",null,"If your lambda doesn't rely on any task state then it may not matter which\ntask shard processes a given source document.\nIn these instances you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"shuffle: any"),", which allows source documents\nto be processed by any available task shard."),(0,r.kt)("p",null,"This is common for transformation lambdas which perform basic filtering\nor mapping of source documents and which don't require any joined task state."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"transforms:\n  - name: fromOrders\n    source: acmeCo/orders\n    shuffle: any\n    # The user's lambda is a pure function and can be evaluated by any available shard.\n    lambda:\n      SELECT $customer_id, $item_price WHERE $item_price > 100;\n")),(0,r.kt)("h4",{id:"shuffle-lambda"},"shuffle: lambda"),(0,r.kt)("admonition",{title:"Warning",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Computed shuffles are in active development and are not yet functional.")),(0,r.kt)("p",null,"Your source documents may not always contain an appropriate value to shuffle upon.\nFor instance, you might want to shuffle on product ID and order date,\nbut your source documents contain only an order timestamp field."),(0,r.kt)("p",null,"You can use ",(0,r.kt)("inlineCode",{parentName:"p"},"shuffle: lambda")," to define a function that maps your\nsource document into the appropriate shuffle key:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"transforms:\n  - name: fromOrders\n    source: acmeCo/orders\n    shuffle:\n      lambda: SELECT $product_id, DATE($order_timestamp);\n    # Flow guarantees that the same shard will process the user's lambda\n    # for all instances of a specific (product ID, date) tuple.\n    lambda: ...\n")),(0,r.kt)("p",null,"Your shuffle lambda must return exactly one row, and its columns and\ntypes must align with the other shuffles of your derivation transformations."),(0,r.kt)("p",null,"Flow must know the types of your composite shuffle key.\nIn most cases it will infer these types from the ",(0,r.kt)("inlineCode",{parentName:"p"},"shuffle: key")," of another transformation.\nIf you have no ",(0,r.kt)("inlineCode",{parentName:"p"},"shuffle: key")," transformations, Flow will ask that you explicitly tell it your shuffle types:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"derive:\n  using:\n    sqlite: {}\n  shuffleKeyTypes: [integer, string]\n  transforms:\n    - name: fromOrders\n      source: acmeCo/orders\n      shuffle:\n        lambda: SELECT $product_id, DATE($order_timestamp);\n      lambda: ...\n")),(0,r.kt)("h3",{id:"lambdas"},"Lambdas"),(0,r.kt)("p",null,"Lambdas are user-defined functions that are invoked by transformations.\nThey accept documents as arguments\nand return transformed documents in response.\nLambdas can update internal task state,\npublish documents into the derived collection,\nor both."),(0,r.kt)("p",null,'Lambdas are "serverless": Flow manages the execution\nand scaling of your transformation lambdas on your behalf.'),(0,r.kt)("h3",{id:"processing-order"},"Processing order"),(0,r.kt)("p",null,"Transformations may simultaneously read from many source collections,\nor even read from the same source collection multiple times."),(0,r.kt)("p",null,"Roughly speaking, the derivation will globally process transformations and\ntheir source documents in the time-based order in which the source documents\nwere originally written to their source collections.\nThis means that a derivation started a month ago\nand a new copy of the derivation started today,\nwill process documents in the same order and arrive at the same result.\nDerivations are ",(0,r.kt)("strong",{parentName:"p"},"repeatable"),"."),(0,r.kt)("p",null,"More precisely, processing order is stable for each individual shuffle key,\nthough different shuffle keys may process in different orders if more than\none task shard is used."),(0,r.kt)("p",null,"Processing order can be attenuated through a ",(0,r.kt)("a",{parentName:"p",href:"#read-delay"},"read delay"),"\nor differentiated ",(0,r.kt)("a",{parentName:"p",href:"#read-priority"},"read priority"),"."),(0,r.kt)("h3",{id:"read-delay"},"Read delay"),(0,r.kt)("p",null,"A transformation can define a read delay, which will hold back the processing\nof its source documents until the time delay condition is met.\nFor example, a read delay of 15 minutes would mean that a source document\ncannot be processed until it was published at least 15 minutes ago.\nIf the derivation is working through a historical backlog of source documents,\nthan a delayed transformation will respect its ordering delay relative\nto the publishing times of other historical documents also being read."),(0,r.kt)("p",null,"Event-driven workflows are a great fit for reacting to events as they occur,\nbut aren\u2019t terribly good at taking action when something ",(0,r.kt)("em",{parentName:"p"},"hasn\u2019t")," happened:"),(0,r.kt)("blockquote",null,(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},"A user adds a product to their cart, but then doesn\u2019t complete a purchase."),(0,r.kt)("li",{parentName:"ul"},"A temperature sensor stops producing its expected, periodic measurements."))),(0,r.kt)("p",null,"A common pattern for tackling these workflows in Flow is to\nread a source collection without a delay and update an internal state.\nThen, read a collection with a read delay\nand determine whether the desired action has happened or not.\nFor example, source from a collection of sensor readings\nand index the last timestamp of each sensor.\nThen, source the same collection again with a read delay:\nif the register timestamp isn't more recent\nthan the delayed source reading,\nthe sensor failed to produce a measurement."),(0,r.kt)("p",null,"Flow read delays are very efficient and scale better\nthan managing very large numbers of fine-grain timers."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#grouped-windows-of-transfers"},"See Grouped Windows of Transfers for an example using a read delay"),"\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/estuary/flow/blob/master/examples/citi-bike/idle-bikes.flow.yaml"},'Learn more from the Citi Bike "idle bikes" example')),(0,r.kt)("h3",{id:"read-priority"},"Read priority"),(0,r.kt)("p",null,"Sometimes it's necessary for ",(0,r.kt)("em",{parentName:"p"},"all")," documents of a source collection\nto be processed by a transformation before ",(0,r.kt)("em",{parentName:"p"},"any")," documents of some\nother source collection are processed, regardless of their\nrelative publishing time.\nFor example, a collection may have corrections that should be\napplied before the historical data of another collection\nis re-processed."),(0,r.kt)("p",null,"Transformation priorities allow you to express the relative\nprocessing priority of a derivation's various transformations.\nWhen priorities are not equal, ",(0,r.kt)("em",{parentName:"p"},"all")," available source documents\nof a higher-priority transformation\nare processed before ",(0,r.kt)("em",{parentName:"p"},"any")," source documents\nof a lower-priority transformation."),(0,r.kt)("h2",{id:"internal-state"},"Internal State"),(0,r.kt)("p",null,"Derivation tasks often require an internal state,\nperhaps to hold a partial aggregation or join result.\nInternal state is not a direct part of the output of a derivation.\nInstead, transformation lambdas query and update internal state\nas they process source documents and return derived documents."),(0,r.kt)("p",null,"For SQLite derivations,\nthe entire SQLite database is the internal state of the task.\nTypeScript derivations can use in-memory states with a\nrecovery and checkpoint mechanism.\nEstuary intends to offer an additional mechanisms for\nautomatic internal state snapshot and recovery in the future."),(0,r.kt)("p",null,"The exact nature of internal task states vary,\nbut under the hood they're backed by a replicated\nembedded RocksDB instance which is co-located\nwith the task shard execution contexts that Flow manages.\nAs contexts are assigned and re-assigned,\ntheir state databases travel with them."),(0,r.kt)("p",null,"If a task shard needs to be scaled out,\nFlow is able to perform an ",(0,r.kt)("a",{parentName:"p",href:"../advanced/shards/#shard-splits"},"online split"),",\nwhich cheaply clones its state database into two new databases\n\u2014 and paired shards \u2014 which are re-assigned to other machines."),(0,r.kt)("h2",{id:"where-to-accumulate"},"Where to accumulate?"),(0,r.kt)("p",null,"Derivation collection schemas may have\n",(0,r.kt)("a",{parentName:"p",href:"/pr-preview/pr-1169/concepts/schemas#reductions"},"reduction")," annotations,\nand lambdas can be combined with reductions in interesting ways.\nYou may be familiar with ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"reduce")," functions\nbuilt into languages like\n",(0,r.kt)("a",{parentName:"p",href:"https://book.pythontips.com/en/latest/map_filter.html"},"Python"),",\n",(0,r.kt)("a",{parentName:"p",href:"https://www.freecodecamp.org/news/javascript-map-reduce-and-filter-explained-with-examples/"},"JavaScript"),',\nand many others\nor have used tools like MapReduce or Spark.\nIn functional terms, lambdas you write within Flow are "mappers,"\nand reductions are always done\nby the Flow runtime using your schema annotations.'),(0,r.kt)("p",null,"This means that, when you implement a derivation,\nyou get to choose where ",(0,r.kt)("strong",{parentName:"p"},"accumulation")," will happen:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Your lambdas can update and query aggregates stored in ",(0,r.kt)("a",{parentName:"li",href:"#internal-state"},"internal task state"),".\n",(0,r.kt)("a",{parentName:"li",href:"#approving-transfers"},"Approving Transfers")," is an example that maintains account balances in a SQLite table."),(0,r.kt)("li",{parentName:"ol"},"Or, your lambdas can compute ",(0,r.kt)("em",{parentName:"li"},"changes")," of an aggregate, which are then reduced by Flow using reduction annotations.\n",(0,r.kt)("a",{parentName:"li",href:"#current-account-balances"},"Current Account Balances")," is an example that combines a lambda with a reduce annotation.")),(0,r.kt)("p",null,"These two approaches can produce equivalent results,\nbut they do so in very different ways."),(0,r.kt)("h3",{id:"accumulate-in-internal-task-state"},"Accumulate in Internal Task State"),(0,r.kt)("p",null,"You can accumulate using the internal state of your derivation:\nfor instance, by using an internal table within your SQLite derivation.\nYou then write lambdas which update that state,\nor query it to publish derived documents."),(0,r.kt)("p",null,"For example, consider a collection that\u2019s summing a value:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Time"),(0,r.kt)("th",{parentName:"tr",align:null},"State"),(0,r.kt)("th",{parentName:"tr",align:null},"Lambdas"),(0,r.kt)("th",{parentName:"tr",align:null},"Derived Document"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"T0"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"0")),(0,r.kt)("td",{parentName:"tr",align:null},"UPDATE val = val + 5; SELECT val;"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"5"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"T1"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"5")),(0,r.kt)("td",{parentName:"tr",align:null},"UPDATE val = val - 1; SELECT val;"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"4"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"T2"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"4")),(0,r.kt)("td",{parentName:"tr",align:null},"UPDATE val = val + 2; SELECT val;"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"6"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"T3"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"6")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("p",null,"Using a derivation's internal state is a great solution if you expect to\nmaterialize the derived collection into a non-transactional store.\nThat's because its documents are complete statements of the current answer,\nand can be correctly applied to systems that support only at-least-once semantics."),(0,r.kt)("p",null,"They\u2019re also well-suited for materializations into endpoints that aren't stateful,\nsuch as Pub/Sub systems or Webhooks."),(0,r.kt)("h3",{id:"accumulate-in-a-database"},"Accumulate in a Database"),(0,r.kt)("p",null,"To accumulate in your materialization endpoint, such as a database,\nyou define a derivation with a reducible schema\nand implement lambdas which publish the ",(0,r.kt)("em",{parentName:"p"},"changes")," to a current answer.\nThe Flow runtime then uses your reduction annotations\nto combine the documents published into your derived collection."),(0,r.kt)("p",null,"Later, when the collection is materialized, your reduction annotations\nare applied again to reduce each collection document into a final,\nfully-reduced value for each collection key\nthat's kept up to date in the materialized table."),(0,r.kt)("p",null,"A key insight is that the database is\nthe ",(0,r.kt)("em",{parentName:"p"},"only")," stateful system in this scenario.\nThe derivation itself is stateless, with lambdas that are pure functions,\nwhich is typically extremely performant."),(0,r.kt)("p",null,"Returning to our summing example:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Time"),(0,r.kt)("th",{parentName:"tr",align:null},"DB"),(0,r.kt)("th",{parentName:"tr",align:null},"Lambdas"),(0,r.kt)("th",{parentName:"tr",align:null},"Derived Document"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"T0"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"0")),(0,r.kt)("td",{parentName:"tr",align:null},"SELECT 5;"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"5"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"T1"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"5")),(0,r.kt)("td",{parentName:"tr",align:null},"SELECT -1;"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"-1"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"T2"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"4")),(0,r.kt)("td",{parentName:"tr",align:null},"SELECT 2;"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"2"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"T3"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"6")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("p",null,"This works especially well when materializing into a transactional database.\nFlow couples its processing transactions with corresponding database transactions,\nensuring end-to-end \u201cexactly once\u201d semantics."),(0,r.kt)("p",null,"When materializing into a non-transactional store,\nFlow is only able to provide weaker \u201cat least once\u201d semantics;\nit\u2019s possible that a document may be combined into a database value more than once.\nWhether that\u2019s a concern depends a bit on the task at hand.\nSome reductions like ",(0,r.kt)("inlineCode",{parentName:"p"},"merge"),' can be applied repeatedly without changing the result,\nwhile in other use cases approximations are acceptable.\nFor the summing example above,\n"at-least-once" semantics could give an incorrect result.'),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/estuary/flow/tree/master/examples/derive-patterns"},"Learn more in the derivation pattern examples of Flow's repository")))}f.isMDXComponent=!0},1748:(e,n,t)=>{var a={"./locale":9234,"./locale.js":9234};function r(e){var n=o(e);return t(n)}function o(e){if(!t.o(a,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return a[e]}r.keys=function(){return Object.keys(a)},r.resolve=o,e.exports=r,r.id=1748}}]);