"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[3295],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>d});var s=t(96540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},81078:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"reference/deletions","title":"Handling Deletions in Estuary Flow","description":"Estuary supports two categories of deletions: soft deletes and hard deletes. These deletion types determine how documents are marked and treated within the system. Below is an explanation of each category.","source":"@site/docs/reference/deletions.md","sourceDirName":"reference","slug":"/reference/deletions","permalink":"/pr-preview/pr-2431/reference/deletions","draft":false,"unlisted":false,"editUrl":"https://github.com/estuary/flow/edit/master/site/docs/reference/deletions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Backfilling Data","permalink":"/pr-preview/pr-2431/reference/backfilling-data"},"next":{"title":"Materialization sync schedule","permalink":"/pr-preview/pr-2431/reference/materialization-sync-schedule"}}');var i=t(74848),r=t(28453);const o={},d="Handling Deletions in Estuary Flow",l={},a=[{value:"Soft Deletes",id:"soft-deletes",level:2},{value:"Hard Deletes",id:"hard-deletes",level:2},{value:"Deletions and Derivations",id:"deletions-and-derivations",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"handling-deletions-in-estuary-flow",children:"Handling Deletions in Estuary Flow"})}),"\n",(0,i.jsxs)(n.p,{children:["Estuary supports two categories of deletions: ",(0,i.jsx)(n.strong,{children:"soft deletes"})," and ",(0,i.jsx)(n.strong,{children:"hard deletes"}),". These deletion types determine how documents are marked and treated within the system. Below is an explanation of each category."]}),"\n",(0,i.jsxs)(n.p,{children:["Delete events contain a very limited set of fields compared to create and update events.\nOnly the primary key and meta information are present. The ",(0,i.jsx)(n.code,{children:"_meta/op"})," field will be set to ",(0,i.jsx)(n.code,{children:"d"}),".\nFor example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "_meta": {\n    "op": "d",\n    "source": {\n      "loc": [\n        516715804872,\n        516715805272,\n        516715805488\n      ],\n      "schema": "public",\n      "table": "shipments",\n      "ts_ms": 1758800000000,\n      "txid": 390000000\n    },\n    "uuid": "abc-123-def-456"\n  },\n  "id": 1234\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"soft-deletes",children:"Soft Deletes"}),"\n",(0,i.jsx)(n.p,{children:"Soft deletes occur when a document is marked as deleted but is not physically removed from the destination. Instead, it is flagged for deletion with a specific metadata field."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Flagging Soft Deletes"}),": The field ",(0,i.jsx)(n.code,{children:"_meta/op"})," is set to ",(0,i.jsx)(n.code,{children:"'d'"})," to indicate that a document has been marked for deletion."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Document Retention"}),": The document remains in the destination even though it is marked as deleted."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Filtering Soft Deleted Documents"}),": To exclude soft-deleted documents from queries, you can filter out documents where ",(0,i.jsx)(n.code,{children:"_meta/op = 'd'"}),". This ensures that soft-deleted documents are ignored without permanently removing them."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"hard-deletes",children:"Hard Deletes"}),"\n",(0,i.jsx)(n.p,{children:"Hard deletes go a step further than soft deletes by permanently removing documents from the destination."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Flagging Hard Deletes"}),": Similar to soft deletes, the ",(0,i.jsx)(n.code,{children:"_meta/op"})," field is set to ",(0,i.jsx)(n.code,{children:"'d'"})," for documents that need to be deleted."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Document Removal"}),": Once a document is flagged, a query is issued to physically remove any document marked with ",(0,i.jsx)(n.code,{children:"_meta/op = 'd'"})," from the destination."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Supported Materialization Connectors for Hard Deletes"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Snowflake"}),"\n",(0,i.jsx)(n.li,{children:"Google BigQuery"}),"\n",(0,i.jsx)(n.li,{children:"Databricks"}),"\n",(0,i.jsx)(n.li,{children:"Amazon Redshift"}),"\n",(0,i.jsx)(n.li,{children:"Elastic"}),"\n",(0,i.jsx)(n.li,{children:"PostgreSQL"}),"\n",(0,i.jsx)(n.li,{children:"MySQL"}),"\n",(0,i.jsx)(n.li,{children:"SQL Server"}),"\n",(0,i.jsx)(n.li,{children:"AlloyDB"}),"\n",(0,i.jsx)(n.li,{children:"MongoDB"}),"\n",(0,i.jsx)(n.li,{children:"MotherDuck"}),"\n",(0,i.jsx)(n.li,{children:"TimescaleDB"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"deletions-and-derivations",children:"Deletions and Derivations"}),"\n",(0,i.jsx)(n.p,{children:"When working with derived collections, since you are filtering and transforming the original data collection, you must take care to ensure delete events are still passed along to the materialization."}),"\n",(0,i.jsx)(n.p,{children:"There are a couple best practices to consider when writing derivations in conjunction with deletions."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Filtering"})}),"\n",(0,i.jsx)(n.p,{children:"Since delete events lack most document fields, it can be easy to accidentally filter them out from downstream systems."}),"\n",(0,i.jsxs)(n.p,{children:["You may therefore want to explicitly check the ",(0,i.jsx)(n.code,{children:"_meta/op"})," field as part of any filtering statement in your transformation logic.\nFor example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"WHERE $_meta$op != 'd'\nAND $created_at > '2025-01-01'\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Hard deletions as reduction annotations"})}),"\n",(0,i.jsxs)(n.p,{children:["Deletes may sometimes appear without an associated create event for the ID, such as when using multiple filter conditions in your derivation.\nIf a delete event is the first time Flow has seen a specific ID, the ID will not be properly passed along for hard deletion in the materialization.\nThis is because Flow uses ",(0,i.jsx)(n.a,{href:"/concepts/#reductions",children:(0,i.jsx)(n.strong,{children:"reductions"})})," to handle hard deletes.\nEssentially, if there isn't already a document for that ID, there is nothing for the new document to ",(0,i.jsx)(n.em,{children:"reduce into"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"To handle this edge case, you should ensure there is more than one document for the ID so the deletion reduction can take place.\nA simple solution is to emit a delete event twice in your transformation.\nThese delete event emissions should all be contained in the same lambda statement to avoid further orphaned deletions."}),"\n",(0,i.jsx)(n.p,{children:"For example, consider this SQL lambda statement:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Perform your desired transformation on the data when the event is not 'd'\nSELECT\n  $id,\n  JSON($flow_document)\nWHERE $_meta$op != 'd';\n\n-- In case we run across IDs we haven't seen before, ensure there is already\n-- a document in place so that delete reductions will propagate correctly\nSELECT $id, $_meta where $_meta$op = 'd';\nSELECT $id, $_meta where $_meta$op = 'd';\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);