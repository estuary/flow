"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[4185],{28453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>l});var i=a(96540);const s={},t=i.createContext(s);function r(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(t.Provider,{value:n},e.children)}},55153:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"reference/backfilling-data","title":"Backfilling Data","description":"When new captures are created, you often have the option of backfilling data. This captures data in its current state and then switches to capturing change events on an ongoing basis.","source":"@site/docs/reference/backfilling-data.md","sourceDirName":"reference","slug":"/reference/backfilling-data","permalink":"/pr-preview/pr-2141/reference/backfilling-data","draft":false,"unlisted":false,"editUrl":"https://github.com/estuary/flow/edit/master/site/docs/reference/backfilling-data.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Allowlisting IP Addresses for Estuary Flow","permalink":"/pr-preview/pr-2141/reference/allow-ip-addresses"},"next":{"title":"Handling Deletions in Estuary Flow","permalink":"/pr-preview/pr-2141/reference/deletions"}}');var s=a(74848),t=a(28453);const r={},l="Backfilling Data",o={},c=[{value:"Preventing backfills",id:"preventing-backfills",level:2},{value:"Preventing backfills during database upgrades",id:"preventing-backfills-during-database-upgrades",level:3},{value:"Backfill modes",id:"backfill-modes",level:2},{value:"Advanced backfill configuration in specific systems",id:"advanced-backfill-configuration-in-specific-systems",level:2},{value:"PostgreSQL Capture",id:"postgresql-capture",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"backfilling-data",children:"Backfilling Data"})}),"\n",(0,s.jsx)(n.p,{children:"When new captures are created, you often have the option of backfilling data. This captures data in its current state and then switches to capturing change events on an ongoing basis."}),"\n",(0,s.jsx)(n.p,{children:"This is desirable in most cases, as it ensures that a complete view of your data is captured into Flow."}),"\n",(0,s.jsxs)(n.p,{children:["Also see how ",(0,s.jsx)(n.a,{href:"https://docs.estuary.dev/concepts/advanced/evolutions/#what-do-schema-evolutions-do",children:"schema evolution"})," can help with backfills when a source's schema becomes incompatible with the existing schema."]}),"\n",(0,s.jsx)(n.h2,{id:"preventing-backfills",children:"Preventing backfills"}),"\n",(0,s.jsx)(n.p,{children:"Preventing backfills when possible can help save costs and computational resources. You may find it appropriate to skip the backfill, especially for extremely large datasets or tables."}),"\n",(0,s.jsx)(n.p,{children:"In this case, many connectors allow you to turn off backfilling on a per-stream or per-table basis. See each individual connector's properties for details."}),"\n",(0,s.jsx)(n.h3,{id:"preventing-backfills-during-database-upgrades",children:"Preventing backfills during database upgrades"}),"\n",(0,s.jsx)(n.p,{children:"During an upgrade, some databases invalidate a replication slot, binlog position, CDC tables, or similar. As Flow relies on these methods to keep its place, upgrades will disrupt the Flow pipeline in these cases."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If a database upgrade ",(0,s.jsx)(n.strong,{children:"will not"})," affect these resources, the Flow connector should simply resume when the upgrade completes and no action is required."]}),"\n",(0,s.jsxs)(n.li,{children:["If a database upgrade ",(0,s.jsx)(n.strong,{children:"will"})," affect these or similar resources, you may need to trigger a backfill after the upgrade completes."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The easiest and most bulletproof solution when this happens is to backfill all bindings of the impacted capture(s) after performing the upgrade. This will permit the captures to recreate entities as necessary, establish a new CDC position, and then backfill all table contents to ensure that any changes which might have occurred in the meantime are correctly captured."}),"\n",(0,s.jsx)(n.p,{children:"However, it is common to want to avoid a full backfill when performing this sort of database maintenance, as these backfills may take some time and require a significant amount of extra data movement even if nothing has actually changed. Some connectors provide features which may be used to accomplish this, however they typically require some amount of extra setup or user knowledge to guarantee certain invariants (put simply: if there were a more efficient way to re-establish consistency in the general case, that's what we would already be doing when asked to backfill the data again)."}),"\n",(0,s.jsx)(n.p,{children:"For example, Postgres currently deletes or requires users to drop logical replication slots during a major version upgrade. To prevent a full backfill during the upgrade, follow these steps:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Pause database writes so no further changes can occur."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Monitor the current capture to ensure captures are fully up-to-date."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"These two steps ensure the connector won't miss any changes."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Perform the database upgrade."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Backfill each binding of the capture using the ",(0,s.jsx)(n.a,{href:"#backfill-modes",children:'"Only Changes" backfill mode'}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'This will not cause a full backfill. "Backfilling" all bindings at once resets the WAL (Write-Ahead Log) position for the capture, essentially allowing it to "jump ahead" to the current end of the WAL. The "Only Changes" mode will skip re-reading existing table content.'}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Resume database writes."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"backfill-modes",children:"Backfill modes"}),"\n",(0,s.jsxs)(n.p,{children:['The connectors that use CDC (Change Data Capture) allow fine-grained control of backfills for individual tables. These bindings include a "Backfill Mode" dropdown in their resource configuration. This setting then translates to a ',(0,s.jsx)(n.code,{children:"mode"})," field for that resource in the specification. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'"bindings": [\n    {\n      "resource": {\n        "namespace": "public",\n        "stream": "tableName",\n        "mode": "Only Changes"\n      },\n      "target": "Artificial-Industries/postgres/public/tableName"\n    }\n  ]\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["In general, you should not change this setting. Make sure you understand your use case, such as ",(0,s.jsx)(n.a,{href:"#preventing-backfills-during-database-upgrades",children:"preventing backfills"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:"The following modes are available:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Normal:"})," backfills chunks of the table and emits all replication events regardless of whether they occur within the backfilled portion of the table or not."]}),"\n",(0,s.jsx)(n.p,{children:"In Normal mode, the connector fetches key-ordered chunks of the table for the backfill while performing reads of the WAL.\nAll WAL changes are emitted immediately, whether or not they relate to an unread portion of the table. Therefore, if a change is made, it shows up quickly even if its table is still backfilling."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Precise:"})," backfills chunks of the table and filters replication events in portions of the table which haven't yet been reached."]}),"\n",(0,s.jsx)(n.p,{children:"In Precise mode, the connector fetches key-ordered chunks of the table for the backfill while performing reads of the WAL.\nAny WAL changes for portions of the table that have already been backfilled are emitted. In contrast to Normal mode, however, WAL changes are suppressed if they relate to a part of the table that hasn't been backfilled yet."}),"\n",(0,s.jsx)(n.p,{children:"WAL changes and backfill chunks get stitched together to produce a fully consistent logical sequence of changes for each key. For example, you are guaranteed to see an insert before an update or delete."}),"\n",(0,s.jsx)(n.p,{children:"Note that Precise backfill is not possible in some cases due to equality comparison challenges when using varying character encodings."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Only Changes:"})," skips backfilling the table entirely and jumps directly to replication streaming for the entire dataset."]}),"\n",(0,s.jsx)(n.p,{children:"No backfill of the table content is performed at all. Only WAL changes are emitted."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Without Primary Key:"})," can be used to capture tables without any form of unique primary key."]}),"\n",(0,s.jsxs)(n.p,{children:["The connector uses an alternative physical row identifier (such as a Postgres ",(0,s.jsx)(n.code,{children:"ctid"}),") to scan backfill chunks, rather than walking the table in key order."]}),"\n",(0,s.jsx)(n.p,{children:"This mode lacks the exact correctness properties of the Normal backfill mode."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If you do not choose a specific backfill mode, Flow will default to an automatic mode."}),"\n",(0,s.jsx)(n.h2,{id:"advanced-backfill-configuration-in-specific-systems",children:"Advanced backfill configuration in specific systems"}),"\n",(0,s.jsx)(n.h3,{id:"postgresql-capture",children:"PostgreSQL Capture"}),"\n",(0,s.jsxs)(n.p,{children:["PostgreSQL's ",(0,s.jsx)(n.code,{children:"xmin"})," system column can be used as a cursor to keep track of the current location in a table. If you need to re-backfill a Postgres table, you can reduce the affected data volume by specifying a minimum or maximum backfill ",(0,s.jsx)(n.code,{children:"XID"}),". Estuary will only backfill rows greater than or less than the specified ",(0,s.jsx)(n.code,{children:"XID"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["This can be especially useful in cases where you do not want to re-backfill a full table, but cannot complete the steps in ",(0,s.jsx)(n.a,{href:"#preventing-backfills",children:"Preventing backfills"})," above, such as if you cannot pause database writes during an upgrade."]}),"\n",(0,s.jsx)(n.p,{children:"To configure this option:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Determine the ",(0,s.jsx)(n.code,{children:"xmin"})," value you want to use."]}),"\n",(0,s.jsxs)(n.p,{children:["You can run a query to find a suitable ",(0,s.jsx)(n.code,{children:"XID"}),", such as:\n",(0,s.jsx)(n.code,{children:"SELECT xmin FROM {your_table_name} WHERE created_at < {desired_timestamp} and created_at > {desired_timestamp};"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"In the Estuary dashboard, edit your PostgreSQL Capture."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Under Endpoint Config, expand ",(0,s.jsx)(n.strong,{children:"Advanced Options"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:['Fill out the "Minimum Backfill XID" or "Maximum Backfill XID" field with the ',(0,s.jsx)(n.code,{children:"xmin"})," value you retrieved."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Save and publish your changes."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In rare cases, this method may not work as expected, as in situations where a database has already filled up its entire ",(0,s.jsx)(n.code,{children:"xmin"})," space. In such cases of ",(0,s.jsx)(n.code,{children:"xmin"})," wrapping, using both Minimum and Maximum Backfill XID fields can help narrow down a specific range to backfill."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);