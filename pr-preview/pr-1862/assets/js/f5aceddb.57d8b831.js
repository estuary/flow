"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[4185],{48810:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>l,toc:()=>c});var i=s(74848),a=s(28453);const t={},r="Backfilling Data",l={id:"reference/backfilling-data",title:"Backfilling Data",description:"When new captures are created, you often have the option of backfilling data. This captures data in its current state and then switches to capturing change events on an ongoing basis.",source:"@site/docs/reference/backfilling-data.md",sourceDirName:"reference",slug:"/reference/backfilling-data",permalink:"/pr-preview/pr-1862/reference/backfilling-data",draft:!1,unlisted:!1,editUrl:"https://github.com/estuary/flow/edit/master/site/docs/reference/backfilling-data.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Allowlisting IP Addresses for Estuary Flow",permalink:"/pr-preview/pr-1862/reference/allow-ip-addresses"},next:{title:"Handling Deletions in Estuary Flow",permalink:"/pr-preview/pr-1862/reference/deletions"}},o={},c=[{value:"Preventing backfills",id:"preventing-backfills",level:2},{value:"Preventing backfills during database upgrades",id:"preventing-backfills-during-database-upgrades",level:3},{value:"Backfill modes",id:"backfill-modes",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"backfilling-data",children:"Backfilling Data"}),"\n",(0,i.jsx)(n.p,{children:"When new captures are created, you often have the option of backfilling data. This captures data in its current state and then switches to capturing change events on an ongoing basis."}),"\n",(0,i.jsx)(n.p,{children:"This is desirable in most cases, as it ensures that a complete view of your data is captured into Flow."}),"\n",(0,i.jsxs)(n.p,{children:["Also see how ",(0,i.jsx)(n.a,{href:"https://docs.estuary.dev/concepts/advanced/evolutions/#what-do-schema-evolutions-do",children:"schema evolution"})," can help with backfills when a source's schema becomes incompatible with the existing schema."]}),"\n",(0,i.jsx)(n.h2,{id:"preventing-backfills",children:"Preventing backfills"}),"\n",(0,i.jsx)(n.p,{children:"Preventing backfills when possible can help save costs and computational resources. You may find it appropriate to skip the backfill, especially for extremely large datasets or tables."}),"\n",(0,i.jsx)(n.p,{children:"In this case, many connectors allow you to turn off backfilling on a per-stream or per-table basis. See each individual connector's properties for details."}),"\n",(0,i.jsx)(n.h3,{id:"preventing-backfills-during-database-upgrades",children:"Preventing backfills during database upgrades"}),"\n",(0,i.jsx)(n.p,{children:"It is common to want to prevent backfills when performing database maintenance, as database upgrades can kick off a new backfill with Flow. Whether or not a database upgrade automatically performs a backfill depends on the database itself."}),"\n",(0,i.jsx)(n.p,{children:"During an upgrade, some databases invalidate a replication slot, binlog position, CDC tables, or similar. As Flow relies on these methods to keep its place, upgrades will disrupt the Flow pipeline in these cases."}),"\n",(0,i.jsxs)(n.p,{children:["If a database upgrade ",(0,i.jsx)(n.strong,{children:"will"})," affect these or similar resources, you can manually prevent a backfill.\nIf a database upgrade ",(0,i.jsx)(n.strong,{children:"will not"})," affect these resources, the Flow connector should simply resume when the upgrade completes."]}),"\n",(0,i.jsx)(n.p,{children:"For example, Postgres currently deletes or requires users to drop logical replication slots during a major version upgrade. To prevent a backfill during the upgrade, follow these steps:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Pause database writes so no further changes can occur."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Monitor the current capture to ensure captures are fully up-to-date."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"These two steps ensure the connector won't miss any changes."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Perform the database upgrade."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Backfill each binding of the capture using the ",(0,i.jsx)(n.a,{href:"#backfill-modes",children:'"Only Changes" backfill mode'}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'This will not cause a full backfill. "Backfilling" the bindings resets the WAL (Write-Ahead Log) position for the capture, essentially resetting its place. The "Only Changes" mode will skip re-reading existing table content.'}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Resume database writes."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"backfill-modes",children:"Backfill modes"}),"\n",(0,i.jsxs)(n.p,{children:['Some connectors, such as those working with SQL sources, allow fine-grained control of backfills for individual tables. These bindings include a "Backfill Mode" dropdown in their resource configuration. This setting then translates to a ',(0,i.jsx)(n.code,{children:"mode"})," field for that resource in the specification. For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'"bindings": [\n    {\n      "resource": {\n        "namespace": "public",\n        "stream": "tableName",\n        "mode": "Only Changes"\n      },\n      "target": "Artificial-Industries/postgres/public/tableName"\n    }\n  ]\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"In general, you should not change this setting. Make sure you understand your use case, such as preventing backfills, as discussed above."})}),"\n",(0,i.jsx)(n.p,{children:"The following modes are available:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Normal:"})," backfills chunks of the table and emits all replication events regardless of whether they occur within the backfilled portion of the table or not."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Precise:"})," backfills chunks of the table and filters replication events in portions of the table which haven't yet been reached."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Only Changes:"})," skips backfilling the table entirely and jumps directly to replication streaming for the entire dataset."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Without Primary Key:"})," can be used to capture tables without any form of unique primary key, but lacks the exact correctness properties of the normal backfill mode."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If you do not choose a specific backfill mode, Flow will default to an automatic mode."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var i=s(96540);const a={},t=i.createContext(a);function r(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);