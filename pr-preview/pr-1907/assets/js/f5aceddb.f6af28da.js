"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[4185],{48810:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=t(74848),s=t(28453);const i={},r="Backfilling Data",l={id:"reference/backfilling-data",title:"Backfilling Data",description:"When new captures are created, you often have the option of backfilling data. This captures data in its current state and then switches to capturing change events on an ongoing basis.",source:"@site/docs/reference/backfilling-data.md",sourceDirName:"reference",slug:"/reference/backfilling-data",permalink:"/pr-preview/pr-1907/reference/backfilling-data",draft:!1,unlisted:!1,editUrl:"https://github.com/estuary/flow/edit/master/site/docs/reference/backfilling-data.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Allowlisting IP Addresses for Estuary Flow",permalink:"/pr-preview/pr-1907/reference/allow-ip-addresses"},next:{title:"Handling Deletions in Estuary Flow",permalink:"/pr-preview/pr-1907/reference/deletions"}},o={},c=[{value:"Preventing backfills",id:"preventing-backfills",level:2},{value:"Preventing backfills during database upgrades",id:"preventing-backfills-during-database-upgrades",level:3},{value:"Backfill modes",id:"backfill-modes",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"backfilling-data",children:"Backfilling Data"}),"\n",(0,a.jsx)(n.p,{children:"When new captures are created, you often have the option of backfilling data. This captures data in its current state and then switches to capturing change events on an ongoing basis."}),"\n",(0,a.jsx)(n.p,{children:"This is desirable in most cases, as it ensures that a complete view of your data is captured into Flow."}),"\n",(0,a.jsxs)(n.p,{children:["Also see how ",(0,a.jsx)(n.a,{href:"https://docs.estuary.dev/concepts/advanced/evolutions/#what-do-schema-evolutions-do",children:"schema evolution"})," can help with backfills when a source's schema becomes incompatible with the existing schema."]}),"\n",(0,a.jsx)(n.h2,{id:"preventing-backfills",children:"Preventing backfills"}),"\n",(0,a.jsx)(n.p,{children:"Preventing backfills when possible can help save costs and computational resources. You may find it appropriate to skip the backfill, especially for extremely large datasets or tables."}),"\n",(0,a.jsx)(n.p,{children:"In this case, many connectors allow you to turn off backfilling on a per-stream or per-table basis. See each individual connector's properties for details."}),"\n",(0,a.jsx)(n.h3,{id:"preventing-backfills-during-database-upgrades",children:"Preventing backfills during database upgrades"}),"\n",(0,a.jsx)(n.p,{children:"It is common to want to prevent backfills when performing database maintenance, as database upgrades can kick off a new backfill with Flow. Whether or not a database upgrade automatically performs a backfill depends on the database itself."}),"\n",(0,a.jsx)(n.p,{children:"During an upgrade, some databases invalidate a replication slot, binlog position, CDC tables, or similar. As Flow relies on these methods to keep its place, upgrades will disrupt the Flow pipeline in these cases."}),"\n",(0,a.jsxs)(n.p,{children:["If a database upgrade ",(0,a.jsx)(n.strong,{children:"will"})," affect these or similar resources, you can manually prevent a backfill.\nIf a database upgrade ",(0,a.jsx)(n.strong,{children:"will not"})," affect these resources, the Flow connector should simply resume when the upgrade completes."]}),"\n",(0,a.jsx)(n.p,{children:"For example, Postgres currently deletes or requires users to drop logical replication slots during a major version upgrade. To prevent a backfill during the upgrade, follow these steps:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Pause database writes so no further changes can occur."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Monitor the current capture to ensure captures are fully up-to-date."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"These two steps ensure the connector won't miss any changes."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Perform the database upgrade."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Backfill each binding of the capture using the ",(0,a.jsx)(n.a,{href:"#backfill-modes",children:'"Only Changes" backfill mode'}),"."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:'This will not cause a full backfill. "Backfilling" the bindings resets the WAL (Write-Ahead Log) position for the capture, essentially resetting its place. The "Only Changes" mode will skip re-reading existing table content.'}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Resume database writes."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"backfill-modes",children:"Backfill modes"}),"\n",(0,a.jsxs)(n.p,{children:['The connectors that use CDC (Change Data Capture) allow fine-grained control of backfills for individual tables. These bindings include a "Backfill Mode" dropdown in their resource configuration. This setting then translates to a ',(0,a.jsx)(n.code,{children:"mode"})," field for that resource in the specification. For example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'"bindings": [\n    {\n      "resource": {\n        "namespace": "public",\n        "stream": "tableName",\n        "mode": "Only Changes"\n      },\n      "target": "Artificial-Industries/postgres/public/tableName"\n    }\n  ]\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsxs)(n.p,{children:["In general, you should not change this setting. Make sure you understand your use case, such as ",(0,a.jsx)(n.a,{href:"#preventing-backfills-during-database-upgrades",children:"preventing backfills"}),"."]})}),"\n",(0,a.jsx)(n.p,{children:"The following modes are available:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Normal:"})," backfills chunks of the table and emits all replication events regardless of whether they occur within the backfilled portion of the table or not."]}),"\n",(0,a.jsx)(n.p,{children:"In Normal mode, the connector fetches key-ordered chunks of the table for the backfill while performing reads of the WAL.\nAll WAL changes are emitted immediately, whether or not they relate to an unread portion of the table. Therefore, if a change is made, it shows up quickly even if its table is still backfilling."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Precise:"})," backfills chunks of the table and filters replication events in portions of the table which haven't yet been reached."]}),"\n",(0,a.jsx)(n.p,{children:"In Precise mode, the connector fetches key-ordered chunks of the table for the backfill while performing reads of the WAL.\nAny WAL changes for portions of the table that have already been backfilled are emitted. In contrast to Normal mode, however, WAL changes are suppressed if they relate to a part of the table that hasn't been backfilled yet."}),"\n",(0,a.jsx)(n.p,{children:"WAL changes and backfill chunks get stitched together to produce a fully consistent logical sequence of changes for each key. For example, you are guaranteed to see an insert before an update or delete."}),"\n",(0,a.jsx)(n.p,{children:"Note that Precise backfill is not possible in some cases due to equality comparison challenges when using varying character encodings."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Only Changes:"})," skips backfilling the table entirely and jumps directly to replication streaming for the entire dataset."]}),"\n",(0,a.jsx)(n.p,{children:"No backfill of the table content is performed at all. Only WAL changes are emitted."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Without Primary Key:"})," can be used to capture tables without any form of unique primary key."]}),"\n",(0,a.jsxs)(n.p,{children:["The connector uses an alternative physical row identifier (such as a Postgres ",(0,a.jsx)(n.code,{children:"ctid"}),") to scan backfill chunks, rather than walking the table in key order."]}),"\n",(0,a.jsx)(n.p,{children:"This mode lacks the exact correctness properties of the Normal backfill mode."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"If you do not choose a specific backfill mode, Flow will default to an automatic mode."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var a=t(96540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);