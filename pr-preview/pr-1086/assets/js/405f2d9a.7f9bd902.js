"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[8273],{3905:(e,t,r)=>{r.d(t,{Zo:()=>m,kt:()=>y});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},m=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=l(r),d=a,y=u["".concat(c,".").concat(d)]||u[d]||p[d]||i;return r?n.createElement(y,o(o({ref:t},m),{},{components:r})):n.createElement(y,o({ref:t},m))}));function y(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=r[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},554:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var n=r(7462),a=(r(7294),r(3905));const i={description:"Using the merge reduction strategy",sidebar_position:3},o="merge",s={unversionedId:"reference/reduction-strategies/merge",id:"reference/reduction-strategies/merge",title:"merge",description:"Using the merge reduction strategy",source:"@site/docs/reference/reduction-strategies/merge.md",sourceDirName:"reference/reduction-strategies",slug:"/reference/reduction-strategies/merge",permalink:"/reference/reduction-strategies/merge",draft:!1,editUrl:"https://github.com/estuary/flow/edit/master/site/docs/reference/reduction-strategies/merge.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{description:"Using the merge reduction strategy",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"firstWriteWins and lastWriteWins",permalink:"/reference/reduction-strategies/firstwritewins-and-lastwritewins"},next:{title:"minimize and maximize",permalink:"/reference/reduction-strategies/minimize-and-maximize"}},c={},l=[],m={toc:l},u="wrapper";function p(e){let{components:t,...r}=e;return(0,a.kt)(u,(0,n.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"merge"},"merge"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"merge")," reduces the left-hand side and right-hand side by recursively reducing shared document locations. The LHS and RHS must either both be objects, or both be arrays."),(0,a.kt)("p",null,"If both sides are objects, ",(0,a.kt)("inlineCode",{parentName:"p"},"merge")," performs a deep merge of each property. If LHS and RHS are both arrays, items at each index of both sides are merged together, extending the shorter of the two sides by taking items off the longer:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'collections:\n  - name: example/reductions/merge\n    schema:\n      type: object\n      reduce: { strategy: merge }\n      properties:\n        key: { type: string }\n        value:\n          # Merge only works with types "array" or "object".\n          # Others will throw an error at build time.\n          type: [array, object]\n          reduce: { strategy: merge }\n          # Deeply merge sub-locations (items or properties) by summing them.\n          items:\n            type: number\n            reduce: { strategy: sum }\n          additionalProperties:\n            type: number\n            reduce: { strategy: sum }\n      required: [key]\n    key: [/key]\n\ntests:\n  "Expect we can merge arrays by index":\n    - ingest:\n        collection: example/reductions/merge\n        documents:\n          - { key: "key", value: [1, 1] }\n          - { key: "key", value: [2, 2, 2] }\n    - verify:\n        collection: example/reductions/merge\n        documents:\n          - { key: "key", value: [3, 3, 2] }\n\n  "Expect we can merge objects by property":\n    - ingest:\n        collection: example/reductions/merge\n        documents:\n          - { key: "key", value: { "a": 1, "b": 1 } }\n          - { key: "key", value: { "a": 1, "c": 1 } }\n    - verify:\n        collection: example/reductions/merge\n        documents:\n          - { key: "key", value: { "a": 2, "b": 1, "c": 1 } }\n')),(0,a.kt)("p",null,"Merge may also take a ",(0,a.kt)("inlineCode",{parentName:"p"},"key"),", which is one or more JSON pointers that are relative to the reduced location. If both sides are arrays and a merge key is present, then a deep sorted merge of the respective items is done, as ordered by the key. Arrays must be pre-sorted and de-duplicated by the key, and ",(0,a.kt)("inlineCode",{parentName:"p"},"merge")," itself always maintains this invariant."),(0,a.kt)("p",null,"Note that you can use a key of ","[","\u201c\u201d] for natural item ordering, such as merging sorted arrays of scalars."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'collections:\n  - name: example/reductions/merge-key\n    schema:\n      type: object\n      reduce: { strategy: merge }\n      properties:\n        key: { type: string }\n        value:\n          type: array\n          reduce:\n            strategy: merge\n            key: [/k]\n          items: { reduce: { strategy: firstWriteWins } }\n      required: [key]\n    key: [/key]\n\ntests:\n  "Expect we can merge sorted arrays":\n    - ingest:\n        collection: example/reductions/merge-key\n        documents:\n          - { key: "key", value: [{ k: "a", v: 1 }, { k: "b", v: 1 }] }\n          - { key: "key", value: [{ k: "a", v: 2 }, { k: "c", v: 2 }] }\n    - verify:\n        collection: example/reductions/merge-key\n        documents:\n          - {\n              key: "key",\n              value: [{ k: "a", v: 1 }, { k: "b", v: 1 }, { k: "c", v: 2 }],\n            }\n')),(0,a.kt)("p",null,"As with ",(0,a.kt)("inlineCode",{parentName:"p"},"append"),", the LHS of ",(0,a.kt)("inlineCode",{parentName:"p"},"merge")," ",(0,a.kt)("em",{parentName:"p"},"may")," be null, in which case the reduction is treated as a no-op and its result remains null."))}p.isMDXComponent=!0}}]);