"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[2519],{28453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>l});var i=n(96540);const t={},a=i.createContext(t);function r(e){const s=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(a.Provider,{value:s},e.children)}},85344:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"guides/advanced-usage/feature-flags","title":"Feature Flags","description":"Feature flags are advanced configuration options that modify connector behavior for non-standard or complex situations. They\'re intentionally not prominently exposed because most users don\'t need them\u2014they exist for edge cases like migrating existing tables, preserving data during backfills, or controlling schema inference behavior.","source":"@site/docs/guides/advanced-usage/feature-flags.md","sourceDirName":"guides/advanced-usage","slug":"/guides/advanced-usage/feature-flags","permalink":"/pr-preview/pr-2648/guides/advanced-usage/feature-flags","draft":false,"unlisted":false,"editUrl":"https://github.com/estuary/flow/edit/master/site/docs/guides/advanced-usage/feature-flags.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Document Metadata Fields","permalink":"/pr-preview/pr-2648/guides/advanced-usage/metadata-fields"},"next":{"title":"Custom Column Types","permalink":"/pr-preview/pr-2648/guides/advanced-usage/custom-column-types"}}');var t=n(74848),a=n(28453);const r={sidebar_position:2},l="Feature Flags",o={},c=[{value:"Setting Feature Flags",id:"setting-feature-flags",level:2},{value:"Materialization Feature Flags",id:"materialization-feature-flags",level:2},{value:"allow_existing_tables_for_new_bindings",id:"allow_existing_tables_for_new_bindings",level:3},{value:"retain_existing_data_on_backfill",id:"retain_existing_data_on_backfill",level:3},{value:"datetime_keys_as_string",id:"datetime_keys_as_string",level:3},{value:"Additional Materialization Flags",id:"additional-materialization-flags",level:3},{value:"Capture Feature Flags",id:"capture-feature-flags",level:2},{value:"use_schema_inference / no_use_schema_inference",id:"use_schema_inference--no_use_schema_inference",level:3},{value:"emit_sourced_schemas / no_emit_sourced_schemas",id:"emit_sourced_schemas--no_emit_sourced_schemas",level:3},{value:"Migrating to Schema Inference",id:"migrating-to-schema-inference",level:3},{value:"keyless_row_id",id:"keyless_row_id",level:3}];function d(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"feature-flags",children:"Feature Flags"})}),"\n",(0,t.jsx)(s.p,{children:"Feature flags are advanced configuration options that modify connector behavior for non-standard or complex situations. They're intentionally not prominently exposed because most users don't need them\u2014they exist for edge cases like migrating existing tables, preserving data during backfills, or controlling schema inference behavior."}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Important:"})," Feature flags have specific caveats and trade-offs. Contact ",(0,t.jsx)(s.a,{href:"mailto:support@estuary.dev",children:"Estuary support"})," before enabling any feature flag to ensure it's appropriate for your use case."]}),"\n",(0,t.jsx)(s.h2,{id:"setting-feature-flags",children:"Setting Feature Flags"}),"\n",(0,t.jsxs)(s.p,{children:["Some connectors expose feature flags directly in the web app under ",(0,t.jsx)(s.strong,{children:"Endpoint Config \u2192 Advanced \u2192 Feature Flags"}),". For connectors that don't expose them in the UI, or to set flags via spec files, use the ",(0,t.jsx)(s.code,{children:"advanced.feature_flags"})," field as a comma-separated string:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-yaml",children:'materializations:\n  acmeCo/my-materialization:\n    endpoint:\n      connector:\n        image: ghcr.io/estuary/materialize-postgres:dev\n        config:\n          address: localhost:5432\n          database: mydb\n          user: flow_user\n          password: secret\n          advanced:\n            feature_flags: "allow_existing_tables_for_new_bindings,retain_existing_data_on_backfill"\n'})}),"\n",(0,t.jsx)(s.h2,{id:"materialization-feature-flags",children:"Materialization Feature Flags"}),"\n",(0,t.jsx)(s.h3,{id:"allow_existing_tables_for_new_bindings",children:"allow_existing_tables_for_new_bindings"}),"\n",(0,t.jsx)(s.p,{children:"Allows materializations to write to tables that already exist in the destination, even for newly added bindings."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Default:"})," Disabled. New bindings fail if the target table already exists."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Use case:"})," Migrating data from another system into Estuary-managed tables, or re-creating a materialization that was previously deleted."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Caveats:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Enabling this flag disables load-key optimizations for affected bindings, which may impact performance. This is necessary to ensure merge operations work correctly with pre-existing data."}),"\n",(0,t.jsx)(s.li,{children:"The connector cannot verify that existing table schemas are compatible."}),"\n",(0,t.jsxs)(s.li,{children:["This flag alone does ",(0,t.jsx)(s.strong,{children:"not"})," prevent backfill of the source collection. To avoid backfilling data into the existing table, also configure ",(0,t.jsx)(s.a,{href:"/concepts/materialization/#backfills",children:(0,t.jsx)(s.code,{children:"notBefore"})}),' or use "Only Changes" mode on the binding.']}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Applies to:"})," All SQL and warehouse materializers (PostgreSQL, MySQL, Snowflake, BigQuery, Redshift, etc.)"]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"retain_existing_data_on_backfill",children:"retain_existing_data_on_backfill"}),"\n",(0,t.jsx)(s.p,{children:"Skips truncating destination tables when a backfill is triggered."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Default:"})," Disabled. Tables are truncated at the start of a backfill to ensure consistency."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Use case:"})," Preserving historical data in the destination when a schema change triggers an automatic backfill."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Caveats:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"May result in duplicate or inconsistent data if the source collection contains updated versions of previously materialized documents."}),"\n",(0,t.jsx)(s.li,{children:"If collection keys or the destination table schema change in incompatible ways, the connector will still drop and recreate the table even with this flag enabled."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Applies to:"})," Most SQL and warehouse materializers."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"datetime_keys_as_string",children:"datetime_keys_as_string"}),"\n",(0,t.jsx)(s.p,{children:"Converts datetime columns used as collection keys to string representation instead of native datetime types."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Default:"})," Enabled for new materializations. This is the standard behavior to preserve precision for datetime keys used as unique identifiers."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Use case:"})," Datetime values used as keys often require exact string matching. Native datetime types may lose precision or have inconsistent timezone handling, causing key mismatches."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Opt-out:"})," Use ",(0,t.jsx)(s.code,{children:"no_datetime_keys_as_string"})," if you need the legacy behavior of using native datetime types for key columns."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Applies to:"})," PostgreSQL, MySQL, Snowflake, BigQuery, and other SQL materializers."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"additional-materialization-flags",children:"Additional Materialization Flags"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Flag"}),(0,t.jsx)(s.th,{children:"Description"}),(0,t.jsx)(s.th,{children:"Applies To"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"uuid_logical_type"})}),(0,t.jsx)(s.td,{children:"Use UUID logical type in Parquet output instead of fixed-length byte arrays."}),(0,t.jsx)(s.td,{children:"Parquet-based connectors (S3, GCS)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"objects_and_arrays_as_json"})}),(0,t.jsx)(s.td,{children:"Store nested objects and arrays as JSON strings instead of STRUCT/ARRAY types."}),(0,t.jsx)(s.td,{children:"BigQuery"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"snowpipe_streaming"})}),(0,t.jsx)(s.td,{children:"Use Snowpipe Streaming API for lower-latency ingestion."}),(0,t.jsx)(s.td,{children:"Snowflake"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"s3_use_dualstack_endpoints"})}),(0,t.jsx)(s.td,{children:"Use S3 dual-stack endpoints for IPv6 compatibility."}),(0,t.jsx)(s.td,{children:"Redshift"})]})]})]}),"\n",(0,t.jsx)(s.h2,{id:"capture-feature-flags",children:"Capture Feature Flags"}),"\n",(0,t.jsxs)(s.p,{children:["The following flags control schema inference behavior for database captures. These flags were introduced when Estuary migrated to automatic schema inference. New captures have both features enabled by default. Existing captures created before this migration have ",(0,t.jsx)(s.code,{children:"no_emit_sourced_schemas"})," and ",(0,t.jsx)(s.code,{children:"no_use_schema_inference"})," flags set to preserve their original behavior."]}),"\n",(0,t.jsx)(s.h3,{id:"use_schema_inference--no_use_schema_inference",children:"use_schema_inference / no_use_schema_inference"}),"\n",(0,t.jsx)(s.p,{children:"Enables schema inference in addition to the connector's native schema discovery."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Default:"})," Enabled for new captures. Existing captures may have ",(0,t.jsx)(s.code,{children:"no_use_schema_inference"})," set."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Behavior:"})," Adds ",(0,t.jsx)(s.code,{children:"x-infer-schema: true"})," to the collection schema, telling Flow to infer schema from captured documents alongside the connector's discovered column types."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Use case:"})," Automatically adapts to schema changes when new columns are added to source tables. Without this, new columns would be rejected until the capture is manually re-discovered."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Caveat:"})," May capture columns that weren't part of the original discovery. Use ",(0,t.jsx)(s.code,{children:"no_use_schema_inference"})," if you need strict schema control."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Applies to:"})," All SQL database capture connectors."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"emit_sourced_schemas--no_emit_sourced_schemas",children:"emit_sourced_schemas / no_emit_sourced_schemas"}),"\n",(0,t.jsx)(s.p,{children:"Emits schema updates to Flow during capture based on the source database's current schema."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Default:"})," Enabled for new captures. Existing captures may have ",(0,t.jsx)(s.code,{children:"no_emit_sourced_schemas"})," set."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Behavior:"})," The connector periodically sends SourcedSchema messages containing the authoritative schema from the source database. Flow uses these to update collection schemas without requiring manual re-discovery."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Use case:"})," Keeps collection schemas synchronized with source table changes (new columns, type changes) automatically."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Caveat:"})," Schema changes propagate automatically, which may trigger downstream backfills in materializations if incompatible changes occur. Use ",(0,t.jsx)(s.code,{children:"no_emit_sourced_schemas"})," to disable."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Applies to:"})," All SQL database capture connectors."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"migrating-to-schema-inference",children:"Migrating to Schema Inference"}),"\n",(0,t.jsxs)(s.p,{children:["If you have an existing capture with ",(0,t.jsx)(s.code,{children:"no_emit_sourced_schemas"})," and ",(0,t.jsx)(s.code,{children:"no_use_schema_inference"})," flags and want to migrate to the new schema inference behavior:"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["Remove ",(0,t.jsx)(s.code,{children:"no_emit_sourced_schemas"})," from the feature flags"]}),"\n",(0,t.jsx)(s.li,{children:"Save the capture and let it restart"}),"\n",(0,t.jsxs)(s.li,{children:["Remove ",(0,t.jsx)(s.code,{children:"no_use_schema_inference"})," from the feature flags"]}),"\n",(0,t.jsx)(s.li,{children:"Edit the capture and refresh all bindings (do not backfill)"}),"\n",(0,t.jsx)(s.li,{children:"Save the capture and let it restart"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"This staged approach ensures schemas are properly synchronized before inference is enabled."}),"\n",(0,t.jsx)(s.h3,{id:"keyless_row_id",children:"keyless_row_id"}),"\n",(0,t.jsx)(s.p,{children:"Generates synthetic row identifiers for tables without primary keys."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Default:"})," Enabled when capturing keyless tables."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Use case:"})," Capturing data from tables that lack primary keys while maintaining document identity."]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);