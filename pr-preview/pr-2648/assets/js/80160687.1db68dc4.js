"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[9355],{10148:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"guides/troubleshooting/schema-inference-issues","title":"Fixing Schema Inference Issues from Bad Upstream Data","description":"Problem","source":"@site/docs/guides/troubleshooting/schema-inference-issues.md","sourceDirName":"guides/troubleshooting","slug":"/guides/troubleshooting/schema-inference-issues","permalink":"/pr-preview/pr-2648/guides/troubleshooting/schema-inference-issues","draft":false,"unlisted":false,"editUrl":"https://github.com/estuary/flow/edit/master/site/docs/guides/troubleshooting/schema-inference-issues.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Custom Column Types","permalink":"/pr-preview/pr-2648/guides/advanced-usage/custom-column-types"},"next":{"title":"Handling Deletions in Estuary","permalink":"/pr-preview/pr-2648/reference/deletions/"}}');var t=s(74848),r=s(28453);const o={sidebar_position:1},d="Fixing Schema Inference Issues from Bad Upstream Data",l={},c=[{value:"Problem",id:"problem",level:2},{value:"Solutions",id:"solutions",level:2},{value:"Option 1: Fix the Source Data and Backfill (<code>dataflow reset</code>)",id:"option-1-fix-the-source-data-and-backfill-dataflow-reset",level:3},{value:"Option 2: Cast to String (<code>castToString</code>)",id:"option-2-cast-to-string-casttostring",level:3},{value:"Option 3: Custom DDL Override (<code>ddl</code>)",id:"option-3-custom-ddl-override-ddl",level:3},{value:"How to Apply Options 2 &amp; 3",id:"how-to-apply-options-2--3",level:2},{value:"Why Schema Keeps Reverting",id:"why-schema-keeps-reverting",level:2},{value:"Supported Connectors",id:"supported-connectors",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"fixing-schema-inference-issues-from-bad-upstream-data",children:"Fixing Schema Inference Issues from Bad Upstream Data"})}),"\n",(0,t.jsx)(n.h2,{id:"problem",children:"Problem"}),"\n",(0,t.jsx)(n.p,{children:"When using schema inference with sources like Azure Blob Storage, MongoDB, or other loosely-structured systems, Estuary automatically infers field types based on observed data. Sometimes unexpected or incorrect values from upstream can cause issues:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Bad data may cause the inferred schema to update in ways that break your materialization (e.g., a string field suddenly containing an integer, or numeric bounds exceeding destination limits)"}),"\n",(0,t.jsx)(n.li,{children:"The inferred type may not match what your downstream systems expect"}),"\n",(0,t.jsx)(n.li,{children:"Editing the collection schema directly doesn't stick\u2014schema inference may overwrite your changes when new data arrives"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"solutions",children:"Solutions"}),"\n",(0,t.jsxs)(n.h3,{id:"option-1-fix-the-source-data-and-backfill-dataflow-reset",children:["Option 1: Fix the Source Data and Backfill (",(0,t.jsx)(n.code,{children:"dataflow reset"}),")"]}),"\n",(0,t.jsx)(n.p,{children:'If you can fix or remove the bad data upstream, this is the easiest option and leaves a clean dataset. Trigger a backfill with "dataflow reset" selected to re-infer the schema from scratch.'}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Trade-offs:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You need to fix the source data first"}),"\n",(0,t.jsx)(n.li,{children:"Depending on dataset size, this could mean a long interruption to your downstream systems while the backfill repopulates"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"How to apply:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Fix or remove the problematic data in your source system"}),"\n",(0,t.jsx)(n.li,{children:"Go to your capture in the Estuary dashboard"}),"\n",(0,t.jsx)(n.li,{children:"Edit the capture and select the affected binding"}),"\n",(0,t.jsxs)(n.li,{children:["Under ",(0,t.jsx)(n.strong,{children:"Backfill"}),", choose ",(0,t.jsx)(n.strong,{children:"Dataflow reset"})]}),"\n",(0,t.jsx)(n.li,{children:"Save and Publish"}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"option-2-cast-to-string-casttostring",children:["Option 2: Cast to String (",(0,t.jsx)(n.code,{children:"castToString"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"If you can't fix the source data, the simplest workaround is to cast the field to a string at the materialization level:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "source": "your/collection/path",\n  "resource": {\n    "schema": "PUBLIC",\n    "table": "your_table"\n  },\n  "fields": {\n    "recommended": true,\n    "include": {\n      "problematic_field": {\n        "castToString": true\n      }\n    }\n  }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"This works for any connector and converts the value to its string representation."}),"\n",(0,t.jsxs)(n.h3,{id:"option-3-custom-ddl-override-ddl",children:["Option 3: Custom DDL Override (",(0,t.jsx)(n.code,{children:"ddl"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["For more control, use the ",(0,t.jsx)(n.code,{children:"ddl"})," option to specify the exact column type in the destination:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "source": "your/collection/path",\n  "resource": {\n    "schema": "PUBLIC",\n    "table": "your_table"\n  },\n  "fields": {\n    "recommended": true,\n    "include": {\n      "problematic_field": {\n        "ddl": "VARCHAR(255)"\n      }\n    }\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ddl"})," value is passed directly to the destination database, so use syntax appropriate for your connector (e.g., ",(0,t.jsx)(n.code,{children:"VARCHAR(255)"})," for Snowflake, ",(0,t.jsx)(n.code,{children:"STRING"})," for BigQuery)."]}),"\n",(0,t.jsx)(n.h2,{id:"how-to-apply-options-2--3",children:"How to Apply Options 2 & 3"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Go to your materialization in the Estuary dashboard"}),"\n",(0,t.jsxs)(n.li,{children:["Click ",(0,t.jsx)(n.strong,{children:"Edit"})," \u2192 ",(0,t.jsx)(n.strong,{children:"Spec Editor"})," (advanced mode)"]}),"\n",(0,t.jsx)(n.li,{children:"Find the binding for your collection"}),"\n",(0,t.jsxs)(n.li,{children:["Add the ",(0,t.jsx)(n.code,{children:"fields.include"})," section with your field configuration"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Save and Publish"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Tip:"}),' First "require" the field in the UI, then add the ',(0,t.jsx)(n.code,{children:"ddl"})," or ",(0,t.jsx)(n.code,{children:"castToString"})," option in the spec editor."]}),"\n",(0,t.jsx)(n.h2,{id:"why-schema-keeps-reverting",children:"Why Schema Keeps Reverting"}),"\n",(0,t.jsx)(n.p,{children:"If you edit the collection's schema directly (under Sources \u2192 Collection), schema inference may overwrite your changes when new data arrives that doesn't match your edits."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ddl"})," and ",(0,t.jsx)(n.code,{children:"castToString"})," options are applied at the ",(0,t.jsx)(n.strong,{children:"materialization"})," level, so they persist regardless of schema inference changes to the source collection."]}),"\n",(0,t.jsx)(n.h2,{id:"supported-connectors",children:"Supported Connectors"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ddl"})," override is supported by SQL-based materialization connectors including:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Snowflake"}),"\n",(0,t.jsx)(n.li,{children:"BigQuery"}),"\n",(0,t.jsx)(n.li,{children:"Redshift"}),"\n",(0,t.jsx)(n.li,{children:"PostgreSQL"}),"\n",(0,t.jsx)(n.li,{children:"MySQL"}),"\n",(0,t.jsx)(n.li,{children:"SQL Server"}),"\n",(0,t.jsx)(n.li,{children:"Databricks"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>d});var i=s(96540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);