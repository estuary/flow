"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[9355],{10148:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"guides/troubleshooting/schema-inference-issues","title":"Fixing Schema Inference Issues","description":"Problem","source":"@site/docs/guides/troubleshooting/schema-inference-issues.md","sourceDirName":"guides/troubleshooting","slug":"/guides/troubleshooting/schema-inference-issues","permalink":"/pr-preview/pr-2648/guides/troubleshooting/schema-inference-issues","draft":false,"unlisted":false,"editUrl":"https://github.com/estuary/flow/edit/master/site/docs/guides/troubleshooting/schema-inference-issues.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Custom Column Types","permalink":"/pr-preview/pr-2648/guides/advanced-usage/custom-column-types"},"next":{"title":"Handling Deletions in Estuary","permalink":"/pr-preview/pr-2648/reference/deletions/"}}');var i=s(74848),o=s(28453);const r={sidebar_position:1},a="Fixing Schema Inference Issues",c={},d=[{value:"Problem",id:"problem",level:2},{value:"Solutions",id:"solutions",level:2},{value:"Option 1: Fix the Source Data and Backfill (<code>dataflow reset</code>)",id:"option-1-fix-the-source-data-and-backfill-dataflow-reset",level:3},{value:"Option 2: Cast to String (<code>castToString</code>)",id:"option-2-cast-to-string-casttostring",level:3},{value:"Option 3: Custom DDL Override (<code>ddl</code>)",id:"option-3-custom-ddl-override-ddl",level:3},{value:"Why Schema Keeps Reverting",id:"why-schema-keeps-reverting",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"fixing-schema-inference-issues",children:"Fixing Schema Inference Issues"})}),"\n",(0,i.jsx)(t.h2,{id:"problem",children:"Problem"}),"\n",(0,i.jsx)(t.p,{children:"When using schema inference with sources like Azure Blob Storage, MongoDB, or other loosely-structured systems, Estuary automatically infers field types based on observed data. Sometimes unexpected or incorrect values from upstream can cause issues:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Bad data may cause the inferred schema to update in ways that break your materialization (e.g., a string field suddenly containing an integer, or numeric bounds exceeding destination limits)"}),"\n",(0,i.jsx)(t.li,{children:"The inferred type may not match what your downstream systems expect"}),"\n",(0,i.jsx)(t.li,{children:"Editing the collection schema directly doesn't stick\u2014schema inference may overwrite your changes when new data arrives"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"solutions",children:"Solutions"}),"\n",(0,i.jsxs)(t.h3,{id:"option-1-fix-the-source-data-and-backfill-dataflow-reset",children:["Option 1: Fix the Source Data and Backfill (",(0,i.jsx)(t.code,{children:"dataflow reset"}),")"]}),"\n",(0,i.jsx)(t.p,{children:'If you can fix or remove the bad data upstream, this is the easiest option and leaves a clean dataset. Trigger a backfill with "dataflow reset" selected to re-infer the schema from scratch.'}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Trade-offs:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"You need to fix the source data first"}),"\n",(0,i.jsx)(t.li,{children:"Depending on dataset size, this could mean a long interruption to your downstream systems while the backfill repopulates"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"How to apply:"})}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Fix or remove the problematic data in your source system"}),"\n",(0,i.jsx)(t.li,{children:"Go to your capture in the Estuary dashboard"}),"\n",(0,i.jsx)(t.li,{children:"Edit the capture and select the affected binding"}),"\n",(0,i.jsxs)(t.li,{children:["Under ",(0,i.jsx)(t.strong,{children:"Backfill"}),", choose ",(0,i.jsx)(t.strong,{children:"Dataflow reset"})]}),"\n",(0,i.jsx)(t.li,{children:"Save and Publish"}),"\n"]}),"\n",(0,i.jsxs)(t.h3,{id:"option-2-cast-to-string-casttostring",children:["Option 2: Cast to String (",(0,i.jsx)(t.code,{children:"castToString"}),")"]}),"\n",(0,i.jsx)(t.p,{children:"If you can't fix the source data, the simplest workaround is to cast the field to a string at the materialization level. This works for any connector and converts the value to its string representation."}),"\n",(0,i.jsxs)(t.p,{children:["See ",(0,i.jsx)(t.a,{href:"/guides/advanced-usage/custom-column-types#casttostring",children:"Custom Column Types \u2014 castToString"})," for configuration details."]}),"\n",(0,i.jsxs)(t.h3,{id:"option-3-custom-ddl-override-ddl",children:["Option 3: Custom DDL Override (",(0,i.jsx)(t.code,{children:"ddl"}),")"]}),"\n",(0,i.jsxs)(t.p,{children:["For more control, use the ",(0,i.jsx)(t.code,{children:"ddl"})," option to specify the exact column type in the destination. The ",(0,i.jsx)(t.code,{children:"ddl"})," value is passed directly to the destination database, so use syntax appropriate for your connector (e.g., ",(0,i.jsx)(t.code,{children:"VARCHAR(255)"})," for Snowflake, ",(0,i.jsx)(t.code,{children:"STRING"})," for BigQuery)."]}),"\n",(0,i.jsxs)(t.p,{children:["See ",(0,i.jsx)(t.a,{href:"/guides/advanced-usage/custom-column-types#ddl",children:"Custom Column Types \u2014 DDL"})," for configuration details and supported connectors."]}),"\n",(0,i.jsx)(t.h2,{id:"why-schema-keeps-reverting",children:"Why Schema Keeps Reverting"}),"\n",(0,i.jsx)(t.p,{children:"If you edit the collection's schema directly (under Sources \u2192 Collection), schema inference may overwrite your changes when new data arrives that doesn't match your edits."}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"ddl"})," and ",(0,i.jsx)(t.code,{children:"castToString"})," options are applied at the ",(0,i.jsx)(t.strong,{children:"materialization"})," level, so they persist regardless of schema inference changes to the source collection."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>a});var n=s(96540);const i={},o=n.createContext(i);function r(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);