package sql

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"strings"

	"github.com/estuary/flow/go/materialize/lifecycle"
	pf "github.com/estuary/flow/go/protocols/flow"
	pm "github.com/estuary/flow/go/protocols/materialize"
	log "github.com/sirupsen/logrus"
)

// Driver implements the pm.DriverServer interface.
type Driver struct {
	// NewEndpoint func(endpointType pf.EndpointType, endpointConfig json.RawMessage) (*Endpoint, err error)
	// The SQLGenerator to use for generating statements for use with the go sql package.
	NewEndpoint func(context.Context, pf.EndpointType, json.RawMessage) (*Endpoint, error)

	RunTransactions func(
		stream pm.Driver_TransactionsServer,
		endpoint *Endpoint,
		spec *pf.MaterializationSpec,
		fence *Fence,
	) error
}

var _ pm.DriverServer = &Driver{}

// Validate implements the DriverServer interface.
func (d *Driver) Validate(ctx context.Context, req *pm.ValidateRequest) (*pm.ValidateResponse, error) {
	endpoint, err := d.NewEndpoint(
		ctx,
		req.EndpointType,
		json.RawMessage(req.EndpointConfigJson),
	)
	if err != nil {
		return nil, fmt.Errorf("building endpoint: %w", err)
	} else if err = req.Collection.Validate(); err != nil {
		return nil, fmt.Errorf("validating collection: %w", err)
	}

	current, err := endpoint.LoadSpec(false)
	if err != nil {
		return nil, fmt.Errorf("loading current spec: %w", err)
	}

	var constraints map[string]*pm.Constraint
	if current != nil {
		constraints = ValidateMatchesExisting(current, req.Collection)
	} else {
		constraints = ValidateNewSQLProjections(req.Collection)
	}

	return &pm.ValidateResponse{Constraints: constraints}, nil
}

// Apply implements the DriverServer interface.
func (d *Driver) Apply(ctx context.Context, req *pm.ApplyRequest) (*pm.ApplyResponse, error) {
	endpoint, err := d.NewEndpoint(
		ctx,
		req.Materialization.EndpointType,
		json.RawMessage(req.Materialization.EndpointConfig),
	)
	if err != nil {
		return nil, fmt.Errorf("building endpoint: %w", err)
	} else if err = req.Materialization.Validate(); err != nil {
		return nil, fmt.Errorf("validating collection: %w", err)
	}

	current, err := endpoint.LoadSpec(false)
	if err != nil {
		return nil, fmt.Errorf("loading current spec: %w", err)
	}

	var constraints map[string]*pm.Constraint
	if current != nil {
		constraints = ValidateMatchesExisting(current, req.Materialization.Collection)
	} else {
		constraints = ValidateNewSQLProjections(req.Materialization.Collection)
	}

	// Validate the request materialization is a valid solution for its own constraints.
	if err = ValidateSelectedFields(constraints, req.Materialization); err != nil {
		return nil, fmt.Errorf("re-validating materialization: %w", err)
	}

	// We don't handle any form of schema migrations, so we require that the list of
	// fields in the request is identical to the current fields. doValidate doesn't handle that
	// because the list of fields isn't known until Apply is called.
	if current != nil && !req.Materialization.FieldSelection.Equal(current.FieldSelection) {
		return nil, fmt.Errorf(
			"The set of fields in the request differs from the existing fields,"+
				"which is disallowed because this driver does not perform schema migrations. "+
				"Request fields: %s , Existing fields: %s",
			req.Materialization.FieldSelection.String(),
			current.FieldSelection.String(),
		)
	}

	// If schema was already applied, there's no further work to be done.
	if current != nil {
		return new(pm.ApplyResponse), nil
	}

	// Generate statements to be applied.
	statements, err := generateApplyStatements(endpoint, req.Materialization)
	if err != nil {
		return nil, err
	}

	// Apply the statements if not in DryRun.
	if !req.DryRun {
		if err = endpoint.ApplyStatements(statements); err != nil {
			return nil, fmt.Errorf("applying schema updates: %w", err)
		}
	}

	// Build and return a description of what happened (or would have happened).
	return &pm.ApplyResponse{
		ActionDescription: fmt.Sprintf(
			"%s\nBEGIN;\n%s\nCOMMIT;\n",
			endpoint.Generator.Comment(fmt.Sprintf(
				"Generated by Flow for materializing collection '%s'\nto table: %s",
				req.Materialization.Collection.Collection,
				endpoint.Tables.Target,
			)),
			strings.Join(statements, "\n\n"),
		),
	}, nil
}

// Transactions implements the DriverServer interface.
func (d *Driver) Transactions(stream pm.Driver_TransactionsServer) error {
	var open, err = stream.Recv()
	if err != nil {
		return fmt.Errorf("read Open: %w", err)
	} else if open.Open == nil {
		return fmt.Errorf("expected Open, got %#v", open)
	}

	endpoint, err := d.NewEndpoint(
		stream.Context(),
		open.Open.EndpointType,
		json.RawMessage(open.Open.EndpointConfigJson),
	)
	if err != nil {
		return fmt.Errorf("building endpoint: %w", err)
	}

	spec, err := endpoint.LoadSpec(true)
	if err != nil {
		return fmt.Errorf("loading materialization spec: %w", err)
	}
	fence, err := endpoint.NewFence(open.Open.ShardFqn)
	if err != nil {
		return fmt.Errorf("installing fence: %w", err)
	}

	if err = stream.Send(&pm.TransactionResponse{
		Opened: &pm.TransactionResponse_Opened{
			FlowCheckpoint: fence.Checkpoint,
			DeltaUpdates:   false,
		},
	}); err != nil {
		return fmt.Errorf("sending Opened: %w", err)
	}

	return d.RunTransactions(stream, endpoint, spec, fence)
}

// RunSQLTransactions runs transactions against the standard `database/sql`
// interface using point lookups and insertions. It's SLOW because it must
// round-trip each statement. Use this only for testing & SQLite.
func RunSQLTransactions(
	stream pm.Driver_TransactionsServer,
	endpoint *Endpoint,
	spec *pf.MaterializationSpec,
	fence *Fence,
) error {
	var target = TableForMaterialization(endpoint.Tables.Target, "", spec)

	loadSQL, loadParams, err := endpoint.Generator.QueryOnPrimaryKey(target, spec.FieldSelection.Document)
	if err != nil {
		return fmt.Errorf("building load SQL: %w", err)
	}
	insertSQL, insertParams, err := endpoint.Generator.InsertStatement(target)
	if err != nil {
		return fmt.Errorf("building insert SQL: %w", err)
	}
	updateSQL, updateParams, err := endpoint.Generator.UpdateStatement(
		target,
		append(append([]string{}, spec.FieldSelection.Values...), spec.FieldSelection.Document),
		spec.FieldSelection.Keys)
	if err != nil {
		return fmt.Errorf("building update SQL: %w", err)
	}

	var response *pm.TransactionResponse // In-progress response.
	var txn *sql.Tx                      // Current transaction.

	defer func() {
		if txn != nil {
			_ = txn.Rollback() // Best-effort rollback.
		}
	}()

	for {
		if txn, err = endpoint.DB.BeginTx(endpoint.Context, nil); err != nil {
			return fmt.Errorf("DB.BeginTx: %w", err)
		}

		loadStmt, err := txn.Prepare(loadSQL)
		if err != nil {
			return fmt.Errorf("txn.Prepare(loadSQL): %w", err)
		}

		// Process all Load requests until Prepare is read.
		var loadIt = lifecycle.NewLoadIterator(stream)
		for loadIt.Next() {
			converted, err := loadParams.Convert(loadIt.Key)
			if err != nil {
				return fmt.Errorf("converting Load key %v: %w", loadIt.Key, err)
			}

			var document json.RawMessage
			err = loadStmt.QueryRow(converted...).Scan(&document)

			log.WithFields(log.Fields{
				"key": loadIt.Key,
				"err": err,
			}).Trace("loaded")

			if err == sql.ErrNoRows {
				// Lookup miss (not an error).
			} else if err != nil {
				return fmt.Errorf("querying Load key %v: %w", loadIt.Key, err)
			} else if err = lifecycle.StageLoaded(stream, &response, document); err != nil {
				return err
			}
		}
		if loadIt.Err() == io.EOF {
			return nil // Clean shutdown.
		} else if loadIt.Err() != nil {
			return err
		}

		// Apply the client's prepared checkpoint to our fence.
		fence.Checkpoint = loadIt.Prepare().FlowCheckpoint
		if err = fence.Update(
			func(_ context.Context, sql string, arguments ...interface{}) (rowsAffected int64, _ error) {
				if result, err := txn.Exec(sql, arguments...); err != nil {
					return 0, fmt.Errorf("txn.Exec: %w", err)
				} else if rowsAffected, err = result.RowsAffected(); err != nil {
					return 0, fmt.Errorf("result.RowsAffected: %w", err)
				}
				return
			},
		); err != nil {
			return fmt.Errorf("fence.Update: %w", err)
		}

		// Respond with our Prepared. Pass `nil` because we don't use driver checkpoints.
		if err = lifecycle.WritePrepared(stream, &response, nil); err != nil {
			return err
		}

		insertStmt, err := txn.Prepare(insertSQL)
		if err != nil {
			return fmt.Errorf("txn.Prepare(insertSQL): %w", err)
		}
		updateStmt, err := txn.Prepare(updateSQL)
		if err != nil {
			return fmt.Errorf("txn.Prepare(updateSQL): %w", err)
		}

		// Process all Store requests until Commit is read.
		var storeIt = lifecycle.NewStoreIterator(stream)
		for storeIt.Next() {
			if storeIt.Exists {
				converted, err := updateParams.Convert(append(append(
					storeIt.Values, storeIt.RawJSON), storeIt.Key...))
				if err != nil {
					return fmt.Errorf("converting update parameters: %w", err)
				}
				if _, err = updateStmt.Exec(converted...); err != nil {
					return fmt.Errorf("updating document: %w", err)
				}

				log.WithFields(log.Fields{
					"key":    storeIt.Key,
					"values": storeIt.Values,
				}).Trace("updated")
			} else {
				converted, err := insertParams.Convert(append(append(
					storeIt.Key, storeIt.Values...), storeIt.RawJSON))
				if err != nil {
					return fmt.Errorf("converting insert parameters: %w", err)
				}
				if _, err = insertStmt.Exec(converted...); err != nil {
					return fmt.Errorf("inserting document: %w", err)
				}

				log.WithFields(log.Fields{
					"key":    storeIt.Key,
					"values": storeIt.Values,
				}).Trace("inserted")
			}
		}
		if storeIt.Err() != nil {
			return err
		}

		if err = txn.Commit(); err != nil {
			return fmt.Errorf("txn.Commit: %w", err)
		}

		// Acknowledge our commit.
		if err = lifecycle.WriteCommitted(stream, &response); err != nil {
			return err
		}
	}
}
