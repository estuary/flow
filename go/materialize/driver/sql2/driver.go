package sql

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"strings"

	"github.com/estuary/flow/go/fdb/tuple"
	"github.com/estuary/flow/go/materialize/lifecycle"
	pf "github.com/estuary/flow/go/protocols/flow"
	pm "github.com/estuary/flow/go/protocols/materialize"
	log "github.com/sirupsen/logrus"
)

// Driver implements the pm.DriverServer interface.
type Driver struct {
	// NewEndpoint func(endpointType pf.EndpointType, endpointConfig json.RawMessage) (*Endpoint, err error)
	// The SQLGenerator to use for generating statements for use with the go sql package.
	NewEndpoint func(context.Context, pf.EndpointType, json.RawMessage) (*Endpoint, error)

	RunTransactions func(
		stream pm.Driver_TransactionsServer,
		endpoint *Endpoint,
		spec *pf.MaterializationSpec,
		fence *Fence,
	) error
}

var _ pm.DriverServer = &Driver{}

// Validate implements the DriverServer interface.
func (d *Driver) Validate(ctx context.Context, req *pm.ValidateRequest) (*pm.ValidateResponse, error) {
	endpoint, err := d.NewEndpoint(
		ctx,
		req.EndpointType,
		json.RawMessage(req.EndpointConfigJson),
	)
	if err != nil {
		return nil, fmt.Errorf("building endpoint: %w", err)
	} else if err = req.Collection.Validate(); err != nil {
		return nil, fmt.Errorf("validating collection: %w", err)
	}

	current, err := endpoint.LoadSpec(false)
	if err != nil {
		return nil, fmt.Errorf("loading current spec: %w", err)
	}

	var constraints map[string]*pm.Constraint
	if current != nil {
		constraints = ValidateMatchesExisting(current, req.Collection)
	} else {
		constraints = ValidateNewSQLProjections(req.Collection)
	}

	return &pm.ValidateResponse{Constraints: constraints}, nil
}

// Apply implements the DriverServer interface.
func (d *Driver) Apply(ctx context.Context, req *pm.ApplyRequest) (*pm.ApplyResponse, error) {
	endpoint, err := d.NewEndpoint(
		ctx,
		req.Materialization.EndpointType,
		json.RawMessage(req.Materialization.EndpointConfig),
	)
	if err != nil {
		return nil, fmt.Errorf("building endpoint: %w", err)
	} else if err = req.Materialization.Validate(); err != nil {
		return nil, fmt.Errorf("validating collection: %w", err)
	}

	current, err := endpoint.LoadSpec(false)
	if err != nil {
		return nil, fmt.Errorf("loading current spec: %w", err)
	}

	var constraints map[string]*pm.Constraint
	if current != nil {
		constraints = ValidateMatchesExisting(current, req.Materialization.Collection)
	} else {
		constraints = ValidateNewSQLProjections(req.Materialization.Collection)
	}

	// Validate the request materialization is a valid solution for its own constraints.
	if err = ValidateSelectedFields(constraints, req.Materialization); err != nil {
		return nil, fmt.Errorf("re-validating materialization: %w", err)
	}

	// We don't handle any form of schema migrations, so we require that the list of
	// fields in the request is identical to the current fields. doValidate doesn't handle that
	// because the list of fields isn't known until Apply is called.
	if current != nil && !req.Materialization.FieldSelection.Equal(&current.FieldSelection) {
		return nil, fmt.Errorf(
			"The set of fields in the request differs from the existing fields, which is disallowed because this driver does not perform schema migrations. Request fields: [%s], existing fields: [%s]",
			strings.Join(req.Materialization.FieldSelection.AllFields(), ", "),
			strings.Join(current.FieldSelection.AllFields(), ", "),
		)
	}

	// If schema was already applied, there's no further work to be done.
	if current != nil {
		return new(pm.ApplyResponse), nil
	}

	// Generate statements to be applied.
	statements, err := generateApplyStatements(endpoint, req.Materialization)
	if err != nil {
		return nil, err
	}

	// Apply the statements if not in DryRun.
	if !req.DryRun {
		if err = endpoint.ApplyStatements(statements); err != nil {
			return nil, fmt.Errorf("applying schema updates: %w", err)
		}
	}

	// Build and return a description of what happened (or would have happened).
	return &pm.ApplyResponse{
		ActionDescription: fmt.Sprintf(
			"%s\nBEGIN;\n%s\nCOMMIT;\n",
			endpoint.Generator.Comment(fmt.Sprintf(
				"Generated by Flow for materializing collection '%s'\nto table: %s",
				req.Materialization.Collection.Collection,
				endpoint.Tables.Target,
			)),
			strings.Join(statements, "\n\n"),
		),
	}, nil
}

// Transactions implements the DriverServer interface.
func (d *Driver) Transactions(stream pm.Driver_TransactionsServer) error {
	var request, err = stream.Recv()
	if err != nil {
		return fmt.Errorf("read open: %w", err)
	} else if request.Open == nil {
		return fmt.Errorf("expected Open, got %#v", request)
	}

	endpoint, err := d.NewEndpoint(
		stream.Context(),
		request.Open.EndpointType,
		json.RawMessage(request.Open.EndpointConfigJson),
	)
	if err != nil {
		return fmt.Errorf("building endpoint: %w", err)
	}

	spec, err := endpoint.LoadSpec(true)
	if err != nil {
		return fmt.Errorf("loading materialization spec: %w", err)
	}
	fence, err := endpoint.NewFence(request.Open.ShardFqn)
	if err != nil {
		return fmt.Errorf("installing fence: %w", err)
	}

	return d.RunTransactions(stream, endpoint, spec, fence)
}

// RunSQLTransactions runs transactions against the standard `database/sql`
// interface using point lookups and insertions. It's SLOW because it must
// round-trip each statement. Use this only for testing & SQLite.
func RunSQLTransactions(
	stream pm.Driver_TransactionsServer,
	endpoint *Endpoint,
	spec *pf.MaterializationSpec,
	fence *Fence,
) error {
	var target = TableForMaterialization(endpoint.Tables.Target, "", spec)

	loadSQL, loadParams, err := endpoint.Generator.QueryOnPrimaryKey(target, spec.FieldSelection.Document)
	if err != nil {
		return fmt.Errorf("building load SQL: %w", err)
	}
	insertSQL, insertParams, err := endpoint.Generator.InsertStatement(target)
	if err != nil {
		return fmt.Errorf("building insert SQL: %w", err)
	}
	updateSQL, updateParams, err := endpoint.Generator.UpdateStatement(
		target,
		append(append([]string{}, spec.FieldSelection.Values...), spec.FieldSelection.Document),
		spec.FieldSelection.Keys)
	if err != nil {
		return fmt.Errorf("building update SQL: %w", err)
	}

	var response *pm.TransactionResponse // In-progress response.
	var txn *sql.Tx                      // Current transaction.

	defer func() {
		if txn != nil {
			_ = txn.Rollback() // Best-effort rollback.
		}
	}()

	for {
		if txn, err = endpoint.DB.BeginTx(endpoint.Context, nil); err != nil {
			return fmt.Errorf("DB.BeginTx: %w", err)
		}

		loadStmt, err := txn.Prepare(loadSQL)
		if err != nil {
			return fmt.Errorf("txn.Prepare(loadSQL): %w", err)
		}

		// Callback invoked for each document key to load.
		var loadFn = func(key tuple.Tuple) error {
			converted, err := loadParams.Convert(key)
			if err != nil {
				return fmt.Errorf("converting key %v: %w", key, err)
			}

			var document json.RawMessage
			err = loadStmt.QueryRow(converted...).Scan(&document)

			log.WithFields(log.Fields{
				"key": key,
				"err": err,
			}).Debug("loaded")

			if err == sql.ErrNoRows {
				return nil // Lookup miss (not an error).
			} else if err != nil {
				return fmt.Errorf("querying document: %w", err)
			}
			return lifecycle.WriteLoaded(stream, &response, document)
		}

		// Process all TransactionRequest.Load, returning a Prepare.
		prepare, err := lifecycle.ReadAllLoads(stream, loadFn)
		if err == io.EOF {
			return nil // Clean shutdown.
		} else if err != nil {
			return fmt.Errorf("loading keys: %w", err)
		}

		// Apply the client's prepared checkpoint to our fence.
		fence.Checkpoint = prepare.FlowCheckpoint
		if err = fence.Update(
			func(_ context.Context, sql string, arguments ...interface{}) (rowsAffected int64, _ error) {
				if result, err := txn.Exec(sql, arguments...); err != nil {
					return 0, fmt.Errorf("txn.Exec: %w", err)
				} else if rowsAffected, err = result.RowsAffected(); err != nil {
					return 0, fmt.Errorf("result.RowsAffected: %w", err)
				}
				return
			},
		); err != nil {
			return fmt.Errorf("fence.Update: %w", err)
		}

		// Respond with our Prepared. Pass `nil` because we don't use driver checkpoints.
		if err = lifecycle.WritePrepared(stream, &response, nil); err != nil {
			return err
		}

		insertStmt, err := txn.Prepare(insertSQL)
		if err != nil {
			return fmt.Errorf("txn.Prepare(insertSQL): %w", err)
		}
		updateStmt, err := txn.Prepare(updateSQL)
		if err != nil {
			return fmt.Errorf("txn.Prepare(updateSQL): %w", err)
		}

		// Callback invoked for each document to insert.
		var insertFn = func(key, values tuple.Tuple, doc json.RawMessage) error {
			converted, err := insertParams.Convert(append(append(key, values...), doc))
			if err != nil {
				return fmt.Errorf("converting insert parameters: %w", err)
			}
			if _, err = insertStmt.Exec(converted...); err != nil {
				return fmt.Errorf("inserting document: %w", err)
			}

			log.WithFields(log.Fields{
				"key":    key,
				"values": values,
			}).Info("inserted")

			return nil
		}

		// Callback invoked for each document to update.
		var updateFn = func(key, values tuple.Tuple, doc json.RawMessage) error {
			converted, err := updateParams.Convert(append(append(values, doc), key...))
			if err != nil {
				return fmt.Errorf("converting update parameters: %w", err)
			}
			if _, err = updateStmt.Exec(converted...); err != nil {
				return fmt.Errorf("updating document: %w", err)
			}

			log.WithFields(log.Fields{
				"key":    key,
				"values": values,
			}).Info("updated")

			return nil
		}

		// Process stored documents from the client.
		if _, err = lifecycle.ReadAllStores(stream, insertFn, updateFn); err != nil {
			return fmt.Errorf("storing documents: %w", err)
		}

		if err = txn.Commit(); err != nil {
			return fmt.Errorf("txn.Commit: %w", err)
		}

		// Acknowledge our commit.
		if err = lifecycle.WriteCommitted(stream, &response); err != nil {
			return err
		}
	}
}
