// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go/protocol/flow.proto

package protocol

import (
	bytes "bytes"
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	go_gazette_dev_core_broker_protocol "go.gazette.dev/core/broker/protocol"
	protocol "go.gazette.dev/core/broker/protocol"
	protocol1 "go.gazette.dev/core/consumer/protocol"
	recoverylog "go.gazette.dev/core/consumer/recoverylog"
	go_gazette_dev_core_message "go.gazette.dev/core/message"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ContentType is an encoding used for document content.
type ContentType int32

const (
	ContentType_INVALID ContentType = 0
	// JSON is the usual text encoding, with a trailing newline.
	ContentType_JSON ContentType = 1
)

var ContentType_name = map[int32]string{
	0: "INVALID",
	1: "JSON",
}

var ContentType_value = map[string]int32{
	"INVALID": 0,
	"JSON":    1,
}

func (x ContentType) String() string {
	return proto.EnumName(ContentType_name, int32(x))
}

func (ContentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{0}
}

type Field_Value_Kind int32

const (
	Field_Value_INVALID  Field_Value_Kind = 0
	Field_Value_NULL     Field_Value_Kind = 1
	Field_Value_TRUE     Field_Value_Kind = 2
	Field_Value_FALSE    Field_Value_Kind = 3
	Field_Value_STRING   Field_Value_Kind = 4
	Field_Value_UNSIGNED Field_Value_Kind = 5
	Field_Value_SIGNED   Field_Value_Kind = 6
	Field_Value_DOUBLE   Field_Value_Kind = 7
	Field_Value_OBJECT   Field_Value_Kind = 8
	Field_Value_ARRAY    Field_Value_Kind = 9
)

var Field_Value_Kind_name = map[int32]string{
	0: "INVALID",
	1: "NULL",
	2: "TRUE",
	3: "FALSE",
	4: "STRING",
	5: "UNSIGNED",
	6: "SIGNED",
	7: "DOUBLE",
	8: "OBJECT",
	9: "ARRAY",
}

var Field_Value_Kind_value = map[string]int32{
	"INVALID":  0,
	"NULL":     1,
	"TRUE":     2,
	"FALSE":    3,
	"STRING":   4,
	"UNSIGNED": 5,
	"SIGNED":   6,
	"DOUBLE":   7,
	"OBJECT":   8,
	"ARRAY":    9,
}

func (x Field_Value_Kind) String() string {
	return proto.EnumName(Field_Value_Kind_name, int32(x))
}

func (Field_Value_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{6, 0, 0}
}

// Slice represents a contiguous slice of bytes within an associated Arena.
type Slice struct {
	Begin uint32 `protobuf:"varint,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End   uint32 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *Slice) Reset()         { *m = Slice{} }
func (m *Slice) String() string { return proto.CompactTextString(m) }
func (*Slice) ProtoMessage()    {}
func (*Slice) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{0}
}
func (m *Slice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Slice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Slice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Slice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Slice.Merge(m, src)
}
func (m *Slice) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Slice) XXX_DiscardUnknown() {
	xxx_messageInfo_Slice.DiscardUnknown(m)
}

var xxx_messageInfo_Slice proto.InternalMessageInfo

func (m *Slice) GetBegin() uint32 {
	if m != nil {
		return m.Begin
	}
	return 0
}

func (m *Slice) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

// UUIDParts is a deconstructed, RFC 4122 v1 variant Universally Unique
// Identifier as used by Gazette.
type UUIDParts struct {
	// Producer is the unique node identifier portion of a v1 UUID, as the high
	// 48 bits of |producer_and_flags|. The MSB must be 1 to mark this producer
	// as "multicast" and not an actual MAC address (as per RFC 4122).
	//
	// Bits 49-54 must be zero.
	//
	// The low 10 bits are the 10 least-significant bits of the v1 UUID clock
	// sequence, used by Gazette to represent flags over message transaction
	// semantics.
	ProducerAndFlags uint64 `protobuf:"fixed64,1,opt,name=producer_and_flags,json=producerAndFlags,proto3" json:"producer_and_flags,omitempty"`
	// Clock is a v1 UUID 60-bit timestamp (60 MSBs), followed by 4 bits of
	// sequence counter.
	Clock go_gazette_dev_core_message.Clock `protobuf:"fixed64,2,opt,name=clock,proto3,casttype=go.gazette.dev/core/message.Clock" json:"clock,omitempty"`
}

func (m *UUIDParts) Reset()         { *m = UUIDParts{} }
func (m *UUIDParts) String() string { return proto.CompactTextString(m) }
func (*UUIDParts) ProtoMessage()    {}
func (*UUIDParts) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{1}
}
func (m *UUIDParts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UUIDParts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UUIDParts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UUIDParts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UUIDParts.Merge(m, src)
}
func (m *UUIDParts) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UUIDParts) XXX_DiscardUnknown() {
	xxx_messageInfo_UUIDParts.DiscardUnknown(m)
}

var xxx_messageInfo_UUIDParts proto.InternalMessageInfo

func (m *UUIDParts) GetProducerAndFlags() uint64 {
	if m != nil {
		return m.ProducerAndFlags
	}
	return 0
}

func (m *UUIDParts) GetClock() go_gazette_dev_core_message.Clock {
	if m != nil {
		return m.Clock
	}
	return 0
}

// Shuffle of documents, mapping each document to member indicies within a
// Ring.
type Shuffle struct {
	// Transform for which this Shuffle is being applied.
	Transform Transform `protobuf:"bytes,1,opt,name=transform,proto3,casttype=Transform" json:"transform,omitempty"`
	// Composite key over which shuffling occurs, specified as one or more
	// JSON-Pointers indicating a message location to extract.
	ShuffleKeyPtr []string `protobuf:"bytes,2,rep,name=shuffle_key_ptr,json=shuffleKeyPtr,proto3" json:"shuffle_key_ptr,omitempty"`
	// Number of top-ranked processors to broadcast each message to, after
	// shuffling. Usually this is one. If non-zero, |choose_from| cannot be set.
	BroadcastTo uint32 `protobuf:"varint,3,opt,name=broadcast_to,json=broadcastTo,proto3" json:"broadcast_to,omitempty"`
	// Number of top-ranked readers from which a single reader index will be
	// selected, after shuffling. The message Clock value is used to pseudo
	// randomly pick the final index, making the selection deterministic.
	// Values larger than one can be used to distribute "hot keys" which might
	// otherwise overwhelm specific readers.
	// Usually this is zero and |broadcast_to| is used instead. If non-zero,
	// |broadcast_to| cannot be set.
	ChooseFrom uint32 `protobuf:"varint,4,opt,name=choose_from,json=chooseFrom,proto3" json:"choose_from,omitempty"`
	// Number of seconds for which documents of this collection are delayed
	// while reading, relative to other documents (when back-filling) and the
	// present wall-clock time (when tailing).
	ReadDelaySeconds     uint32   `protobuf:"varint,5,opt,name=read_delay_seconds,json=readDelaySeconds,proto3" json:"read_delay_seconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Shuffle) Reset()         { *m = Shuffle{} }
func (m *Shuffle) String() string { return proto.CompactTextString(m) }
func (*Shuffle) ProtoMessage()    {}
func (*Shuffle) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{2}
}
func (m *Shuffle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Shuffle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Shuffle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Shuffle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Shuffle.Merge(m, src)
}
func (m *Shuffle) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Shuffle) XXX_DiscardUnknown() {
	xxx_messageInfo_Shuffle.DiscardUnknown(m)
}

var xxx_messageInfo_Shuffle proto.InternalMessageInfo

func (m *Shuffle) GetTransform() Transform {
	if m != nil {
		return m.Transform
	}
	return ""
}

func (m *Shuffle) GetShuffleKeyPtr() []string {
	if m != nil {
		return m.ShuffleKeyPtr
	}
	return nil
}

func (m *Shuffle) GetBroadcastTo() uint32 {
	if m != nil {
		return m.BroadcastTo
	}
	return 0
}

func (m *Shuffle) GetChooseFrom() uint32 {
	if m != nil {
		return m.ChooseFrom
	}
	return 0
}

func (m *Shuffle) GetReadDelaySeconds() uint32 {
	if m != nil {
		return m.ReadDelaySeconds
	}
	return 0
}

// Ring is a topology of members, working in concert to share a task.
// Each derived collection has a Ring of member shards which are
// responsible for its continuous derivation.
type Ring struct {
	// Unique name of this ring.
	Name                 string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Members              []Ring_Member `protobuf:"bytes,2,rep,name=members,proto3" json:"members"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Ring) Reset()         { *m = Ring{} }
func (m *Ring) String() string { return proto.CompactTextString(m) }
func (*Ring) ProtoMessage()    {}
func (*Ring) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{3}
}
func (m *Ring) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ring) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ring.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ring) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ring.Merge(m, src)
}
func (m *Ring) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Ring) XXX_DiscardUnknown() {
	xxx_messageInfo_Ring.DiscardUnknown(m)
}

var xxx_messageInfo_Ring proto.InternalMessageInfo

func (m *Ring) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Ring) GetMembers() []Ring_Member {
	if m != nil {
		return m.Members
	}
	return nil
}

// Current members of this ring.
type Ring_Member struct {
	// Miniumum Clock of messages processed by this member, used to:
	// - Lower-bound messages mapped to this member.
	// - Lower-bound the fragment from which this member starts reading.
	MinMsgClock go_gazette_dev_core_message.Clock `protobuf:"varint,1,opt,name=min_msg_clock,json=minMsgClock,proto3,casttype=go.gazette.dev/core/message.Clock" json:"min_msg_clock,omitempty"`
	// Maximum Clock of messages processed by this member, used to
	// upper-bound messages mapped to this member.
	MaxMsgClock          go_gazette_dev_core_message.Clock `protobuf:"varint,2,opt,name=max_msg_clock,json=maxMsgClock,proto3,casttype=go.gazette.dev/core/message.Clock" json:"max_msg_clock,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *Ring_Member) Reset()         { *m = Ring_Member{} }
func (m *Ring_Member) String() string { return proto.CompactTextString(m) }
func (*Ring_Member) ProtoMessage()    {}
func (*Ring_Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{3, 0}
}
func (m *Ring_Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ring_Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ring_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ring_Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ring_Member.Merge(m, src)
}
func (m *Ring_Member) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Ring_Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Ring_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Ring_Member proto.InternalMessageInfo

func (m *Ring_Member) GetMinMsgClock() go_gazette_dev_core_message.Clock {
	if m != nil {
		return m.MinMsgClock
	}
	return 0
}

func (m *Ring_Member) GetMaxMsgClock() go_gazette_dev_core_message.Clock {
	if m != nil {
		return m.MaxMsgClock
	}
	return 0
}

// ShuffleConfig places a Shuffle within a specific, configured execution
// context within which it runs.
type ShuffleConfig struct {
	// Journal to be shuffled.
	Journal go_gazette_dev_core_broker_protocol.Journal `protobuf:"bytes,1,opt,name=journal,proto3,casttype=go.gazette.dev/core/broker/protocol.Journal" json:"journal,omitempty"`
	// Ring on whose behalf this journal is being shuffled.
	Ring Ring `protobuf:"bytes,2,opt,name=ring,proto3" json:"ring"`
	// Coordinator is the ring member index which is responsible for shuffled
	// reads of this journal.
	Coordinator uint32 `protobuf:"varint,3,opt,name=coordinator,proto3" json:"coordinator,omitempty"`
	// Shuffle of this ShuffleConfig.
	Shuffle              Shuffle  `protobuf:"bytes,4,opt,name=shuffle,proto3" json:"shuffle"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShuffleConfig) Reset()         { *m = ShuffleConfig{} }
func (m *ShuffleConfig) String() string { return proto.CompactTextString(m) }
func (*ShuffleConfig) ProtoMessage()    {}
func (*ShuffleConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{4}
}
func (m *ShuffleConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShuffleConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShuffleConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShuffleConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShuffleConfig.Merge(m, src)
}
func (m *ShuffleConfig) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShuffleConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ShuffleConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ShuffleConfig proto.InternalMessageInfo

func (m *ShuffleConfig) GetJournal() go_gazette_dev_core_broker_protocol.Journal {
	if m != nil {
		return m.Journal
	}
	return ""
}

func (m *ShuffleConfig) GetRing() Ring {
	if m != nil {
		return m.Ring
	}
	return Ring{}
}

func (m *ShuffleConfig) GetCoordinator() uint32 {
	if m != nil {
		return m.Coordinator
	}
	return 0
}

func (m *ShuffleConfig) GetShuffle() Shuffle {
	if m != nil {
		return m.Shuffle
	}
	return Shuffle{}
}

// Transform describes a specific transform of a derived collection.
type TransformSpec struct {
	Source TransformSpec_Source `protobuf:"bytes,2,opt,name=source,proto3" json:"source"`
	// Shuffle applied to source documents for this transform.
	// Note that the Shuffle embeds the Transform name.
	Shuffle              Shuffle                  `protobuf:"bytes,3,opt,name=shuffle,proto3" json:"shuffle"`
	Derivation           TransformSpec_Derivation `protobuf:"bytes,5,opt,name=derivation,proto3" json:"derivation"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TransformSpec) Reset()         { *m = TransformSpec{} }
func (m *TransformSpec) String() string { return proto.CompactTextString(m) }
func (*TransformSpec) ProtoMessage()    {}
func (*TransformSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{5}
}
func (m *TransformSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransformSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransformSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransformSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransformSpec.Merge(m, src)
}
func (m *TransformSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransformSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TransformSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TransformSpec proto.InternalMessageInfo

func (m *TransformSpec) GetSource() TransformSpec_Source {
	if m != nil {
		return m.Source
	}
	return TransformSpec_Source{}
}

func (m *TransformSpec) GetShuffle() Shuffle {
	if m != nil {
		return m.Shuffle
	}
	return Shuffle{}
}

func (m *TransformSpec) GetDerivation() TransformSpec_Derivation {
	if m != nil {
		return m.Derivation
	}
	return TransformSpec_Derivation{}
}

// Source collection read by this transform.
type TransformSpec_Source struct {
	// Name of the collection.
	Name Collection `protobuf:"bytes,1,opt,name=name,proto3,casttype=Collection" json:"name,omitempty"`
	// Selector of partitions of the collection which this transform reads.
	Partitions           protocol.LabelSelector `protobuf:"bytes,2,opt,name=partitions,proto3" json:"partitions"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TransformSpec_Source) Reset()         { *m = TransformSpec_Source{} }
func (m *TransformSpec_Source) String() string { return proto.CompactTextString(m) }
func (*TransformSpec_Source) ProtoMessage()    {}
func (*TransformSpec_Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{5, 0}
}
func (m *TransformSpec_Source) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransformSpec_Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransformSpec_Source.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransformSpec_Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransformSpec_Source.Merge(m, src)
}
func (m *TransformSpec_Source) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransformSpec_Source) XXX_DiscardUnknown() {
	xxx_messageInfo_TransformSpec_Source.DiscardUnknown(m)
}

var xxx_messageInfo_TransformSpec_Source proto.InternalMessageInfo

func (m *TransformSpec_Source) GetName() Collection {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TransformSpec_Source) GetPartitions() protocol.LabelSelector {
	if m != nil {
		return m.Partitions
	}
	return protocol.LabelSelector{}
}

// Derived collection produced by this transform.
type TransformSpec_Derivation struct {
	Name                 Collection `protobuf:"bytes,1,opt,name=name,proto3,casttype=Collection" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TransformSpec_Derivation) Reset()         { *m = TransformSpec_Derivation{} }
func (m *TransformSpec_Derivation) String() string { return proto.CompactTextString(m) }
func (*TransformSpec_Derivation) ProtoMessage()    {}
func (*TransformSpec_Derivation) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{5, 1}
}
func (m *TransformSpec_Derivation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransformSpec_Derivation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransformSpec_Derivation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransformSpec_Derivation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransformSpec_Derivation.Merge(m, src)
}
func (m *TransformSpec_Derivation) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransformSpec_Derivation) XXX_DiscardUnknown() {
	xxx_messageInfo_TransformSpec_Derivation.DiscardUnknown(m)
}

var xxx_messageInfo_TransformSpec_Derivation proto.InternalMessageInfo

func (m *TransformSpec_Derivation) GetName() Collection {
	if m != nil {
		return m.Name
	}
	return ""
}

// Field holds a column of values extracted from a document location.
type Field struct {
	Values               []Field_Value `protobuf:"bytes,1,rep,name=values,proto3" json:"values"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Field) Reset()         { *m = Field{} }
func (m *Field) String() string { return proto.CompactTextString(m) }
func (*Field) ProtoMessage()    {}
func (*Field) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{6}
}
func (m *Field) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Field) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Field.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Field) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Field.Merge(m, src)
}
func (m *Field) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Field) XXX_DiscardUnknown() {
	xxx_messageInfo_Field.DiscardUnknown(m)
}

var xxx_messageInfo_Field proto.InternalMessageInfo

func (m *Field) GetValues() []Field_Value {
	if m != nil {
		return m.Values
	}
	return nil
}

// Value is the extracted representation of the field value.
type Field_Value struct {
	Kind                 Field_Value_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=flow.Field_Value_Kind" json:"kind,omitempty"`
	Unsigned             uint64           `protobuf:"varint,2,opt,name=unsigned,proto3" json:"unsigned,omitempty"`
	Signed               int64            `protobuf:"zigzag64,3,opt,name=signed,proto3" json:"signed,omitempty"`
	Double               float64          `protobuf:"fixed64,4,opt,name=double,proto3" json:"double,omitempty"`
	Bytes                Slice            `protobuf:"bytes,5,opt,name=bytes,proto3" json:"bytes"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Field_Value) Reset()         { *m = Field_Value{} }
func (m *Field_Value) String() string { return proto.CompactTextString(m) }
func (*Field_Value) ProtoMessage()    {}
func (*Field_Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{6, 0}
}
func (m *Field_Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Field_Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Field_Value.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Field_Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Field_Value.Merge(m, src)
}
func (m *Field_Value) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Field_Value) XXX_DiscardUnknown() {
	xxx_messageInfo_Field_Value.DiscardUnknown(m)
}

var xxx_messageInfo_Field_Value proto.InternalMessageInfo

func (m *Field_Value) GetKind() Field_Value_Kind {
	if m != nil {
		return m.Kind
	}
	return Field_Value_INVALID
}

func (m *Field_Value) GetUnsigned() uint64 {
	if m != nil {
		return m.Unsigned
	}
	return 0
}

func (m *Field_Value) GetSigned() int64 {
	if m != nil {
		return m.Signed
	}
	return 0
}

func (m *Field_Value) GetDouble() float64 {
	if m != nil {
		return m.Double
	}
	return 0
}

func (m *Field_Value) GetBytes() Slice {
	if m != nil {
		return m.Bytes
	}
	return Slice{}
}

// ShuffleRequest is the request message of a Shuffle RPC.
type ShuffleRequest struct {
	Config ShuffleConfig `protobuf:"bytes,1,opt,name=config,proto3" json:"config"`
	// Index of this member within the ring.
	RingIndex uint32 `protobuf:"varint,2,opt,name=ring_index,json=ringIndex,proto3" json:"ring_index,omitempty"`
	// Offset to begin reading the journal from.
	Offset go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,3,opt,name=offset,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"offset,omitempty"`
	// Offset to stop reading the journal at, or zero if unbounded.
	EndOffset go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,4,opt,name=end_offset,json=endOffset,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"end_offset,omitempty"`
	// Resolution header of the |config.coordinator_index| shard.
	Resolution           *protocol.Header `protobuf:"bytes,5,opt,name=resolution,proto3" json:"resolution,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ShuffleRequest) Reset()         { *m = ShuffleRequest{} }
func (m *ShuffleRequest) String() string { return proto.CompactTextString(m) }
func (*ShuffleRequest) ProtoMessage()    {}
func (*ShuffleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{7}
}
func (m *ShuffleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShuffleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShuffleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShuffleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShuffleRequest.Merge(m, src)
}
func (m *ShuffleRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShuffleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ShuffleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ShuffleRequest proto.InternalMessageInfo

func (m *ShuffleRequest) GetConfig() ShuffleConfig {
	if m != nil {
		return m.Config
	}
	return ShuffleConfig{}
}

func (m *ShuffleRequest) GetRingIndex() uint32 {
	if m != nil {
		return m.RingIndex
	}
	return 0
}

func (m *ShuffleRequest) GetOffset() go_gazette_dev_core_broker_protocol.Offset {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *ShuffleRequest) GetEndOffset() go_gazette_dev_core_broker_protocol.Offset {
	if m != nil {
		return m.EndOffset
	}
	return 0
}

func (m *ShuffleRequest) GetResolution() *protocol.Header {
	if m != nil {
		return m.Resolution
	}
	return nil
}

// ShuffleResponse is the streamed response message of a Shuffle RPC.
type ShuffleResponse struct {
	// Status of the Shuffle RPC.
	Status protocol1.Status `protobuf:"varint,1,opt,name=status,proto3,enum=consumer.Status" json:"status,omitempty"`
	// Header of the response.
	Header *protocol.Header `protobuf:"bytes,2,opt,name=header,proto3" json:"header,omitempty"`
	// Terminal error encountered while serving this ShuffleRequest. A terminal
	// error is only sent if a future ShuffleRequest of this same configuration
	// and offset will fail in the exact same way, and operator intervention is
	// required to properly recover. Such errors are returned so that the caller
	// can also abort with a useful, contextual error message.
	//
	// Examples of terminal errors include the requested journal not existing,
	// or data corruption. Errors *not* returned as |terminal_error| include
	// network errors, process failures, and other conditions which can be
	// retried.
	TerminalError string `protobuf:"bytes,3,opt,name=terminal_error,json=terminalError,proto3" json:"terminal_error,omitempty"`
	// Offset which was read through to produce this ShuffleResponse.
	ReadThrough go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,4,opt,name=read_through,json=readThrough,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"read_through,omitempty"`
	// WriteHead of the journal as reported by the broker, as of the creation of
	// this ShuffleResponse.
	WriteHead go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,5,opt,name=write_head,json=writeHead,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"write_head,omitempty"`
	// Memory arena of this message.
	Arena Arena `protobuf:"bytes,6,opt,name=arena,proto3,casttype=Arena" json:"arena,omitempty"`
	// Transform name, passed through from the ShuffleRequest.
	Transform Transform `protobuf:"bytes,7,opt,name=transform,proto3,casttype=Transform" json:"transform,omitempty"`
	// ContentType of documents in this ShuffleResponse.
	ContentType ContentType `protobuf:"varint,8,opt,name=content_type,json=contentType,proto3,enum=flow.ContentType" json:"content_type,omitempty"`
	// Content of documents included in this ShuffleResponse.
	Content []Slice `protobuf:"bytes,9,rep,name=content,proto3" json:"content"`
	// The begin offset of each document within the requested journal.
	Begin []go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,10,rep,packed,name=begin,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"begin,omitempty"`
	// The end offset of each document within the journal.
	End []go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,11,rep,packed,name=end,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"end,omitempty"`
	// UUIDParts of each document.
	UuidParts []UUIDParts `protobuf:"bytes,12,rep,name=uuid_parts,json=uuidParts,proto3" json:"uuid_parts"`
	// Extracted shuffle key of each document, with one Field for each
	// component of the composite shuffle key.
	ShuffleKey []Field `protobuf:"bytes,13,rep,name=shuffle_key,json=shuffleKey,proto3" json:"shuffle_key"`
	// Extracted unique hash of the document shuffle key (low 64-bits).
	ShuffleHashesLow []uint64 `protobuf:"fixed64,14,rep,packed,name=shuffle_hashes_low,json=shuffleHashesLow,proto3" json:"shuffle_hashes_low,omitempty"`
	// Extracted unique hash of the document shuffle key (high 64-bits).
	ShuffleHashesHigh    []uint64 `protobuf:"fixed64,15,rep,packed,name=shuffle_hashes_high,json=shuffleHashesHigh,proto3" json:"shuffle_hashes_high,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShuffleResponse) Reset()         { *m = ShuffleResponse{} }
func (m *ShuffleResponse) String() string { return proto.CompactTextString(m) }
func (*ShuffleResponse) ProtoMessage()    {}
func (*ShuffleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{8}
}
func (m *ShuffleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShuffleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShuffleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShuffleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShuffleResponse.Merge(m, src)
}
func (m *ShuffleResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShuffleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ShuffleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ShuffleResponse proto.InternalMessageInfo

func (m *ShuffleResponse) GetStatus() protocol1.Status {
	if m != nil {
		return m.Status
	}
	return protocol1.Status_OK
}

func (m *ShuffleResponse) GetHeader() *protocol.Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ShuffleResponse) GetTerminalError() string {
	if m != nil {
		return m.TerminalError
	}
	return ""
}

func (m *ShuffleResponse) GetReadThrough() go_gazette_dev_core_broker_protocol.Offset {
	if m != nil {
		return m.ReadThrough
	}
	return 0
}

func (m *ShuffleResponse) GetWriteHead() go_gazette_dev_core_broker_protocol.Offset {
	if m != nil {
		return m.WriteHead
	}
	return 0
}

func (m *ShuffleResponse) GetArena() Arena {
	if m != nil {
		return m.Arena
	}
	return nil
}

func (m *ShuffleResponse) GetTransform() Transform {
	if m != nil {
		return m.Transform
	}
	return ""
}

func (m *ShuffleResponse) GetContentType() ContentType {
	if m != nil {
		return m.ContentType
	}
	return ContentType_INVALID
}

func (m *ShuffleResponse) GetContent() []Slice {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *ShuffleResponse) GetBegin() []go_gazette_dev_core_broker_protocol.Offset {
	if m != nil {
		return m.Begin
	}
	return nil
}

func (m *ShuffleResponse) GetEnd() []go_gazette_dev_core_broker_protocol.Offset {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *ShuffleResponse) GetUuidParts() []UUIDParts {
	if m != nil {
		return m.UuidParts
	}
	return nil
}

func (m *ShuffleResponse) GetShuffleKey() []Field {
	if m != nil {
		return m.ShuffleKey
	}
	return nil
}

func (m *ShuffleResponse) GetShuffleHashesLow() []uint64 {
	if m != nil {
		return m.ShuffleHashesLow
	}
	return nil
}

func (m *ShuffleResponse) GetShuffleHashesHigh() []uint64 {
	if m != nil {
		return m.ShuffleHashesHigh
	}
	return nil
}

type ExtractRequest struct {
	// Memory arena of this message.
	Arena Arena `protobuf:"bytes,1,opt,name=arena,proto3,casttype=Arena" json:"arena,omitempty"`
	// ContentType of documents in this ExtractRequest.
	ContentType ContentType `protobuf:"varint,2,opt,name=content_type,json=contentType,proto3,enum=flow.ContentType" json:"content_type,omitempty"`
	// Content of documents included in this ExtractRequest.
	Content []Slice `protobuf:"bytes,3,rep,name=content,proto3" json:"content"`
	// JSON pointer of document UUID to extract.
	// If empty, UUIDParts are not extracted.
	UuidPtr string `protobuf:"bytes,4,opt,name=uuid_ptr,json=uuidPtr,proto3" json:"uuid_ptr,omitempty"`
	// Composite of JSON pointers to extract from documents and hash.
	// If empty, hashes are not extracted.
	HashPtrs []string `protobuf:"bytes,5,rep,name=hash_ptrs,json=hashPtrs,proto3" json:"hash_ptrs,omitempty"`
	// Field JSON pointers to extract from documents and return.
	// If empty, no fields are extracted.
	FieldPtrs            []string `protobuf:"bytes,6,rep,name=field_ptrs,json=fieldPtrs,proto3" json:"field_ptrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtractRequest) Reset()         { *m = ExtractRequest{} }
func (m *ExtractRequest) String() string { return proto.CompactTextString(m) }
func (*ExtractRequest) ProtoMessage()    {}
func (*ExtractRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{9}
}
func (m *ExtractRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtractRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtractRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtractRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtractRequest.Merge(m, src)
}
func (m *ExtractRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExtractRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtractRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExtractRequest proto.InternalMessageInfo

func (m *ExtractRequest) GetArena() Arena {
	if m != nil {
		return m.Arena
	}
	return nil
}

func (m *ExtractRequest) GetContentType() ContentType {
	if m != nil {
		return m.ContentType
	}
	return ContentType_INVALID
}

func (m *ExtractRequest) GetContent() []Slice {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *ExtractRequest) GetUuidPtr() string {
	if m != nil {
		return m.UuidPtr
	}
	return ""
}

func (m *ExtractRequest) GetHashPtrs() []string {
	if m != nil {
		return m.HashPtrs
	}
	return nil
}

func (m *ExtractRequest) GetFieldPtrs() []string {
	if m != nil {
		return m.FieldPtrs
	}
	return nil
}

type ExtractResponse struct {
	// Memory arena of this message.
	Arena Arena `protobuf:"bytes,1,opt,name=arena,proto3,casttype=Arena" json:"arena,omitempty"`
	// UUIDParts extracted from request Documents.
	UuidParts []UUIDParts `protobuf:"bytes,2,rep,name=uuid_parts,json=uuidParts,proto3" json:"uuid_parts"`
	// Hashes extracted from request Documents (low 64-bits).
	// If the request |hash_ptrs| was empty, so are these.
	HashesLow []uint64 `protobuf:"fixed64,3,rep,packed,name=hashes_low,json=hashesLow,proto3" json:"hashes_low,omitempty"`
	// Hashes extracted from request Documents (high 64-bits).
	HashesHigh []uint64 `protobuf:"fixed64,4,rep,packed,name=hashes_high,json=hashesHigh,proto3" json:"hashes_high,omitempty"`
	// Fields extracted from request Documents, one column per request pointer.
	Fields               []Field  `protobuf:"bytes,5,rep,name=fields,proto3" json:"fields"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtractResponse) Reset()         { *m = ExtractResponse{} }
func (m *ExtractResponse) String() string { return proto.CompactTextString(m) }
func (*ExtractResponse) ProtoMessage()    {}
func (*ExtractResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{10}
}
func (m *ExtractResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtractResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtractResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtractResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtractResponse.Merge(m, src)
}
func (m *ExtractResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExtractResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtractResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExtractResponse proto.InternalMessageInfo

func (m *ExtractResponse) GetArena() Arena {
	if m != nil {
		return m.Arena
	}
	return nil
}

func (m *ExtractResponse) GetUuidParts() []UUIDParts {
	if m != nil {
		return m.UuidParts
	}
	return nil
}

func (m *ExtractResponse) GetHashesLow() []uint64 {
	if m != nil {
		return m.HashesLow
	}
	return nil
}

func (m *ExtractResponse) GetHashesHigh() []uint64 {
	if m != nil {
		return m.HashesHigh
	}
	return nil
}

func (m *ExtractResponse) GetFields() []Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

type CombineRequest struct {
	// Memory arena of this message.
	Arena Arena `protobuf:"bytes,1,opt,name=arena,proto3,casttype=Arena" json:"arena,omitempty"`
	// ContentType of documents in this CombineRequest.
	ContentType ContentType `protobuf:"varint,2,opt,name=content_type,json=contentType,proto3,enum=flow.ContentType" json:"content_type,omitempty"`
	// Content of documents included in this CombineRequest.
	Content []Slice `protobuf:"bytes,3,rep,name=content,proto3" json:"content"`
	// ContentType of documents in the returned CombineResponse.
	Accept ContentType `protobuf:"varint,4,opt,name=accept,proto3,enum=flow.ContentType" json:"accept,omitempty"`
	// Schema against which documents are to be validated,
	// and which provides reduction annotations.
	SchemaUri string `protobuf:"bytes,5,opt,name=schema_uri,json=schemaUri,proto3" json:"schema_uri,omitempty"`
	// Composite key used to group documents to be combined, specified as one or
	// more JSON-Pointers indicating a message location to extract.
	KeyPtr []string `protobuf:"bytes,6,rep,name=key_ptr,json=keyPtr,proto3" json:"key_ptr,omitempty"`
	// Field JSON pointers to be extracted from combined documents and returned.
	// If empty, no fields are extracted.
	FieldPtrs            []string `protobuf:"bytes,7,rep,name=field_ptrs,json=fieldPtrs,proto3" json:"field_ptrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CombineRequest) Reset()         { *m = CombineRequest{} }
func (m *CombineRequest) String() string { return proto.CompactTextString(m) }
func (*CombineRequest) ProtoMessage()    {}
func (*CombineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{11}
}
func (m *CombineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombineRequest.Merge(m, src)
}
func (m *CombineRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CombineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CombineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CombineRequest proto.InternalMessageInfo

func (m *CombineRequest) GetArena() Arena {
	if m != nil {
		return m.Arena
	}
	return nil
}

func (m *CombineRequest) GetContentType() ContentType {
	if m != nil {
		return m.ContentType
	}
	return ContentType_INVALID
}

func (m *CombineRequest) GetContent() []Slice {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *CombineRequest) GetAccept() ContentType {
	if m != nil {
		return m.Accept
	}
	return ContentType_INVALID
}

func (m *CombineRequest) GetSchemaUri() string {
	if m != nil {
		return m.SchemaUri
	}
	return ""
}

func (m *CombineRequest) GetKeyPtr() []string {
	if m != nil {
		return m.KeyPtr
	}
	return nil
}

func (m *CombineRequest) GetFieldPtrs() []string {
	if m != nil {
		return m.FieldPtrs
	}
	return nil
}

type CombineResponse struct {
	// Memory arena of this message.
	Arena Arena `protobuf:"bytes,1,opt,name=arena,proto3,casttype=Arena" json:"arena,omitempty"`
	// Content of documents included in this CombineResponse.
	// ContentType is that of the CombineRequest's |accept| field.
	Content []Slice `protobuf:"bytes,3,rep,name=content,proto3" json:"content"`
	// Fields extracted from request Documents, one column per request pointer.
	Fields               []Field  `protobuf:"bytes,4,rep,name=fields,proto3" json:"fields"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CombineResponse) Reset()         { *m = CombineResponse{} }
func (m *CombineResponse) String() string { return proto.CompactTextString(m) }
func (*CombineResponse) ProtoMessage()    {}
func (*CombineResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{12}
}
func (m *CombineResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombineResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombineResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombineResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombineResponse.Merge(m, src)
}
func (m *CombineResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CombineResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CombineResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CombineResponse proto.InternalMessageInfo

func (m *CombineResponse) GetArena() Arena {
	if m != nil {
		return m.Arena
	}
	return nil
}

func (m *CombineResponse) GetContent() []Slice {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *CombineResponse) GetFields() []Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

// DeriveRequest is the streamed union type message of a Derive RPC.
type DeriveRequest struct {
	// Types that are valid to be assigned to Kind:
	//	*DeriveRequest_Open_
	//	*DeriveRequest_Extend_
	//	*DeriveRequest_Flush_
	//	*DeriveRequest_Prepare_
	//	*DeriveRequest_Commit_
	Kind                 isDeriveRequest_Kind `protobuf_oneof:"kind"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *DeriveRequest) Reset()         { *m = DeriveRequest{} }
func (m *DeriveRequest) String() string { return proto.CompactTextString(m) }
func (*DeriveRequest) ProtoMessage()    {}
func (*DeriveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{13}
}
func (m *DeriveRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveRequest.Merge(m, src)
}
func (m *DeriveRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveRequest proto.InternalMessageInfo

type isDeriveRequest_Kind interface {
	isDeriveRequest_Kind()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type DeriveRequest_Open_ struct {
	Open *DeriveRequest_Open `protobuf:"bytes,1,opt,name=open,proto3,oneof" json:"open,omitempty"`
}
type DeriveRequest_Extend_ struct {
	Extend *DeriveRequest_Extend `protobuf:"bytes,2,opt,name=extend,proto3,oneof" json:"extend,omitempty"`
}
type DeriveRequest_Flush_ struct {
	Flush *DeriveRequest_Flush `protobuf:"bytes,3,opt,name=flush,proto3,oneof" json:"flush,omitempty"`
}
type DeriveRequest_Prepare_ struct {
	Prepare *DeriveRequest_Prepare `protobuf:"bytes,4,opt,name=prepare,proto3,oneof" json:"prepare,omitempty"`
}
type DeriveRequest_Commit_ struct {
	Commit *DeriveRequest_Commit `protobuf:"bytes,5,opt,name=commit,proto3,oneof" json:"commit,omitempty"`
}

func (*DeriveRequest_Open_) isDeriveRequest_Kind()    {}
func (*DeriveRequest_Extend_) isDeriveRequest_Kind()  {}
func (*DeriveRequest_Flush_) isDeriveRequest_Kind()   {}
func (*DeriveRequest_Prepare_) isDeriveRequest_Kind() {}
func (*DeriveRequest_Commit_) isDeriveRequest_Kind()  {}

func (m *DeriveRequest) GetKind() isDeriveRequest_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *DeriveRequest) GetOpen() *DeriveRequest_Open {
	if x, ok := m.GetKind().(*DeriveRequest_Open_); ok {
		return x.Open
	}
	return nil
}

func (m *DeriveRequest) GetExtend() *DeriveRequest_Extend {
	if x, ok := m.GetKind().(*DeriveRequest_Extend_); ok {
		return x.Extend
	}
	return nil
}

func (m *DeriveRequest) GetFlush() *DeriveRequest_Flush {
	if x, ok := m.GetKind().(*DeriveRequest_Flush_); ok {
		return x.Flush
	}
	return nil
}

func (m *DeriveRequest) GetPrepare() *DeriveRequest_Prepare {
	if x, ok := m.GetKind().(*DeriveRequest_Prepare_); ok {
		return x.Prepare
	}
	return nil
}

func (m *DeriveRequest) GetCommit() *DeriveRequest_Commit {
	if x, ok := m.GetKind().(*DeriveRequest_Commit_); ok {
		return x.Commit
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DeriveRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DeriveRequest_Open_)(nil),
		(*DeriveRequest_Extend_)(nil),
		(*DeriveRequest_Flush_)(nil),
		(*DeriveRequest_Prepare_)(nil),
		(*DeriveRequest_Commit_)(nil),
	}
}

// OPEN is sent (only) as the first message of a Derive RPC,
// and opens the derive transaction.
type DeriveRequest_Open struct {
	// Collection to be derived.
	Collection Collection `protobuf:"bytes,1,opt,name=collection,proto3,casttype=Collection" json:"collection,omitempty"`
	// ContentType of documents in the returned DeriveResponse.
	Accept               ContentType `protobuf:"varint,2,opt,name=accept,proto3,enum=flow.ContentType" json:"accept,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DeriveRequest_Open) Reset()         { *m = DeriveRequest_Open{} }
func (m *DeriveRequest_Open) String() string { return proto.CompactTextString(m) }
func (*DeriveRequest_Open) ProtoMessage()    {}
func (*DeriveRequest_Open) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{13, 0}
}
func (m *DeriveRequest_Open) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveRequest_Open) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveRequest_Open.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveRequest_Open) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveRequest_Open.Merge(m, src)
}
func (m *DeriveRequest_Open) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveRequest_Open) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveRequest_Open.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveRequest_Open proto.InternalMessageInfo

func (m *DeriveRequest_Open) GetCollection() Collection {
	if m != nil {
		return m.Collection
	}
	return ""
}

func (m *DeriveRequest_Open) GetAccept() ContentType {
	if m != nil {
		return m.Accept
	}
	return ContentType_INVALID
}

// EXTEND extends the derive transaction with additional
// source collection documents.
//
// * The flow consumer sends any number of EXTEND DeriveRequests,
//   containing source collection documents.
// * Concurrently, the derive worker responds with any number of
//   EXTEND DeriveResponses, each having documents to be added to
//   the collection being derived.
// * The flow consumer is responsible for publishing each derived
//   document to the appropriate collection & partition.
// * Note that DeriveRequest and DeriveResponse EXTEND messages are _not_ 1:1.
//
// EXTEND transitions to EXTEND or FLUSH.
type DeriveRequest_Extend struct {
	// Transform to which documents are applied.
	Transform Transform `protobuf:"bytes,1,opt,name=transform,proto3,casttype=Transform" json:"transform,omitempty"`
	// Memory arena of this message.
	Arena Arena `protobuf:"bytes,2,opt,name=arena,proto3,casttype=Arena" json:"arena,omitempty"`
	// ContentType of documents.
	ContentType ContentType `protobuf:"varint,3,opt,name=content_type,json=contentType,proto3,enum=flow.ContentType" json:"content_type,omitempty"`
	// Content of documents.
	Content              []Slice  `protobuf:"bytes,4,rep,name=content,proto3" json:"content"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveRequest_Extend) Reset()         { *m = DeriveRequest_Extend{} }
func (m *DeriveRequest_Extend) String() string { return proto.CompactTextString(m) }
func (*DeriveRequest_Extend) ProtoMessage()    {}
func (*DeriveRequest_Extend) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{13, 1}
}
func (m *DeriveRequest_Extend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveRequest_Extend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveRequest_Extend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveRequest_Extend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveRequest_Extend.Merge(m, src)
}
func (m *DeriveRequest_Extend) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveRequest_Extend) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveRequest_Extend.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveRequest_Extend proto.InternalMessageInfo

func (m *DeriveRequest_Extend) GetTransform() Transform {
	if m != nil {
		return m.Transform
	}
	return ""
}

func (m *DeriveRequest_Extend) GetArena() Arena {
	if m != nil {
		return m.Arena
	}
	return nil
}

func (m *DeriveRequest_Extend) GetContentType() ContentType {
	if m != nil {
		return m.ContentType
	}
	return ContentType_INVALID
}

func (m *DeriveRequest_Extend) GetContent() []Slice {
	if m != nil {
		return m.Content
	}
	return nil
}

// FLUSH indicates the transacton pipeline is to flush.
//
// * The flow consumer issues FLUSH when its consumer transaction begins to
//   close.
// * The derive worker responds with FLUSH to indicate that all source
//   documents have been processed and all derived documents emitted.
// * The flow consumer awaits the response FLUSH, while continuing to begin
//   publish operations for all derived documents seen in the meantime.
// * On seeing FLUSH, the flow consumer is assured it's sequenced and started
//   publishing all derived documents of the transaction, and can now build
//   the consumer.Checkpoint which will be committed to the store.
//
// FLUSH transitions to PREPARE.
type DeriveRequest_Flush struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveRequest_Flush) Reset()         { *m = DeriveRequest_Flush{} }
func (m *DeriveRequest_Flush) String() string { return proto.CompactTextString(m) }
func (*DeriveRequest_Flush) ProtoMessage()    {}
func (*DeriveRequest_Flush) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{13, 2}
}
func (m *DeriveRequest_Flush) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveRequest_Flush) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveRequest_Flush.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveRequest_Flush) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveRequest_Flush.Merge(m, src)
}
func (m *DeriveRequest_Flush) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveRequest_Flush) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveRequest_Flush.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveRequest_Flush proto.InternalMessageInfo

// PREPARE begins a commit of the transaction.
//
// * The flow consumer sends PREPARE with its consumer.Checkpoint.
// * On receipt, the derive worker queues an atomic recoverylog.Recorder
//   block that's conditioned on an (unresolved) "commit" future. Within
//   this recording block, underlying store commits (SQLite COMMIT and writing
//   a RocksDB WriteBatch) are issued to persist all state changes of the
//   transaction, along with the consumer.Checkpoint.
// * The derive worker responds with PREPARE once all local commits have
//   completed, and recoverylog writes have been queued (but not started,
//   awaiting COMMIT).
// * On receipt, the flow consumer arranges to invoke COMMIT on the completion
//   of all outstanding journal writes -- this the OpFuture passed to the
//   Store.StartCommit interface. It returns a future which will resolve only
//   after reading COMMIT from this transaction -- the OpFuture returned by
//   that interface.
//
// It's an error if a prior transaction is still running at the onset of
// PREPARE. However at the completion of PREPARE, a new & concurrent
// Transaction may begin, though it itself cannot PREPARE until this
// Transaction fully completes.
//
// PREPARE transitions to COMMIT.
type DeriveRequest_Prepare struct {
	// Checkpoint to commit.
	Checkpoint           protocol1.Checkpoint `protobuf:"bytes,1,opt,name=checkpoint,proto3" json:"checkpoint"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *DeriveRequest_Prepare) Reset()         { *m = DeriveRequest_Prepare{} }
func (m *DeriveRequest_Prepare) String() string { return proto.CompactTextString(m) }
func (*DeriveRequest_Prepare) ProtoMessage()    {}
func (*DeriveRequest_Prepare) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{13, 3}
}
func (m *DeriveRequest_Prepare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveRequest_Prepare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveRequest_Prepare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveRequest_Prepare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveRequest_Prepare.Merge(m, src)
}
func (m *DeriveRequest_Prepare) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveRequest_Prepare) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveRequest_Prepare.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveRequest_Prepare proto.InternalMessageInfo

func (m *DeriveRequest_Prepare) GetCheckpoint() protocol1.Checkpoint {
	if m != nil {
		return m.Checkpoint
	}
	return protocol1.Checkpoint{}
}

// COMMIT commits the transaction by resolving the "commit" future created
// during PREPARE, allowing the atomic commit block created in PREPARE
// to flush to the recovery log. The derive worker responds with COMMIT
// when the commit barrier has fully resolved.
//
// COMMIT transitions to stream close.
type DeriveRequest_Commit struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveRequest_Commit) Reset()         { *m = DeriveRequest_Commit{} }
func (m *DeriveRequest_Commit) String() string { return proto.CompactTextString(m) }
func (*DeriveRequest_Commit) ProtoMessage()    {}
func (*DeriveRequest_Commit) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{13, 4}
}
func (m *DeriveRequest_Commit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveRequest_Commit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveRequest_Commit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveRequest_Commit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveRequest_Commit.Merge(m, src)
}
func (m *DeriveRequest_Commit) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveRequest_Commit) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveRequest_Commit.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveRequest_Commit proto.InternalMessageInfo

// DeriveResponse is the streamed response message of a Derive RPC.
type DeriveResponse struct {
	// Types that are valid to be assigned to Kind:
	//	*DeriveResponse_Extend_
	//	*DeriveResponse_Flush_
	//	*DeriveResponse_Prepare_
	//	*DeriveResponse_Commit_
	Kind                 isDeriveResponse_Kind `protobuf_oneof:"kind"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *DeriveResponse) Reset()         { *m = DeriveResponse{} }
func (m *DeriveResponse) String() string { return proto.CompactTextString(m) }
func (*DeriveResponse) ProtoMessage()    {}
func (*DeriveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{14}
}
func (m *DeriveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveResponse.Merge(m, src)
}
func (m *DeriveResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveResponse proto.InternalMessageInfo

type isDeriveResponse_Kind interface {
	isDeriveResponse_Kind()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type DeriveResponse_Extend_ struct {
	Extend *DeriveResponse_Extend `protobuf:"bytes,2,opt,name=extend,proto3,oneof" json:"extend,omitempty"`
}
type DeriveResponse_Flush_ struct {
	Flush *DeriveResponse_Flush `protobuf:"bytes,3,opt,name=flush,proto3,oneof" json:"flush,omitempty"`
}
type DeriveResponse_Prepare_ struct {
	Prepare *DeriveResponse_Prepare `protobuf:"bytes,4,opt,name=prepare,proto3,oneof" json:"prepare,omitempty"`
}
type DeriveResponse_Commit_ struct {
	Commit *DeriveResponse_Commit `protobuf:"bytes,5,opt,name=commit,proto3,oneof" json:"commit,omitempty"`
}

func (*DeriveResponse_Extend_) isDeriveResponse_Kind()  {}
func (*DeriveResponse_Flush_) isDeriveResponse_Kind()   {}
func (*DeriveResponse_Prepare_) isDeriveResponse_Kind() {}
func (*DeriveResponse_Commit_) isDeriveResponse_Kind()  {}

func (m *DeriveResponse) GetKind() isDeriveResponse_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *DeriveResponse) GetExtend() *DeriveResponse_Extend {
	if x, ok := m.GetKind().(*DeriveResponse_Extend_); ok {
		return x.Extend
	}
	return nil
}

func (m *DeriveResponse) GetFlush() *DeriveResponse_Flush {
	if x, ok := m.GetKind().(*DeriveResponse_Flush_); ok {
		return x.Flush
	}
	return nil
}

func (m *DeriveResponse) GetPrepare() *DeriveResponse_Prepare {
	if x, ok := m.GetKind().(*DeriveResponse_Prepare_); ok {
		return x.Prepare
	}
	return nil
}

func (m *DeriveResponse) GetCommit() *DeriveResponse_Commit {
	if x, ok := m.GetKind().(*DeriveResponse_Commit_); ok {
		return x.Commit
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DeriveResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DeriveResponse_Extend_)(nil),
		(*DeriveResponse_Flush_)(nil),
		(*DeriveResponse_Prepare_)(nil),
		(*DeriveResponse_Commit_)(nil),
	}
}

// EXTEND extends the derive transaction with additional derived collection
// documents.
type DeriveResponse_Extend struct {
	// Memory arena of this message.
	Arena Arena `protobuf:"bytes,1,opt,name=arena,proto3,casttype=Arena" json:"arena,omitempty"`
	// Content of documents. ContentType is as specified by
	// DeriveRequest.Open.accept.
	Content []Slice `protobuf:"bytes,2,rep,name=content,proto3" json:"content"`
	// Logical partitions extracted from |documents|.
	Partitions           []Field  `protobuf:"bytes,3,rep,name=partitions,proto3" json:"partitions"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveResponse_Extend) Reset()         { *m = DeriveResponse_Extend{} }
func (m *DeriveResponse_Extend) String() string { return proto.CompactTextString(m) }
func (*DeriveResponse_Extend) ProtoMessage()    {}
func (*DeriveResponse_Extend) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{14, 0}
}
func (m *DeriveResponse_Extend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveResponse_Extend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveResponse_Extend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveResponse_Extend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveResponse_Extend.Merge(m, src)
}
func (m *DeriveResponse_Extend) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveResponse_Extend) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveResponse_Extend.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveResponse_Extend proto.InternalMessageInfo

func (m *DeriveResponse_Extend) GetArena() Arena {
	if m != nil {
		return m.Arena
	}
	return nil
}

func (m *DeriveResponse_Extend) GetContent() []Slice {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *DeriveResponse_Extend) GetPartitions() []Field {
	if m != nil {
		return m.Partitions
	}
	return nil
}

// FLUSH is sent in response to a DeriveRequest.Flush, only after all
// request documents have been processed and response Extend messages sent.
type DeriveResponse_Flush struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveResponse_Flush) Reset()         { *m = DeriveResponse_Flush{} }
func (m *DeriveResponse_Flush) String() string { return proto.CompactTextString(m) }
func (*DeriveResponse_Flush) ProtoMessage()    {}
func (*DeriveResponse_Flush) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{14, 1}
}
func (m *DeriveResponse_Flush) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveResponse_Flush) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveResponse_Flush.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveResponse_Flush) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveResponse_Flush.Merge(m, src)
}
func (m *DeriveResponse_Flush) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveResponse_Flush) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveResponse_Flush.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveResponse_Flush proto.InternalMessageInfo

// PREPARE is sent in response to a DeriveRequest.Prepare, only after local
// store updates for commit (including the provided checkpoint) have been
// staged behind a created, unresolved commit barrier.
type DeriveResponse_Prepare struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveResponse_Prepare) Reset()         { *m = DeriveResponse_Prepare{} }
func (m *DeriveResponse_Prepare) String() string { return proto.CompactTextString(m) }
func (*DeriveResponse_Prepare) ProtoMessage()    {}
func (*DeriveResponse_Prepare) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{14, 2}
}
func (m *DeriveResponse_Prepare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveResponse_Prepare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveResponse_Prepare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveResponse_Prepare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveResponse_Prepare.Merge(m, src)
}
func (m *DeriveResponse_Prepare) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveResponse_Prepare) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveResponse_Prepare.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveResponse_Prepare proto.InternalMessageInfo

// COMMIT is sent in response to a DeriveRequest.Commit, when the
// commit barrier has resolved (meaning the transaction is committed).
type DeriveResponse_Commit struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveResponse_Commit) Reset()         { *m = DeriveResponse_Commit{} }
func (m *DeriveResponse_Commit) String() string { return proto.CompactTextString(m) }
func (*DeriveResponse_Commit) ProtoMessage()    {}
func (*DeriveResponse_Commit) Descriptor() ([]byte, []int) {
	return fileDescriptor_9dd0e7f3bbc7f41f, []int{14, 3}
}
func (m *DeriveResponse_Commit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveResponse_Commit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveResponse_Commit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveResponse_Commit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveResponse_Commit.Merge(m, src)
}
func (m *DeriveResponse_Commit) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveResponse_Commit) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveResponse_Commit.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveResponse_Commit proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("flow.ContentType", ContentType_name, ContentType_value)
	proto.RegisterEnum("flow.Field_Value_Kind", Field_Value_Kind_name, Field_Value_Kind_value)
	proto.RegisterType((*Slice)(nil), "flow.Slice")
	proto.RegisterType((*UUIDParts)(nil), "flow.UUIDParts")
	proto.RegisterType((*Shuffle)(nil), "flow.Shuffle")
	proto.RegisterType((*Ring)(nil), "flow.Ring")
	proto.RegisterType((*Ring_Member)(nil), "flow.Ring.Member")
	proto.RegisterType((*ShuffleConfig)(nil), "flow.ShuffleConfig")
	proto.RegisterType((*TransformSpec)(nil), "flow.TransformSpec")
	proto.RegisterType((*TransformSpec_Source)(nil), "flow.TransformSpec.Source")
	proto.RegisterType((*TransformSpec_Derivation)(nil), "flow.TransformSpec.Derivation")
	proto.RegisterType((*Field)(nil), "flow.Field")
	proto.RegisterType((*Field_Value)(nil), "flow.Field.Value")
	proto.RegisterType((*ShuffleRequest)(nil), "flow.ShuffleRequest")
	proto.RegisterType((*ShuffleResponse)(nil), "flow.ShuffleResponse")
	proto.RegisterType((*ExtractRequest)(nil), "flow.ExtractRequest")
	proto.RegisterType((*ExtractResponse)(nil), "flow.ExtractResponse")
	proto.RegisterType((*CombineRequest)(nil), "flow.CombineRequest")
	proto.RegisterType((*CombineResponse)(nil), "flow.CombineResponse")
	proto.RegisterType((*DeriveRequest)(nil), "flow.DeriveRequest")
	proto.RegisterType((*DeriveRequest_Open)(nil), "flow.DeriveRequest.Open")
	proto.RegisterType((*DeriveRequest_Extend)(nil), "flow.DeriveRequest.Extend")
	proto.RegisterType((*DeriveRequest_Flush)(nil), "flow.DeriveRequest.Flush")
	proto.RegisterType((*DeriveRequest_Prepare)(nil), "flow.DeriveRequest.Prepare")
	proto.RegisterType((*DeriveRequest_Commit)(nil), "flow.DeriveRequest.Commit")
	proto.RegisterType((*DeriveResponse)(nil), "flow.DeriveResponse")
	proto.RegisterType((*DeriveResponse_Extend)(nil), "flow.DeriveResponse.Extend")
	proto.RegisterType((*DeriveResponse_Flush)(nil), "flow.DeriveResponse.Flush")
	proto.RegisterType((*DeriveResponse_Prepare)(nil), "flow.DeriveResponse.Prepare")
	proto.RegisterType((*DeriveResponse_Commit)(nil), "flow.DeriveResponse.Commit")
}

func init() { proto.RegisterFile("go/protocol/flow.proto", fileDescriptor_9dd0e7f3bbc7f41f) }

var fileDescriptor_9dd0e7f3bbc7f41f = []byte{
	// 1989 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x4f, 0x6f, 0xe3, 0xd6,
	0x11, 0x37, 0x25, 0x8a, 0x12, 0x47, 0x96, 0xad, 0xbc, 0x75, 0x36, 0x8a, 0xd2, 0x58, 0x8e, 0x90,
	0xa4, 0xce, 0x6e, 0x4b, 0xef, 0xaa, 0x9b, 0x26, 0xd8, 0x20, 0x40, 0x2d, 0x5b, 0x8e, 0xbd, 0xf1,
	0xda, 0x5b, 0xca, 0x0e, 0xd0, 0x5e, 0x08, 0x8a, 0x7c, 0xa2, 0x58, 0x53, 0x7c, 0xea, 0x23, 0xb5,
	0x6b, 0xb7, 0x5f, 0xa0, 0xed, 0xa9, 0xa7, 0x22, 0xa7, 0x22, 0x0d, 0xda, 0x73, 0xd1, 0x63, 0x8f,
	0xbd, 0xe5, 0x18, 0xa0, 0x40, 0x7b, 0xaa, 0x51, 0xa4, 0x97, 0x02, 0xfd, 0x06, 0x3e, 0x15, 0xef,
	0x0f, 0x29, 0x4a, 0xd6, 0xd6, 0x7f, 0x4e, 0xbd, 0x08, 0x8f, 0x33, 0xbf, 0x19, 0xce, 0x9b, 0xdf,
	0xbc, 0x79, 0x43, 0xc1, 0x5d, 0x8f, 0x6c, 0x8c, 0x28, 0x89, 0x89, 0x43, 0x82, 0x8d, 0x7e, 0x40,
	0x5e, 0x18, 0xfc, 0x09, 0xa9, 0x6c, 0x5d, 0x5f, 0xed, 0x51, 0x72, 0x82, 0xe9, 0x04, 0x91, 0x2c,
	0x04, 0xaa, 0xbe, 0xe6, 0x90, 0x30, 0x1a, 0x0f, 0xff, 0x07, 0xe2, 0xdd, 0x14, 0x41, 0xb1, 0x43,
	0x9e, 0x63, 0x7a, 0x16, 0x10, 0x8f, 0xaf, 0xa9, 0x8b, 0x5d, 0x8b, 0x8c, 0x24, 0xae, 0x36, 0x8a,
	0xcf, 0x46, 0x38, 0xda, 0xc0, 0xc3, 0x51, 0x7c, 0x26, 0x7e, 0xa5, 0x66, 0xc5, 0x23, 0x1e, 0xe1,
	0xcb, 0x0d, 0xb6, 0x12, 0xd2, 0xe6, 0xc7, 0x50, 0xe8, 0x06, 0xbe, 0x83, 0xd1, 0x0a, 0x14, 0x7a,
	0xd8, 0xf3, 0xc3, 0x9a, 0xb2, 0xa6, 0xac, 0x57, 0x4c, 0xf1, 0x80, 0xaa, 0x90, 0xc7, 0xa1, 0x5b,
	0xcb, 0x71, 0x19, 0x5b, 0x3e, 0x5e, 0xfc, 0xfa, 0x77, 0x8d, 0x85, 0x5f, 0x7f, 0xd9, 0x58, 0xf8,
	0xfc, 0xcb, 0xc6, 0x42, 0xf3, 0x17, 0x0a, 0xe8, 0xc7, 0xc7, 0x7b, 0xdb, 0xcf, 0x6c, 0x1a, 0x47,
	0xe8, 0x3b, 0x80, 0x46, 0x94, 0xb8, 0x63, 0x07, 0x53, 0xcb, 0x0e, 0x5d, 0xab, 0x1f, 0xd8, 0x5e,
	0xc4, 0x1d, 0x6a, 0x66, 0x35, 0xd1, 0x6c, 0x86, 0xee, 0x0e, 0x93, 0xa3, 0x8f, 0xa0, 0xe0, 0x04,
	0xc4, 0x39, 0xe1, 0xde, 0xb5, 0xf6, 0x3b, 0x17, 0xe7, 0x8d, 0xb7, 0x3c, 0x62, 0x78, 0xf6, 0xcf,
	0x70, 0x1c, 0x63, 0xc3, 0xc5, 0xcf, 0x37, 0x1c, 0x42, 0xf1, 0xc6, 0x10, 0x47, 0x91, 0xed, 0x61,
	0x63, 0x8b, 0x81, 0x4d, 0x61, 0xf3, 0xb8, 0xfa, 0xef, 0x2f, 0x1a, 0xca, 0x54, 0x28, 0x7f, 0x53,
	0xa0, 0xd8, 0x1d, 0x8c, 0xfb, 0xfd, 0x00, 0xa3, 0xfb, 0xa0, 0xc7, 0xd4, 0x0e, 0xa3, 0x3e, 0xa1,
	0x43, 0xfe, 0x7e, 0xbd, 0x5d, 0xb9, 0x38, 0x6f, 0xe8, 0x47, 0x89, 0xd0, 0x9c, 0xe8, 0xd1, 0xbb,
	0xb0, 0x1c, 0x09, 0x3b, 0xeb, 0x04, 0x9f, 0x59, 0xa3, 0x98, 0xd6, 0x72, 0x6b, 0xf9, 0x75, 0xdd,
	0xac, 0x48, 0xf1, 0xa7, 0xf8, 0xec, 0x59, 0x4c, 0xd1, 0x5b, 0xb0, 0xd8, 0xa3, 0xc4, 0x76, 0x1d,
	0x3b, 0x8a, 0xad, 0x98, 0xd4, 0xf2, 0x3c, 0x29, 0xe5, 0x54, 0x76, 0x44, 0x50, 0x03, 0xca, 0xce,
	0x80, 0x90, 0x08, 0x5b, 0x7d, 0x4a, 0x86, 0x35, 0x95, 0x23, 0x40, 0x88, 0x76, 0x28, 0x19, 0xb2,
	0x0c, 0x51, 0x6c, 0xbb, 0x96, 0x8b, 0x03, 0xfb, 0xcc, 0x8a, 0xb0, 0x43, 0x42, 0x37, 0xaa, 0x15,
	0x38, 0xae, 0xca, 0x34, 0xdb, 0x4c, 0xd1, 0x15, 0xf2, 0xc7, 0x2a, 0xdb, 0x64, 0xf3, 0x42, 0x01,
	0xd5, 0xf4, 0x43, 0x0f, 0x21, 0x50, 0x43, 0x7b, 0x88, 0xc5, 0x86, 0x4c, 0xbe, 0x46, 0x0f, 0xa1,
	0x38, 0xc4, 0xc3, 0x1e, 0xa6, 0x11, 0x0f, 0xba, 0xdc, 0x7a, 0xc5, 0xe0, 0xd5, 0xc7, 0x0c, 0x8c,
	0xa7, 0x5c, 0xd3, 0x56, 0xbf, 0x3a, 0x6f, 0x2c, 0x98, 0x09, 0xae, 0xfe, 0x7b, 0x05, 0x34, 0xa1,
	0x41, 0x7b, 0x50, 0x19, 0xfa, 0xa1, 0x35, 0x8c, 0x3c, 0x4b, 0x50, 0xc1, 0x5c, 0xab, 0xd7, 0xa5,
	0xa2, 0x3c, 0xf4, 0xc3, 0xa7, 0x91, 0xc7, 0x1f, 0xb8, 0x2b, 0xfb, 0x34, 0xe3, 0x2a, 0x77, 0x33,
	0x57, 0xf6, 0x69, 0xe2, 0x4a, 0x6c, 0x5b, 0x6e, 0xfe, 0xef, 0x0a, 0x54, 0x24, 0xab, 0x5b, 0x24,
	0xec, 0xfb, 0x1e, 0xda, 0x83, 0xe2, 0x4f, 0xc8, 0x98, 0x86, 0x76, 0x20, 0x99, 0xdd, 0xb8, 0x38,
	0x6f, 0xdc, 0x9f, 0xf7, 0x8a, 0x99, 0x43, 0x67, 0x3c, 0x11, 0x66, 0x66, 0x62, 0x8f, 0xde, 0x06,
	0x95, 0xfa, 0xa1, 0xc7, 0x43, 0x2d, 0xb7, 0x60, 0x92, 0x39, 0x99, 0x32, 0xae, 0x45, 0x6b, 0x50,
	0x76, 0x08, 0xa1, 0xae, 0x1f, 0xda, 0x31, 0xa1, 0x09, 0xed, 0x19, 0x11, 0xfa, 0x2e, 0x14, 0x65,
	0xa9, 0x70, 0xca, 0xcb, 0xad, 0x8a, 0x70, 0x25, 0x03, 0x4f, 0x08, 0x90, 0x18, 0xb9, 0xb3, 0x7f,
	0xe4, 0xa0, 0x92, 0xd6, 0x63, 0x77, 0x84, 0x1d, 0xf4, 0x21, 0x68, 0x11, 0x19, 0x53, 0x07, 0xcb,
	0x80, 0xea, 0xc2, 0xcb, 0x14, 0xc8, 0xe8, 0x72, 0x84, 0x74, 0x29, 0xf1, 0xd9, 0x00, 0xf2, 0x57,
	0x07, 0x80, 0xb6, 0x01, 0x5c, 0x4c, 0xfd, 0xe7, 0x76, 0xec, 0x93, 0x90, 0x57, 0x5f, 0xb9, 0xb5,
	0x3a, 0xef, 0x65, 0xdb, 0x29, 0x4a, 0xba, 0xc8, 0xd8, 0xd5, 0x4f, 0x40, 0x13, 0xc1, 0xa0, 0x66,
	0xb6, 0x30, 0xdb, 0x4b, 0x17, 0xe7, 0x0d, 0xd8, 0x22, 0x41, 0x80, 0x1d, 0x86, 0x93, 0x85, 0xfa,
	0x31, 0xc0, 0xc8, 0xa6, 0xb1, 0xcf, 0x44, 0x91, 0xdc, 0xe0, 0x6b, 0x46, 0xca, 0xcd, 0xbe, 0xdd,
	0xc3, 0x41, 0x17, 0x33, 0x1b, 0x92, 0x54, 0x6c, 0xc6, 0xa0, 0xfe, 0x00, 0x60, 0x12, 0xcc, 0x75,
	0x5e, 0xd8, 0xfc, 0x67, 0x0e, 0x0a, 0x3b, 0x3e, 0x0e, 0x5c, 0xb4, 0x01, 0xda, 0x73, 0x3b, 0x18,
	0x63, 0xd6, 0x8a, 0x32, 0x47, 0x84, 0x2b, 0x8d, 0xcf, 0x98, 0x26, 0x49, 0xa7, 0x80, 0xd5, 0xff,
	0x90, 0x83, 0x02, 0x97, 0xa3, 0x7b, 0xa0, 0x9e, 0xf8, 0xa1, 0xcb, 0x5f, 0xb4, 0xd4, 0xba, 0x7b,
	0xc9, 0xd0, 0xf8, 0xd4, 0x0f, 0x5d, 0x93, 0x63, 0x50, 0x1d, 0x4a, 0xe3, 0x30, 0xf2, 0xbd, 0x10,
	0x8b, 0x86, 0xa9, 0x9a, 0xe9, 0x33, 0xba, 0x0b, 0x9a, 0xd4, 0x30, 0x7e, 0x90, 0xa9, 0x4d, 0xe4,
	0x2e, 0x19, 0xf7, 0x64, 0xe1, 0x28, 0xa6, 0x7c, 0x42, 0xdf, 0x86, 0x42, 0xef, 0x2c, 0xc6, 0x91,
	0x24, 0xa7, 0x2c, 0xe9, 0x64, 0x9d, 0x5a, 0xc6, 0x2a, 0xf4, 0xcd, 0x9f, 0x83, 0xca, 0x42, 0x40,
	0x65, 0x28, 0xee, 0x1d, 0x7c, 0xb6, 0xb9, 0xbf, 0xb7, 0x5d, 0x5d, 0x40, 0x25, 0x50, 0x0f, 0x8e,
	0xf7, 0xf7, 0xab, 0x0a, 0x5b, 0x1d, 0x99, 0xc7, 0x9d, 0x6a, 0x0e, 0xe9, 0x50, 0xd8, 0xd9, 0xdc,
	0xef, 0x76, 0xaa, 0x79, 0x04, 0xa0, 0x75, 0x8f, 0xcc, 0xbd, 0x83, 0x4f, 0xaa, 0x2a, 0x5a, 0x84,
	0xd2, 0xf1, 0x41, 0x77, 0xef, 0x93, 0x83, 0xce, 0x76, 0xb5, 0xc0, 0x35, 0x62, 0xad, 0xb1, 0xf5,
	0xf6, 0xe1, 0x71, 0x7b, 0xbf, 0x53, 0x2d, 0xb2, 0xf5, 0x61, 0xfb, 0x49, 0x67, 0xeb, 0xa8, 0x5a,
	0x62, 0x8e, 0x36, 0x4d, 0x73, 0xf3, 0x47, 0x55, 0xbd, 0xf9, 0xa7, 0x1c, 0x2c, 0xc9, 0x12, 0x33,
	0xf1, 0x4f, 0xc7, 0x38, 0x8a, 0xd1, 0x43, 0xd0, 0x1c, 0x7e, 0x4e, 0x79, 0xca, 0xca, 0xad, 0x3b,
	0x53, 0x85, 0x28, 0x8e, 0x70, 0x92, 0x6d, 0x01, 0x44, 0x6f, 0x02, 0xb0, 0x73, 0x66, 0xf9, 0xa1,
	0x8b, 0x4f, 0xe5, 0x55, 0xa3, 0x33, 0xc9, 0x1e, 0x13, 0xa0, 0x1d, 0xd0, 0x48, 0xbf, 0x1f, 0xe1,
	0x98, 0xa7, 0x2e, 0xdf, 0x36, 0x2e, 0xce, 0x1b, 0xf7, 0xae, 0x73, 0xdc, 0x0f, 0xb9, 0x95, 0x29,
	0xad, 0xd1, 0x53, 0x00, 0x1c, 0xba, 0x96, 0xf4, 0xa5, 0xde, 0xca, 0x97, 0x8e, 0x43, 0x57, 0x2c,
	0xd1, 0x03, 0x00, 0x8a, 0x23, 0x12, 0x8c, 0x33, 0x67, 0xa8, 0x3a, 0xa9, 0xe7, 0x5d, 0x6c, 0xbb,
	0x98, 0x9a, 0x19, 0x8c, 0x3c, 0xf6, 0x7f, 0xd4, 0x60, 0x39, 0xcd, 0x59, 0x34, 0x22, 0x61, 0x84,
	0xd1, 0x3a, 0x68, 0x51, 0x6c, 0xc7, 0xe3, 0x48, 0xd6, 0x59, 0xd5, 0x48, 0x6e, 0x7b, 0xa3, 0xcb,
	0xe5, 0xa6, 0xd4, 0x33, 0xe4, 0x80, 0x7b, 0x96, 0x27, 0xe8, 0xf2, 0x1b, 0xa5, 0x1e, 0xbd, 0x03,
	0x4b, 0x31, 0xa6, 0x43, 0x3f, 0xb4, 0x03, 0x0b, 0x53, 0x2a, 0x1b, 0x97, 0x6e, 0x56, 0x12, 0x69,
	0x87, 0x09, 0xd1, 0x0f, 0x61, 0x91, 0x5f, 0x48, 0xf1, 0x80, 0x92, 0xb1, 0x37, 0xb8, 0x65, 0x5e,
	0xca, 0xcc, 0xc7, 0x91, 0x70, 0xc1, 0x12, 0xfd, 0x82, 0xfa, 0x31, 0xb6, 0x58, 0x24, 0x3c, 0x33,
	0xb7, 0x48, 0x34, 0xf7, 0xc0, 0xb6, 0x84, 0x1a, 0x50, 0xb0, 0x29, 0x0e, 0xed, 0x9a, 0xb6, 0xa6,
	0xac, 0x2f, 0xb6, 0xf5, 0x8b, 0xf3, 0x46, 0x61, 0x93, 0x09, 0x4c, 0x21, 0x9f, 0xbe, 0xec, 0x8b,
	0x57, 0x5c, 0xf6, 0x8f, 0x60, 0xd1, 0x21, 0x61, 0x8c, 0xc3, 0xd8, 0x62, 0x83, 0x52, 0xad, 0xc4,
	0x13, 0x2e, 0x3b, 0xc2, 0x96, 0xd0, 0x1c, 0x9d, 0x8d, 0x30, 0x6b, 0xf0, 0xe9, 0x03, 0xba, 0x0f,
	0x45, 0xf9, 0x58, 0xd3, 0x79, 0x0b, 0x99, 0x73, 0x20, 0x13, 0x04, 0xda, 0x4e, 0x26, 0x29, 0x58,
	0xcb, 0xdf, 0x62, 0xeb, 0x72, 0xf2, 0xfa, 0x81, 0x98, 0xbc, 0xca, 0xb7, 0xf2, 0xc1, 0x4c, 0xd1,
	0x23, 0x80, 0xf1, 0xd8, 0x77, 0x2d, 0xd6, 0x45, 0xa3, 0xda, 0x22, 0x8f, 0x7b, 0x59, 0xc4, 0x9d,
	0x8e, 0x6c, 0x32, 0x76, 0x9d, 0x01, 0xc5, 0x0c, 0xd7, 0x82, 0x72, 0x66, 0x1a, 0xaa, 0x55, 0xb2,
	0xdb, 0xe5, 0x8d, 0x2f, 0x69, 0xce, 0x93, 0xe1, 0x88, 0x4d, 0x35, 0x89, 0xcd, 0xc0, 0x8e, 0x06,
	0x38, 0xb2, 0x02, 0xf2, 0xa2, 0xb6, 0xb4, 0x96, 0x67, 0x73, 0x9f, 0xd4, 0xec, 0x72, 0xc5, 0x3e,
	0x79, 0x81, 0x0c, 0xb8, 0x33, 0x83, 0x1e, 0xf8, 0xde, 0xa0, 0xb6, 0xcc, 0xe1, 0xaf, 0x4c, 0xc1,
	0x77, 0x7d, 0x6f, 0xd0, 0xfc, 0x8f, 0x02, 0x4b, 0x9d, 0xd3, 0x98, 0xda, 0x4e, 0x9c, 0x74, 0x99,
	0xb4, 0x26, 0x94, 0x97, 0xd4, 0xc4, 0x2c, 0xcd, 0xb9, 0x9b, 0xd2, 0x9c, 0xbf, 0x92, 0xe6, 0xd7,
	0xa1, 0x24, 0xd2, 0x1b, 0x53, 0x7e, 0x6a, 0x74, 0xb3, 0xc8, 0xb3, 0x18, 0x53, 0xf4, 0x06, 0xe8,
	0x6c, 0x67, 0x4c, 0xc5, 0x3a, 0x38, 0x9b, 0x25, 0x4b, 0x4c, 0xf0, 0x2c, 0xa6, 0x11, 0x6b, 0x77,
	0x7d, 0x96, 0x47, 0xa1, 0xd5, 0xb8, 0x56, 0xe7, 0x12, 0xa6, 0x6e, 0xfe, 0x55, 0x81, 0xe5, 0x74,
	0xb7, 0xb2, 0x3f, 0x5c, 0x63, 0xbb, 0x59, 0xaa, 0x73, 0xd7, 0xa4, 0xfa, 0x4d, 0x80, 0x0c, 0x5d,
	0x79, 0x9e, 0x7f, 0x7d, 0x90, 0xf2, 0xd4, 0x80, 0x72, 0x96, 0x1f, 0x95, 0xeb, 0xa5, 0x05, 0x23,
	0x06, 0xbd, 0x07, 0x1a, 0x8f, 0x5b, 0xec, 0x71, 0x6e, 0x95, 0x48, 0x40, 0xf3, 0x37, 0x39, 0x58,
	0xda, 0x22, 0xc3, 0x9e, 0x1f, 0xe2, 0xff, 0x27, 0x0e, 0xdf, 0x03, 0xcd, 0x76, 0x1c, 0x3c, 0x12,
	0xf7, 0xc1, 0x5c, 0xe7, 0x12, 0xc0, 0x92, 0x15, 0x39, 0x03, 0x3c, 0xb4, 0xad, 0x31, 0xf5, 0x79,
	0x57, 0xd3, 0x4d, 0x5d, 0x48, 0x8e, 0xa9, 0x8f, 0x5e, 0x83, 0x62, 0xf2, 0xf1, 0x20, 0x28, 0xd5,
	0x4e, 0xc4, 0x57, 0xc3, 0x34, 0xdd, 0xc5, 0x59, 0xba, 0x7f, 0xa5, 0xc0, 0x72, 0x9a, 0x98, 0xeb,
	0xd2, 0x7d, 0xd3, 0x3d, 0x4a, 0x96, 0xd4, 0xab, 0x58, 0xfa, 0xbc, 0x00, 0x15, 0x3e, 0x65, 0xa5,
	0x24, 0x19, 0xa0, 0x92, 0x11, 0x0e, 0xe5, 0x65, 0x5e, 0x13, 0xa6, 0x53, 0x10, 0xe3, 0x70, 0x84,
	0xc3, 0xdd, 0x05, 0x93, 0xe3, 0xd0, 0x23, 0xd0, 0xf0, 0x69, 0x9c, 0x7c, 0x32, 0xa6, 0x23, 0xec,
	0xb4, 0x45, 0x87, 0x23, 0x76, 0x17, 0x4c, 0x89, 0x45, 0x0f, 0xa1, 0xd0, 0x0f, 0xc6, 0xd1, 0x40,
	0x0e, 0xaf, 0xaf, 0xcf, 0x33, 0xda, 0x61, 0x80, 0xdd, 0x05, 0x53, 0x20, 0xd1, 0x07, 0x50, 0x1c,
	0x51, 0x3c, 0xb2, 0x69, 0x32, 0x72, 0xbf, 0x31, 0xcf, 0xe8, 0x99, 0x80, 0xec, 0x2e, 0x98, 0x09,
	0x9a, 0x45, 0xe8, 0x90, 0xe1, 0xd0, 0x8f, 0xe5, 0x9d, 0x3d, 0x37, 0xc2, 0x2d, 0x8e, 0xd8, 0xe5,
	0x33, 0x0a, 0x5b, 0xd5, 0x6d, 0x50, 0xd9, 0x3e, 0x91, 0x01, 0xe0, 0xa4, 0x83, 0xe6, 0x4b, 0xc6,
	0xcf, 0x0c, 0x22, 0x53, 0x60, 0xb9, 0x2b, 0x0a, 0xac, 0xfe, 0x67, 0x05, 0x34, 0x91, 0x99, 0x9b,
	0x7d, 0xbe, 0xa6, 0xd5, 0x92, 0xbb, 0xe6, 0x39, 0xca, 0xdf, 0xf4, 0x1c, 0xa9, 0x57, 0xd5, 0x58,
	0xbd, 0x08, 0x05, 0xce, 0x4f, 0xbd, 0x03, 0x45, 0x99, 0x73, 0xf4, 0x18, 0xc0, 0x19, 0x60, 0xe7,
	0x64, 0x44, 0xfc, 0x30, 0x96, 0x05, 0xb4, 0x32, 0x19, 0x6c, 0xb6, 0x52, 0x5d, 0x72, 0xa1, 0x4c,
	0xd0, 0xf5, 0x12, 0x68, 0x82, 0x82, 0xb6, 0x26, 0x06, 0xf0, 0xe6, 0x6f, 0xf3, 0xb0, 0x94, 0x70,
	0x24, 0x8f, 0xc9, 0xfb, 0x33, 0xb5, 0x36, 0x53, 0x01, 0x02, 0x75, 0xb9, 0xd8, 0x5a, 0xd3, 0xc5,
	0x56, 0x9f, 0x6b, 0x35, 0x53, 0x6d, 0x1f, 0xce, 0x56, 0xdb, 0xb7, 0xe6, 0x5a, 0xcd, 0x29, 0xb7,
	0xf7, 0x67, 0xca, 0x6d, 0x7e, 0x90, 0x97, 0xea, 0xed, 0x97, 0x93, 0x62, 0xb8, 0x49, 0x37, 0xc8,
	0x5d, 0xd9, 0x0d, 0x1e, 0x4e, 0x7d, 0x86, 0xe5, 0x5f, 0x7a, 0xbb, 0x67, 0x3e, 0xbd, 0x52, 0x72,
	0xf5, 0x94, 0xdc, 0xcb, 0x04, 0xdd, 0x7b, 0x1b, 0xca, 0x99, 0x5a, 0xba, 0xf4, 0x3d, 0xf2, 0xa4,
	0x7b, 0x78, 0x50, 0x55, 0x5a, 0xdb, 0x50, 0x92, 0xc3, 0x2f, 0x65, 0x49, 0x4d, 0xfe, 0xaf, 0x59,
	0x99, 0xfa, 0x4a, 0x90, 0xa7, 0xb0, 0xfe, 0xea, 0x8c, 0x54, 0x24, 0xeb, 0x81, 0xd2, 0xda, 0x84,
	0xa2, 0xbc, 0x22, 0xd1, 0xf7, 0x27, 0x4b, 0xe9, 0x64, 0x7a, 0x54, 0x48, 0x9c, 0xcc, 0x5c, 0xa9,
	0xcc, 0x85, 0x6c, 0xbb, 0xcc, 0x45, 0xb2, 0x5c, 0x49, 0x0e, 0x45, 0xf6, 0xa6, 0x4a, 0x5c, 0xcc,
	0xb4, 0xe9, 0xd6, 0x5f, 0x14, 0xd0, 0x04, 0x8f, 0x68, 0x13, 0x5e, 0x31, 0x71, 0x14, 0x13, 0x8a,
	0x27, 0x65, 0x8d, 0xee, 0x1a, 0x1e, 0x21, 0x5e, 0x80, 0xc5, 0x88, 0xde, 0x1b, 0xf7, 0x8d, 0xce,
	0x70, 0x14, 0x9f, 0xd5, 0xe7, 0x1e, 0x02, 0xf4, 0x41, 0xea, 0xec, 0xce, 0x9c, 0x8e, 0x54, 0x5f,
	0x99, 0x57, 0x37, 0xeb, 0xca, 0x03, 0x05, 0x7d, 0x04, 0xd0, 0x1e, 0xfb, 0x81, 0xbb, 0xeb, 0x87,
	0x71, 0xf4, 0xd2, 0x97, 0xbe, 0x6a, 0x64, 0xfe, 0x37, 0x34, 0x76, 0xba, 0x4f, 0x39, 0xbc, 0x7d,
	0xf7, 0xab, 0x6f, 0x56, 0x95, 0xaf, 0xbf, 0x59, 0x55, 0xbe, 0xf8, 0xd7, 0xaa, 0xf2, 0xe3, 0x52,
	0x32, 0x47, 0xf6, 0x34, 0xbe, 0xfa, 0xde, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x6b, 0x7d, 0x29,
	0x82, 0xd7, 0x14, 0x00, 0x00,
}

func (this *UUIDParts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UUIDParts)
	if !ok {
		that2, ok := that.(UUIDParts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProducerAndFlags != that1.ProducerAndFlags {
		return false
	}
	if this.Clock != that1.Clock {
		return false
	}
	return true
}
func (this *Shuffle) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Shuffle)
	if !ok {
		that2, ok := that.(Shuffle)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Transform != that1.Transform {
		return false
	}
	if len(this.ShuffleKeyPtr) != len(that1.ShuffleKeyPtr) {
		return false
	}
	for i := range this.ShuffleKeyPtr {
		if this.ShuffleKeyPtr[i] != that1.ShuffleKeyPtr[i] {
			return false
		}
	}
	if this.BroadcastTo != that1.BroadcastTo {
		return false
	}
	if this.ChooseFrom != that1.ChooseFrom {
		return false
	}
	if this.ReadDelaySeconds != that1.ReadDelaySeconds {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Ring) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ring)
	if !ok {
		that2, ok := that.(Ring)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Members) != len(that1.Members) {
		return false
	}
	for i := range this.Members {
		if !this.Members[i].Equal(&that1.Members[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Ring_Member) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ring_Member)
	if !ok {
		that2, ok := that.(Ring_Member)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinMsgClock != that1.MinMsgClock {
		return false
	}
	if this.MaxMsgClock != that1.MaxMsgClock {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ShuffleConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShuffleConfig)
	if !ok {
		that2, ok := that.(ShuffleConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Journal != that1.Journal {
		return false
	}
	if !this.Ring.Equal(&that1.Ring) {
		return false
	}
	if this.Coordinator != that1.Coordinator {
		return false
	}
	if !this.Shuffle.Equal(&that1.Shuffle) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ShuffleRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShuffleRequest)
	if !ok {
		that2, ok := that.(ShuffleRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Config.Equal(&that1.Config) {
		return false
	}
	if this.RingIndex != that1.RingIndex {
		return false
	}
	if this.Offset != that1.Offset {
		return false
	}
	if this.EndOffset != that1.EndOffset {
		return false
	}
	if !this.Resolution.Equal(that1.Resolution) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ShufflerClient is the client API for Shuffler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ShufflerClient interface {
	Shuffle(ctx context.Context, in *ShuffleRequest, opts ...grpc.CallOption) (Shuffler_ShuffleClient, error)
}

type shufflerClient struct {
	cc *grpc.ClientConn
}

func NewShufflerClient(cc *grpc.ClientConn) ShufflerClient {
	return &shufflerClient{cc}
}

func (c *shufflerClient) Shuffle(ctx context.Context, in *ShuffleRequest, opts ...grpc.CallOption) (Shuffler_ShuffleClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Shuffler_serviceDesc.Streams[0], "/flow.Shuffler/Shuffle", opts...)
	if err != nil {
		return nil, err
	}
	x := &shufflerShuffleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Shuffler_ShuffleClient interface {
	Recv() (*ShuffleResponse, error)
	grpc.ClientStream
}

type shufflerShuffleClient struct {
	grpc.ClientStream
}

func (x *shufflerShuffleClient) Recv() (*ShuffleResponse, error) {
	m := new(ShuffleResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ShufflerServer is the server API for Shuffler service.
type ShufflerServer interface {
	Shuffle(*ShuffleRequest, Shuffler_ShuffleServer) error
}

// UnimplementedShufflerServer can be embedded to have forward compatible implementations.
type UnimplementedShufflerServer struct {
}

func (*UnimplementedShufflerServer) Shuffle(req *ShuffleRequest, srv Shuffler_ShuffleServer) error {
	return status.Errorf(codes.Unimplemented, "method Shuffle not implemented")
}

func RegisterShufflerServer(s *grpc.Server, srv ShufflerServer) {
	s.RegisterService(&_Shuffler_serviceDesc, srv)
}

func _Shuffler_Shuffle_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ShuffleRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ShufflerServer).Shuffle(m, &shufflerShuffleServer{stream})
}

type Shuffler_ShuffleServer interface {
	Send(*ShuffleResponse) error
	grpc.ServerStream
}

type shufflerShuffleServer struct {
	grpc.ServerStream
}

func (x *shufflerShuffleServer) Send(m *ShuffleResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Shuffler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "flow.Shuffler",
	HandlerType: (*ShufflerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Shuffle",
			Handler:       _Shuffler_Shuffle_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "go/protocol/flow.proto",
}

// ExtractClient is the client API for Extract service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ExtractClient interface {
	Extract(ctx context.Context, in *ExtractRequest, opts ...grpc.CallOption) (*ExtractResponse, error)
}

type extractClient struct {
	cc *grpc.ClientConn
}

func NewExtractClient(cc *grpc.ClientConn) ExtractClient {
	return &extractClient{cc}
}

func (c *extractClient) Extract(ctx context.Context, in *ExtractRequest, opts ...grpc.CallOption) (*ExtractResponse, error) {
	out := new(ExtractResponse)
	err := c.cc.Invoke(ctx, "/flow.Extract/Extract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExtractServer is the server API for Extract service.
type ExtractServer interface {
	Extract(context.Context, *ExtractRequest) (*ExtractResponse, error)
}

// UnimplementedExtractServer can be embedded to have forward compatible implementations.
type UnimplementedExtractServer struct {
}

func (*UnimplementedExtractServer) Extract(ctx context.Context, req *ExtractRequest) (*ExtractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Extract not implemented")
}

func RegisterExtractServer(s *grpc.Server, srv ExtractServer) {
	s.RegisterService(&_Extract_serviceDesc, srv)
}

func _Extract_Extract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExtractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtractServer).Extract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.Extract/Extract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtractServer).Extract(ctx, req.(*ExtractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Extract_serviceDesc = grpc.ServiceDesc{
	ServiceName: "flow.Extract",
	HandlerType: (*ExtractServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Extract",
			Handler:    _Extract_Extract_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/protocol/flow.proto",
}

// CombineClient is the client API for Combine service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CombineClient interface {
	Combine(ctx context.Context, in *CombineRequest, opts ...grpc.CallOption) (*CombineResponse, error)
}

type combineClient struct {
	cc *grpc.ClientConn
}

func NewCombineClient(cc *grpc.ClientConn) CombineClient {
	return &combineClient{cc}
}

func (c *combineClient) Combine(ctx context.Context, in *CombineRequest, opts ...grpc.CallOption) (*CombineResponse, error) {
	out := new(CombineResponse)
	err := c.cc.Invoke(ctx, "/flow.Combine/Combine", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CombineServer is the server API for Combine service.
type CombineServer interface {
	Combine(context.Context, *CombineRequest) (*CombineResponse, error)
}

// UnimplementedCombineServer can be embedded to have forward compatible implementations.
type UnimplementedCombineServer struct {
}

func (*UnimplementedCombineServer) Combine(ctx context.Context, req *CombineRequest) (*CombineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Combine not implemented")
}

func RegisterCombineServer(s *grpc.Server, srv CombineServer) {
	s.RegisterService(&_Combine_serviceDesc, srv)
}

func _Combine_Combine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CombineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CombineServer).Combine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.Combine/Combine",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CombineServer).Combine(ctx, req.(*CombineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Combine_serviceDesc = grpc.ServiceDesc{
	ServiceName: "flow.Combine",
	HandlerType: (*CombineServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Combine",
			Handler:    _Combine_Combine_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/protocol/flow.proto",
}

// DeriveClient is the client API for Derive service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DeriveClient interface {
	// RestoreCheckpoint recovers the most recent Checkpoint previously committed
	// to the Store. It is called just once, at Shard start-up. If an external
	// system is used, it should install a transactional "write fence" to ensure
	// that an older Store instance of another process cannot successfully
	// StartCommit after this RestoreCheckpoint returns.
	RestoreCheckpoint(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*protocol1.Checkpoint, error)
	// Derive begins a pipelined derive transaction, following the
	// state machine detailed in DeriveState.
	Derive(ctx context.Context, opts ...grpc.CallOption) (Derive_DeriveClient, error)
	// BuildHints returns FSMHints which may be played back to fully reconstruct
	// the local filesystem state produced by this derive worker. It may block
	// while pending operations sync to the recovery log.
	BuildHints(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*recoverylog.FSMHints, error)
}

type deriveClient struct {
	cc *grpc.ClientConn
}

func NewDeriveClient(cc *grpc.ClientConn) DeriveClient {
	return &deriveClient{cc}
}

func (c *deriveClient) RestoreCheckpoint(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*protocol1.Checkpoint, error) {
	out := new(protocol1.Checkpoint)
	err := c.cc.Invoke(ctx, "/flow.Derive/RestoreCheckpoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deriveClient) Derive(ctx context.Context, opts ...grpc.CallOption) (Derive_DeriveClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Derive_serviceDesc.Streams[0], "/flow.Derive/Derive", opts...)
	if err != nil {
		return nil, err
	}
	x := &deriveDeriveClient{stream}
	return x, nil
}

type Derive_DeriveClient interface {
	Send(*DeriveRequest) error
	Recv() (*DeriveResponse, error)
	grpc.ClientStream
}

type deriveDeriveClient struct {
	grpc.ClientStream
}

func (x *deriveDeriveClient) Send(m *DeriveRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *deriveDeriveClient) Recv() (*DeriveResponse, error) {
	m := new(DeriveResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *deriveClient) BuildHints(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*recoverylog.FSMHints, error) {
	out := new(recoverylog.FSMHints)
	err := c.cc.Invoke(ctx, "/flow.Derive/BuildHints", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeriveServer is the server API for Derive service.
type DeriveServer interface {
	// RestoreCheckpoint recovers the most recent Checkpoint previously committed
	// to the Store. It is called just once, at Shard start-up. If an external
	// system is used, it should install a transactional "write fence" to ensure
	// that an older Store instance of another process cannot successfully
	// StartCommit after this RestoreCheckpoint returns.
	RestoreCheckpoint(context.Context, *empty.Empty) (*protocol1.Checkpoint, error)
	// Derive begins a pipelined derive transaction, following the
	// state machine detailed in DeriveState.
	Derive(Derive_DeriveServer) error
	// BuildHints returns FSMHints which may be played back to fully reconstruct
	// the local filesystem state produced by this derive worker. It may block
	// while pending operations sync to the recovery log.
	BuildHints(context.Context, *empty.Empty) (*recoverylog.FSMHints, error)
}

// UnimplementedDeriveServer can be embedded to have forward compatible implementations.
type UnimplementedDeriveServer struct {
}

func (*UnimplementedDeriveServer) RestoreCheckpoint(ctx context.Context, req *empty.Empty) (*protocol1.Checkpoint, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreCheckpoint not implemented")
}
func (*UnimplementedDeriveServer) Derive(srv Derive_DeriveServer) error {
	return status.Errorf(codes.Unimplemented, "method Derive not implemented")
}
func (*UnimplementedDeriveServer) BuildHints(ctx context.Context, req *empty.Empty) (*recoverylog.FSMHints, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildHints not implemented")
}

func RegisterDeriveServer(s *grpc.Server, srv DeriveServer) {
	s.RegisterService(&_Derive_serviceDesc, srv)
}

func _Derive_RestoreCheckpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeriveServer).RestoreCheckpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.Derive/RestoreCheckpoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeriveServer).RestoreCheckpoint(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Derive_Derive_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DeriveServer).Derive(&deriveDeriveServer{stream})
}

type Derive_DeriveServer interface {
	Send(*DeriveResponse) error
	Recv() (*DeriveRequest, error)
	grpc.ServerStream
}

type deriveDeriveServer struct {
	grpc.ServerStream
}

func (x *deriveDeriveServer) Send(m *DeriveResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *deriveDeriveServer) Recv() (*DeriveRequest, error) {
	m := new(DeriveRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Derive_BuildHints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeriveServer).BuildHints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.Derive/BuildHints",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeriveServer).BuildHints(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Derive_serviceDesc = grpc.ServiceDesc{
	ServiceName: "flow.Derive",
	HandlerType: (*DeriveServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RestoreCheckpoint",
			Handler:    _Derive_RestoreCheckpoint_Handler,
		},
		{
			MethodName: "BuildHints",
			Handler:    _Derive_BuildHints_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Derive",
			Handler:       _Derive_Derive_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "go/protocol/flow.proto",
}

func (m *Slice) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Slice) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Slice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Begin != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Begin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UUIDParts) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UUIDParts) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UUIDParts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Clock != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Clock))
		i--
		dAtA[i] = 0x11
	}
	if m.ProducerAndFlags != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ProducerAndFlags))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Shuffle) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shuffle) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Shuffle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReadDelaySeconds != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ReadDelaySeconds))
		i--
		dAtA[i] = 0x28
	}
	if m.ChooseFrom != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ChooseFrom))
		i--
		dAtA[i] = 0x20
	}
	if m.BroadcastTo != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.BroadcastTo))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ShuffleKeyPtr) > 0 {
		for iNdEx := len(m.ShuffleKeyPtr) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ShuffleKeyPtr[iNdEx])
			copy(dAtA[i:], m.ShuffleKeyPtr[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.ShuffleKeyPtr[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Transform) > 0 {
		i -= len(m.Transform)
		copy(dAtA[i:], m.Transform)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Transform)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Ring) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ring) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ring) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Ring_Member) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ring_Member) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ring_Member) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxMsgClock != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.MaxMsgClock))
		i--
		dAtA[i] = 0x10
	}
	if m.MinMsgClock != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.MinMsgClock))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShuffleConfig) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShuffleConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShuffleConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Shuffle.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.Coordinator != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Coordinator))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Ring.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Journal) > 0 {
		i -= len(m.Journal)
		copy(dAtA[i:], m.Journal)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Journal)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransformSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransformSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransformSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Derivation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Shuffle.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}

func (m *TransformSpec_Source) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransformSpec_Source) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransformSpec_Source) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Partitions.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransformSpec_Derivation) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransformSpec_Derivation) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransformSpec_Derivation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Field) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Field) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Field) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Field_Value) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Field_Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Field_Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Bytes.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Double != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Double))))
		i--
		dAtA[i] = 0x21
	}
	if m.Signed != 0 {
		i = encodeVarintFlow(dAtA, i, uint64((uint64(m.Signed)<<1)^uint64((m.Signed>>63))))
		i--
		dAtA[i] = 0x18
	}
	if m.Unsigned != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Unsigned))
		i--
		dAtA[i] = 0x10
	}
	if m.Kind != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShuffleRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShuffleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShuffleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Resolution != nil {
		{
			size, err := m.Resolution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.EndOffset != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.EndOffset))
		i--
		dAtA[i] = 0x20
	}
	if m.Offset != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if m.RingIndex != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.RingIndex))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ShuffleResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShuffleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShuffleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ShuffleHashesHigh) > 0 {
		for iNdEx := len(m.ShuffleHashesHigh) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ShuffleHashesHigh[iNdEx]))
		}
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ShuffleHashesHigh)*8))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.ShuffleHashesLow) > 0 {
		for iNdEx := len(m.ShuffleHashesLow) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ShuffleHashesLow[iNdEx]))
		}
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ShuffleHashesLow)*8))
		i--
		dAtA[i] = 0x72
	}
	if len(m.ShuffleKey) > 0 {
		for iNdEx := len(m.ShuffleKey) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShuffleKey[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.UuidParts) > 0 {
		for iNdEx := len(m.UuidParts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UuidParts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.End) > 0 {
		dAtA11 := make([]byte, len(m.End)*10)
		var j10 int
		for _, num1 := range m.End {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintFlow(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Begin) > 0 {
		dAtA13 := make([]byte, len(m.Begin)*10)
		var j12 int
		for _, num1 := range m.Begin {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintFlow(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Content) > 0 {
		for iNdEx := len(m.Content) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Content[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.ContentType != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ContentType))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Transform) > 0 {
		i -= len(m.Transform)
		copy(dAtA[i:], m.Transform)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Transform)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Arena) > 0 {
		i -= len(m.Arena)
		copy(dAtA[i:], m.Arena)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Arena)))
		i--
		dAtA[i] = 0x32
	}
	if m.WriteHead != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.WriteHead))
		i--
		dAtA[i] = 0x28
	}
	if m.ReadThrough != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ReadThrough))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TerminalError) > 0 {
		i -= len(m.TerminalError)
		copy(dAtA[i:], m.TerminalError)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.TerminalError)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExtractRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtractRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtractRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FieldPtrs) > 0 {
		for iNdEx := len(m.FieldPtrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FieldPtrs[iNdEx])
			copy(dAtA[i:], m.FieldPtrs[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.FieldPtrs[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.HashPtrs) > 0 {
		for iNdEx := len(m.HashPtrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.HashPtrs[iNdEx])
			copy(dAtA[i:], m.HashPtrs[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.HashPtrs[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.UuidPtr) > 0 {
		i -= len(m.UuidPtr)
		copy(dAtA[i:], m.UuidPtr)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.UuidPtr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Content) > 0 {
		for iNdEx := len(m.Content) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Content[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ContentType != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ContentType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Arena) > 0 {
		i -= len(m.Arena)
		copy(dAtA[i:], m.Arena)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Arena)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExtractResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtractResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtractResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.HashesHigh) > 0 {
		for iNdEx := len(m.HashesHigh) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.HashesHigh[iNdEx]))
		}
		i = encodeVarintFlow(dAtA, i, uint64(len(m.HashesHigh)*8))
		i--
		dAtA[i] = 0x22
	}
	if len(m.HashesLow) > 0 {
		for iNdEx := len(m.HashesLow) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.HashesLow[iNdEx]))
		}
		i = encodeVarintFlow(dAtA, i, uint64(len(m.HashesLow)*8))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UuidParts) > 0 {
		for iNdEx := len(m.UuidParts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UuidParts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Arena) > 0 {
		i -= len(m.Arena)
		copy(dAtA[i:], m.Arena)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Arena)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CombineRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombineRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FieldPtrs) > 0 {
		for iNdEx := len(m.FieldPtrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FieldPtrs[iNdEx])
			copy(dAtA[i:], m.FieldPtrs[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.FieldPtrs[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.KeyPtr) > 0 {
		for iNdEx := len(m.KeyPtr) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyPtr[iNdEx])
			copy(dAtA[i:], m.KeyPtr[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.KeyPtr[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SchemaUri) > 0 {
		i -= len(m.SchemaUri)
		copy(dAtA[i:], m.SchemaUri)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.SchemaUri)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Accept != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Accept))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Content) > 0 {
		for iNdEx := len(m.Content) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Content[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ContentType != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ContentType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Arena) > 0 {
		i -= len(m.Arena)
		copy(dAtA[i:], m.Arena)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Arena)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CombineResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombineResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Content) > 0 {
		for iNdEx := len(m.Content) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Content[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Arena) > 0 {
		i -= len(m.Arena)
		copy(dAtA[i:], m.Arena)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Arena)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Kind != nil {
		{
			size := m.Kind.ProtoSize()
			i -= size
			if _, err := m.Kind.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeriveRequest_Open_) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveRequest_Open_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Open != nil {
		{
			size, err := m.Open.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DeriveRequest_Extend_) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveRequest_Extend_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Extend != nil {
		{
			size, err := m.Extend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DeriveRequest_Flush_) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveRequest_Flush_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Flush != nil {
		{
			size, err := m.Flush.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DeriveRequest_Prepare_) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveRequest_Prepare_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Prepare != nil {
		{
			size, err := m.Prepare.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DeriveRequest_Commit_) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveRequest_Commit_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DeriveRequest_Open) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveRequest_Open) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveRequest_Open) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Accept != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Accept))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Collection) > 0 {
		i -= len(m.Collection)
		copy(dAtA[i:], m.Collection)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Collection)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveRequest_Extend) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveRequest_Extend) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveRequest_Extend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Content) > 0 {
		for iNdEx := len(m.Content) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Content[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ContentType != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ContentType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Arena) > 0 {
		i -= len(m.Arena)
		copy(dAtA[i:], m.Arena)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Arena)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Transform) > 0 {
		i -= len(m.Transform)
		copy(dAtA[i:], m.Transform)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Transform)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveRequest_Flush) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveRequest_Flush) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveRequest_Flush) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeriveRequest_Prepare) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveRequest_Prepare) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveRequest_Prepare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeriveRequest_Commit) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveRequest_Commit) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveRequest_Commit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeriveResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Kind != nil {
		{
			size := m.Kind.ProtoSize()
			i -= size
			if _, err := m.Kind.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeriveResponse_Extend_) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveResponse_Extend_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Extend != nil {
		{
			size, err := m.Extend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DeriveResponse_Flush_) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveResponse_Flush_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Flush != nil {
		{
			size, err := m.Flush.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DeriveResponse_Prepare_) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveResponse_Prepare_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Prepare != nil {
		{
			size, err := m.Prepare.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DeriveResponse_Commit_) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveResponse_Commit_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DeriveResponse_Extend) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveResponse_Extend) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveResponse_Extend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Partitions) > 0 {
		for iNdEx := len(m.Partitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Partitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Content) > 0 {
		for iNdEx := len(m.Content) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Content[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Arena) > 0 {
		i -= len(m.Arena)
		copy(dAtA[i:], m.Arena)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Arena)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveResponse_Flush) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveResponse_Flush) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveResponse_Flush) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeriveResponse_Prepare) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveResponse_Prepare) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveResponse_Prepare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeriveResponse_Commit) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveResponse_Commit) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveResponse_Commit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintFlow(dAtA []byte, offset int, v uint64) int {
	offset -= sovFlow(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Slice) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != 0 {
		n += 1 + sovFlow(uint64(m.Begin))
	}
	if m.End != 0 {
		n += 1 + sovFlow(uint64(m.End))
	}
	return n
}

func (m *UUIDParts) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProducerAndFlags != 0 {
		n += 9
	}
	if m.Clock != 0 {
		n += 9
	}
	return n
}

func (m *Shuffle) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Transform)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.ShuffleKeyPtr) > 0 {
		for _, s := range m.ShuffleKeyPtr {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.BroadcastTo != 0 {
		n += 1 + sovFlow(uint64(m.BroadcastTo))
	}
	if m.ChooseFrom != 0 {
		n += 1 + sovFlow(uint64(m.ChooseFrom))
	}
	if m.ReadDelaySeconds != 0 {
		n += 1 + sovFlow(uint64(m.ReadDelaySeconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Ring) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Ring_Member) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinMsgClock != 0 {
		n += 1 + sovFlow(uint64(m.MinMsgClock))
	}
	if m.MaxMsgClock != 0 {
		n += 1 + sovFlow(uint64(m.MaxMsgClock))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShuffleConfig) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = m.Ring.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.Coordinator != 0 {
		n += 1 + sovFlow(uint64(m.Coordinator))
	}
	l = m.Shuffle.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransformSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Source.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	l = m.Shuffle.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	l = m.Derivation.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransformSpec_Source) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = m.Partitions.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransformSpec_Derivation) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Field) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Field_Value) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovFlow(uint64(m.Kind))
	}
	if m.Unsigned != 0 {
		n += 1 + sovFlow(uint64(m.Unsigned))
	}
	if m.Signed != 0 {
		n += 1 + sozFlow(uint64(m.Signed))
	}
	if m.Double != 0 {
		n += 9
	}
	l = m.Bytes.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShuffleRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Config.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.RingIndex != 0 {
		n += 1 + sovFlow(uint64(m.RingIndex))
	}
	if m.Offset != 0 {
		n += 1 + sovFlow(uint64(m.Offset))
	}
	if m.EndOffset != 0 {
		n += 1 + sovFlow(uint64(m.EndOffset))
	}
	if m.Resolution != nil {
		l = m.Resolution.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShuffleResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovFlow(uint64(m.Status))
	}
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.TerminalError)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.ReadThrough != 0 {
		n += 1 + sovFlow(uint64(m.ReadThrough))
	}
	if m.WriteHead != 0 {
		n += 1 + sovFlow(uint64(m.WriteHead))
	}
	l = len(m.Arena)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Transform)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.ContentType != 0 {
		n += 1 + sovFlow(uint64(m.ContentType))
	}
	if len(m.Content) > 0 {
		for _, e := range m.Content {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.Begin) > 0 {
		l = 0
		for _, e := range m.Begin {
			l += sovFlow(uint64(e))
		}
		n += 1 + sovFlow(uint64(l)) + l
	}
	if len(m.End) > 0 {
		l = 0
		for _, e := range m.End {
			l += sovFlow(uint64(e))
		}
		n += 1 + sovFlow(uint64(l)) + l
	}
	if len(m.UuidParts) > 0 {
		for _, e := range m.UuidParts {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.ShuffleKey) > 0 {
		for _, e := range m.ShuffleKey {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.ShuffleHashesLow) > 0 {
		n += 1 + sovFlow(uint64(len(m.ShuffleHashesLow)*8)) + len(m.ShuffleHashesLow)*8
	}
	if len(m.ShuffleHashesHigh) > 0 {
		n += 1 + sovFlow(uint64(len(m.ShuffleHashesHigh)*8)) + len(m.ShuffleHashesHigh)*8
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtractRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Arena)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.ContentType != 0 {
		n += 1 + sovFlow(uint64(m.ContentType))
	}
	if len(m.Content) > 0 {
		for _, e := range m.Content {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = len(m.UuidPtr)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.HashPtrs) > 0 {
		for _, s := range m.HashPtrs {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.FieldPtrs) > 0 {
		for _, s := range m.FieldPtrs {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtractResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Arena)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.UuidParts) > 0 {
		for _, e := range m.UuidParts {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.HashesLow) > 0 {
		n += 1 + sovFlow(uint64(len(m.HashesLow)*8)) + len(m.HashesLow)*8
	}
	if len(m.HashesHigh) > 0 {
		n += 1 + sovFlow(uint64(len(m.HashesHigh)*8)) + len(m.HashesHigh)*8
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CombineRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Arena)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.ContentType != 0 {
		n += 1 + sovFlow(uint64(m.ContentType))
	}
	if len(m.Content) > 0 {
		for _, e := range m.Content {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.Accept != 0 {
		n += 1 + sovFlow(uint64(m.Accept))
	}
	l = len(m.SchemaUri)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.KeyPtr) > 0 {
		for _, s := range m.KeyPtr {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.FieldPtrs) > 0 {
		for _, s := range m.FieldPtrs {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CombineResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Arena)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Content) > 0 {
		for _, e := range m.Content {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != nil {
		n += m.Kind.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveRequest_Open_) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Open != nil {
		l = m.Open.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}
func (m *DeriveRequest_Extend_) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Extend != nil {
		l = m.Extend.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}
func (m *DeriveRequest_Flush_) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flush != nil {
		l = m.Flush.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}
func (m *DeriveRequest_Prepare_) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prepare != nil {
		l = m.Prepare.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}
func (m *DeriveRequest_Commit_) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}
func (m *DeriveRequest_Open) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Collection)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Accept != 0 {
		n += 1 + sovFlow(uint64(m.Accept))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveRequest_Extend) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Transform)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Arena)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.ContentType != 0 {
		n += 1 + sovFlow(uint64(m.ContentType))
	}
	if len(m.Content) > 0 {
		for _, e := range m.Content {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveRequest_Flush) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveRequest_Prepare) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Checkpoint.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveRequest_Commit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != nil {
		n += m.Kind.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveResponse_Extend_) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Extend != nil {
		l = m.Extend.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}
func (m *DeriveResponse_Flush_) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flush != nil {
		l = m.Flush.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}
func (m *DeriveResponse_Prepare_) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prepare != nil {
		l = m.Prepare.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}
func (m *DeriveResponse_Commit_) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}
func (m *DeriveResponse_Extend) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Arena)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Content) > 0 {
		for _, e := range m.Content {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.Partitions) > 0 {
		for _, e := range m.Partitions {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveResponse_Flush) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveResponse_Prepare) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveResponse_Commit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFlow(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFlow(x uint64) (n int) {
	return sovFlow(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Slice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Slice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Slice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UUIDParts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UUIDParts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UUIDParts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerAndFlags", wireType)
			}
			m.ProducerAndFlags = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ProducerAndFlags = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clock", wireType)
			}
			m.Clock = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Clock = go_gazette_dev_core_message.Clock(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shuffle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shuffle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shuffle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transform = Transform(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleKeyPtr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShuffleKeyPtr = append(m.ShuffleKeyPtr, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BroadcastTo", wireType)
			}
			m.BroadcastTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BroadcastTo |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChooseFrom", wireType)
			}
			m.ChooseFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChooseFrom |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadDelaySeconds", wireType)
			}
			m.ReadDelaySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadDelaySeconds |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ring) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ring: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ring: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, Ring_Member{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ring_Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinMsgClock", wireType)
			}
			m.MinMsgClock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinMsgClock |= go_gazette_dev_core_message.Clock(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMsgClock", wireType)
			}
			m.MaxMsgClock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMsgClock |= go_gazette_dev_core_message.Clock(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShuffleConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShuffleConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShuffleConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = go_gazette_dev_core_broker_protocol.Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ring", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ring.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinator", wireType)
			}
			m.Coordinator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coordinator |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shuffle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shuffle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransformSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransformSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransformSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shuffle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shuffle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Derivation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Derivation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransformSpec_Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = Collection(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Partitions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransformSpec_Derivation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Derivation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Derivation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = Collection(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Field) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Field: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Field: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, Field_Value{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Field_Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= Field_Value_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unsigned", wireType)
			}
			m.Unsigned = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unsigned |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signed", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Signed = int64(v)
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Double", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Double = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Bytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShuffleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShuffleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShuffleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingIndex", wireType)
			}
			m.RingIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndOffset", wireType)
			}
			m.EndOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndOffset |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resolution == nil {
				m.Resolution = &protocol.Header{}
			}
			if err := m.Resolution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShuffleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShuffleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShuffleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= protocol1.Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &protocol.Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TerminalError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TerminalError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadThrough", wireType)
			}
			m.ReadThrough = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadThrough |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteHead", wireType)
			}
			m.WriteHead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteHead |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arena", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arena = append(m.Arena[:0], dAtA[iNdEx:postIndex]...)
			if m.Arena == nil {
				m.Arena = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transform = Transform(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			m.ContentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentType |= ContentType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content, Slice{})
			if err := m.Content[len(m.Content)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v go_gazette_dev_core_broker_protocol.Offset
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Begin = append(m.Begin, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlow
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlow
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Begin) == 0 {
					m.Begin = make([]go_gazette_dev_core_broker_protocol.Offset, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v go_gazette_dev_core_broker_protocol.Offset
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Begin = append(m.Begin, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
		case 11:
			if wireType == 0 {
				var v go_gazette_dev_core_broker_protocol.Offset
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.End = append(m.End, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlow
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlow
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.End) == 0 {
					m.End = make([]go_gazette_dev_core_broker_protocol.Offset, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v go_gazette_dev_core_broker_protocol.Offset
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.End = append(m.End, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidParts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidParts = append(m.UuidParts, UUIDParts{})
			if err := m.UuidParts[len(m.UuidParts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShuffleKey = append(m.ShuffleKey, Field{})
			if err := m.ShuffleKey[len(m.ShuffleKey)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.ShuffleHashesLow = append(m.ShuffleHashesLow, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlow
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlow
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.ShuffleHashesLow) == 0 {
					m.ShuffleHashesLow = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.ShuffleHashesLow = append(m.ShuffleHashesLow, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleHashesLow", wireType)
			}
		case 15:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.ShuffleHashesHigh = append(m.ShuffleHashesHigh, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlow
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlow
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.ShuffleHashesHigh) == 0 {
					m.ShuffleHashesHigh = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.ShuffleHashesHigh = append(m.ShuffleHashesHigh, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleHashesHigh", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtractRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtractRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtractRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arena", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arena = append(m.Arena[:0], dAtA[iNdEx:postIndex]...)
			if m.Arena == nil {
				m.Arena = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			m.ContentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentType |= ContentType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content, Slice{})
			if err := m.Content[len(m.Content)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidPtr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidPtr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashPtrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashPtrs = append(m.HashPtrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPtrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPtrs = append(m.FieldPtrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtractResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtractResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtractResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arena", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arena = append(m.Arena[:0], dAtA[iNdEx:postIndex]...)
			if m.Arena == nil {
				m.Arena = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidParts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidParts = append(m.UuidParts, UUIDParts{})
			if err := m.UuidParts[len(m.UuidParts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.HashesLow = append(m.HashesLow, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlow
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlow
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.HashesLow) == 0 {
					m.HashesLow = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.HashesLow = append(m.HashesLow, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HashesLow", wireType)
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.HashesHigh = append(m.HashesHigh, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlow
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlow
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.HashesHigh) == 0 {
					m.HashesHigh = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.HashesHigh = append(m.HashesHigh, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HashesHigh", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arena", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arena = append(m.Arena[:0], dAtA[iNdEx:postIndex]...)
			if m.Arena == nil {
				m.Arena = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			m.ContentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentType |= ContentType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content, Slice{})
			if err := m.Content[len(m.Content)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accept", wireType)
			}
			m.Accept = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Accept |= ContentType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPtr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyPtr = append(m.KeyPtr, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPtrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPtrs = append(m.FieldPtrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombineResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombineResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arena", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arena = append(m.Arena[:0], dAtA[iNdEx:postIndex]...)
			if m.Arena == nil {
				m.Arena = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content, Slice{})
			if err := m.Content[len(m.Content)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeriveRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeriveRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeriveRequest_Open{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &DeriveRequest_Open_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeriveRequest_Extend{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &DeriveRequest_Extend_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flush", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeriveRequest_Flush{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &DeriveRequest_Flush_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prepare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeriveRequest_Prepare{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &DeriveRequest_Prepare_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeriveRequest_Commit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &DeriveRequest_Commit_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveRequest_Open) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Open: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Open: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collection = Collection(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accept", wireType)
			}
			m.Accept = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Accept |= ContentType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveRequest_Extend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Extend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Extend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transform = Transform(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arena", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arena = append(m.Arena[:0], dAtA[iNdEx:postIndex]...)
			if m.Arena == nil {
				m.Arena = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			m.ContentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentType |= ContentType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content, Slice{})
			if err := m.Content[len(m.Content)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveRequest_Flush) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flush: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flush: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveRequest_Prepare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveRequest_Commit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeriveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeriveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeriveResponse_Extend{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &DeriveResponse_Extend_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flush", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeriveResponse_Flush{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &DeriveResponse_Flush_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prepare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeriveResponse_Prepare{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &DeriveResponse_Prepare_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeriveResponse_Commit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &DeriveResponse_Commit_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveResponse_Extend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Extend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Extend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arena", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arena = append(m.Arena[:0], dAtA[iNdEx:postIndex]...)
			if m.Arena == nil {
				m.Arena = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content, Slice{})
			if err := m.Content[len(m.Content)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, Field{})
			if err := m.Partitions[len(m.Partitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveResponse_Flush) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flush: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flush: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveResponse_Prepare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveResponse_Commit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlow(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFlow
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFlow
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFlow
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFlow        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlow          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFlow = fmt.Errorf("proto: unexpected end of group")
)
