// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go/protocols/derive/derive.proto

package derive

import (
	context "context"
	encoding_json "encoding/json"
	fmt "fmt"
	flow "github.com/estuary/flow/go/protocols/flow"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	protocol "go.gazette.dev/core/consumer/protocol"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Request struct {
	Spec        *Request_Spec        `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	Validate    *Request_Validate    `protobuf:"bytes,2,opt,name=validate,proto3" json:"validate,omitempty"`
	Open        *Request_Open        `protobuf:"bytes,3,opt,name=open,proto3" json:"open,omitempty"`
	Read        *Request_Read        `protobuf:"bytes,4,opt,name=read,proto3" json:"read,omitempty"`
	Flush       *Request_Flush       `protobuf:"bytes,5,opt,name=flush,proto3" json:"flush,omitempty"`
	StartCommit *Request_StartCommit `protobuf:"bytes,6,opt,name=start_commit,json=startCommit,proto3" json:"start_commit,omitempty"`
	Reset_      *Request_Reset       `protobuf:"bytes,7,opt,name=reset,proto3" json:"reset,omitempty"`
	// Reserved for internal use.
	Internal             []byte   `protobuf:"bytes,100,opt,name=internal,json=$internal,proto3" json:"internal,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{0}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

// Spec requests the specification definition of this connector.
// Notably this includes its configuration JSON schemas.
type Request_Spec struct {
	// Connector type addressed by this request.
	ConnectorType flow.CollectionSpec_Derivation_ConnectorType `protobuf:"varint,1,opt,name=connector_type,json=connectorType,proto3,enum=flow.CollectionSpec_Derivation_ConnectorType" json:"connector_type,omitempty"`
	// Connector configuration, as an encoded JSON object.
	// This may be a partial specification (for example, a Docker image),
	// providing only enough information to fetch the remainder of the
	// specification schema.
	ConfigJson           encoding_json.RawMessage `protobuf:"bytes,2,opt,name=config_json,json=config,proto3,casttype=encoding/json.RawMessage" json:"config_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Request_Spec) Reset()         { *m = Request_Spec{} }
func (m *Request_Spec) String() string { return proto.CompactTextString(m) }
func (*Request_Spec) ProtoMessage()    {}
func (*Request_Spec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{0, 0}
}
func (m *Request_Spec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Spec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Spec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Spec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Spec.Merge(m, src)
}
func (m *Request_Spec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Spec) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Spec.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Spec proto.InternalMessageInfo

// Validate a derivation configuration and proposed transforms.
// Validate is run out-of-band with ongoing connector invocations.
// It's purpose is to confirm that the proposed configuration
// is likely to succeed if applied and run, or to report any
// potential issues for the user to address.
type Request_Validate struct {
	// Connector type addressed by this request.
	ConnectorType flow.CollectionSpec_Derivation_ConnectorType `protobuf:"varint,1,opt,name=connector_type,json=connectorType,proto3,enum=flow.CollectionSpec_Derivation_ConnectorType" json:"connector_type,omitempty"`
	// Connector configuration, as an encoded JSON object.
	ConfigJson encoding_json.RawMessage `protobuf:"bytes,2,opt,name=config_json,json=config,proto3,casttype=encoding/json.RawMessage" json:"config_json,omitempty"`
	// Collection to be derived.
	Collection flow.CollectionSpec           `protobuf:"bytes,3,opt,name=collection,proto3" json:"collection"`
	Transforms []*Request_Validate_Transform `protobuf:"bytes,4,rep,name=transforms,proto3" json:"transforms,omitempty"`
	// JSON types of shuffle key components extracted by the transforms of this derivation.
	ShuffleKeyTypes []flow.CollectionSpec_Derivation_ShuffleType `protobuf:"varint,5,rep,packed,name=shuffle_key_types,json=shuffleKeyTypes,proto3,enum=flow.CollectionSpec_Derivation_ShuffleType" json:"shuffle_key_types,omitempty"`
	// URL which roots the current Flow project.
	//
	// Derivation connectors should use this URL to generate any project-level
	// files which are returned with Response.Validated.generated_files.
	ProjectRoot string `protobuf:"bytes,6,opt,name=project_root,json=projectRoot,proto3" json:"project_root,omitempty"`
	// Map of relative JSON pointers to the derivation specification,
	// and the absolute URL from which the location's content was resolved.
	// Connectors may use this for generating more helpful errors which are
	// framed to the user's filesystem, rather than the filesystem within
	// the connector.
	ImportMap map[string]string `protobuf:"bytes,7,rep,name=import_map,json=importMap,proto3" json:"import_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Last CollectionSpec which was validated and published.
	LastCollection *flow.CollectionSpec `protobuf:"bytes,8,opt,name=last_collection,json=lastCollection,proto3" json:"last_collection,omitempty"`
	// Version of the last validated CollectionSpec.
	LastVersion          string   `protobuf:"bytes,9,opt,name=last_version,json=lastVersion,proto3" json:"last_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request_Validate) Reset()         { *m = Request_Validate{} }
func (m *Request_Validate) String() string { return proto.CompactTextString(m) }
func (*Request_Validate) ProtoMessage()    {}
func (*Request_Validate) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{0, 1}
}
func (m *Request_Validate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Validate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Validate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Validate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Validate.Merge(m, src)
}
func (m *Request_Validate) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Validate) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Validate.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Validate proto.InternalMessageInfo

type Request_Validate_Transform struct {
	// Stable name of this transform.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Sourced collection of this transform.
	Collection flow.CollectionSpec `protobuf:"bytes,2,opt,name=collection,proto3" json:"collection"`
	// JSON-encoded object which specifies the shuffle lambda configuration.
	// If this transform has no shuffle lambda, this is empty.
	ShuffleLambdaConfigJson encoding_json.RawMessage `protobuf:"bytes,3,opt,name=shuffle_lambda_config_json,json=shuffleLambdaConfig,proto3,casttype=encoding/json.RawMessage" json:"shuffle_lambda_config_json,omitempty"`
	// JSON-encoded object which specifies the lambda configuration.
	LambdaConfigJson encoding_json.RawMessage `protobuf:"bytes,4,opt,name=lambda_config_json,json=lambdaConfig,proto3,casttype=encoding/json.RawMessage" json:"lambda_config_json,omitempty"`
	// Backfill counter for this transform.
	Backfill             uint32   `protobuf:"varint,5,opt,name=backfill,proto3" json:"backfill,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request_Validate_Transform) Reset()         { *m = Request_Validate_Transform{} }
func (m *Request_Validate_Transform) String() string { return proto.CompactTextString(m) }
func (*Request_Validate_Transform) ProtoMessage()    {}
func (*Request_Validate_Transform) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{0, 1, 0}
}
func (m *Request_Validate_Transform) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Validate_Transform) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Validate_Transform.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Validate_Transform) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Validate_Transform.Merge(m, src)
}
func (m *Request_Validate_Transform) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Validate_Transform) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Validate_Transform.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Validate_Transform proto.InternalMessageInfo

// Open a derivation stream.
type Request_Open struct {
	// Collection to be derived.
	Collection *flow.CollectionSpec `protobuf:"bytes,1,opt,name=collection,proto3" json:"collection,omitempty"`
	// Version of the opened MaterializationSpec.
	// The driver may want to require that this match the version last
	// provided to a successful Apply RPC. It's possible that it won't,
	// due to expected propagation races in Flow's distributed runtime.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Range of documents to be processed by this invocation.
	Range *flow.RangeSpec `protobuf:"bytes,3,opt,name=range,proto3" json:"range,omitempty"`
	// Last-persisted connector checkpoint state from a previous invocation.
	StateJson            encoding_json.RawMessage `protobuf:"bytes,5,opt,name=state_json,json=state,proto3,casttype=encoding/json.RawMessage" json:"state_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Request_Open) Reset()         { *m = Request_Open{} }
func (m *Request_Open) String() string { return proto.CompactTextString(m) }
func (*Request_Open) ProtoMessage()    {}
func (*Request_Open) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{0, 2}
}
func (m *Request_Open) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Open) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Open.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Open) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Open.Merge(m, src)
}
func (m *Request_Open) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Open) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Open.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Open proto.InternalMessageInfo

// Read a document for one of the Opened transforms.
type Request_Read struct {
	// Index of the Open transform for which this document was read.
	Transform uint32 `protobuf:"varint,1,opt,name=transform,proto3" json:"transform,omitempty"`
	// Deconstructed document UUID.
	Uuid    *flow.UUIDParts       `protobuf:"bytes,2,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Shuffle *Request_Read_Shuffle `protobuf:"bytes,3,opt,name=shuffle,proto3" json:"shuffle,omitempty"`
	// JSON document which was read.
	DocJson              encoding_json.RawMessage `protobuf:"bytes,4,opt,name=doc_json,json=doc,proto3,casttype=encoding/json.RawMessage" json:"doc_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Request_Read) Reset()         { *m = Request_Read{} }
func (m *Request_Read) String() string { return proto.CompactTextString(m) }
func (*Request_Read) ProtoMessage()    {}
func (*Request_Read) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{0, 3}
}
func (m *Request_Read) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Read) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Read.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Read) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Read.Merge(m, src)
}
func (m *Request_Read) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Read) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Read.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Read proto.InternalMessageInfo

// Shuffle under which this document was mapped.
type Request_Read_Shuffle struct {
	// Shuffle key, as an array of key components.
	// Ordering matches `keys` of the materialization's field selection.
	KeyJson encoding_json.RawMessage `protobuf:"bytes,1,opt,name=key_json,json=key,proto3,casttype=encoding/json.RawMessage" json:"key_json,omitempty"`
	// Packed tuple of the document's shuffled key.
	Packed []byte `protobuf:"bytes,2,opt,name=packed,proto3" json:"packed,omitempty"`
	// Stable hash of this document's shuffle key, which falls within
	// `key_begin` and `key_end` of the Request.Open.
	Hash                 uint32   `protobuf:"varint,3,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request_Read_Shuffle) Reset()         { *m = Request_Read_Shuffle{} }
func (m *Request_Read_Shuffle) String() string { return proto.CompactTextString(m) }
func (*Request_Read_Shuffle) ProtoMessage()    {}
func (*Request_Read_Shuffle) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{0, 3, 0}
}
func (m *Request_Read_Shuffle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Read_Shuffle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Read_Shuffle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Read_Shuffle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Read_Shuffle.Merge(m, src)
}
func (m *Request_Read_Shuffle) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Read_Shuffle) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Read_Shuffle.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Read_Shuffle proto.InternalMessageInfo

// Flush tells the connector it should immediately complete any deferred
// work and respond with Published documents for all previously Read
// documents, and then respond with Flushed.
type Request_Flush struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request_Flush) Reset()         { *m = Request_Flush{} }
func (m *Request_Flush) String() string { return proto.CompactTextString(m) }
func (*Request_Flush) ProtoMessage()    {}
func (*Request_Flush) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{0, 4}
}
func (m *Request_Flush) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Flush) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Flush.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Flush) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Flush.Merge(m, src)
}
func (m *Request_Flush) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Flush) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Flush.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Flush proto.InternalMessageInfo

// StartCommit indicates that the Flow runtime is beginning to commit.
// The checkpoint is purely advisory and the connector is not required to touch it.
// The connector responds with StartedCommit.
type Request_StartCommit struct {
	// Flow runtime checkpoint associated with this transaction.
	RuntimeCheckpoint    *protocol.Checkpoint `protobuf:"bytes,1,opt,name=runtime_checkpoint,json=runtimeCheckpoint,proto3" json:"runtime_checkpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Request_StartCommit) Reset()         { *m = Request_StartCommit{} }
func (m *Request_StartCommit) String() string { return proto.CompactTextString(m) }
func (*Request_StartCommit) ProtoMessage()    {}
func (*Request_StartCommit) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{0, 5}
}
func (m *Request_StartCommit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_StartCommit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_StartCommit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_StartCommit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_StartCommit.Merge(m, src)
}
func (m *Request_StartCommit) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_StartCommit) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_StartCommit.DiscardUnknown(m)
}

var xxx_messageInfo_Request_StartCommit proto.InternalMessageInfo

// Reset any internal state, as if the derivation were just initialized.
// This is used only when running Flow tests, and clears the effects of
// one test before running the next.
type Request_Reset struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request_Reset) Reset()         { *m = Request_Reset{} }
func (m *Request_Reset) String() string { return proto.CompactTextString(m) }
func (*Request_Reset) ProtoMessage()    {}
func (*Request_Reset) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{0, 6}
}
func (m *Request_Reset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Reset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Reset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Reset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Reset.Merge(m, src)
}
func (m *Request_Reset) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Reset) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Reset.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Reset proto.InternalMessageInfo

type Response struct {
	Spec          *Response_Spec          `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	Validated     *Response_Validated     `protobuf:"bytes,2,opt,name=validated,proto3" json:"validated,omitempty"`
	Opened        *Response_Opened        `protobuf:"bytes,3,opt,name=opened,proto3" json:"opened,omitempty"`
	Published     *Response_Published     `protobuf:"bytes,4,opt,name=published,proto3" json:"published,omitempty"`
	Flushed       *Response_Flushed       `protobuf:"bytes,5,opt,name=flushed,proto3" json:"flushed,omitempty"`
	StartedCommit *Response_StartedCommit `protobuf:"bytes,6,opt,name=started_commit,json=startedCommit,proto3" json:"started_commit,omitempty"`
	// Reserved for internal use.
	Internal             []byte   `protobuf:"bytes,100,opt,name=internal,json=$internal,proto3" json:"internal,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{1}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

// Spec responds to Request.Spec.
type Response_Spec struct {
	// Protocol version must be 3032023.
	Protocol uint32 `protobuf:"varint,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// JSON schema of the connector's configuration.
	ConfigSchemaJson encoding_json.RawMessage `protobuf:"bytes,2,opt,name=config_schema_json,json=configSchema,proto3,casttype=encoding/json.RawMessage" json:"config_schema_json,omitempty"`
	// JSON schema of the connector's lambda configuration.
	// The "resource" terminology is used with Response.Spec
	// only for symmetry with the capture and materialization protocols.
	// NOTE(johnny): We can encapsulate separate lambda config vs
	// shuffle lambda config schemas by encapsulating them as separate
	// definitions within the resource config schema.
	ResourceConfigSchemaJson encoding_json.RawMessage `protobuf:"bytes,3,opt,name=resource_config_schema_json,json=resourceConfigSchema,proto3,casttype=encoding/json.RawMessage" json:"resource_config_schema_json,omitempty"`
	// URL for connector's documention.
	DocumentationUrl string `protobuf:"bytes,4,opt,name=documentation_url,json=documentationUrl,proto3" json:"documentation_url,omitempty"`
	// Optional OAuth2 configuration.
	Oauth2               *flow.OAuth2 `protobuf:"bytes,5,opt,name=oauth2,proto3" json:"oauth2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Response_Spec) Reset()         { *m = Response_Spec{} }
func (m *Response_Spec) String() string { return proto.CompactTextString(m) }
func (*Response_Spec) ProtoMessage()    {}
func (*Response_Spec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{1, 0}
}
func (m *Response_Spec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Spec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Spec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Spec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Spec.Merge(m, src)
}
func (m *Response_Spec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Spec) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Spec.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Spec proto.InternalMessageInfo

// Validated responds to Request.Validate.
type Response_Validated struct {
	Transforms []*Response_Validated_Transform `protobuf:"bytes,1,rep,name=transforms,proto3" json:"transforms,omitempty"`
	// Generated files returned by the connector.
	// Keys are absolute URLs of the generated resource, and values are its
	// generated file content.
	//
	// This can include project-level files, which should be underneath
	// Request.Validate.project_root.
	//
	// When run in certain contexts within a user's local development environment,
	// reads of Flow specifications use a relaxed handling for missing configuration
	// files: rather than failing due to a missing file, the config file is instead
	// resolved into an absolute URL of where the file is *expected* to live.
	// The connector should handle these missing configs by generating and returning
	// stub implementations of these files at those URLs.
	GeneratedFiles       map[string]string `protobuf:"bytes,2,rep,name=generated_files,json=generatedFiles,proto3" json:"generated_files,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Response_Validated) Reset()         { *m = Response_Validated{} }
func (m *Response_Validated) String() string { return proto.CompactTextString(m) }
func (*Response_Validated) ProtoMessage()    {}
func (*Response_Validated) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{1, 1}
}
func (m *Response_Validated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Validated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Validated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Validated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Validated.Merge(m, src)
}
func (m *Response_Validated) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Validated) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Validated.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Validated proto.InternalMessageInfo

type Response_Validated_Transform struct {
	// Is this transform known to be read-only?
	ReadOnly             bool     `protobuf:"varint,1,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response_Validated_Transform) Reset()         { *m = Response_Validated_Transform{} }
func (m *Response_Validated_Transform) String() string { return proto.CompactTextString(m) }
func (*Response_Validated_Transform) ProtoMessage()    {}
func (*Response_Validated_Transform) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{1, 1, 0}
}
func (m *Response_Validated_Transform) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Validated_Transform) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Validated_Transform.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Validated_Transform) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Validated_Transform.Merge(m, src)
}
func (m *Response_Validated_Transform) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Validated_Transform) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Validated_Transform.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Validated_Transform proto.InternalMessageInfo

// Opened responds to Request.Open.
type Response_Opened struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response_Opened) Reset()         { *m = Response_Opened{} }
func (m *Response_Opened) String() string { return proto.CompactTextString(m) }
func (*Response_Opened) ProtoMessage()    {}
func (*Response_Opened) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{1, 2}
}
func (m *Response_Opened) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Opened) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Opened.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Opened) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Opened.Merge(m, src)
}
func (m *Response_Opened) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Opened) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Opened.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Opened proto.InternalMessageInfo

type Response_Published struct {
	// Published JSON document.
	DocJson              encoding_json.RawMessage `protobuf:"bytes,1,opt,name=doc_json,json=doc,proto3,casttype=encoding/json.RawMessage" json:"doc_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Response_Published) Reset()         { *m = Response_Published{} }
func (m *Response_Published) String() string { return proto.CompactTextString(m) }
func (*Response_Published) ProtoMessage()    {}
func (*Response_Published) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{1, 3}
}
func (m *Response_Published) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Published) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Published.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Published) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Published.Merge(m, src)
}
func (m *Response_Published) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Published) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Published.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Published proto.InternalMessageInfo

// Flushed responds to Request.Flush, and indicates that all documents
// have been published.
type Response_Flushed struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response_Flushed) Reset()         { *m = Response_Flushed{} }
func (m *Response_Flushed) String() string { return proto.CompactTextString(m) }
func (*Response_Flushed) ProtoMessage()    {}
func (*Response_Flushed) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{1, 4}
}
func (m *Response_Flushed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Flushed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Flushed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Flushed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Flushed.Merge(m, src)
}
func (m *Response_Flushed) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Flushed) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Flushed.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Flushed proto.InternalMessageInfo

// StartedCommit responds to a Request.StartCommit, and includes an optional
// connector state update.
type Response_StartedCommit struct {
	State                *flow.ConnectorState `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Response_StartedCommit) Reset()         { *m = Response_StartedCommit{} }
func (m *Response_StartedCommit) String() string { return proto.CompactTextString(m) }
func (*Response_StartedCommit) ProtoMessage()    {}
func (*Response_StartedCommit) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410d076c75e1e4f, []int{1, 5}
}
func (m *Response_StartedCommit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_StartedCommit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_StartedCommit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_StartedCommit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_StartedCommit.Merge(m, src)
}
func (m *Response_StartedCommit) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_StartedCommit) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_StartedCommit.DiscardUnknown(m)
}

var xxx_messageInfo_Response_StartedCommit proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Request)(nil), "derive.Request")
	proto.RegisterType((*Request_Spec)(nil), "derive.Request.Spec")
	proto.RegisterType((*Request_Validate)(nil), "derive.Request.Validate")
	proto.RegisterMapType((map[string]string)(nil), "derive.Request.Validate.ImportMapEntry")
	proto.RegisterType((*Request_Validate_Transform)(nil), "derive.Request.Validate.Transform")
	proto.RegisterType((*Request_Open)(nil), "derive.Request.Open")
	proto.RegisterType((*Request_Read)(nil), "derive.Request.Read")
	proto.RegisterType((*Request_Read_Shuffle)(nil), "derive.Request.Read.Shuffle")
	proto.RegisterType((*Request_Flush)(nil), "derive.Request.Flush")
	proto.RegisterType((*Request_StartCommit)(nil), "derive.Request.StartCommit")
	proto.RegisterType((*Request_Reset)(nil), "derive.Request.Reset")
	proto.RegisterType((*Response)(nil), "derive.Response")
	proto.RegisterType((*Response_Spec)(nil), "derive.Response.Spec")
	proto.RegisterType((*Response_Validated)(nil), "derive.Response.Validated")
	proto.RegisterMapType((map[string]string)(nil), "derive.Response.Validated.GeneratedFilesEntry")
	proto.RegisterType((*Response_Validated_Transform)(nil), "derive.Response.Validated.Transform")
	proto.RegisterType((*Response_Opened)(nil), "derive.Response.Opened")
	proto.RegisterType((*Response_Published)(nil), "derive.Response.Published")
	proto.RegisterType((*Response_Flushed)(nil), "derive.Response.Flushed")
	proto.RegisterType((*Response_StartedCommit)(nil), "derive.Response.StartedCommit")
}

func init() { proto.RegisterFile("go/protocols/derive/derive.proto", fileDescriptor_4410d076c75e1e4f) }

var fileDescriptor_4410d076c75e1e4f = []byte{
	// 1287 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xef, 0x3a, 0xfe, 0xb3, 0xfb, 0xe2, 0x38, 0xe9, 0x34, 0xc0, 0x6a, 0x13, 0xa5, 0xa1, 0x14,
	0x61, 0x88, 0x70, 0x90, 0x5b, 0x41, 0x29, 0x2d, 0xa2, 0x71, 0x1b, 0x54, 0xa0, 0x4a, 0x35, 0x69,
	0x5a, 0x89, 0x8b, 0x35, 0xd9, 0x1d, 0xdb, 0xdb, 0xac, 0x77, 0x96, 0x9d, 0xd9, 0x54, 0xfe, 0x22,
	0x94, 0x03, 0x07, 0xc4, 0x87, 0xe0, 0xca, 0xb5, 0x47, 0x3e, 0x41, 0x25, 0xca, 0x99, 0x2f, 0xc0,
	0x09, 0xcd, 0x9f, 0x5d, 0xdb, 0xb1, 0x53, 0xdc, 0x1b, 0x97, 0x64, 0xde, 0x7b, 0xbf, 0xf7, 0x66,
	0xf6, 0xbd, 0x37, 0xef, 0x37, 0x86, 0xed, 0x3e, 0xdb, 0x4d, 0x52, 0x26, 0x98, 0xcf, 0x22, 0xbe,
	0x1b, 0xd0, 0x34, 0x3c, 0xa5, 0xe6, 0x5f, 0x4b, 0xe9, 0x51, 0x55, 0x4b, 0xde, 0xb6, 0xcf, 0x62,
	0x9e, 0x0d, 0x69, 0x5a, 0xe0, 0x8b, 0x85, 0x46, 0x7a, 0x9b, 0x53, 0xb1, 0x7a, 0x11, 0x7b, 0xa6,
	0xfe, 0x18, 0xeb, 0x7a, 0x9f, 0xf5, 0x99, 0x5a, 0xee, 0xca, 0x95, 0xd6, 0x5e, 0xf9, 0x7b, 0x15,
	0x6a, 0x98, 0xfe, 0x90, 0x51, 0x2e, 0x50, 0x13, 0xca, 0x3c, 0xa1, 0xbe, 0x6b, 0x6d, 0x5b, 0xcd,
	0xe5, 0xf6, 0x7a, 0xcb, 0x1c, 0xc3, 0x98, 0x5b, 0x87, 0x09, 0xf5, 0xb1, 0x42, 0xa0, 0xeb, 0x60,
	0x9f, 0x92, 0x28, 0x0c, 0x88, 0xa0, 0x6e, 0x49, 0xa1, 0xdd, 0xb3, 0xe8, 0xc7, 0xc6, 0x8e, 0x0b,
	0xa4, 0x8c, 0xcf, 0x12, 0x1a, 0xbb, 0x4b, 0xf3, 0xe3, 0x1f, 0x24, 0x34, 0xc6, 0x0a, 0x21, 0x91,
	0x29, 0x25, 0x81, 0x5b, 0x9e, 0x8f, 0xc4, 0x94, 0x04, 0x58, 0x21, 0xd0, 0x0e, 0x54, 0x7a, 0x51,
	0xc6, 0x07, 0x6e, 0x45, 0x41, 0xdf, 0x3a, 0x0b, 0xdd, 0x97, 0x46, 0xac, 0x31, 0xe8, 0x4b, 0xa8,
	0x73, 0x41, 0x52, 0xd1, 0xf5, 0xd9, 0x70, 0x18, 0x0a, 0xb7, 0xaa, 0x7c, 0x36, 0x66, 0x3e, 0x54,
	0x62, 0x3a, 0x0a, 0x82, 0x97, 0xf9, 0x58, 0x90, 0x9b, 0xa5, 0x94, 0x53, 0xe1, 0xd6, 0xe6, 0x6f,
	0x86, 0xa5, 0x11, 0x6b, 0x0c, 0xda, 0x00, 0x3b, 0x8c, 0x05, 0x4d, 0x63, 0x12, 0xb9, 0xc1, 0xb6,
	0xd5, 0xac, 0x63, 0xe7, 0x6a, 0xae, 0xf0, 0x9e, 0x5b, 0x50, 0x96, 0xf9, 0x44, 0x8f, 0xa0, 0xe1,
	0xb3, 0x38, 0xa6, 0xbe, 0x60, 0x69, 0x57, 0x8c, 0x12, 0xaa, 0xb2, 0xdf, 0x68, 0x7f, 0xdc, 0x52,
	0xa5, 0xeb, 0xb0, 0x28, 0xa2, 0xbe, 0x08, 0x59, 0x2c, 0xd1, 0xad, 0xbb, 0x72, 0x3f, 0x22, 0xc5,
	0x56, 0x27, 0xf7, 0x7a, 0x34, 0x4a, 0x28, 0x5e, 0xf1, 0x27, 0x45, 0xf4, 0x39, 0x2c, 0xfb, 0x2c,
	0xee, 0x85, 0xfd, 0xee, 0x53, 0xce, 0x62, 0x55, 0x22, 0x67, 0x6f, 0xf3, 0x9f, 0x97, 0x97, 0x5d,
	0x1a, 0xfb, 0x2c, 0x08, 0xe3, 0xfe, 0xae, 0x34, 0xb4, 0x30, 0x79, 0xf6, 0x80, 0x72, 0x4e, 0xfa,
	0x14, 0x57, 0xb5, 0x83, 0xf7, 0x53, 0x0d, 0xec, 0xbc, 0x76, 0xff, 0xbb, 0xd3, 0xa1, 0x9b, 0x00,
	0x7e, 0xb1, 0x69, 0xd1, 0x48, 0x73, 0x0e, 0xb3, 0x57, 0x7e, 0xf1, 0xf2, 0xf2, 0x05, 0x3c, 0x81,
	0x46, 0x7b, 0x00, 0x22, 0x25, 0x31, 0xef, 0xb1, 0x74, 0xc8, 0xdd, 0xf2, 0xf6, 0x52, 0x73, 0xb9,
	0x7d, 0xe5, 0xbc, 0xb6, 0x6d, 0x3d, 0xca, 0xa1, 0x78, 0xc2, 0x0b, 0x3d, 0x81, 0x8b, 0x7c, 0x90,
	0xf5, 0x7a, 0x11, 0xed, 0x9e, 0xd0, 0x91, 0x4a, 0x09, 0x77, 0x2b, 0xdb, 0x4b, 0xcd, 0x46, 0x7b,
	0xe7, 0xbf, 0x72, 0x72, 0xa8, 0x1d, 0x55, 0x46, 0x56, 0x4d, 0x94, 0x6f, 0xe9, 0x48, 0xca, 0x1c,
	0xbd, 0x0b, 0xf5, 0x24, 0x65, 0x4f, 0xa9, 0x2f, 0xba, 0x29, 0x63, 0xba, 0x35, 0x1d, 0xbc, 0x6c,
	0x74, 0x98, 0x31, 0x81, 0xf6, 0x01, 0xc2, 0x61, 0xc2, 0x52, 0xd1, 0x1d, 0x92, 0xc4, 0xad, 0xa9,
	0xf3, 0x7f, 0x70, 0xee, 0xf9, 0xef, 0x2b, 0xe8, 0x03, 0x92, 0xdc, 0x8b, 0x45, 0x3a, 0xc2, 0x4e,
	0x98, 0xcb, 0xe8, 0x36, 0xac, 0x46, 0x84, 0xcb, 0x4b, 0x50, 0x24, 0xd2, 0x3e, 0x3f, 0x91, 0xb8,
	0x21, 0xc1, 0x63, 0x9d, 0x3c, 0xa9, 0x72, 0x3f, 0xa5, 0x29, 0x97, 0xbe, 0x8e, 0x3e, 0xa9, 0xd4,
	0x3d, 0xd6, 0x2a, 0xef, 0xc7, 0x12, 0x38, 0x45, 0xfe, 0x10, 0x82, 0x72, 0x4c, 0x86, 0xba, 0x75,
	0x1c, 0xac, 0xd6, 0x67, 0xea, 0x58, 0x7a, 0xa3, 0x3a, 0x1e, 0x81, 0x97, 0xd7, 0x20, 0x22, 0xc3,
	0xe3, 0x80, 0x74, 0x27, 0xbb, 0x69, 0x69, 0x81, 0x6e, 0xba, 0x64, 0xfc, 0xbf, 0x53, 0xee, 0x1d,
	0xdd, 0x5a, 0xfb, 0x80, 0xe6, 0x84, 0x2b, 0x2f, 0x10, 0xae, 0x1e, 0x4d, 0xc6, 0xf1, 0xc0, 0x3e,
	0x26, 0xfe, 0x49, 0x2f, 0x8c, 0x22, 0x35, 0x94, 0x56, 0x70, 0x21, 0x7b, 0xb7, 0xa0, 0x31, 0x5d,
	0x17, 0xb4, 0x06, 0x4b, 0x27, 0x74, 0x64, 0x72, 0x23, 0x97, 0x68, 0x1d, 0x2a, 0xa7, 0x24, 0xca,
	0xf4, 0x60, 0x75, 0xb0, 0x16, 0x6e, 0x96, 0x6e, 0x58, 0xde, 0x6f, 0x16, 0x94, 0xe5, 0x90, 0x44,
	0xd7, 0xa7, 0xb2, 0x67, 0xbd, 0xa6, 0x78, 0x93, 0x79, 0x73, 0xa1, 0x96, 0xd7, 0x4c, 0x87, 0xce,
	0x45, 0xf4, 0x3e, 0x54, 0x52, 0x12, 0xf7, 0xa9, 0xb9, 0x50, 0xab, 0x3a, 0x14, 0x96, 0x2a, 0x15,
	0x45, 0x5b, 0xd1, 0x67, 0x00, 0x5c, 0x10, 0x41, 0x75, 0x66, 0x2a, 0x0b, 0x64, 0xa6, 0xa2, 0xf0,
	0xde, 0xaf, 0x25, 0x28, 0xcb, 0x99, 0x8d, 0x36, 0xc1, 0x29, 0x2e, 0x93, 0x3a, 0xf7, 0x0a, 0x1e,
	0x2b, 0xd0, 0x7b, 0x50, 0xce, 0xb2, 0x30, 0x30, 0xed, 0x60, 0x4e, 0x71, 0x74, 0x74, 0xff, 0xee,
	0x43, 0x92, 0x0a, 0x8e, 0x95, 0x11, 0x7d, 0x0a, 0x35, 0x53, 0x3d, 0x73, 0xda, 0xcd, 0x79, 0xec,
	0x90, 0x5f, 0x36, 0x9c, 0x83, 0xd1, 0x35, 0xb0, 0x03, 0xe6, 0x2f, 0x5e, 0xd4, 0xa5, 0x80, 0xf9,
	0xde, 0x53, 0xa8, 0x1d, 0x8e, 0xfd, 0xe5, 0x8d, 0x57, 0xfe, 0xd6, 0x22, 0xfe, 0xb2, 0x96, 0x6f,
	0x43, 0x35, 0x21, 0xfe, 0x09, 0xd5, 0xdf, 0x54, 0xc7, 0x46, 0x92, 0x57, 0x62, 0x40, 0xf8, 0x40,
	0x7d, 0xc1, 0x0a, 0x56, 0x6b, 0xaf, 0x06, 0x15, 0x45, 0x56, 0x1e, 0x86, 0xe5, 0x09, 0x06, 0x42,
	0x1d, 0x40, 0x69, 0x16, 0x8b, 0x70, 0x48, 0xbb, 0xfe, 0x80, 0xfa, 0x27, 0x09, 0x0b, 0x63, 0x51,
	0x14, 0x3d, 0x7f, 0x14, 0xb4, 0x3a, 0x85, 0x0d, 0x5f, 0x34, 0xf8, 0xb1, 0x4a, 0x06, 0x57, 0xe4,
	0x74, 0xe5, 0x77, 0x1b, 0x6c, 0x4c, 0x79, 0xc2, 0x62, 0x4e, 0xd1, 0x87, 0x53, 0x84, 0x3f, 0x41,
	0x67, 0xda, 0x3e, 0xc9, 0xf8, 0x37, 0xc0, 0xc9, 0x79, 0x3c, 0x2f, 0x90, 0x37, 0x83, 0xcf, 0x87,
	0x4f, 0x80, 0xc7, 0x60, 0xb4, 0x0b, 0x55, 0xc9, 0xe9, 0x34, 0x30, 0xf5, 0x7a, 0x67, 0xc6, 0xed,
	0x40, 0x99, 0xb1, 0x81, 0xc9, 0xad, 0x92, 0xec, 0x38, 0x0a, 0xf9, 0x80, 0xe6, 0x2f, 0x80, 0xd9,
	0xad, 0x1e, 0xe6, 0x08, 0x3c, 0x06, 0xa3, 0x36, 0xd4, 0x14, 0xd1, 0xd3, 0xc0, 0x3c, 0x07, 0xdc,
	0x19, 0xbf, 0x7d, 0x6d, 0xc7, 0x39, 0x10, 0xdd, 0x83, 0x86, 0xa2, 0x78, 0x1a, 0x4c, 0xbf, 0x0a,
	0xb6, 0x66, 0xb3, 0xa1, 0x61, 0xe6, 0x61, 0xb0, 0xc2, 0x27, 0xc5, 0xd7, 0xb3, 0xfd, 0xcf, 0x25,
	0xc3, 0xf6, 0x1e, 0xd8, 0xf9, 0x03, 0xcd, 0xb4, 0x7f, 0x21, 0xcb, 0xf9, 0x63, 0x06, 0x0f, 0xf7,
	0x07, 0x74, 0x48, 0x16, 0x27, 0xc7, 0xba, 0xf6, 0x3b, 0x54, 0x6e, 0xe8, 0x09, 0x6c, 0xa4, 0x94,
	0xb3, 0x2c, 0xf5, 0x69, 0x77, 0x4e, 0xc0, 0x45, 0xe6, 0xe3, 0x7a, 0x1e, 0xa0, 0x33, 0x19, 0x78,
	0x07, 0x2e, 0x06, 0xcc, 0xcf, 0x86, 0x34, 0x16, 0x8a, 0xd0, 0xba, 0x59, 0x1a, 0xe9, 0xab, 0x84,
	0xd7, 0xa6, 0x0c, 0x47, 0x69, 0x84, 0xae, 0x42, 0x95, 0x91, 0x4c, 0x0c, 0xda, 0xa6, 0x12, 0x75,
	0x7d, 0x9b, 0x0f, 0xee, 0x48, 0x1d, 0x36, 0xb6, 0x6f, 0xca, 0x76, 0x75, 0xad, 0xe6, 0x3d, 0x2f,
	0x81, 0x53, 0xb4, 0x0e, 0xba, 0x3b, 0x45, 0xd3, 0x96, 0xa2, 0xb9, 0xab, 0xe7, 0xb7, 0xda, 0xb9,
	0x44, 0xbd, 0xda, 0xa7, 0x31, 0x4d, 0x25, 0xa4, 0xdb, 0x0b, 0x23, 0xca, 0xdd, 0x92, 0x0a, 0xd5,
	0x7a, 0x4d, 0xa8, 0xaf, 0x73, 0x8f, 0x7d, 0xe9, 0xa0, 0x89, 0xb3, 0xd1, 0x9f, 0x52, 0x7a, 0xcd,
	0x49, 0x6a, 0xdb, 0x00, 0x47, 0xbe, 0x42, 0xbb, 0x2c, 0x8e, 0xf4, 0x0c, 0xb7, 0xb1, 0x2d, 0x15,
	0x07, 0x71, 0x34, 0xf2, 0xee, 0xc0, 0xa5, 0x39, 0x01, 0xdf, 0x68, 0xe2, 0xdb, 0x50, 0xd5, 0x97,
	0xc3, 0xfb, 0x0a, 0x9c, 0xa2, 0xe5, 0xa7, 0x66, 0x99, 0xb5, 0xe8, 0x2c, 0x73, 0xa0, 0x66, 0x9a,
	0xdf, 0xfb, 0x02, 0x56, 0xa6, 0x9a, 0x19, 0x7d, 0x04, 0x7a, 0x52, 0x9f, 0xe5, 0x12, 0xf3, 0x6a,
	0x3b, 0x94, 0x36, 0x33, 0xcc, 0xdb, 0xb7, 0xc0, 0x29, 0x0c, 0xf2, 0x72, 0xab, 0x17, 0x0e, 0x45,
	0xab, 0x67, 0xc6, 0xb0, 0xb7, 0x76, 0x36, 0xd1, 0x4d, 0xeb, 0x13, 0x6b, 0xef, 0xf6, 0x8b, 0x3f,
	0xb7, 0x2e, 0xbc, 0x78, 0xb5, 0x65, 0xfd, 0xf1, 0x6a, 0xcb, 0xfa, 0xe5, 0xaf, 0x2d, 0xeb, 0xfb,
	0x9d, 0x7e, 0x28, 0x06, 0xd9, 0x71, 0xcb, 0x67, 0xc3, 0x5d, 0xca, 0x45, 0x46, 0xd2, 0x91, 0xfe,
	0xed, 0x32, 0xe7, 0x97, 0xd1, 0x71, 0x55, 0x69, 0xae, 0xfd, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x72,
	0x38, 0xa4, 0x72, 0x37, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ConnectorClient is the client API for Connector service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ConnectorClient interface {
	Derive(ctx context.Context, opts ...grpc.CallOption) (Connector_DeriveClient, error)
}

type connectorClient struct {
	cc *grpc.ClientConn
}

func NewConnectorClient(cc *grpc.ClientConn) ConnectorClient {
	return &connectorClient{cc}
}

func (c *connectorClient) Derive(ctx context.Context, opts ...grpc.CallOption) (Connector_DeriveClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Connector_serviceDesc.Streams[0], "/derive.Connector/Derive", opts...)
	if err != nil {
		return nil, err
	}
	x := &connectorDeriveClient{stream}
	return x, nil
}

type Connector_DeriveClient interface {
	Send(*Request) error
	Recv() (*Response, error)
	grpc.ClientStream
}

type connectorDeriveClient struct {
	grpc.ClientStream
}

func (x *connectorDeriveClient) Send(m *Request) error {
	return x.ClientStream.SendMsg(m)
}

func (x *connectorDeriveClient) Recv() (*Response, error) {
	m := new(Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ConnectorServer is the server API for Connector service.
type ConnectorServer interface {
	Derive(Connector_DeriveServer) error
}

// UnimplementedConnectorServer can be embedded to have forward compatible implementations.
type UnimplementedConnectorServer struct {
}

func (*UnimplementedConnectorServer) Derive(srv Connector_DeriveServer) error {
	return status.Errorf(codes.Unimplemented, "method Derive not implemented")
}

func RegisterConnectorServer(s *grpc.Server, srv ConnectorServer) {
	s.RegisterService(&_Connector_serviceDesc, srv)
}

func _Connector_Derive_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ConnectorServer).Derive(&connectorDeriveServer{stream})
}

type Connector_DeriveServer interface {
	Send(*Response) error
	Recv() (*Request, error)
	grpc.ServerStream
}

type connectorDeriveServer struct {
	grpc.ServerStream
}

func (x *connectorDeriveServer) Send(m *Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *connectorDeriveServer) Recv() (*Request, error) {
	m := new(Request)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Connector_serviceDesc = grpc.ServiceDesc{
	ServiceName: "derive.Connector",
	HandlerType: (*ConnectorServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Derive",
			Handler:       _Connector_Derive_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "go/protocols/derive/derive.proto",
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Internal) > 0 {
		i -= len(m.Internal)
		copy(dAtA[i:], m.Internal)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.Internal)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if m.Reset_ != nil {
		{
			size, err := m.Reset_.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.StartCommit != nil {
		{
			size, err := m.StartCommit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Flush != nil {
		{
			size, err := m.Flush.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Read != nil {
		{
			size, err := m.Read.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Open != nil {
		{
			size, err := m.Open.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Validate != nil {
		{
			size, err := m.Validate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request_Spec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Spec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Spec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ConfigJson) > 0 {
		i -= len(m.ConfigJson)
		copy(dAtA[i:], m.ConfigJson)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.ConfigJson)))
		i--
		dAtA[i] = 0x12
	}
	if m.ConnectorType != 0 {
		i = encodeVarintDerive(dAtA, i, uint64(m.ConnectorType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request_Validate) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Validate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Validate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LastVersion) > 0 {
		i -= len(m.LastVersion)
		copy(dAtA[i:], m.LastVersion)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.LastVersion)))
		i--
		dAtA[i] = 0x4a
	}
	if m.LastCollection != nil {
		{
			size, err := m.LastCollection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.ImportMap) > 0 {
		for k := range m.ImportMap {
			v := m.ImportMap[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintDerive(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDerive(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDerive(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ProjectRoot) > 0 {
		i -= len(m.ProjectRoot)
		copy(dAtA[i:], m.ProjectRoot)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.ProjectRoot)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ShuffleKeyTypes) > 0 {
		dAtA10 := make([]byte, len(m.ShuffleKeyTypes)*10)
		var j9 int
		for _, num := range m.ShuffleKeyTypes {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintDerive(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Transforms) > 0 {
		for iNdEx := len(m.Transforms) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Transforms[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDerive(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.Collection.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintDerive(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.ConfigJson) > 0 {
		i -= len(m.ConfigJson)
		copy(dAtA[i:], m.ConfigJson)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.ConfigJson)))
		i--
		dAtA[i] = 0x12
	}
	if m.ConnectorType != 0 {
		i = encodeVarintDerive(dAtA, i, uint64(m.ConnectorType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request_Validate_Transform) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Validate_Transform) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Validate_Transform) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Backfill != 0 {
		i = encodeVarintDerive(dAtA, i, uint64(m.Backfill))
		i--
		dAtA[i] = 0x28
	}
	if len(m.LambdaConfigJson) > 0 {
		i -= len(m.LambdaConfigJson)
		copy(dAtA[i:], m.LambdaConfigJson)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.LambdaConfigJson)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ShuffleLambdaConfigJson) > 0 {
		i -= len(m.ShuffleLambdaConfigJson)
		copy(dAtA[i:], m.ShuffleLambdaConfigJson)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.ShuffleLambdaConfigJson)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Collection.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintDerive(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request_Open) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Open) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Open) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StateJson) > 0 {
		i -= len(m.StateJson)
		copy(dAtA[i:], m.StateJson)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.StateJson)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if m.Collection != nil {
		{
			size, err := m.Collection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request_Read) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Read) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Read) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DocJson) > 0 {
		i -= len(m.DocJson)
		copy(dAtA[i:], m.DocJson)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.DocJson)))
		i--
		dAtA[i] = 0x22
	}
	if m.Shuffle != nil {
		{
			size, err := m.Shuffle.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Uuid != nil {
		{
			size, err := m.Uuid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Transform != 0 {
		i = encodeVarintDerive(dAtA, i, uint64(m.Transform))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request_Read_Shuffle) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Read_Shuffle) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Read_Shuffle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Hash != 0 {
		i = encodeVarintDerive(dAtA, i, uint64(m.Hash))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Packed) > 0 {
		i -= len(m.Packed)
		copy(dAtA[i:], m.Packed)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.Packed)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KeyJson) > 0 {
		i -= len(m.KeyJson)
		copy(dAtA[i:], m.KeyJson)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.KeyJson)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request_Flush) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Flush) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Flush) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Request_StartCommit) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_StartCommit) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_StartCommit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RuntimeCheckpoint != nil {
		{
			size, err := m.RuntimeCheckpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request_Reset) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Reset) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Reset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Internal) > 0 {
		i -= len(m.Internal)
		copy(dAtA[i:], m.Internal)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.Internal)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if m.StartedCommit != nil {
		{
			size, err := m.StartedCommit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Flushed != nil {
		{
			size, err := m.Flushed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Published != nil {
		{
			size, err := m.Published.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Opened != nil {
		{
			size, err := m.Opened.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Validated != nil {
		{
			size, err := m.Validated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response_Spec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Spec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Spec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Oauth2 != nil {
		{
			size, err := m.Oauth2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DocumentationUrl) > 0 {
		i -= len(m.DocumentationUrl)
		copy(dAtA[i:], m.DocumentationUrl)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.DocumentationUrl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ResourceConfigSchemaJson) > 0 {
		i -= len(m.ResourceConfigSchemaJson)
		copy(dAtA[i:], m.ResourceConfigSchemaJson)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.ResourceConfigSchemaJson)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ConfigSchemaJson) > 0 {
		i -= len(m.ConfigSchemaJson)
		copy(dAtA[i:], m.ConfigSchemaJson)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.ConfigSchemaJson)))
		i--
		dAtA[i] = 0x12
	}
	if m.Protocol != 0 {
		i = encodeVarintDerive(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Response_Validated) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Validated) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Validated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GeneratedFiles) > 0 {
		for k := range m.GeneratedFiles {
			v := m.GeneratedFiles[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintDerive(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDerive(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDerive(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Transforms) > 0 {
		for iNdEx := len(m.Transforms) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Transforms[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDerive(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Response_Validated_Transform) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Validated_Transform) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Validated_Transform) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReadOnly {
		i--
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Response_Opened) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Opened) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Opened) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Response_Published) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Published) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Published) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DocJson) > 0 {
		i -= len(m.DocJson)
		copy(dAtA[i:], m.DocJson)
		i = encodeVarintDerive(dAtA, i, uint64(len(m.DocJson)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response_Flushed) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Flushed) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Flushed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Response_StartedCommit) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_StartedCommit) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_StartedCommit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDerive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDerive(dAtA []byte, offset int, v uint64) int {
	offset -= sovDerive(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Request) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.Validate != nil {
		l = m.Validate.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.Open != nil {
		l = m.Open.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.Read != nil {
		l = m.Read.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.Flush != nil {
		l = m.Flush.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.StartCommit != nil {
		l = m.StartCommit.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.Reset_ != nil {
		l = m.Reset_.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	l = len(m.Internal)
	if l > 0 {
		n += 2 + l + sovDerive(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Spec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectorType != 0 {
		n += 1 + sovDerive(uint64(m.ConnectorType))
	}
	l = len(m.ConfigJson)
	if l > 0 {
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Validate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectorType != 0 {
		n += 1 + sovDerive(uint64(m.ConnectorType))
	}
	l = len(m.ConfigJson)
	if l > 0 {
		n += 1 + l + sovDerive(uint64(l))
	}
	l = m.Collection.ProtoSize()
	n += 1 + l + sovDerive(uint64(l))
	if len(m.Transforms) > 0 {
		for _, e := range m.Transforms {
			l = e.ProtoSize()
			n += 1 + l + sovDerive(uint64(l))
		}
	}
	if len(m.ShuffleKeyTypes) > 0 {
		l = 0
		for _, e := range m.ShuffleKeyTypes {
			l += sovDerive(uint64(e))
		}
		n += 1 + sovDerive(uint64(l)) + l
	}
	l = len(m.ProjectRoot)
	if l > 0 {
		n += 1 + l + sovDerive(uint64(l))
	}
	if len(m.ImportMap) > 0 {
		for k, v := range m.ImportMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDerive(uint64(len(k))) + 1 + len(v) + sovDerive(uint64(len(v)))
			n += mapEntrySize + 1 + sovDerive(uint64(mapEntrySize))
		}
	}
	if m.LastCollection != nil {
		l = m.LastCollection.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	l = len(m.LastVersion)
	if l > 0 {
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Validate_Transform) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDerive(uint64(l))
	}
	l = m.Collection.ProtoSize()
	n += 1 + l + sovDerive(uint64(l))
	l = len(m.ShuffleLambdaConfigJson)
	if l > 0 {
		n += 1 + l + sovDerive(uint64(l))
	}
	l = len(m.LambdaConfigJson)
	if l > 0 {
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.Backfill != 0 {
		n += 1 + sovDerive(uint64(m.Backfill))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Open) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Collection != nil {
		l = m.Collection.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.Range != nil {
		l = m.Range.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	l = len(m.StateJson)
	if l > 0 {
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Read) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transform != 0 {
		n += 1 + sovDerive(uint64(m.Transform))
	}
	if m.Uuid != nil {
		l = m.Uuid.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.Shuffle != nil {
		l = m.Shuffle.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	l = len(m.DocJson)
	if l > 0 {
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Read_Shuffle) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyJson)
	if l > 0 {
		n += 1 + l + sovDerive(uint64(l))
	}
	l = len(m.Packed)
	if l > 0 {
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.Hash != 0 {
		n += 1 + sovDerive(uint64(m.Hash))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Flush) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_StartCommit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuntimeCheckpoint != nil {
		l = m.RuntimeCheckpoint.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Reset) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.Validated != nil {
		l = m.Validated.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.Opened != nil {
		l = m.Opened.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.Published != nil {
		l = m.Published.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.Flushed != nil {
		l = m.Flushed.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.StartedCommit != nil {
		l = m.StartedCommit.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	l = len(m.Internal)
	if l > 0 {
		n += 2 + l + sovDerive(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Spec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Protocol != 0 {
		n += 1 + sovDerive(uint64(m.Protocol))
	}
	l = len(m.ConfigSchemaJson)
	if l > 0 {
		n += 1 + l + sovDerive(uint64(l))
	}
	l = len(m.ResourceConfigSchemaJson)
	if l > 0 {
		n += 1 + l + sovDerive(uint64(l))
	}
	l = len(m.DocumentationUrl)
	if l > 0 {
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.Oauth2 != nil {
		l = m.Oauth2.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Validated) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Transforms) > 0 {
		for _, e := range m.Transforms {
			l = e.ProtoSize()
			n += 1 + l + sovDerive(uint64(l))
		}
	}
	if len(m.GeneratedFiles) > 0 {
		for k, v := range m.GeneratedFiles {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDerive(uint64(len(k))) + 1 + len(v) + sovDerive(uint64(len(v)))
			n += mapEntrySize + 1 + sovDerive(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Validated_Transform) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReadOnly {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Opened) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Published) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DocJson)
	if l > 0 {
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Flushed) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_StartedCommit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = m.State.ProtoSize()
		n += 1 + l + sovDerive(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDerive(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDerive(x uint64) (n int) {
	return sovDerive(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &Request_Spec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Validate == nil {
				m.Validate = &Request_Validate{}
			}
			if err := m.Validate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Open == nil {
				m.Open = &Request_Open{}
			}
			if err := m.Open.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Read == nil {
				m.Read = &Request_Read{}
			}
			if err := m.Read.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flush", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flush == nil {
				m.Flush = &Request_Flush{}
			}
			if err := m.Flush.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartCommit == nil {
				m.StartCommit = &Request_StartCommit{}
			}
			if err := m.StartCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reset_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reset_ == nil {
				m.Reset_ = &Request_Reset{}
			}
			if err := m.Reset_.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Internal = append(m.Internal[:0], dAtA[iNdEx:postIndex]...)
			if m.Internal == nil {
				m.Internal = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Spec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorType", wireType)
			}
			m.ConnectorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectorType |= flow.CollectionSpec_Derivation_ConnectorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Validate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorType", wireType)
			}
			m.ConnectorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectorType |= flow.CollectionSpec_Derivation_ConnectorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transforms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transforms = append(m.Transforms, &Request_Validate_Transform{})
			if err := m.Transforms[len(m.Transforms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v flow.CollectionSpec_Derivation_ShuffleType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDerive
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= flow.CollectionSpec_Derivation_ShuffleType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ShuffleKeyTypes = append(m.ShuffleKeyTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDerive
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDerive
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDerive
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ShuffleKeyTypes) == 0 {
					m.ShuffleKeyTypes = make([]flow.CollectionSpec_Derivation_ShuffleType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v flow.CollectionSpec_Derivation_ShuffleType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDerive
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= flow.CollectionSpec_Derivation_ShuffleType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ShuffleKeyTypes = append(m.ShuffleKeyTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleKeyTypes", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectRoot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImportMap == nil {
				m.ImportMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDerive
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDerive
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDerive
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDerive
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDerive
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDerive
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthDerive
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDerive(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDerive
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ImportMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCollection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastCollection == nil {
				m.LastCollection = &flow.CollectionSpec{}
			}
			if err := m.LastCollection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Validate_Transform) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transform: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transform: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleLambdaConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShuffleLambdaConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LambdaConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LambdaConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backfill", wireType)
			}
			m.Backfill = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Backfill |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Open) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Open: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Open: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Collection == nil {
				m.Collection = &flow.CollectionSpec{}
			}
			if err := m.Collection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &flow.RangeSpec{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Read) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Read: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Read: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			m.Transform = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Transform |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uuid == nil {
				m.Uuid = &flow.UUIDParts{}
			}
			if err := m.Uuid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shuffle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shuffle == nil {
				m.Shuffle = &Request_Read_Shuffle{}
			}
			if err := m.Shuffle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Read_Shuffle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shuffle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shuffle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Packed = append(m.Packed[:0], dAtA[iNdEx:postIndex]...)
			if m.Packed == nil {
				m.Packed = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			m.Hash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hash |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Flush) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flush: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flush: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_StartCommit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartCommit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartCommit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeCheckpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuntimeCheckpoint == nil {
				m.RuntimeCheckpoint = &protocol.Checkpoint{}
			}
			if err := m.RuntimeCheckpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Reset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &Response_Spec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Validated == nil {
				m.Validated = &Response_Validated{}
			}
			if err := m.Validated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opened", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opened == nil {
				m.Opened = &Response_Opened{}
			}
			if err := m.Opened.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Published", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Published == nil {
				m.Published = &Response_Published{}
			}
			if err := m.Published.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flushed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flushed == nil {
				m.Flushed = &Response_Flushed{}
			}
			if err := m.Flushed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedCommit == nil {
				m.StartedCommit = &Response_StartedCommit{}
			}
			if err := m.StartedCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Internal = append(m.Internal[:0], dAtA[iNdEx:postIndex]...)
			if m.Internal == nil {
				m.Internal = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Spec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigSchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigSchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceConfigSchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceConfigSchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentationUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocumentationUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oauth2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Oauth2 == nil {
				m.Oauth2 = &flow.OAuth2{}
			}
			if err := m.Oauth2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Validated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transforms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transforms = append(m.Transforms, &Response_Validated_Transform{})
			if err := m.Transforms[len(m.Transforms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GeneratedFiles == nil {
				m.GeneratedFiles = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDerive
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDerive
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDerive
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDerive
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDerive
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDerive
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthDerive
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDerive(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDerive
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GeneratedFiles[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Validated_Transform) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transform: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transform: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Opened) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opened: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opened: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Published) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Published: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Published: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Flushed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flushed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flushed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_StartedCommit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartedCommit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartedCommit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &flow.ConnectorState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDerive(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDerive
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDerive
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDerive
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDerive
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDerive
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDerive        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDerive          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDerive = fmt.Errorf("proto: unexpected end of group")
)
