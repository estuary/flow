syntax = "proto3";

package shuffle;
option go_package = "github.com/estuary/flow/go/protocols/shuffle";

import "broker/protocol/protocol.proto";
import "consumer/protocol/protocol.proto";
import "go/protocols/flow/flow.proto";

// Member represents a participant in the shuffle topology (e.x. a task shard).
message Member {
  // Key and r-clock document range owned by this member.
  flow.RangeSpec range = 1;
  // gRPC endpoint of this member.
  string endpoint = 2;
}

message CollectionPartitions {
  // Collection specification.
  flow.CollectionSpec collection = 1;
  // Partition selector for filtering source collection journals.
  protocol.LabelSelector partition_selector = 2;
}

// Task which we're performing shuffles for.
message Task {
  oneof task {
    // Partitions of a single collection (ad-hoc read).
    CollectionPartitions collection_partitions = 1;
    // Derivation for which we're performing shuffles.
    // The collection's `derivation` field must be set.
    flow.CollectionSpec derivation = 2;
    // Materialization for which we're performing shuffles.
    flow.MaterializationSpec materialization = 3;
  }
}

// When appending to Journals, independent producers author transactions
// spanning one or more journals. When reading, we track the progress of each
// producer to understand the status of its transactions. JournalProducer
// represents the progress of a tuple (journal name, binding index, producer ID).
// A binding is the context under which a task is reading a journal, and there
// may be multiple such contexts per journal which read independently.
//
// JournalProducer uses a delta-encoding scheme to efficiently represent
// the progression of journal names across a sequence of instances.
// Given a known preceding journal name string, an instance encodes how many
// right-most bytes to truncate, followed by a suffix to append, to reconstruct
// the present value. In the common case where a journal name is the same
// (only the producer ID has changed), then related fields are their defaults
// and are omitted from the encoded protobuf stream.
message JournalProducer {
  // Number of bytes to truncate from the preceding name.
  // Must align with a UTF-8 code point boundary.
  // Negative values (e.x. -1) discard the entire preceding name.
  int32 journal_name_truncate_delta = 1;
  // Suffix to append to the preceding, truncated name.
  string journal_name_suffix = 2;
  // Binding index of this JournalProducer.
  // When persisting across sessions, this should be mapped via the task's
  // `journal_read_suffix` to ensure stability across task versions.
  uint32 binding = 3;
  // Producer ID of the JournalProducer, extracted from a document UUID.
  fixed64 producer_id = 4;
  // Clock of the last ACK seen from this producer.
  fixed64 last_ack = 5;
  // Document offset:
  // - When positive, the producer has an uncommitted transaction
  //   which begins at this offset.
  // - When negative, the producer last committed with an
  //   ACK which ends at the byte prior to this offset.
  // - When zero, the producer is committed but the last offset is unknown.
  int64 offset = 6;
}

// JournalProducerChunk is a portion of a sequence of JournalProducers, where the
// entire sequence is ordered on ascending (journal name, binding index, producer ID).
//
// A final empty chunk represents end-of-sequence.
message JournalProducerChunk {
  repeated JournalProducer chunk = 1;
}

// SessionRequest is sent by the Coordinator to manage the shuffle session.
message SessionRequest {
  // Open initiates a new shuffle session.
  // Sent once at the start of the Session RPC.
  message Open {
    // Unique identifier for this session instance.
    // Used to correlate Slice and Queue RPCs, and to name queue files.
    fixed64 session_id = 1;
    // Task for which we're performing shuffles.
    Task task = 2;
    // Members participating in this shuffle session.
    repeated Member members = 3;
  }
  Open open = 1;

  // The last-committed checkpoint which the session is resuming from.
  // It's streamed by the Coordinator after reading SessionResponse.Opened.
  JournalProducerChunk last_commit_chunk = 2;

  // A read-through checkpoint delta (atop the last commit), that was prepared
  // but not yet committed during the previous session.
  //
  // If non-empty, the read-through checkpoint must be read through on startup
  // and will be the first "next checkpoint" response.
  JournalProducerChunk read_through_chunk = 3;

  // NextCheckpoint requests the next available checkpoint delta.
  // This is a blocking request: the Session only responds when progress is
  // available. The client requests a next checkpoint at times of its choosing
  // (e.g., after completing processing of the previous checkpoint).
  message NextCheckpoint {}
  NextCheckpoint next_checkpoint = 4;
}

// SessionResponse is sent by the Session to the Coordinator.
message SessionResponse {
  // Opened confirms the Session is ready.
  // Sent after all Slices have responded Opened.
  message Opened {}
  Opened opened = 1;

  // The next checkpoint delta (atop the last commit) which reflects the extents
  // of a transaction which is ready to be processed. It's sent in response to
  // SessionRequest.NextCheckpoint, and is never empty (though the Session may
  // block indefinitely until progress is available).
  JournalProducerChunk next_checkpoint_chunk = 2;
}

// SliceRequest is sent by the Session to each member's Slice RPC.
message SliceRequest {
  // Open initiates the Slice.
  // The Slice opens Queue RPCs to all members before responding Opened.
  message Open {
    // Session ID from SessionRequest.Open.
    fixed64 session_id = 1;
    // Task for which we're performing shuffles.
    Task task = 2;
    // Members participating in this shuffle session.
    // Must be the same members and order as Session.Open.
    repeated Member members = 3;
    // Index of this member within the members list.
    uint32 member_index = 4;
  }
  Open open = 1;

  // Start is sent after all Slices have responded Opened and the Session has
  // received the last-committed & read-through checkpoints from the Coordinator.
  // On receipt, Slices start listing watches and may send SliceResponse.ListingAdded.
  message Start {}
  Start start = 2;

  // StartRead instructs the Slice to begin reading a journal.
  message StartRead {
    // Binding index within the task (derivation transform or
    // materialization binding).
    uint32 binding = 1;
    // Journal to be read.
    protocol.JournalSpec spec = 2;
    // Etcd revision at which the journal was created.
    int64 create_revision = 3;
    // Etcd revision at which the journal was last modified.
    int64 mod_revision = 4;
    // Current route of the journal, as an initial advisory hint.
    protocol.Route route = 5;
    // Producers of this Journal as-of the last-committed checkpoint.
    repeated JournalProducer checkpoint = 6;
  }
  StartRead start_read = 3;
}

// SliceResponse is sent by each Slice back to the Session.
message SliceResponse {
  // Opened confirms the Slice is ready.
  // Sent after all Queue RPCs have responded Opened.
  message Opened {}
  Opened opened = 1;

  message ListingAdded {
    // Binding index of the listing.
    uint32 binding = 1;
    // Journal which was added to the listing.
    protocol.JournalSpec spec = 2;
    // Etcd revision at which the journal was created.
    int64 create_revision = 3;
    // Etcd revision at which the journal was last modified.
    int64 mod_revision = 4;
    // Current route of the journal, as an initial advisory hint.
    protocol.Route route = 5;
  }
  ListingAdded listing_added = 2;

  // ProgressDelta reports read progress across all journals since the last flush.
  // Sent after completion of each Flush (all Queue RPCs responded Flushed),
  // guaranteeing all documents up to this point are available across queues.
  message ProgressDelta {
    repeated JournalProducer journal_producers = 1;

    message CausalHint {
      // The hinted journal.
      string journal = 1;
      // Producer ID extracted from document UUID.
      fixed64 producer_id = 2;
      // Clock of the expected ACK for this producer.
      fixed64 last_ack = 3;
    }
    repeated CausalHint causal_hints = 2;
  }
  ProgressDelta progress_delta = 3;
}

// QueueRequest is sent by Slices to each member's Queue.
message QueueRequest {
  // Open initiates the Queue RPC.
  // Multiple Slices open Queue RPCs to the same member, and the Queue
  // task joins these streams and processes documents in merged order.
  message Open {
    // Session ID for correlating streams from the same session.
    // Combined with member_index to deterministically name the queue file.
    fixed64 session_id = 1;
    // Members participating in this shuffle session.
    // Must be the same members and order as Session.Open.
    repeated Member members = 2;
    // Index of the source Slice member within the session's member list.
    uint32 slice_member_index = 3;
    // Index of the target Queue member within the session's member list.
    uint32 queue_member_index = 4;
  }
  Open open = 1;

  // Enqueue sends a document to be written to the queue.
  // The Queue merges across Slice streams, ordering by (priority, clock).
  //
  // ACK documents (identifiable via uuid_parts.node flags) may be sent
  // to multiple Queues based on the tracked key/r-clock extent of the
  // producer's prior documents.
  message Enqueue {
    // Document's source journal.
    string journal = 1;
    // Binding index for this document.
    uint32 binding = 2;
    // UUID of the document.
    // Contains producer ID, clock, and flags (e.g. ACK).
    flow.UUIDParts uuid_parts = 3;
    // Packed shuffle key of the document.
    bytes packed_key = 4;
    // Priority of this document's binding.
    // Queue orders documents by (priority DESC, clock ASC).
    uint32 priority = 5;
    // Document content as JSON bytes.
    bytes doc_json = 6;
  }
  Enqueue enqueue = 2;

  // Flush requests a durability barrier.
  message Flush {
    // Sequence number for correlating Flush with Flushed response.
    // Allows pipelining if we later want multiple in-flight flushes.
    uint64 seq = 1;
  }
  Flush flush = 3;
}

// QueueResponse is sent by the Queue back to each Slice.
message QueueResponse {
  // Opened confirms the Queue is ready to receive documents.
  // Sent after the Queue has joined over the member's queue file.
  message Opened {}
  Opened opened = 1;

  // Flushed confirms all preceding documents are durable on disk.
  // Only after receiving Flushed from ALL Queues can a Slice safely
  // report ProgressDelta to the Session.
  message Flushed {
    // Sequence number from the corresponding Flush request.
    uint64 seq = 1;
  }
  Flushed flushed = 2;
}

// Shuffle service provides coordinated, disk-backed shuffled reads.
service Shuffle {
  // Session is the top-level RPC opened by the Coordinator (typically
  // shard-000). It manages the shuffle lifecycle, journal watches,
  // and checkpoint aggregation.
  rpc Session(stream SessionRequest) returns (stream SessionResponse);

  // Slice is opened by the Session to each member. Each Slice reads
  // an assigned subset of journals and routes documents to Queues.
  rpc Slice(stream SliceRequest) returns (stream SliceResponse);

  // Queue is opened by each Slice to each member. Documents flow
  // from Slices through Queues to on-disk queue files.
  rpc Queue(stream QueueRequest) returns (stream QueueResponse);
}
