// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go/protocols/flow/flow.proto

package flow

import (
	bytes "bytes"
	context "context"
	encoding_binary "encoding/binary"
	encoding_json "encoding/json"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	go_gazette_dev_core_broker_protocol "go.gazette.dev/core/broker/protocol"
	protocol "go.gazette.dev/core/broker/protocol"
	go_gazette_dev_core_consumer_protocol "go.gazette.dev/core/consumer/protocol"
	protocol1 "go.gazette.dev/core/consumer/protocol"
	go_gazette_dev_core_message "go.gazette.dev/core/message"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EndpointType enumerates the endpoint types understood by Flow.
type EndpointType int32

const (
	// Reserved for REMOTE gRPC servers if there's ever a use case.
	EndpointType_INVALID        EndpointType = 0
	EndpointType_SQLITE         EndpointType = 2
	EndpointType_INGEST         EndpointType = 3
	EndpointType_AIRBYTE_SOURCE EndpointType = 7
	EndpointType_FLOW_SINK      EndpointType = 8
)

var EndpointType_name = map[int32]string{
	0: "INVALID",
	2: "SQLITE",
	3: "INGEST",
	7: "AIRBYTE_SOURCE",
	8: "FLOW_SINK",
}

var EndpointType_value = map[string]int32{
	"INVALID":        0,
	"SQLITE":         2,
	"INGEST":         3,
	"AIRBYTE_SOURCE": 7,
	"FLOW_SINK":      8,
}

func (x EndpointType) String() string {
	return proto.EnumName(EndpointType_name, int32(x))
}

func (EndpointType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{0}
}

// LogLevelFilter is a common representation of a simple logging filter, which
// is shared between Rust and Go code. This enum is not used directly within
// other messages here because logging is configured at the time that Rust
// Service instances are created, not when they're configured.
type LogLevelFilter int32

const (
	LogLevelFilter_OFF   LogLevelFilter = 0
	LogLevelFilter_ERROR LogLevelFilter = 1
	LogLevelFilter_WARN  LogLevelFilter = 2
	LogLevelFilter_INFO  LogLevelFilter = 3
	LogLevelFilter_DEBUG LogLevelFilter = 4
	LogLevelFilter_TRACE LogLevelFilter = 5
)

var LogLevelFilter_name = map[int32]string{
	0: "OFF",
	1: "ERROR",
	2: "WARN",
	3: "INFO",
	4: "DEBUG",
	5: "TRACE",
}

var LogLevelFilter_value = map[string]int32{
	"OFF":   0,
	"ERROR": 1,
	"WARN":  2,
	"INFO":  3,
	"DEBUG": 4,
	"TRACE": 5,
}

func (x LogLevelFilter) String() string {
	return proto.EnumName(LogLevelFilter_name, int32(x))
}

func (LogLevelFilter) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{1}
}

// ContentType enumerates the content types understood by Flow.
type ContentType int32

const (
	ContentType_CATALOG           ContentType = 0
	ContentType_JSON_SCHEMA       ContentType = 1
	ContentType_TYPESCRIPT_MODULE ContentType = 2
	ContentType_NPM_PACKAGE       ContentType = 3
	ContentType_CONFIG            ContentType = 4
	ContentType_DOCUMENTS_FIXTURE ContentType = 5
)

var ContentType_name = map[int32]string{
	0: "CATALOG",
	1: "JSON_SCHEMA",
	2: "TYPESCRIPT_MODULE",
	3: "NPM_PACKAGE",
	4: "CONFIG",
	5: "DOCUMENTS_FIXTURE",
}

var ContentType_value = map[string]int32{
	"CATALOG":           0,
	"JSON_SCHEMA":       1,
	"TYPESCRIPT_MODULE": 2,
	"NPM_PACKAGE":       3,
	"CONFIG":            4,
	"DOCUMENTS_FIXTURE": 5,
}

func (x ContentType) String() string {
	return proto.EnumName(ContentType_name, int32(x))
}

func (ContentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{2}
}

// Exists enumerates the possible states of existence for a location.
type Inference_Exists int32

const (
	Inference_INVALID Inference_Exists = 0
	// The location must exist.
	Inference_MUST Inference_Exists = 1
	// The location may exist or be undefined.
	// Its schema has explicit keywords which allow it to exist
	// and which may constrain its shape, such as additionalProperties,
	// items, unevaluatedProperties, or unevaluatedItems.
	Inference_MAY Inference_Exists = 2
	// The location may exist or be undefined.
	// Its schema omits any associated keywords, but the specification's
	// default behavior allows the location to exist.
	Inference_IMPLICIT Inference_Exists = 3
	// The location cannot exist. For example, it's outside of permitted
	// array bounds, or is a disallowed property, or has an impossible type.
	Inference_CANNOT Inference_Exists = 4
)

var Inference_Exists_name = map[int32]string{
	0: "INVALID",
	1: "MUST",
	2: "MAY",
	3: "IMPLICIT",
	4: "CANNOT",
}

var Inference_Exists_value = map[string]int32{
	"INVALID":  0,
	"MUST":     1,
	"MAY":      2,
	"IMPLICIT": 3,
	"CANNOT":   4,
}

func (x Inference_Exists) String() string {
	return proto.EnumName(Inference_Exists_name, int32(x))
}

func (Inference_Exists) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{6, 0}
}

// Type of this step.
type TestSpec_Step_Type int32

const (
	TestSpec_Step_INGEST TestSpec_Step_Type = 0
	TestSpec_Step_VERIFY TestSpec_Step_Type = 1
)

var TestSpec_Step_Type_name = map[int32]string{
	0: "INGEST",
	1: "VERIFY",
}

var TestSpec_Step_Type_value = map[string]int32{
	"INGEST": 0,
	"VERIFY": 1,
}

func (x TestSpec_Step_Type) String() string {
	return proto.EnumName(TestSpec_Step_Type_name, int32(x))
}

func (TestSpec_Step_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{14, 0, 0}
}

// Code labels message codes passed over the CGO bridge.
type ExtractAPI_Code int32

const (
	ExtractAPI_INVALID ExtractAPI_Code = 0
	// Configure or re-configure the extractor (Go -> Rust).
	ExtractAPI_CONFIGURE ExtractAPI_Code = 1
	// Extract from a document (Go -> Rust).
	ExtractAPI_EXTRACT ExtractAPI_Code = 2
	// UUID extracted from a document (Rust -> Go).
	ExtractAPI_EXTRACTED_UUID ExtractAPI_Code = 3
	// Fields extracted from a document (Rust -> Go).
	ExtractAPI_EXTRACTED_FIELDS ExtractAPI_Code = 4
)

var ExtractAPI_Code_name = map[int32]string{
	0: "INVALID",
	1: "CONFIGURE",
	2: "EXTRACT",
	3: "EXTRACTED_UUID",
	4: "EXTRACTED_FIELDS",
}

var ExtractAPI_Code_value = map[string]int32{
	"INVALID":          0,
	"CONFIGURE":        1,
	"EXTRACT":          2,
	"EXTRACTED_UUID":   3,
	"EXTRACTED_FIELDS": 4,
}

func (x ExtractAPI_Code) String() string {
	return proto.EnumName(ExtractAPI_Code_name, int32(x))
}

func (ExtractAPI_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{19, 0}
}

// Code labels message codes passed over the CGO bridge.
type CombineAPI_Code int32

const (
	CombineAPI_INVALID CombineAPI_Code = 0
	// Configure or re-configure the combiner (Go -> Rust).
	// A combiner may be configured only on first initialization,
	// or immediately after having drained.
	CombineAPI_CONFIGURE CombineAPI_Code = 1
	// Reduce a left-hand side document (Go -> Rust).
	CombineAPI_REDUCE_LEFT CombineAPI_Code = 2
	// Combine a right-hand side document (Go -> Rust).
	CombineAPI_COMBINE_RIGHT CombineAPI_Code = 3
	// Drain the combiner (Go -> Rust).
	CombineAPI_DRAIN_CHUNK CombineAPI_Code = 200
	// Next drained document is partially combined (Rust -> Go).
	CombineAPI_DRAINED_COMBINED_DOCUMENT CombineAPI_Code = 201
	// Next drained document is fully reduced (Rust -> Go).
	CombineAPI_DRAINED_REDUCED_DOCUMENT CombineAPI_Code = 202
	// Next drained key (follows drained document; Rust -> Go).
	CombineAPI_DRAINED_KEY CombineAPI_Code = 203
	// Next drained fields (follows key; Rust -> Go).
	CombineAPI_DRAINED_FIELDS CombineAPI_Code = 204
	// Drain stats, sent after all documents have been drained. (Rust -> Go)
	CombineAPI_DRAINED_STATS CombineAPI_Code = 205
)

var CombineAPI_Code_name = map[int32]string{
	0:   "INVALID",
	1:   "CONFIGURE",
	2:   "REDUCE_LEFT",
	3:   "COMBINE_RIGHT",
	200: "DRAIN_CHUNK",
	201: "DRAINED_COMBINED_DOCUMENT",
	202: "DRAINED_REDUCED_DOCUMENT",
	203: "DRAINED_KEY",
	204: "DRAINED_FIELDS",
	205: "DRAINED_STATS",
}

var CombineAPI_Code_value = map[string]int32{
	"INVALID":                   0,
	"CONFIGURE":                 1,
	"REDUCE_LEFT":               2,
	"COMBINE_RIGHT":             3,
	"DRAIN_CHUNK":               200,
	"DRAINED_COMBINED_DOCUMENT": 201,
	"DRAINED_REDUCED_DOCUMENT":  202,
	"DRAINED_KEY":               203,
	"DRAINED_FIELDS":            204,
	"DRAINED_STATS":             205,
}

func (x CombineAPI_Code) String() string {
	return proto.EnumName(CombineAPI_Code_name, int32(x))
}

func (CombineAPI_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{20, 0}
}

// Codes passed over the CGO bridge.
type DeriveAPI_Code int32

const (
	DeriveAPI_INVALID DeriveAPI_Code = 0
	// Open the registers database (Go -> Rust).
	DeriveAPI_OPEN DeriveAPI_Code = 1
	// Restore the last checkpoint from an opened database (Go <-> Rust).
	DeriveAPI_RESTORE_CHECKPOINT DeriveAPI_Code = 2
	// Configure or re-configure the derive API (Go -> Rust).
	DeriveAPI_CONFIGURE DeriveAPI_Code = 3
	// Begin a new transaction (Go -> Rust).
	DeriveAPI_BEGIN_TRANSACTION DeriveAPI_Code = 4
	// Next source document header (Go -> Rust).
	DeriveAPI_NEXT_DOCUMENT_HEADER DeriveAPI_Code = 5
	// Next source document body (Go -> Rust).
	DeriveAPI_NEXT_DOCUMENT_BODY DeriveAPI_Code = 6
	// Trampoline task start or completion (Rust <-> Go).
	DeriveAPI_TRAMPOLINE DeriveAPI_Code = 7
	// Trampoline sub-type: invoke transform lambda.
	DeriveAPI_TRAMPOLINE_INVOKE DeriveAPI_Code = 8
	// Flush transaction (Go -> Rust).
	DeriveAPI_FLUSH_TRANSACTION DeriveAPI_Code = 9
	// Transaction completed flushing (Rust -> Go).
	DeriveAPI_FLUSHED_TRANSACTION DeriveAPI_Code = 10
	// Prepare transaction to commit (Go -> Rust).
	DeriveAPI_PREPARE_TO_COMMIT DeriveAPI_Code = 11
	// Clear registers values (test support only; Go -> Rust).
	DeriveAPI_CLEAR_REGISTERS DeriveAPI_Code = 12
	// Drain the combiner (Go -> Rust).
	DeriveAPI_DRAIN_CHUNK DeriveAPI_Code = 200
	// Next drained document is partially combined (Rust -> Go).
	DeriveAPI_DRAINED_COMBINED_DOCUMENT DeriveAPI_Code = 201
	// Next drained document is fully reduced (Rust -> Go).
	DeriveAPI_DRAINED_REDUCED_DOCUMENT DeriveAPI_Code = 202
	// Next drained key (follows drained document; Rust -> Go).
	DeriveAPI_DRAINED_KEY DeriveAPI_Code = 203
	// Next drained fields (follows key; Rust -> Go).
	DeriveAPI_DRAINED_FIELDS DeriveAPI_Code = 204
	// Drain stats, sent after all documents have been drained. (Rust -> Go)
	DeriveAPI_DRAINED_STATS DeriveAPI_Code = 205
)

var DeriveAPI_Code_name = map[int32]string{
	0:   "INVALID",
	1:   "OPEN",
	2:   "RESTORE_CHECKPOINT",
	3:   "CONFIGURE",
	4:   "BEGIN_TRANSACTION",
	5:   "NEXT_DOCUMENT_HEADER",
	6:   "NEXT_DOCUMENT_BODY",
	7:   "TRAMPOLINE",
	8:   "TRAMPOLINE_INVOKE",
	9:   "FLUSH_TRANSACTION",
	10:  "FLUSHED_TRANSACTION",
	11:  "PREPARE_TO_COMMIT",
	12:  "CLEAR_REGISTERS",
	200: "DRAIN_CHUNK",
	201: "DRAINED_COMBINED_DOCUMENT",
	202: "DRAINED_REDUCED_DOCUMENT",
	203: "DRAINED_KEY",
	204: "DRAINED_FIELDS",
	205: "DRAINED_STATS",
}

var DeriveAPI_Code_value = map[string]int32{
	"INVALID":                   0,
	"OPEN":                      1,
	"RESTORE_CHECKPOINT":        2,
	"CONFIGURE":                 3,
	"BEGIN_TRANSACTION":         4,
	"NEXT_DOCUMENT_HEADER":      5,
	"NEXT_DOCUMENT_BODY":        6,
	"TRAMPOLINE":                7,
	"TRAMPOLINE_INVOKE":         8,
	"FLUSH_TRANSACTION":         9,
	"FLUSHED_TRANSACTION":       10,
	"PREPARE_TO_COMMIT":         11,
	"CLEAR_REGISTERS":           12,
	"DRAIN_CHUNK":               200,
	"DRAINED_COMBINED_DOCUMENT": 201,
	"DRAINED_REDUCED_DOCUMENT":  202,
	"DRAINED_KEY":               203,
	"DRAINED_FIELDS":            204,
	"DRAINED_STATS":             205,
}

func (x DeriveAPI_Code) String() string {
	return proto.EnumName(DeriveAPI_Code_name, int32(x))
}

func (DeriveAPI_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{21, 0}
}

// Code labels message codes passed over the CGO bridge.
type BuildAPI_Code int32

const (
	// Begin a build with a Config (Go -> Rust).
	BuildAPI_BEGIN BuildAPI_Code = 0
	// Poll the build after completing one or more trampoline tasks (Go ->
	// Rust).
	BuildAPI_POLL BuildAPI_Code = 1
	// Trampoline task start or completion (Rust <-> Go).
	BuildAPI_TRAMPOLINE BuildAPI_Code = 2
	// Trampoline sub-type: Start fetch of a resource.
	BuildAPI_TRAMPOLINE_FETCH BuildAPI_Code = 3
	// Trampoline sub-type: Start validation of a capture.
	BuildAPI_TRAMPOLINE_VALIDATE_CAPTURE BuildAPI_Code = 4
	// Trampoline sub-type: Start validation of a materialization.
	BuildAPI_TRAMPOLINE_VALIDATE_MATERIALIZATION BuildAPI_Code = 5
	// Build completed successfully (Rust -> Go).
	BuildAPI_DONE BuildAPI_Code = 6
	// Build completed with errors (Rust -> Go).
	BuildAPI_DONE_WITH_ERRORS BuildAPI_Code = 7
	// Generate catalog specification JSON schema (Go <-> Rust)
	BuildAPI_CATALOG_SCHEMA BuildAPI_Code = 100
)

var BuildAPI_Code_name = map[int32]string{
	0:   "BEGIN",
	1:   "POLL",
	2:   "TRAMPOLINE",
	3:   "TRAMPOLINE_FETCH",
	4:   "TRAMPOLINE_VALIDATE_CAPTURE",
	5:   "TRAMPOLINE_VALIDATE_MATERIALIZATION",
	6:   "DONE",
	7:   "DONE_WITH_ERRORS",
	100: "CATALOG_SCHEMA",
}

var BuildAPI_Code_value = map[string]int32{
	"BEGIN":                               0,
	"POLL":                                1,
	"TRAMPOLINE":                          2,
	"TRAMPOLINE_FETCH":                    3,
	"TRAMPOLINE_VALIDATE_CAPTURE":         4,
	"TRAMPOLINE_VALIDATE_MATERIALIZATION": 5,
	"DONE":                                6,
	"DONE_WITH_ERRORS":                    7,
	"CATALOG_SCHEMA":                      100,
}

func (x BuildAPI_Code) String() string {
	return proto.EnumName(BuildAPI_Code_name, int32(x))
}

func (BuildAPI_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{22, 0}
}

// Slice represents a contiguous slice of bytes within an associated Arena.
type Slice struct {
	Begin uint32 `protobuf:"varint,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End   uint32 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *Slice) Reset()         { *m = Slice{} }
func (m *Slice) String() string { return proto.CompactTextString(m) }
func (*Slice) ProtoMessage()    {}
func (*Slice) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{0}
}
func (m *Slice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Slice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Slice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Slice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Slice.Merge(m, src)
}
func (m *Slice) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Slice) XXX_DiscardUnknown() {
	xxx_messageInfo_Slice.DiscardUnknown(m)
}

var xxx_messageInfo_Slice proto.InternalMessageInfo

// UUIDParts is a deconstructed, RFC 4122 v1 variant Universally Unique
// Identifier as used by Gazette.
type UUIDParts struct {
	// Producer is the unique node identifier portion of a v1 UUID, as the high
	// 48 bits of |producer_and_flags|. The MSB must be 1 to mark this producer
	// as "multicast" and not an actual MAC address (as per RFC 4122).
	//
	// Bits 49-54 must be zero.
	//
	// The low 10 bits are the 10 least-significant bits of the v1 UUID clock
	// sequence, used by Gazette to represent flags over message transaction
	// semantics.
	ProducerAndFlags uint64 `protobuf:"fixed64,1,opt,name=producer_and_flags,json=producerAndFlags,proto3" json:"producer_and_flags,omitempty"`
	// Clock is a v1 UUID 60-bit timestamp (60 MSBs), followed by 4 bits of
	// sequence counter.
	Clock go_gazette_dev_core_message.Clock `protobuf:"fixed64,2,opt,name=clock,proto3,casttype=go.gazette.dev/core/message.Clock" json:"clock,omitempty"`
}

func (m *UUIDParts) Reset()         { *m = UUIDParts{} }
func (m *UUIDParts) String() string { return proto.CompactTextString(m) }
func (*UUIDParts) ProtoMessage()    {}
func (*UUIDParts) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{1}
}
func (m *UUIDParts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UUIDParts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UUIDParts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UUIDParts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UUIDParts.Merge(m, src)
}
func (m *UUIDParts) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UUIDParts) XXX_DiscardUnknown() {
	xxx_messageInfo_UUIDParts.DiscardUnknown(m)
}

var xxx_messageInfo_UUIDParts proto.InternalMessageInfo

// LambdaSpec describes a Flow transformation lambda and how to invoke it.
type LambdaSpec struct {
	// If non-empty, this is a TypeScript lambda and the field is its invocation
	// path. E.x. 'some/derivation/andTransform/Update'.
	Typescript string `protobuf:"bytes,1,opt,name=typescript,proto3" json:"typescript,omitempty"`
	// If non-empty, this is a remote lambda and the field is its invocation URL.
	// E.x. 'https://my/external/api'.
	Remote               string   `protobuf:"bytes,2,opt,name=remote,proto3" json:"remote,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LambdaSpec) Reset()         { *m = LambdaSpec{} }
func (m *LambdaSpec) String() string { return proto.CompactTextString(m) }
func (*LambdaSpec) ProtoMessage()    {}
func (*LambdaSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{2}
}
func (m *LambdaSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LambdaSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LambdaSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LambdaSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LambdaSpec.Merge(m, src)
}
func (m *LambdaSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LambdaSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_LambdaSpec.DiscardUnknown(m)
}

var xxx_messageInfo_LambdaSpec proto.InternalMessageInfo

// Shuffle is a description of a document shuffle, where each document
// is mapped into:
//  * An extracted, packed composite key (a "shuffle key").
//  * A rotated Clock value (an "r-clock").
// The packed key and r-clock can then be compared to individual reader
// RangeSpec's.
//
// Shuffle is a complete description of how a group of related readers
// (e.x. a set of shards collectively processing a single derivation or
// materialization) are performing their read. It contains all (and only!)
// stable descriptions of the read's behavior, and is a primary structure
// across both the shuffle server and client implementations.
//
// Shuffles are also compared using deep equality in order to identify and
// group related reads, placing all reads having equal Shuffles into common
// "read rings" which consolidate their underlying journal reads.
type Shuffle struct {
	// Group to which this shuffle belongs. It's used to suffix all journal
	// reads undertaken by this shuffle, and must be stable. Examples:
	//  `derive/{derivation}/{transform}`
	//  `materialize/{materialization}`
	GroupName string `protobuf:"bytes,1,opt,name=group_name,json=groupName,proto3" json:"group_name,omitempty"`
	// Source collection read by this transform.
	SourceCollection Collection `protobuf:"bytes,2,opt,name=source_collection,json=sourceCollection,proto3,casttype=Collection" json:"source_collection,omitempty"`
	// Selector of partitions of the collection which this transform reads.
	SourcePartitions protocol.LabelSelector `protobuf:"bytes,3,opt,name=source_partitions,json=sourcePartitions,proto3" json:"source_partitions"`
	// JSON pointer locating the UUID of each source document.
	SourceUuidPtr string `protobuf:"bytes,4,opt,name=source_uuid_ptr,json=sourceUuidPtr,proto3" json:"source_uuid_ptr,omitempty"`
	// Composite key over which shuffling occurs, specified as one or more
	// JSON-Pointers indicating a message location to extract.
	ShuffleKeyPtrs []string `protobuf:"bytes,5,rep,name=shuffle_key_ptrs,json=shuffleKeyPtrs,proto3" json:"shuffle_key_ptrs,omitempty"`
	// uses_source_key is true if shuffle_key_ptr is the source's native key,
	// and false if it's some other key. When shuffling using the source's key,
	// we can minimize data movement by assigning a shard coordinator for each
	// journal such that the shard's key range overlap that of the journal.
	UsesSourceKey bool `protobuf:"varint,6,opt,name=uses_source_key,json=usesSourceKey,proto3" json:"uses_source_key,omitempty"`
	// Computed shuffle lambda. If non-nil, then shuffle_key_ptr MUST be empty
	// and uses_source_key MUST be false.
	ShuffleLambda *LambdaSpec `protobuf:"bytes,7,opt,name=shuffle_lambda,json=shuffleLambda,proto3" json:"shuffle_lambda,omitempty"`
	// Schema against which shuffled documents are to be validated.
	SourceSchemaUri string `protobuf:"bytes,8,opt,name=source_schema_uri,json=sourceSchemaUri,proto3" json:"source_schema_uri,omitempty"`
	// uses_source_schema is true iff source_schema_uri is the source collection's
	// schema, and false if it's a source schema specific to this transform.
	UsesSourceSchema bool `protobuf:"varint,9,opt,name=uses_source_schema,json=usesSourceSchema,proto3" json:"uses_source_schema,omitempty"`
	// Validate the schema of documents at time of shuffled read.
	// Deprecated. Will be removed when |validate_schema_json| is established.
	DeprecatedValidateSchemaAtRead bool `protobuf:"varint,10,opt,name=deprecated_validate_schema_at_read,json=deprecatedValidateSchemaAtRead,proto3" json:"deprecated_validate_schema_at_read,omitempty"`
	// filter_r_clocks is true if the shuffle coordinator should filter documents
	// sent to each subscriber based on its covered r-clock ranges and the
	// individual document clocks. If false, the subscriber's r-clock range is
	// ignored and all documents which match the key range are sent.
	//
	// filter_r_clocks is set 'true' when reading on behalf of transforms having
	// a "publish" but not an "update" lambda, as such documents have no
	// side-effects on the reader's state store, and would not be published anyway
	// for falling outside of the reader's r-clock range.
	FilterRClocks bool `protobuf:"varint,11,opt,name=filter_r_clocks,json=filterRClocks,proto3" json:"filter_r_clocks,omitempty"`
	// Number of seconds for which documents of this collection are delayed
	// while reading, relative to other documents (when back-filling) and the
	// present wall-clock time (when tailing).
	ReadDelaySeconds uint32 `protobuf:"varint,12,opt,name=read_delay_seconds,json=readDelaySeconds,proto3" json:"read_delay_seconds,omitempty"`
	// Priority of this shuffle, with respect to other related Shuffle reads
	// (e.x. Shuffles of a different transformation within the same derivation).
	// Higher values imply higher priority.
	Priority uint32 `protobuf:"varint,13,opt,name=priority,proto3" json:"priority,omitempty"`
	// Bundled JSON-schema against which documents are validated. Optional.
	// If not set, no schema validation is performed by the Shuffle server.
	//
	// We always validate documents, but may do so either within the Shuffle
	// server or later, within the shuffle client:
	// - Derivations set `validate_schema_json`, as the derivation runtime can
	//   then by-pass a round of JSON parsing and validation.
	// - Materializations don't, as the materialization runtime immediately
	//   combines over the document which requires parsing & validation
	//   anyway.
	//
	// Unlike other schema_json protobuf fields, we don't use a RawMessage
	// casttype so that the generated Go equals method will work.
	ValidateSchemaJson   string   `protobuf:"bytes,14,opt,name=validate_schema_json,json=validateSchemaJson,proto3" json:"validate_schema_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Shuffle) Reset()         { *m = Shuffle{} }
func (m *Shuffle) String() string { return proto.CompactTextString(m) }
func (*Shuffle) ProtoMessage()    {}
func (*Shuffle) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{3}
}
func (m *Shuffle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Shuffle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Shuffle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Shuffle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Shuffle.Merge(m, src)
}
func (m *Shuffle) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Shuffle) XXX_DiscardUnknown() {
	xxx_messageInfo_Shuffle.DiscardUnknown(m)
}

var xxx_messageInfo_Shuffle proto.InternalMessageInfo

// JournalShuffle is a Shuffle of a Journal by a Coordinator shard.
// They're compared using deep equality in order to consolidate groups of
// related logical reads into a single physical read of the journal.
type JournalShuffle struct {
	// Journal to be shuffled.
	Journal go_gazette_dev_core_broker_protocol.Journal `protobuf:"bytes,1,opt,name=journal,proto3,casttype=go.gazette.dev/core/broker/protocol.Journal" json:"journal,omitempty"`
	// Coordinator is the Shard ID which is responsible for reads of this journal.
	Coordinator go_gazette_dev_core_consumer_protocol.ShardID `protobuf:"bytes,2,opt,name=coordinator,proto3,casttype=go.gazette.dev/core/consumer/protocol.ShardID" json:"coordinator,omitempty"`
	// Shuffle of this JournalShuffle.
	*Shuffle `protobuf:"bytes,3,opt,name=shuffle,proto3,embedded=shuffle" json:"shuffle,omitempty"`
	// Is this a reply of the journal's content? We separate ongoing vs replayed
	// reads of a journal's content into distinct rings.
	Replay bool `protobuf:"varint,4,opt,name=replay,proto3" json:"replay,omitempty"`
	// Build ID of the task which requested this JournalShuffle.
	BuildId              string   `protobuf:"bytes,5,opt,name=build_id,json=buildId,proto3" json:"build_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JournalShuffle) Reset()         { *m = JournalShuffle{} }
func (m *JournalShuffle) String() string { return proto.CompactTextString(m) }
func (*JournalShuffle) ProtoMessage()    {}
func (*JournalShuffle) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{4}
}
func (m *JournalShuffle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JournalShuffle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JournalShuffle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JournalShuffle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JournalShuffle.Merge(m, src)
}
func (m *JournalShuffle) XXX_Size() int {
	return m.ProtoSize()
}
func (m *JournalShuffle) XXX_DiscardUnknown() {
	xxx_messageInfo_JournalShuffle.DiscardUnknown(m)
}

var xxx_messageInfo_JournalShuffle proto.InternalMessageInfo

// Projection is a mapping between a document location, specified as a
// JSON-Pointer, and a corresponding field string in a flattened
// (i.e. tabular or SQL) namespace which aliases it.
type Projection struct {
	// Document location of this projection, as a JSON-Pointer.
	Ptr string `protobuf:"bytes,1,opt,name=ptr,proto3" json:"ptr,omitempty"`
	// Field is the flattened, tabular alias of this projection.
	Field string `protobuf:"bytes,2,opt,name=field,proto3" json:"field,omitempty"`
	// Was this projection explicitly provided ?
	// (As opposed to implicitly created through static analysis of the schema).
	Explicit bool `protobuf:"varint,3,opt,name=explicit,proto3" json:"explicit,omitempty"`
	// Does this projection constitute a logical partitioning of the collection?
	IsPartitionKey bool `protobuf:"varint,4,opt,name=is_partition_key,json=isPartitionKey,proto3" json:"is_partition_key,omitempty"`
	// Does this location form (part of) the collection key?
	IsPrimaryKey bool `protobuf:"varint,5,opt,name=is_primary_key,json=isPrimaryKey,proto3" json:"is_primary_key,omitempty"`
	// Inference of this projection.
	Inference            Inference `protobuf:"bytes,6,opt,name=inference,proto3" json:"inference"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Projection) Reset()         { *m = Projection{} }
func (m *Projection) String() string { return proto.CompactTextString(m) }
func (*Projection) ProtoMessage()    {}
func (*Projection) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{5}
}
func (m *Projection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Projection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Projection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Projection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Projection.Merge(m, src)
}
func (m *Projection) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Projection) XXX_DiscardUnknown() {
	xxx_messageInfo_Projection.DiscardUnknown(m)
}

var xxx_messageInfo_Projection proto.InternalMessageInfo

// Inference details type information which is statically known
// about a given document location.
type Inference struct {
	// The possible types for this location.
	// Subset of ["null", "boolean", "object", "array", "integer", "numeric",
	// "string"].
	Types   []string          `protobuf:"bytes,1,rep,name=types,proto3" json:"types,omitempty"`
	String_ *Inference_String `protobuf:"bytes,3,opt,name=string,proto3" json:"string,omitempty"`
	// The title from the schema, if provided.
	Title string `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	// The description from the schema, if provided.
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// The default value from the schema, if provided.
	DefaultJson encoding_json.RawMessage `protobuf:"bytes,6,opt,name=default_json,json=defaultJson,proto3,casttype=encoding/json.RawMessage" json:"default_json,omitempty"`
	// Whether this location is marked as a secret, like a credential or password.
	Secret bool `protobuf:"varint,7,opt,name=secret,proto3" json:"secret,omitempty"`
	// Existence of this document location.
	Exists               Inference_Exists `protobuf:"varint,8,opt,name=exists,proto3,enum=flow.Inference_Exists" json:"exists,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Inference) Reset()         { *m = Inference{} }
func (m *Inference) String() string { return proto.CompactTextString(m) }
func (*Inference) ProtoMessage()    {}
func (*Inference) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{6}
}
func (m *Inference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Inference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Inference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Inference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Inference.Merge(m, src)
}
func (m *Inference) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Inference) XXX_DiscardUnknown() {
	xxx_messageInfo_Inference.DiscardUnknown(m)
}

var xxx_messageInfo_Inference proto.InternalMessageInfo

// String type-specific inferences, or nil iff types doesn't include "string".
type Inference_String struct {
	// Annotated Content-Type when the projection is of "string" type.
	ContentType string `protobuf:"bytes,3,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	// Annotated format when the projection is of "string" type.
	Format string `protobuf:"bytes,4,opt,name=format,proto3" json:"format,omitempty"`
	// Annotated Content-Encoding when the projection is of "string" type.
	ContentEncoding string `protobuf:"bytes,7,opt,name=content_encoding,json=contentEncoding,proto3" json:"content_encoding,omitempty"`
	// Is the Content-Encoding "base64" (case-invariant)?
	IsBase64 bool `protobuf:"varint,5,opt,name=is_base64,json=isBase64,proto3" json:"is_base64,omitempty"`
	// Maximum length when the projection is of "string" type. Zero for no
	// limit.
	MaxLength            uint32   `protobuf:"varint,6,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Inference_String) Reset()         { *m = Inference_String{} }
func (m *Inference_String) String() string { return proto.CompactTextString(m) }
func (*Inference_String) ProtoMessage()    {}
func (*Inference_String) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{6, 0}
}
func (m *Inference_String) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Inference_String) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Inference_String.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Inference_String) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Inference_String.Merge(m, src)
}
func (m *Inference_String) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Inference_String) XXX_DiscardUnknown() {
	xxx_messageInfo_Inference_String.DiscardUnknown(m)
}

var xxx_messageInfo_Inference_String proto.InternalMessageInfo

type CollectionSpec struct {
	// Name of this collection.
	Collection Collection `protobuf:"bytes,1,opt,name=collection,proto3,casttype=Collection" json:"collection,omitempty"`
	// JSON-schema URI against which collection documents are validated,
	// and which provides reduction annotations.
	// * If this collection is local to this build, then |schema_uri|
	//   is the resource URL and fragment pointer of its schema.
	// * If this is a foreign collection, then |schema_uri| is a synthetic
	//   and unique URL which stands in for the collection's schema.
	SchemaUri string `protobuf:"bytes,2,opt,name=schema_uri,json=schemaUri,proto3" json:"schema_uri,omitempty"`
	// Bundled JSON-schema of the collection
	SchemaJson encoding_json.RawMessage `protobuf:"bytes,8,opt,name=schema_json,json=schemaJson,proto3,casttype=encoding/json.RawMessage" json:"schema_json,omitempty"`
	// Composite key of the collection, as JSON-Pointers.
	KeyPtrs []string `protobuf:"bytes,3,rep,name=key_ptrs,json=keyPtrs,proto3" json:"key_ptrs,omitempty"`
	// JSON pointer locating the UUID of each collection document.
	UuidPtr string `protobuf:"bytes,4,opt,name=uuid_ptr,json=uuidPtr,proto3" json:"uuid_ptr,omitempty"`
	// Logical partition fields of this collection.
	PartitionFields []string `protobuf:"bytes,5,rep,name=partition_fields,json=partitionFields,proto3" json:"partition_fields,omitempty"`
	// Logical projections of this collection
	Projections []Projection `protobuf:"bytes,6,rep,name=projections,proto3" json:"projections"`
	// JSON-encoded document template for creating Gazette consumer
	// transaction acknowledgements of writes into this collection.
	AckJsonTemplate encoding_json.RawMessage `protobuf:"bytes,7,opt,name=ack_json_template,json=ackJsonTemplate,proto3,casttype=encoding/json.RawMessage" json:"ack_json_template,omitempty"`
	// Template for partitions of this collection.
	PartitionTemplate    *protocol.JournalSpec `protobuf:"bytes,9,opt,name=partition_template,json=partitionTemplate,proto3" json:"partition_template,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *CollectionSpec) Reset()         { *m = CollectionSpec{} }
func (m *CollectionSpec) String() string { return proto.CompactTextString(m) }
func (*CollectionSpec) ProtoMessage()    {}
func (*CollectionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{7}
}
func (m *CollectionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionSpec.Merge(m, src)
}
func (m *CollectionSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CollectionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionSpec proto.InternalMessageInfo

// TransformSpec describes a specific transform of a derivation.
type TransformSpec struct {
	// Derivation this transform belongs to.
	Derivation Collection `protobuf:"bytes,1,opt,name=derivation,proto3,casttype=Collection" json:"derivation,omitempty"`
	// Name of this transform, scoped to it's derivation.
	Transform Transform `protobuf:"bytes,2,opt,name=transform,proto3,casttype=Transform" json:"transform,omitempty"`
	// Shuffle applied to source documents for this transform.
	Shuffle Shuffle `protobuf:"bytes,3,opt,name=shuffle,proto3" json:"shuffle"`
	// Update lambda of this transform, if any.
	UpdateLambda *LambdaSpec `protobuf:"bytes,4,opt,name=update_lambda,json=updateLambda,proto3" json:"update_lambda,omitempty"`
	// Publish lambda of this transform, if any.
	PublishLambda        *LambdaSpec `protobuf:"bytes,5,opt,name=publish_lambda,json=publishLambda,proto3" json:"publish_lambda,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TransformSpec) Reset()         { *m = TransformSpec{} }
func (m *TransformSpec) String() string { return proto.CompactTextString(m) }
func (*TransformSpec) ProtoMessage()    {}
func (*TransformSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{8}
}
func (m *TransformSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransformSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransformSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransformSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransformSpec.Merge(m, src)
}
func (m *TransformSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransformSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TransformSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TransformSpec proto.InternalMessageInfo

// DerivationSpec describes a collection, and it's means of derivation.
type DerivationSpec struct {
	// Derivations are collections.
	Collection CollectionSpec `protobuf:"bytes,1,opt,name=collection,proto3" json:"collection"`
	// JSON-schema URI against which derivation registers are validated,
	// and which provides reduction annotations. Register schemas are always
	// local to this build, and are a resource URL and fragment pointer.
	RegisterSchemaUri string `protobuf:"bytes,2,opt,name=register_schema_uri,json=registerSchemaUri,proto3" json:"register_schema_uri,omitempty"`
	// Bundled JSON-schema against which register documents are validated.
	RegisterSchemaJson encoding_json.RawMessage `protobuf:"bytes,7,opt,name=register_schema_json,json=registerSchemaJson,proto3,casttype=encoding/json.RawMessage" json:"register_schema_json,omitempty"`
	// JSON-encoded initial value of novel document registers.
	RegisterInitialJson encoding_json.RawMessage `protobuf:"bytes,3,opt,name=register_initial_json,json=registerInitial,proto3,casttype=encoding/json.RawMessage" json:"register_initial_json,omitempty"`
	// Transforms of this derivation.
	Transforms []TransformSpec `protobuf:"bytes,4,rep,name=transforms,proto3" json:"transforms"`
	// Template for shards of this derivation.
	ShardTemplate *protocol1.ShardSpec `protobuf:"bytes,5,opt,name=shard_template,json=shardTemplate,proto3" json:"shard_template,omitempty"`
	// Template for recovery logs of shards of this derivation.
	RecoveryLogTemplate  *protocol.JournalSpec `protobuf:"bytes,6,opt,name=recovery_log_template,json=recoveryLogTemplate,proto3" json:"recovery_log_template,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *DerivationSpec) Reset()         { *m = DerivationSpec{} }
func (m *DerivationSpec) String() string { return proto.CompactTextString(m) }
func (*DerivationSpec) ProtoMessage()    {}
func (*DerivationSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{9}
}
func (m *DerivationSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DerivationSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DerivationSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DerivationSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DerivationSpec.Merge(m, src)
}
func (m *DerivationSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DerivationSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DerivationSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DerivationSpec proto.InternalMessageInfo

// FieldSelection is a selection of a collection's projection fields.
type FieldSelection struct {
	// Fields for each key component of the collection. Included key fields appear
	// in the collection's key component order, and a given key pointer will be
	// included at most once.
	Keys []string `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	// All other selected fields, other than those in keys and the document field.
	// Entries are in ascending sorted order, and may be empty.
	Values []string `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
	// Field having a document pointer located at the document root.
	Document string `protobuf:"bytes,3,opt,name=document,proto3" json:"document,omitempty"`
	// Additional configuration, keyed by fields included in |keys|, |values|, or
	// |document|. Values are arbitrary JSON-encoded objects.
	FieldConfigJson      map[string]encoding_json.RawMessage `protobuf:"bytes,4,rep,name=field_config_json,json=fieldConfig,proto3,castvalue=encoding/json.RawMessage" json:"field_config_json,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *FieldSelection) Reset()         { *m = FieldSelection{} }
func (m *FieldSelection) String() string { return proto.CompactTextString(m) }
func (*FieldSelection) ProtoMessage()    {}
func (*FieldSelection) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{10}
}
func (m *FieldSelection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldSelection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldSelection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldSelection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldSelection.Merge(m, src)
}
func (m *FieldSelection) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FieldSelection) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldSelection.DiscardUnknown(m)
}

var xxx_messageInfo_FieldSelection proto.InternalMessageInfo

// CaptureSpec describes a collection and its capture from an endpoint.
type CaptureSpec struct {
	// Name of this capture.
	Capture Capture `protobuf:"bytes,1,opt,name=capture,proto3,casttype=Capture" json:"capture,omitempty"`
	// Type of the captures's endpoint.
	EndpointType EndpointType `protobuf:"varint,2,opt,name=endpoint_type,json=endpointType,proto3,enum=flow.EndpointType" json:"endpoint_type,omitempty"`
	// JSON-encoded object which specifies this capture with
	// respect to the endpoint type driver.
	EndpointSpecJson encoding_json.RawMessage `protobuf:"bytes,3,opt,name=endpoint_spec_json,json=endpointSpec,proto3,casttype=encoding/json.RawMessage" json:"endpoint_spec_json,omitempty"`
	Bindings         []*CaptureSpec_Binding   `protobuf:"bytes,4,rep,name=bindings,proto3" json:"bindings,omitempty"`
	// Minimum interval of time between successive invocations of the capture.
	IntervalSeconds uint32 `protobuf:"varint,5,opt,name=interval_seconds,json=intervalSeconds,proto3" json:"interval_seconds,omitempty"`
	// Template for shards of this capture.
	ShardTemplate *protocol1.ShardSpec `protobuf:"bytes,6,opt,name=shard_template,json=shardTemplate,proto3" json:"shard_template,omitempty"`
	// Template for recovery logs of shards of this capture.
	RecoveryLogTemplate  *protocol.JournalSpec `protobuf:"bytes,7,opt,name=recovery_log_template,json=recoveryLogTemplate,proto3" json:"recovery_log_template,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *CaptureSpec) Reset()         { *m = CaptureSpec{} }
func (m *CaptureSpec) String() string { return proto.CompactTextString(m) }
func (*CaptureSpec) ProtoMessage()    {}
func (*CaptureSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{11}
}
func (m *CaptureSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CaptureSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CaptureSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CaptureSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CaptureSpec.Merge(m, src)
}
func (m *CaptureSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CaptureSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CaptureSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CaptureSpec proto.InternalMessageInfo

// Bindings of endpoint resources and collections into which they're captured.
// Bindings are ordered and unique on the bound collection name,
// and are also unique on the resource path.
type CaptureSpec_Binding struct {
	// JSON-encoded object which specifies the endpoint resource to be captured.
	ResourceSpecJson encoding_json.RawMessage `protobuf:"bytes,1,opt,name=resource_spec_json,json=resourceSpec,proto3,casttype=encoding/json.RawMessage" json:"resource_spec_json,omitempty"`
	// Driver-supplied path components which fully qualify the
	// subresource being captured.
	ResourcePath []string `protobuf:"bytes,2,rep,name=resource_path,json=resourcePath,proto3" json:"resource_path,omitempty"`
	// Collection to be captured into.
	Collection           CollectionSpec `protobuf:"bytes,3,opt,name=collection,proto3" json:"collection"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CaptureSpec_Binding) Reset()         { *m = CaptureSpec_Binding{} }
func (m *CaptureSpec_Binding) String() string { return proto.CompactTextString(m) }
func (*CaptureSpec_Binding) ProtoMessage()    {}
func (*CaptureSpec_Binding) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{11, 0}
}
func (m *CaptureSpec_Binding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CaptureSpec_Binding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CaptureSpec_Binding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CaptureSpec_Binding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CaptureSpec_Binding.Merge(m, src)
}
func (m *CaptureSpec_Binding) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CaptureSpec_Binding) XXX_DiscardUnknown() {
	xxx_messageInfo_CaptureSpec_Binding.DiscardUnknown(m)
}

var xxx_messageInfo_CaptureSpec_Binding proto.InternalMessageInfo

// MaterializationSpec describes a collection and its materialization to an
// endpoint.
type MaterializationSpec struct {
	// Name of this materialization.
	Materialization Materialization `protobuf:"bytes,1,opt,name=materialization,proto3,casttype=Materialization" json:"materialization,omitempty"`
	// Type of the materialization's endpoint.
	EndpointType EndpointType `protobuf:"varint,2,opt,name=endpoint_type,json=endpointType,proto3,enum=flow.EndpointType" json:"endpoint_type,omitempty"`
	// JSON-encoded object which specifies this materialization with
	// respect to the endpoint type driver.
	EndpointSpecJson encoding_json.RawMessage       `protobuf:"bytes,3,opt,name=endpoint_spec_json,json=endpointSpec,proto3,casttype=encoding/json.RawMessage" json:"endpoint_spec_json,omitempty"`
	Bindings         []*MaterializationSpec_Binding `protobuf:"bytes,4,rep,name=bindings,proto3" json:"bindings,omitempty"`
	// Template for shards of this materialization.
	ShardTemplate *protocol1.ShardSpec `protobuf:"bytes,5,opt,name=shard_template,json=shardTemplate,proto3" json:"shard_template,omitempty"`
	// Template for recovery logs of shards of this materialization.
	RecoveryLogTemplate  *protocol.JournalSpec `protobuf:"bytes,6,opt,name=recovery_log_template,json=recoveryLogTemplate,proto3" json:"recovery_log_template,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MaterializationSpec) Reset()         { *m = MaterializationSpec{} }
func (m *MaterializationSpec) String() string { return proto.CompactTextString(m) }
func (*MaterializationSpec) ProtoMessage()    {}
func (*MaterializationSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{12}
}
func (m *MaterializationSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaterializationSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaterializationSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaterializationSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaterializationSpec.Merge(m, src)
}
func (m *MaterializationSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MaterializationSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MaterializationSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MaterializationSpec proto.InternalMessageInfo

// Bindings of endpoint resources and collections from which they're
// materialized. Bindings are ordered and unique on the bound collection name,
// and are also unique on the resource path.
type MaterializationSpec_Binding struct {
	// JSON-encoded object which specifies the endpoint resource to be
	// materialized.
	ResourceSpecJson encoding_json.RawMessage `protobuf:"bytes,1,opt,name=resource_spec_json,json=resourceSpec,proto3,casttype=encoding/json.RawMessage" json:"resource_spec_json,omitempty"`
	// Driver-supplied path components which fully qualify the
	// subresource being materialized.
	ResourcePath []string `protobuf:"bytes,2,rep,name=resource_path,json=resourcePath,proto3" json:"resource_path,omitempty"`
	// Collection to be materialized.
	Collection CollectionSpec `protobuf:"bytes,3,opt,name=collection,proto3" json:"collection"`
	// Resolved fields selected for materialization.
	FieldSelection FieldSelection `protobuf:"bytes,4,opt,name=field_selection,json=fieldSelection,proto3" json:"field_selection"`
	// Materialize delta updates of documents rather than full reductions.
	DeltaUpdates bool `protobuf:"varint,5,opt,name=delta_updates,json=deltaUpdates,proto3" json:"delta_updates,omitempty"`
	// Shuffle applied to collection documents for this materialization binding.
	Shuffle              Shuffle  `protobuf:"bytes,6,opt,name=shuffle,proto3" json:"shuffle"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MaterializationSpec_Binding) Reset()         { *m = MaterializationSpec_Binding{} }
func (m *MaterializationSpec_Binding) String() string { return proto.CompactTextString(m) }
func (*MaterializationSpec_Binding) ProtoMessage()    {}
func (*MaterializationSpec_Binding) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{12, 0}
}
func (m *MaterializationSpec_Binding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaterializationSpec_Binding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaterializationSpec_Binding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaterializationSpec_Binding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaterializationSpec_Binding.Merge(m, src)
}
func (m *MaterializationSpec_Binding) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MaterializationSpec_Binding) XXX_DiscardUnknown() {
	xxx_messageInfo_MaterializationSpec_Binding.DiscardUnknown(m)
}

var xxx_messageInfo_MaterializationSpec_Binding proto.InternalMessageInfo

// OAuth2Spec describes an OAuth2 provider
type OAuth2Spec struct {
	// Name of the OAuth2 provider. This is a machine-readable key and must stay
	// consistent. One example use case is to map providers to their respective
	// style of buttons in the UI
	Provider string `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	// Template for authorization URL, this is the first step of the OAuth2 flow
	// where the user is redirected to the OAuth2 provider to authorize access to
	// their account
	AuthUrlTemplate string `protobuf:"bytes,2,opt,name=auth_url_template,json=authUrlTemplate,proto3" json:"auth_url_template,omitempty"`
	// Template for access token URL, this is the second step of the OAuth2 flow,
	// where we request an access token from the provider
	AccessTokenUrlTemplate string `protobuf:"bytes,3,opt,name=access_token_url_template,json=accessTokenUrlTemplate,proto3" json:"access_token_url_template,omitempty"`
	// The method used to send access_token request. POST by default.
	AccessTokenMethod string `protobuf:"bytes,11,opt,name=access_token_method,json=accessTokenMethod,proto3" json:"access_token_method,omitempty"`
	// The POST body of the access_token request
	AccessTokenBody string `protobuf:"bytes,4,opt,name=access_token_body,json=accessTokenBody,proto3" json:"access_token_body,omitempty"`
	// Headers for the access_token request
	AccessTokenHeadersJson encoding_json.RawMessage `protobuf:"bytes,5,opt,name=access_token_headers_json,json=accessTokenHeaders,proto3,casttype=encoding/json.RawMessage" json:"access_token_headers_json,omitempty"`
	// A json map that maps the response from the OAuth provider for Access Token
	// request to keys in the connector endpoint configuration.
	// If the connector supports refresh tokens, must include `refresh_token` and
	// `expires_in`. If this mapping is not provided, the keys from the response
	// are passed as-is to the connector config.
	AccessTokenResponseMapJson encoding_json.RawMessage `protobuf:"bytes,6,opt,name=access_token_response_map_json,json=accessTokenResponseMap,proto3,casttype=encoding/json.RawMessage" json:"access_token_response_map_json,omitempty"`
	// Template for refresh token URL, some providers require that the access
	// token be refreshed.
	RefreshTokenUrlTemplate string `protobuf:"bytes,7,opt,name=refresh_token_url_template,json=refreshTokenUrlTemplate,proto3" json:"refresh_token_url_template,omitempty"`
	// The method used to send refresh_token request. POST by default.
	RefreshTokenMethod string `protobuf:"bytes,12,opt,name=refresh_token_method,json=refreshTokenMethod,proto3" json:"refresh_token_method,omitempty"`
	// The POST body of the refresh_token request
	RefreshTokenBody string `protobuf:"bytes,8,opt,name=refresh_token_body,json=refreshTokenBody,proto3" json:"refresh_token_body,omitempty"`
	// Headers for the refresh_token request
	RefreshTokenHeadersJson encoding_json.RawMessage `protobuf:"bytes,9,opt,name=refresh_token_headers_json,json=refreshTokenHeaders,proto3,casttype=encoding/json.RawMessage" json:"refresh_token_headers_json,omitempty"`
	// A json map that maps the response from the OAuth provider for Refresh Token
	// request to keys in the connector endpoint configuration.
	// If the connector supports refresh tokens, must include `refresh_token` and
	// `expires_in`. If this mapping is not provided, the keys from the response
	// are passed as-is to the connector config.
	RefreshTokenResponseMapJson encoding_json.RawMessage `protobuf:"bytes,10,opt,name=refresh_token_response_map_json,json=refreshTokenResponseMap,proto3,casttype=encoding/json.RawMessage" json:"refresh_token_response_map_json,omitempty"`
	XXX_NoUnkeyedLiteral        struct{}                 `json:"-"`
	XXX_unrecognized            []byte                   `json:"-"`
	XXX_sizecache               int32                    `json:"-"`
}

func (m *OAuth2Spec) Reset()         { *m = OAuth2Spec{} }
func (m *OAuth2Spec) String() string { return proto.CompactTextString(m) }
func (*OAuth2Spec) ProtoMessage()    {}
func (*OAuth2Spec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{13}
}
func (m *OAuth2Spec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OAuth2Spec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OAuth2Spec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OAuth2Spec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OAuth2Spec.Merge(m, src)
}
func (m *OAuth2Spec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OAuth2Spec) XXX_DiscardUnknown() {
	xxx_messageInfo_OAuth2Spec.DiscardUnknown(m)
}

var xxx_messageInfo_OAuth2Spec proto.InternalMessageInfo

// TestSpec describes a catalog test.
type TestSpec struct {
	// Name of this test.
	Test                 string          `protobuf:"bytes,1,opt,name=test,proto3" json:"test,omitempty"`
	Steps                []TestSpec_Step `protobuf:"bytes,2,rep,name=steps,proto3" json:"steps"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *TestSpec) Reset()         { *m = TestSpec{} }
func (m *TestSpec) String() string { return proto.CompactTextString(m) }
func (*TestSpec) ProtoMessage()    {}
func (*TestSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{14}
}
func (m *TestSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSpec.Merge(m, src)
}
func (m *TestSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TestSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TestSpec proto.InternalMessageInfo

// Steps of the test.
type TestSpec_Step struct {
	StepType TestSpec_Step_Type `protobuf:"varint,1,opt,name=step_type,json=stepType,proto3,enum=flow.TestSpec_Step_Type" json:"step_type,omitempty"`
	// Index of this step within the test.
	StepIndex uint32 `protobuf:"varint,2,opt,name=step_index,json=stepIndex,proto3" json:"step_index,omitempty"`
	// Description of this step.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Scope of the test definition location.
	StepScope string `protobuf:"bytes,4,opt,name=step_scope,json=stepScope,proto3" json:"step_scope,omitempty"`
	// Collection ingested or verified by this step.
	Collection Collection `protobuf:"bytes,5,opt,name=collection,proto3,casttype=Collection" json:"collection,omitempty"`
	// Newline-separated JSON documents to ingest or verify.
	DocsJsonLines string `protobuf:"bytes,6,opt,name=docs_json_lines,json=docsJsonLines,proto3" json:"docs_json_lines,omitempty"`
	// When verifying, selector over logical partitions of the collection.
	Partitions           protocol.LabelSelector `protobuf:"bytes,7,opt,name=partitions,proto3" json:"partitions"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TestSpec_Step) Reset()         { *m = TestSpec_Step{} }
func (m *TestSpec_Step) String() string { return proto.CompactTextString(m) }
func (*TestSpec_Step) ProtoMessage()    {}
func (*TestSpec_Step) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{14, 0}
}
func (m *TestSpec_Step) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSpec_Step) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSpec_Step.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSpec_Step) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSpec_Step.Merge(m, src)
}
func (m *TestSpec_Step) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TestSpec_Step) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSpec_Step.DiscardUnknown(m)
}

var xxx_messageInfo_TestSpec_Step proto.InternalMessageInfo

// RangeSpec describes the ranges of shuffle keys and r-clocks which a reader
// is responsible for.
type RangeSpec struct {
	// [begin, end] inclusive range of keys to be shuffled to this reader.
	// Ranges are with respect to a 32-bit hash of a packed document key.
	//
	// The choice of hash function is important: while it need not be
	// cryptographically secure, it must demonstrate a strong "avalanche effect"
	// (ideally meeting the strict avalanche criterion), to ensure that small
	// pertubations of input keys are equally likely to independently affect
	// hash output bits. Particularly the higest bits of the hash result,
	// which dominate the selection of a shuffled shard.
	//
	// At present, Flow uses the high 32 bits of a HighWayHash 64-bit
	// checksum, using a fixed 32-byte key.
	KeyBegin uint32 `protobuf:"fixed32,2,opt,name=key_begin,json=keyBegin,proto3" json:"key_begin,omitempty"`
	KeyEnd   uint32 `protobuf:"fixed32,3,opt,name=key_end,json=keyEnd,proto3" json:"key_end,omitempty"`
	// Rotated [begin, end] inclusive ranges of Clocks.
	RClockBegin uint32 `protobuf:"fixed32,4,opt,name=r_clock_begin,json=rClockBegin,proto3" json:"r_clock_begin,omitempty"`
	RClockEnd   uint32 `protobuf:"fixed32,5,opt,name=r_clock_end,json=rClockEnd,proto3" json:"r_clock_end,omitempty"`
}

func (m *RangeSpec) Reset()      { *m = RangeSpec{} }
func (*RangeSpec) ProtoMessage() {}
func (*RangeSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{15}
}
func (m *RangeSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RangeSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RangeSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeSpec.Merge(m, src)
}
func (m *RangeSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RangeSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RangeSpec proto.InternalMessageInfo

// ShuffleRequest is the request message of a Shuffle RPC.
type ShuffleRequest struct {
	// Journal to be shuffled, routed to a coordinator.
	Shuffle JournalShuffle `protobuf:"bytes,1,opt,name=shuffle,proto3" json:"shuffle"`
	// Resolution header of the |shuffle.coordinator| shard.
	Resolution *protocol.Header `protobuf:"bytes,2,opt,name=resolution,proto3" json:"resolution,omitempty"`
	// Ranges of responsibility which are unique to this reader,
	// against which document shuffle outcomes are matched to determine
	// read eligibility.
	Range RangeSpec `protobuf:"bytes,3,opt,name=range,proto3" json:"range"`
	// Offset to begin reading the journal from.
	Offset go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,4,opt,name=offset,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"offset,omitempty"`
	// Offset to stop reading the journal at, or zero if unbounded.
	EndOffset            go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,5,opt,name=end_offset,json=endOffset,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"end_offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                   `json:"-"`
	XXX_unrecognized     []byte                                     `json:"-"`
	XXX_sizecache        int32                                      `json:"-"`
}

func (m *ShuffleRequest) Reset()         { *m = ShuffleRequest{} }
func (m *ShuffleRequest) String() string { return proto.CompactTextString(m) }
func (*ShuffleRequest) ProtoMessage()    {}
func (*ShuffleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{16}
}
func (m *ShuffleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShuffleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShuffleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShuffleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShuffleRequest.Merge(m, src)
}
func (m *ShuffleRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShuffleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ShuffleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ShuffleRequest proto.InternalMessageInfo

// ShuffleResponse is the streamed response message of a Shuffle RPC.
type ShuffleResponse struct {
	// Status of the Shuffle RPC.
	Status protocol1.Status `protobuf:"varint,1,opt,name=status,proto3,enum=consumer.Status" json:"status,omitempty"`
	// Header of the response.
	Header *protocol.Header `protobuf:"bytes,2,opt,name=header,proto3" json:"header,omitempty"`
	// Terminal error encountered while serving this ShuffleRequest. A terminal
	// error is only sent if a future ShuffleRequest of this same configuration
	// and offset will fail in the exact same way, and operator intervention is
	// required to properly recover. Such errors are returned so that the caller
	// can also abort with a useful, contextual error message.
	//
	// Examples of terminal errors include the requested journal not existing,
	// or data corruption. Errors *not* returned as |terminal_error| include
	// network errors, process failures, and other conditions which can be
	// retried.
	TerminalError string `protobuf:"bytes,3,opt,name=terminal_error,json=terminalError,proto3" json:"terminal_error,omitempty"`
	// Offset which was read through to produce this ShuffleResponse.
	ReadThrough go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,4,opt,name=read_through,json=readThrough,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"read_through,omitempty"`
	// WriteHead of the journal as reported by the broker, as of the creation of
	// this ShuffleResponse.
	WriteHead go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,5,opt,name=write_head,json=writeHead,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"write_head,omitempty"`
	// Memory arena of this message.
	Arena Arena `protobuf:"bytes,6,opt,name=arena,proto3,casttype=Arena" json:"arena,omitempty"`
	// Shuffled documents, each encoded in the 'application/json'
	// media-type.
	DocsJson []Slice `protobuf:"bytes,7,rep,name=docs_json,json=docsJson,proto3" json:"docs_json"`
	// The journal offsets of each document within the requested journal.
	// For a document at index i, its offsets are [ offsets[2*i], offsets[2*i+1]
	// ).
	Offsets []go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,8,rep,packed,name=offsets,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"offsets,omitempty"`
	// UUIDParts of each document.
	UuidParts []UUIDParts `protobuf:"bytes,9,rep,name=uuid_parts,json=uuidParts,proto3" json:"uuid_parts"`
	// Packed, embedded encoding of the shuffle key into a byte string.
	// If the Shuffle specified a Hash to use, it's applied as well.
	PackedKey            []Slice  `protobuf:"bytes,10,rep,name=packed_key,json=packedKey,proto3" json:"packed_key"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShuffleResponse) Reset()         { *m = ShuffleResponse{} }
func (m *ShuffleResponse) String() string { return proto.CompactTextString(m) }
func (*ShuffleResponse) ProtoMessage()    {}
func (*ShuffleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{17}
}
func (m *ShuffleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShuffleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShuffleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShuffleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShuffleResponse.Merge(m, src)
}
func (m *ShuffleResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShuffleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ShuffleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ShuffleResponse proto.InternalMessageInfo

// DriverCheckpoint is a driver-originated checkpoint withn a capture or
// materialization.
type DriverCheckpoint struct {
	// Optional driver checkpoint of this transaction, to be persisted
	// by the Flow runtime and returned in a future transaction stream.
	// If empty, then a previous checkpoint is cleared.
	DriverCheckpointJson encoding_json.RawMessage `protobuf:"bytes,1,opt,name=driver_checkpoint_json,json=driverCheckpoint,proto3,casttype=encoding/json.RawMessage" json:"driver_checkpoint_json,omitempty"`
	// If true, then the driver checkpoint must be non-empty and is
	// applied as an RFC7396 Merge Patch atop the immediately preceeding
	// checkpoint (or to an empty JSON object `{}` if there is no checkpoint).
	Rfc7396MergePatch    bool     `protobuf:"varint,2,opt,name=rfc7396_merge_patch,json=rfc7396MergePatch,proto3" json:"rfc7396_merge_patch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DriverCheckpoint) Reset()         { *m = DriverCheckpoint{} }
func (m *DriverCheckpoint) String() string { return proto.CompactTextString(m) }
func (*DriverCheckpoint) ProtoMessage()    {}
func (*DriverCheckpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{18}
}
func (m *DriverCheckpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DriverCheckpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DriverCheckpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DriverCheckpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DriverCheckpoint.Merge(m, src)
}
func (m *DriverCheckpoint) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DriverCheckpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_DriverCheckpoint.DiscardUnknown(m)
}

var xxx_messageInfo_DriverCheckpoint proto.InternalMessageInfo

type ExtractAPI struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtractAPI) Reset()         { *m = ExtractAPI{} }
func (m *ExtractAPI) String() string { return proto.CompactTextString(m) }
func (*ExtractAPI) ProtoMessage()    {}
func (*ExtractAPI) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{19}
}
func (m *ExtractAPI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtractAPI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtractAPI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtractAPI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtractAPI.Merge(m, src)
}
func (m *ExtractAPI) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExtractAPI) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtractAPI.DiscardUnknown(m)
}

var xxx_messageInfo_ExtractAPI proto.InternalMessageInfo

type ExtractAPI_Config struct {
	// JSON pointer of the document UUID to extract.
	UuidPtr string `protobuf:"bytes,1,opt,name=uuid_ptr,json=uuidPtr,proto3" json:"uuid_ptr,omitempty"`
	// JSON schema to validate non-ACK documents against.
	// If empty then schema validation is not performed.
	SchemaJson encoding_json.RawMessage `protobuf:"bytes,2,opt,name=schema_json,json=schemaJson,proto3,casttype=encoding/json.RawMessage" json:"schema_json,omitempty"`
	// Field JSON pointers to extract from documents and return as packed
	// tuples.
	FieldPtrs            []string `protobuf:"bytes,3,rep,name=field_ptrs,json=fieldPtrs,proto3" json:"field_ptrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtractAPI_Config) Reset()         { *m = ExtractAPI_Config{} }
func (m *ExtractAPI_Config) String() string { return proto.CompactTextString(m) }
func (*ExtractAPI_Config) ProtoMessage()    {}
func (*ExtractAPI_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{19, 0}
}
func (m *ExtractAPI_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtractAPI_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtractAPI_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtractAPI_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtractAPI_Config.Merge(m, src)
}
func (m *ExtractAPI_Config) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExtractAPI_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtractAPI_Config.DiscardUnknown(m)
}

var xxx_messageInfo_ExtractAPI_Config proto.InternalMessageInfo

type CombineAPI struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CombineAPI) Reset()         { *m = CombineAPI{} }
func (m *CombineAPI) String() string { return proto.CompactTextString(m) }
func (*CombineAPI) ProtoMessage()    {}
func (*CombineAPI) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{20}
}
func (m *CombineAPI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombineAPI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombineAPI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombineAPI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombineAPI.Merge(m, src)
}
func (m *CombineAPI) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CombineAPI) XXX_DiscardUnknown() {
	xxx_messageInfo_CombineAPI.DiscardUnknown(m)
}

var xxx_messageInfo_CombineAPI proto.InternalMessageInfo

type CombineAPI_Config struct {
	// JSON schema against which documents are to be validated,
	// and which provides reduction annotations.
	SchemaJson encoding_json.RawMessage `protobuf:"bytes,1,opt,name=schema_json,json=schemaJson,proto3,casttype=encoding/json.RawMessage" json:"schema_json,omitempty"`
	// Composite key used to group documents to be combined, specified as one or
	// more JSON-Pointers indicating a message location to extract.
	// If empty, all request documents are combined into a single response
	// document.
	KeyPtrs []string `protobuf:"bytes,2,rep,name=key_ptrs,json=keyPtrs,proto3" json:"key_ptrs,omitempty"`
	// Field JSON pointers to be extracted from combined documents and returned.
	// If empty, no fields are extracted.
	FieldPtrs []string `protobuf:"bytes,3,rep,name=field_ptrs,json=fieldPtrs,proto3" json:"field_ptrs,omitempty"`
	// JSON-Pointer at which a placeholder UUID should be inserted into
	// returned documents. If empty, no placeholder is inserted.
	UuidPlaceholderPtr   string   `protobuf:"bytes,4,opt,name=uuid_placeholder_ptr,json=uuidPlaceholderPtr,proto3" json:"uuid_placeholder_ptr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CombineAPI_Config) Reset()         { *m = CombineAPI_Config{} }
func (m *CombineAPI_Config) String() string { return proto.CompactTextString(m) }
func (*CombineAPI_Config) ProtoMessage()    {}
func (*CombineAPI_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{20, 0}
}
func (m *CombineAPI_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombineAPI_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombineAPI_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombineAPI_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombineAPI_Config.Merge(m, src)
}
func (m *CombineAPI_Config) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CombineAPI_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_CombineAPI_Config.DiscardUnknown(m)
}

var xxx_messageInfo_CombineAPI_Config proto.InternalMessageInfo

// Stats holds statistics relating to one or more combiner transactions.
type CombineAPI_Stats struct {
	Left                 *DocsAndBytes `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right                *DocsAndBytes `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	Out                  *DocsAndBytes `protobuf:"bytes,3,opt,name=out,proto3" json:"out,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *CombineAPI_Stats) Reset()         { *m = CombineAPI_Stats{} }
func (m *CombineAPI_Stats) String() string { return proto.CompactTextString(m) }
func (*CombineAPI_Stats) ProtoMessage()    {}
func (*CombineAPI_Stats) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{20, 1}
}
func (m *CombineAPI_Stats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombineAPI_Stats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombineAPI_Stats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombineAPI_Stats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombineAPI_Stats.Merge(m, src)
}
func (m *CombineAPI_Stats) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CombineAPI_Stats) XXX_DiscardUnknown() {
	xxx_messageInfo_CombineAPI_Stats.DiscardUnknown(m)
}

var xxx_messageInfo_CombineAPI_Stats proto.InternalMessageInfo

// DeriveAPI is a meta-message which name spaces messages of the Derive API
// bridge.
type DeriveAPI struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveAPI) Reset()         { *m = DeriveAPI{} }
func (m *DeriveAPI) String() string { return proto.CompactTextString(m) }
func (*DeriveAPI) ProtoMessage()    {}
func (*DeriveAPI) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{21}
}
func (m *DeriveAPI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveAPI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveAPI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveAPI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveAPI.Merge(m, src)
}
func (m *DeriveAPI) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveAPI) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveAPI.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveAPI proto.InternalMessageInfo

// Open the registers database.
type DeriveAPI_Open struct {
	// Memory address of an RocksDB Environment to use (as a *rocksdb_env_t).
	// Ownership of the environment is transferred with this message.
	RocksdbEnvMemptr uint64 `protobuf:"fixed64,1,opt,name=rocksdb_env_memptr,json=rocksdbEnvMemptr,proto3" json:"rocksdb_env_memptr,omitempty"`
	// Local directory for ephemeral processing state.
	LocalDir             string   `protobuf:"bytes,2,opt,name=local_dir,json=localDir,proto3" json:"local_dir,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveAPI_Open) Reset()         { *m = DeriveAPI_Open{} }
func (m *DeriveAPI_Open) String() string { return proto.CompactTextString(m) }
func (*DeriveAPI_Open) ProtoMessage()    {}
func (*DeriveAPI_Open) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{21, 0}
}
func (m *DeriveAPI_Open) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveAPI_Open) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveAPI_Open.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveAPI_Open) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveAPI_Open.Merge(m, src)
}
func (m *DeriveAPI_Open) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveAPI_Open) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveAPI_Open.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveAPI_Open proto.InternalMessageInfo

// Config configures the derived DerivationSpec and its associated schema
// index.
type DeriveAPI_Config struct {
	// Derivation to derive.
	Derivation           *DerivationSpec `protobuf:"bytes,1,opt,name=derivation,proto3" json:"derivation,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *DeriveAPI_Config) Reset()         { *m = DeriveAPI_Config{} }
func (m *DeriveAPI_Config) String() string { return proto.CompactTextString(m) }
func (*DeriveAPI_Config) ProtoMessage()    {}
func (*DeriveAPI_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{21, 1}
}
func (m *DeriveAPI_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveAPI_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveAPI_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveAPI_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveAPI_Config.Merge(m, src)
}
func (m *DeriveAPI_Config) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveAPI_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveAPI_Config.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveAPI_Config proto.InternalMessageInfo

// DocHeader precedes a JSON-encoded document.
type DeriveAPI_DocHeader struct {
	// UUID of this document.
	Uuid *UUIDParts `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// FDB packed shuffle key of the document.
	PackedKey []byte `protobuf:"bytes,2,opt,name=packed_key,json=packedKey,proto3" json:"packed_key,omitempty"`
	// Index of the transformation under which this document is being
	// processed, within the configured DerivationSpec.
	TransformIndex       uint32   `protobuf:"varint,3,opt,name=transform_index,json=transformIndex,proto3" json:"transform_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveAPI_DocHeader) Reset()         { *m = DeriveAPI_DocHeader{} }
func (m *DeriveAPI_DocHeader) String() string { return proto.CompactTextString(m) }
func (*DeriveAPI_DocHeader) ProtoMessage()    {}
func (*DeriveAPI_DocHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{21, 2}
}
func (m *DeriveAPI_DocHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveAPI_DocHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveAPI_DocHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveAPI_DocHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveAPI_DocHeader.Merge(m, src)
}
func (m *DeriveAPI_DocHeader) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveAPI_DocHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveAPI_DocHeader.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveAPI_DocHeader proto.InternalMessageInfo

// Invoke a lambda, using Rust-owned memory buffers of invocation content.
// Memory will remain pinned until the trampoline task completion.
// |sources_length| will never be zero. If |registers_length| is zero,
// this invocation is of the update lambda. Otherwise, it's the publish
// lambda.
type DeriveAPI_Invoke struct {
	// Index of the transformation to be invoked within DerivationSpec.
	TransformIndex uint32 `protobuf:"varint,1,opt,name=transform_index,json=transformIndex,proto3" json:"transform_index,omitempty"`
	// Memory pointer and length of comma-separated source documents.
	SourcesMemptr uint64 `protobuf:"fixed64,2,opt,name=sources_memptr,json=sourcesMemptr,proto3" json:"sources_memptr,omitempty"`
	SourcesLength uint64 `protobuf:"varint,3,opt,name=sources_length,json=sourcesLength,proto3" json:"sources_length,omitempty"`
	// Memory pointer and length of comma-separated register documents.
	RegistersMemptr      uint64   `protobuf:"fixed64,4,opt,name=registers_memptr,json=registersMemptr,proto3" json:"registers_memptr,omitempty"`
	RegistersLength      uint64   `protobuf:"varint,5,opt,name=registers_length,json=registersLength,proto3" json:"registers_length,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveAPI_Invoke) Reset()         { *m = DeriveAPI_Invoke{} }
func (m *DeriveAPI_Invoke) String() string { return proto.CompactTextString(m) }
func (*DeriveAPI_Invoke) ProtoMessage()    {}
func (*DeriveAPI_Invoke) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{21, 3}
}
func (m *DeriveAPI_Invoke) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveAPI_Invoke) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveAPI_Invoke.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveAPI_Invoke) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveAPI_Invoke.Merge(m, src)
}
func (m *DeriveAPI_Invoke) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveAPI_Invoke) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveAPI_Invoke.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveAPI_Invoke proto.InternalMessageInfo

// Prepare a commit of the transaction.
type DeriveAPI_Prepare struct {
	// Checkpoint to commit.
	Checkpoint           protocol1.Checkpoint `protobuf:"bytes,1,opt,name=checkpoint,proto3" json:"checkpoint"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *DeriveAPI_Prepare) Reset()         { *m = DeriveAPI_Prepare{} }
func (m *DeriveAPI_Prepare) String() string { return proto.CompactTextString(m) }
func (*DeriveAPI_Prepare) ProtoMessage()    {}
func (*DeriveAPI_Prepare) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{21, 4}
}
func (m *DeriveAPI_Prepare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveAPI_Prepare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveAPI_Prepare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveAPI_Prepare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveAPI_Prepare.Merge(m, src)
}
func (m *DeriveAPI_Prepare) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveAPI_Prepare) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveAPI_Prepare.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveAPI_Prepare proto.InternalMessageInfo

// Stats holds statistics relating to a single derive transaction.
type DeriveAPI_Stats struct {
	// Array indexed by transform_index with stats per transform.
	Transforms []*DeriveAPI_Stats_TransformStats `protobuf:"bytes,1,rep,name=transforms,proto3" json:"transforms,omitempty"`
	Registers  *DeriveAPI_Stats_RegisterStats    `protobuf:"bytes,2,opt,name=registers,proto3" json:"registers,omitempty"`
	// The documents drained from the derive pipeline's combiner. This is not
	// necessarily the same as the sum of all publish lambda outputs because
	// those outputs may be further reduced.
	Output               *DocsAndBytes `protobuf:"bytes,3,opt,name=output,proto3" json:"output,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DeriveAPI_Stats) Reset()         { *m = DeriveAPI_Stats{} }
func (m *DeriveAPI_Stats) String() string { return proto.CompactTextString(m) }
func (*DeriveAPI_Stats) ProtoMessage()    {}
func (*DeriveAPI_Stats) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{21, 5}
}
func (m *DeriveAPI_Stats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveAPI_Stats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveAPI_Stats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveAPI_Stats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveAPI_Stats.Merge(m, src)
}
func (m *DeriveAPI_Stats) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveAPI_Stats) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveAPI_Stats.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveAPI_Stats proto.InternalMessageInfo

// Stats about the invocation of update or publish lambdas.
type DeriveAPI_Stats_InvokeStats struct {
	// The total number of documents and bytes that were output from the
	// invocations.
	Output *DocsAndBytes `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
	// Sum total duration of all invocations, in seconds.
	TotalSeconds         float64  `protobuf:"fixed64,2,opt,name=total_seconds,json=totalSeconds,proto3" json:"total_seconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveAPI_Stats_InvokeStats) Reset()         { *m = DeriveAPI_Stats_InvokeStats{} }
func (m *DeriveAPI_Stats_InvokeStats) String() string { return proto.CompactTextString(m) }
func (*DeriveAPI_Stats_InvokeStats) ProtoMessage()    {}
func (*DeriveAPI_Stats_InvokeStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{21, 5, 0}
}
func (m *DeriveAPI_Stats_InvokeStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveAPI_Stats_InvokeStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveAPI_Stats_InvokeStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveAPI_Stats_InvokeStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveAPI_Stats_InvokeStats.Merge(m, src)
}
func (m *DeriveAPI_Stats_InvokeStats) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveAPI_Stats_InvokeStats) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveAPI_Stats_InvokeStats.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveAPI_Stats_InvokeStats proto.InternalMessageInfo

type DeriveAPI_Stats_TransformStats struct {
	// The total inputs that were fed into this transform.
	Input *DocsAndBytes `protobuf:"bytes,1,opt,name=input,proto3" json:"input,omitempty"`
	// Results of invoking the update lambda.
	Update *DeriveAPI_Stats_InvokeStats `protobuf:"bytes,2,opt,name=update,proto3" json:"update,omitempty"`
	// Results of invoking the publish lambda.
	Publish              *DeriveAPI_Stats_InvokeStats `protobuf:"bytes,3,opt,name=publish,proto3" json:"publish,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *DeriveAPI_Stats_TransformStats) Reset()         { *m = DeriveAPI_Stats_TransformStats{} }
func (m *DeriveAPI_Stats_TransformStats) String() string { return proto.CompactTextString(m) }
func (*DeriveAPI_Stats_TransformStats) ProtoMessage()    {}
func (*DeriveAPI_Stats_TransformStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{21, 5, 1}
}
func (m *DeriveAPI_Stats_TransformStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveAPI_Stats_TransformStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveAPI_Stats_TransformStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveAPI_Stats_TransformStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveAPI_Stats_TransformStats.Merge(m, src)
}
func (m *DeriveAPI_Stats_TransformStats) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveAPI_Stats_TransformStats) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveAPI_Stats_TransformStats.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveAPI_Stats_TransformStats proto.InternalMessageInfo

type DeriveAPI_Stats_RegisterStats struct {
	// The number of new register values that were created and added to the
	// registers database. In the future, it may be nice to also expose stats
	// related to the size of documents stored within registers, but it's not
	// obvious how to count updates to existing values as a result of
	// reductions. So this lone field represents the cerservative subset of
	// register stats that I feel confident we can and should expose as part
	// of the user-facing stats.
	Created              uint32   `protobuf:"varint,1,opt,name=created,proto3" json:"created,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveAPI_Stats_RegisterStats) Reset()         { *m = DeriveAPI_Stats_RegisterStats{} }
func (m *DeriveAPI_Stats_RegisterStats) String() string { return proto.CompactTextString(m) }
func (*DeriveAPI_Stats_RegisterStats) ProtoMessage()    {}
func (*DeriveAPI_Stats_RegisterStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{21, 5, 2}
}
func (m *DeriveAPI_Stats_RegisterStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveAPI_Stats_RegisterStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveAPI_Stats_RegisterStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveAPI_Stats_RegisterStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveAPI_Stats_RegisterStats.Merge(m, src)
}
func (m *DeriveAPI_Stats_RegisterStats) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveAPI_Stats_RegisterStats) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveAPI_Stats_RegisterStats.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveAPI_Stats_RegisterStats proto.InternalMessageInfo

// BuildAPI is a meta-message which name spaces messages of the Build API
// bridge.
type BuildAPI struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuildAPI) Reset()         { *m = BuildAPI{} }
func (m *BuildAPI) String() string { return proto.CompactTextString(m) }
func (*BuildAPI) ProtoMessage()    {}
func (*BuildAPI) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{22}
}
func (m *BuildAPI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildAPI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildAPI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildAPI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildAPI.Merge(m, src)
}
func (m *BuildAPI) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BuildAPI) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildAPI.DiscardUnknown(m)
}

var xxx_messageInfo_BuildAPI proto.InternalMessageInfo

type BuildAPI_Config struct {
	// Identifier of this build.
	// The path of the output database is determined by joining the
	// configured directory and configured build ID.
	BuildId string `protobuf:"bytes,1,opt,name=build_id,json=buildId,proto3" json:"build_id,omitempty"`
	// Path to the directory into which the `node_modules` and `flow_generated`
	// directories are generated, as well as the built NPM package and
	// the output database.
	Directory string `protobuf:"bytes,2,opt,name=directory,proto3" json:"directory,omitempty"`
	// Root catalog source specification. This may be either a local path
	// relative to the current working directory, or an absolute URL.
	Source string `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	// Content type of the source.
	SourceType ContentType `protobuf:"varint,4,opt,name=source_type,json=sourceType,proto3,enum=flow.ContentType" json:"source_type,omitempty"`
	// Should the TypeScript package be generated?
	TypescriptGenerate bool `protobuf:"varint,5,opt,name=typescript_generate,json=typescriptGenerate,proto3" json:"typescript_generate,omitempty"`
	// Should the TypeScript package be built? Implies generation.
	TypescriptCompile bool `protobuf:"varint,6,opt,name=typescript_compile,json=typescriptCompile,proto3" json:"typescript_compile,omitempty"`
	// Should the TypeScript package be packaged into the catalog?
	// Implies generation and compilation.
	TypescriptPackage bool `protobuf:"varint,7,opt,name=typescript_package,json=typescriptPackage,proto3" json:"typescript_package,omitempty"`
	// The Docker network the connectors are given access to during catalog
	// builds.
	ConnectorNetwork     string   `protobuf:"bytes,8,opt,name=connector_network,json=connectorNetwork,proto3" json:"connector_network,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuildAPI_Config) Reset()         { *m = BuildAPI_Config{} }
func (m *BuildAPI_Config) String() string { return proto.CompactTextString(m) }
func (*BuildAPI_Config) ProtoMessage()    {}
func (*BuildAPI_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{22, 0}
}
func (m *BuildAPI_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildAPI_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildAPI_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildAPI_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildAPI_Config.Merge(m, src)
}
func (m *BuildAPI_Config) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BuildAPI_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildAPI_Config.DiscardUnknown(m)
}

var xxx_messageInfo_BuildAPI_Config proto.InternalMessageInfo

type BuildAPI_Fetch struct {
	ResourceUrl          string      `protobuf:"bytes,1,opt,name=resource_url,json=resourceUrl,proto3" json:"resource_url,omitempty"`
	ContentType          ContentType `protobuf:"varint,2,opt,name=content_type,json=contentType,proto3,enum=flow.ContentType" json:"content_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *BuildAPI_Fetch) Reset()         { *m = BuildAPI_Fetch{} }
func (m *BuildAPI_Fetch) String() string { return proto.CompactTextString(m) }
func (*BuildAPI_Fetch) ProtoMessage()    {}
func (*BuildAPI_Fetch) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{22, 1}
}
func (m *BuildAPI_Fetch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildAPI_Fetch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildAPI_Fetch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildAPI_Fetch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildAPI_Fetch.Merge(m, src)
}
func (m *BuildAPI_Fetch) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BuildAPI_Fetch) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildAPI_Fetch.DiscardUnknown(m)
}

var xxx_messageInfo_BuildAPI_Fetch proto.InternalMessageInfo

// ResetStateRequest is the request of the Testing.ResetState RPC.
type ResetStateRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResetStateRequest) Reset()         { *m = ResetStateRequest{} }
func (m *ResetStateRequest) String() string { return proto.CompactTextString(m) }
func (*ResetStateRequest) ProtoMessage()    {}
func (*ResetStateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{23}
}
func (m *ResetStateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetStateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResetStateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResetStateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetStateRequest.Merge(m, src)
}
func (m *ResetStateRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ResetStateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetStateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResetStateRequest proto.InternalMessageInfo

// ResetStateResponse is the response of the Testing.ResetState RPC.
type ResetStateResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResetStateResponse) Reset()         { *m = ResetStateResponse{} }
func (m *ResetStateResponse) String() string { return proto.CompactTextString(m) }
func (*ResetStateResponse) ProtoMessage()    {}
func (*ResetStateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{24}
}
func (m *ResetStateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetStateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResetStateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResetStateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetStateResponse.Merge(m, src)
}
func (m *ResetStateResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ResetStateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetStateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResetStateResponse proto.InternalMessageInfo

// AdvanceTimeRequest is the request of the Testing.AdvanceTime RPC.
type AdvanceTimeRequest struct {
	AdvanceSeconds       uint64   `protobuf:"varint,1,opt,name=advance_seconds,json=advanceSeconds,proto3" json:"advance_seconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AdvanceTimeRequest) Reset()         { *m = AdvanceTimeRequest{} }
func (m *AdvanceTimeRequest) String() string { return proto.CompactTextString(m) }
func (*AdvanceTimeRequest) ProtoMessage()    {}
func (*AdvanceTimeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{25}
}
func (m *AdvanceTimeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvanceTimeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdvanceTimeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdvanceTimeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvanceTimeRequest.Merge(m, src)
}
func (m *AdvanceTimeRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AdvanceTimeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvanceTimeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdvanceTimeRequest proto.InternalMessageInfo

// AdvanceTimeResponse is the response of the Testing.AdvanceTime RPC.
type AdvanceTimeResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AdvanceTimeResponse) Reset()         { *m = AdvanceTimeResponse{} }
func (m *AdvanceTimeResponse) String() string { return proto.CompactTextString(m) }
func (*AdvanceTimeResponse) ProtoMessage()    {}
func (*AdvanceTimeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{26}
}
func (m *AdvanceTimeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvanceTimeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdvanceTimeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdvanceTimeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvanceTimeResponse.Merge(m, src)
}
func (m *AdvanceTimeResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AdvanceTimeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvanceTimeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdvanceTimeResponse proto.InternalMessageInfo

// DocsAndBytes represents a count of JSON documents, and their cumulative total
// size in bytes. This is used by the various Stats messages.
type DocsAndBytes struct {
	Docs                 uint32   `protobuf:"varint,1,opt,name=docs,proto3" json:"docs,omitempty"`
	Bytes                uint32   `protobuf:"varint,2,opt,name=bytes,proto3" json:"bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DocsAndBytes) Reset()         { *m = DocsAndBytes{} }
func (m *DocsAndBytes) String() string { return proto.CompactTextString(m) }
func (*DocsAndBytes) ProtoMessage()    {}
func (*DocsAndBytes) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{27}
}
func (m *DocsAndBytes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocsAndBytes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocsAndBytes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocsAndBytes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocsAndBytes.Merge(m, src)
}
func (m *DocsAndBytes) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DocsAndBytes) XXX_DiscardUnknown() {
	xxx_messageInfo_DocsAndBytes.DiscardUnknown(m)
}

var xxx_messageInfo_DocsAndBytes proto.InternalMessageInfo

type IngestRequest struct {
	// Name of the collection into which to ingest.
	Collection Collection `protobuf:"bytes,1,opt,name=collection,proto3,casttype=Collection" json:"collection,omitempty"`
	// Build ID of the ingested collection.
	BuildId string `protobuf:"bytes,2,opt,name=build_id,json=buildId,proto3" json:"build_id,omitempty"`
	// Newline-separated JSON documents to ingest.
	DocsJsonLines        string   `protobuf:"bytes,3,opt,name=docs_json_lines,json=docsJsonLines,proto3" json:"docs_json_lines,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IngestRequest) Reset()         { *m = IngestRequest{} }
func (m *IngestRequest) String() string { return proto.CompactTextString(m) }
func (*IngestRequest) ProtoMessage()    {}
func (*IngestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{28}
}
func (m *IngestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngestRequest.Merge(m, src)
}
func (m *IngestRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IngestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IngestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IngestRequest proto.InternalMessageInfo

// IngestResponse is the response of the Testing.Ingest RPC.
type IngestResponse struct {
	// Journals appended to by this ingestion, and their maximum offset on commit.
	JournalWriteHeads map[go_gazette_dev_core_broker_protocol.Journal]go_gazette_dev_core_broker_protocol.Offset `protobuf:"bytes,1,rep,name=journal_write_heads,json=journalWriteHeads,proto3,castkey=go.gazette.dev/core/broker/protocol.Journal,castvalue=go.gazette.dev/core/broker/protocol.Offset" json:"journal_write_heads,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Etcd header which describes current journal partitions.
	JournalEtcd          protocol.Header_Etcd `protobuf:"bytes,2,opt,name=journal_etcd,json=journalEtcd,proto3" json:"journal_etcd"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *IngestResponse) Reset()         { *m = IngestResponse{} }
func (m *IngestResponse) String() string { return proto.CompactTextString(m) }
func (*IngestResponse) ProtoMessage()    {}
func (*IngestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{29}
}
func (m *IngestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngestResponse.Merge(m, src)
}
func (m *IngestResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IngestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IngestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IngestResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("flow.EndpointType", EndpointType_name, EndpointType_value)
	proto.RegisterEnum("flow.LogLevelFilter", LogLevelFilter_name, LogLevelFilter_value)
	proto.RegisterEnum("flow.ContentType", ContentType_name, ContentType_value)
	proto.RegisterEnum("flow.Inference_Exists", Inference_Exists_name, Inference_Exists_value)
	proto.RegisterEnum("flow.TestSpec_Step_Type", TestSpec_Step_Type_name, TestSpec_Step_Type_value)
	proto.RegisterEnum("flow.ExtractAPI_Code", ExtractAPI_Code_name, ExtractAPI_Code_value)
	proto.RegisterEnum("flow.CombineAPI_Code", CombineAPI_Code_name, CombineAPI_Code_value)
	proto.RegisterEnum("flow.DeriveAPI_Code", DeriveAPI_Code_name, DeriveAPI_Code_value)
	proto.RegisterEnum("flow.BuildAPI_Code", BuildAPI_Code_name, BuildAPI_Code_value)
	proto.RegisterType((*Slice)(nil), "flow.Slice")
	proto.RegisterType((*UUIDParts)(nil), "flow.UUIDParts")
	proto.RegisterType((*LambdaSpec)(nil), "flow.LambdaSpec")
	proto.RegisterType((*Shuffle)(nil), "flow.Shuffle")
	proto.RegisterType((*JournalShuffle)(nil), "flow.JournalShuffle")
	proto.RegisterType((*Projection)(nil), "flow.Projection")
	proto.RegisterType((*Inference)(nil), "flow.Inference")
	proto.RegisterType((*Inference_String)(nil), "flow.Inference.String")
	proto.RegisterType((*CollectionSpec)(nil), "flow.CollectionSpec")
	proto.RegisterType((*TransformSpec)(nil), "flow.TransformSpec")
	proto.RegisterType((*DerivationSpec)(nil), "flow.DerivationSpec")
	proto.RegisterType((*FieldSelection)(nil), "flow.FieldSelection")
	proto.RegisterMapType((map[string]encoding_json.RawMessage)(nil), "flow.FieldSelection.FieldConfigJsonEntry")
	proto.RegisterType((*CaptureSpec)(nil), "flow.CaptureSpec")
	proto.RegisterType((*CaptureSpec_Binding)(nil), "flow.CaptureSpec.Binding")
	proto.RegisterType((*MaterializationSpec)(nil), "flow.MaterializationSpec")
	proto.RegisterType((*MaterializationSpec_Binding)(nil), "flow.MaterializationSpec.Binding")
	proto.RegisterType((*OAuth2Spec)(nil), "flow.OAuth2Spec")
	proto.RegisterType((*TestSpec)(nil), "flow.TestSpec")
	proto.RegisterType((*TestSpec_Step)(nil), "flow.TestSpec.Step")
	proto.RegisterType((*RangeSpec)(nil), "flow.RangeSpec")
	proto.RegisterType((*ShuffleRequest)(nil), "flow.ShuffleRequest")
	proto.RegisterType((*ShuffleResponse)(nil), "flow.ShuffleResponse")
	proto.RegisterType((*DriverCheckpoint)(nil), "flow.DriverCheckpoint")
	proto.RegisterType((*ExtractAPI)(nil), "flow.ExtractAPI")
	proto.RegisterType((*ExtractAPI_Config)(nil), "flow.ExtractAPI.Config")
	proto.RegisterType((*CombineAPI)(nil), "flow.CombineAPI")
	proto.RegisterType((*CombineAPI_Config)(nil), "flow.CombineAPI.Config")
	proto.RegisterType((*CombineAPI_Stats)(nil), "flow.CombineAPI.Stats")
	proto.RegisterType((*DeriveAPI)(nil), "flow.DeriveAPI")
	proto.RegisterType((*DeriveAPI_Open)(nil), "flow.DeriveAPI.Open")
	proto.RegisterType((*DeriveAPI_Config)(nil), "flow.DeriveAPI.Config")
	proto.RegisterType((*DeriveAPI_DocHeader)(nil), "flow.DeriveAPI.DocHeader")
	proto.RegisterType((*DeriveAPI_Invoke)(nil), "flow.DeriveAPI.Invoke")
	proto.RegisterType((*DeriveAPI_Prepare)(nil), "flow.DeriveAPI.Prepare")
	proto.RegisterType((*DeriveAPI_Stats)(nil), "flow.DeriveAPI.Stats")
	proto.RegisterType((*DeriveAPI_Stats_InvokeStats)(nil), "flow.DeriveAPI.Stats.InvokeStats")
	proto.RegisterType((*DeriveAPI_Stats_TransformStats)(nil), "flow.DeriveAPI.Stats.TransformStats")
	proto.RegisterType((*DeriveAPI_Stats_RegisterStats)(nil), "flow.DeriveAPI.Stats.RegisterStats")
	proto.RegisterType((*BuildAPI)(nil), "flow.BuildAPI")
	proto.RegisterType((*BuildAPI_Config)(nil), "flow.BuildAPI.Config")
	proto.RegisterType((*BuildAPI_Fetch)(nil), "flow.BuildAPI.Fetch")
	proto.RegisterType((*ResetStateRequest)(nil), "flow.ResetStateRequest")
	proto.RegisterType((*ResetStateResponse)(nil), "flow.ResetStateResponse")
	proto.RegisterType((*AdvanceTimeRequest)(nil), "flow.AdvanceTimeRequest")
	proto.RegisterType((*AdvanceTimeResponse)(nil), "flow.AdvanceTimeResponse")
	proto.RegisterType((*DocsAndBytes)(nil), "flow.DocsAndBytes")
	proto.RegisterType((*IngestRequest)(nil), "flow.IngestRequest")
	proto.RegisterType((*IngestResponse)(nil), "flow.IngestResponse")
	proto.RegisterMapType((map[go_gazette_dev_core_broker_protocol.Journal]go_gazette_dev_core_broker_protocol.Offset)(nil), "flow.IngestResponse.JournalWriteHeadsEntry")
}

func init() { proto.RegisterFile("go/protocols/flow/flow.proto", fileDescriptor_d0677502142fec31) }

var fileDescriptor_d0677502142fec31 = []byte{
	// 4376 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x3a, 0x4d, 0x8c, 0x23, 0x57,
	0x5a, 0x53, 0xfe, 0xf7, 0xe7, 0xb6, 0xbb, 0xfa, 0x75, 0xcf, 0xc4, 0xe3, 0x24, 0xed, 0x89, 0xf3,
	0x37, 0x33, 0x21, 0xee, 0x30, 0x49, 0x36, 0xc9, 0x44, 0xb3, 0x2b, 0xff, 0x54, 0x4f, 0x7b, 0xc6,
	0x6d, 0x3b, 0x65, 0x77, 0x92, 0x59, 0xc1, 0x16, 0xd5, 0x55, 0xaf, 0xed, 0x4a, 0x97, 0xab, 0xcc,
	0xab, 0x72, 0x67, 0xbc, 0x17, 0xc4, 0x72, 0x41, 0x8b, 0x90, 0x10, 0x17, 0x72, 0xe0, 0x10, 0xf6,
	0xc0, 0x81, 0x1b, 0x0b, 0x27, 0x84, 0xc4, 0x81, 0x4b, 0xc2, 0x82, 0x14, 0xb1, 0xe4, 0x86, 0x3a,
	0x62, 0xb9, 0x80, 0xb8, 0x71, 0x6c, 0x71, 0x40, 0xef, 0xa7, 0xca, 0x65, 0xb7, 0x67, 0xa6, 0x27,
	0x7b, 0x60, 0xb9, 0x58, 0xf5, 0xbe, 0x3f, 0xbf, 0xf7, 0xbd, 0xef, 0xbf, 0x0a, 0x9e, 0x1b, 0xba,
	0x3b, 0x13, 0xe2, 0xfa, 0xae, 0xe1, 0xda, 0xde, 0xce, 0x91, 0xed, 0x7e, 0xca, 0x7e, 0xaa, 0x0c,
	0x86, 0x12, 0xf4, 0xb9, 0xb4, 0x7d, 0x48, 0xdc, 0x63, 0x4c, 0x42, 0xba, 0xf0, 0x81, 0x53, 0x95,
	0xae, 0x19, 0xae, 0xe3, 0x4d, 0xc7, 0x8f, 0xa1, 0xd8, 0x1a, 0xba, 0x43, 0x97, 0x3d, 0xee, 0xd0,
	0x27, 0x0e, 0xad, 0xdc, 0x81, 0x64, 0xdf, 0xb6, 0x0c, 0x8c, 0xb6, 0x20, 0x79, 0x88, 0x87, 0x96,
	0x53, 0x94, 0xae, 0x49, 0xd7, 0xf3, 0x2a, 0x5f, 0x20, 0x19, 0xe2, 0xd8, 0x31, 0x8b, 0x31, 0x06,
	0xa3, 0x8f, 0xb7, 0xd7, 0xbe, 0xfa, 0xb3, 0xf2, 0xa5, 0x3f, 0xfa, 0x49, 0xf9, 0xd2, 0x67, 0x3f,
	0x29, 0x5f, 0xaa, 0xfc, 0xbe, 0x04, 0xd9, 0x83, 0x83, 0x56, 0xb3, 0xa7, 0x13, 0xdf, 0x43, 0xbf,
	0x06, 0x68, 0x42, 0x5c, 0x73, 0x6a, 0x60, 0xa2, 0xe9, 0x8e, 0xa9, 0x1d, 0xd9, 0xfa, 0xd0, 0x63,
	0x02, 0x53, 0xaa, 0x1c, 0x60, 0x6a, 0x8e, 0xb9, 0x4b, 0xe1, 0xe8, 0x7d, 0x48, 0x1a, 0xb6, 0x6b,
	0x1c, 0x33, 0xe9, 0xa9, 0xfa, 0xcb, 0x67, 0xa7, 0xe5, 0x17, 0x86, 0x6e, 0x75, 0xa8, 0xff, 0x10,
	0xfb, 0x3e, 0xae, 0x9a, 0xf8, 0x64, 0xc7, 0x70, 0x09, 0xde, 0x19, 0x63, 0xcf, 0xd3, 0x87, 0xb8,
	0xda, 0xa0, 0xc4, 0x2a, 0xe7, 0xb9, 0x2d, 0xff, 0xc7, 0xe7, 0x65, 0x69, 0x61, 0x2b, 0xf7, 0x00,
	0xda, 0xfa, 0xf8, 0xd0, 0xd4, 0xfb, 0x13, 0x6c, 0xa0, 0x6d, 0x00, 0x7f, 0x36, 0xc1, 0x9e, 0x41,
	0xac, 0x89, 0xcf, 0xb6, 0x90, 0x55, 0x23, 0x10, 0x74, 0x05, 0x52, 0x04, 0x8f, 0x5d, 0x1f, 0xb3,
	0x7f, 0xcf, 0xaa, 0x62, 0x75, 0x3b, 0x41, 0xe5, 0x56, 0xfe, 0x3a, 0x09, 0xe9, 0xfe, 0x68, 0x7a,
	0x74, 0x64, 0x63, 0xf4, 0x3c, 0xc0, 0x90, 0xb8, 0xd3, 0x89, 0xe6, 0xe8, 0x63, 0x2c, 0x24, 0x65,
	0x19, 0xa4, 0xa3, 0x8f, 0x31, 0x7a, 0x1f, 0x36, 0x3c, 0x77, 0x4a, 0x0c, 0xac, 0x19, 0xae, 0x6d,
	0x63, 0xc3, 0xb7, 0x5c, 0x87, 0xcb, 0xac, 0x17, 0xce, 0x4e, 0xcb, 0xd0, 0x08, 0xa1, 0xaa, 0xcc,
	0x09, 0xe7, 0x10, 0x74, 0x2f, 0x64, 0x9e, 0xe8, 0xc4, 0xb7, 0x28, 0xcc, 0x2b, 0xc6, 0xaf, 0x49,
	0xd7, 0x73, 0xb7, 0x9e, 0xa9, 0x86, 0xf7, 0xd7, 0xd6, 0x0f, 0xb1, 0xdd, 0xc7, 0x94, 0xc9, 0x25,
	0xf5, 0xc4, 0x17, 0xa7, 0xe5, 0x4b, 0x81, 0xac, 0x5e, 0xc8, 0x86, 0x5e, 0x81, 0x75, 0x21, 0x6b,
	0x3a, 0xb5, 0x4c, 0x6d, 0xe2, 0x93, 0x62, 0x82, 0x6d, 0x36, 0xcf, 0xc1, 0x07, 0x53, 0xcb, 0xec,
	0xf9, 0x04, 0x5d, 0x07, 0xd9, 0xe3, 0x47, 0xd3, 0x8e, 0xf1, 0x8c, 0xd2, 0x79, 0xc5, 0xe4, 0xb5,
	0xf8, 0xf5, 0xac, 0x5a, 0x10, 0xf0, 0xfb, 0x78, 0xd6, 0xf3, 0x09, 0x93, 0x38, 0xf5, 0xb0, 0xa7,
	0x09, 0xb1, 0xc7, 0x78, 0x56, 0x4c, 0x5d, 0x93, 0xae, 0x67, 0xd4, 0x3c, 0x05, 0xf7, 0x19, 0xf4,
	0x3e, 0x9e, 0xa1, 0x77, 0x20, 0xe0, 0xd4, 0x6c, 0x76, 0x03, 0xc5, 0x34, 0x3b, 0x82, 0x5c, 0x65,
	0x66, 0x3c, 0xbf, 0x15, 0x35, 0x2f, 0xe8, 0x38, 0x08, 0xdd, 0x0c, 0x8f, 0xef, 0x19, 0x23, 0x3c,
	0xd6, 0xb5, 0x29, 0xb1, 0x8a, 0x19, 0xb6, 0x69, 0x71, 0x96, 0x3e, 0x83, 0x1f, 0x10, 0x8b, 0xda,
	0x56, 0x74, 0x33, 0x9c, 0xa1, 0x98, 0x65, 0xfb, 0x91, 0xe7, 0xfb, 0xe1, 0x0c, 0xe8, 0x1e, 0x54,
	0x4c, 0x3c, 0x21, 0xd8, 0xd0, 0x7d, 0x6c, 0x6a, 0x27, 0xba, 0x6d, 0x99, 0xba, 0x1f, 0xfe, 0x8d,
	0xee, 0x6b, 0x04, 0xeb, 0x66, 0x11, 0x18, 0xf7, 0xf6, 0x9c, 0xf2, 0x43, 0x41, 0xc8, 0xa5, 0xd4,
	0x7c, 0x15, 0xeb, 0x26, 0x55, 0xc3, 0x91, 0x65, 0xfb, 0x98, 0x68, 0x44, 0x63, 0xc6, 0xe7, 0x15,
	0x73, 0x5c, 0x0d, 0x1c, 0xac, 0x32, 0xc3, 0x64, 0xd6, 0x4f, 0xa5, 0x6a, 0x26, 0xb6, 0xf5, 0x99,
	0xe6, 0x61, 0xc3, 0x75, 0x4c, 0xaf, 0xb8, 0xc6, 0x5c, 0x47, 0xa6, 0x98, 0x26, 0x45, 0xf4, 0x39,
	0x1c, 0x95, 0x20, 0x33, 0x21, 0x96, 0x4b, 0x2c, 0x7f, 0x56, 0xcc, 0x33, 0x9a, 0x70, 0x8d, 0xde,
	0x80, 0xad, 0xe5, 0x2d, 0x7f, 0xe2, 0xb9, 0x4e, 0xb1, 0xc0, 0x54, 0x83, 0x4e, 0x16, 0x76, 0x79,
	0xcf, 0x73, 0x1d, 0x61, 0xb6, 0x9f, 0xc5, 0xa0, 0x70, 0xcf, 0x9d, 0x12, 0x47, 0xb7, 0x03, 0xeb,
	0x6d, 0x41, 0xfa, 0x13, 0x0e, 0xe1, 0xa6, 0x5b, 0xdf, 0x39, 0x3b, 0x2d, 0xbf, 0xb6, 0xca, 0xcd,
	0x96, 0x02, 0x4c, 0x55, 0x08, 0x52, 0x03, 0x7e, 0xd4, 0x87, 0x9c, 0xe1, 0xba, 0xc4, 0xb4, 0x1c,
	0xdd, 0x77, 0x89, 0xb0, 0xf1, 0x5f, 0x3f, 0x3b, 0x2d, 0xbf, 0xbe, 0x4a, 0xdc, 0xb9, 0x78, 0x54,
	0xed, 0x8f, 0x74, 0x62, 0xb6, 0x9a, 0x6a, 0x54, 0x0a, 0x7a, 0x1d, 0xd2, 0xc2, 0x26, 0x84, 0xdd,
	0xe7, 0xb9, 0xd1, 0x88, 0xfd, 0xd7, 0x13, 0x5f, 0x9d, 0x96, 0x25, 0x35, 0xa0, 0xe1, 0x6e, 0x3b,
	0xb1, 0xf5, 0x19, 0xb3, 0xed, 0x8c, 0x2a, 0x56, 0xe8, 0x2a, 0x64, 0x0e, 0xa7, 0x96, 0x6d, 0x6a,
	0x96, 0x59, 0x4c, 0x32, 0x2d, 0xa5, 0xd9, 0xba, 0x65, 0x0a, 0xd5, 0x7c, 0x2d, 0x01, 0xf4, 0x88,
	0xfb, 0x89, 0x70, 0x3c, 0x19, 0xe2, 0xd4, 0x41, 0xb8, 0x37, 0xd3, 0x47, 0x1a, 0xff, 0x8e, 0x2c,
	0x6c, 0x9b, 0x22, 0x1e, 0xf0, 0x05, 0xbd, 0x25, 0xfc, 0x70, 0x62, 0x5b, 0x86, 0xe5, 0xb3, 0xfd,
	0x65, 0xd4, 0x70, 0x4d, 0x1d, 0xc9, 0xf2, 0xe6, 0x8e, 0xcb, 0xfc, 0x83, 0xef, 0xaa, 0x60, 0x79,
	0xa1, 0x63, 0x52, 0x07, 0x79, 0x09, 0x0a, 0x94, 0x92, 0x58, 0x63, 0x9d, 0xcc, 0x18, 0x5d, 0x92,
	0xd1, 0xad, 0x59, 0x5e, 0x8f, 0x03, 0x29, 0xd5, 0x9b, 0x90, 0xb5, 0x9c, 0x23, 0x4c, 0xb0, 0x63,
	0x60, 0xe6, 0x68, 0xb9, 0x5b, 0xeb, 0x5c, 0x19, 0xad, 0x00, 0x2c, 0x9c, 0x7f, 0x4e, 0x57, 0xf9,
	0xbd, 0x04, 0x64, 0x43, 0x34, 0x3d, 0x04, 0x8b, 0x71, 0x45, 0x89, 0x39, 0x34, 0x5f, 0xa0, 0x2a,
	0xa4, 0x3c, 0x9f, 0x58, 0xce, 0x50, 0xa8, 0xf8, 0xca, 0x92, 0xd4, 0x6a, 0x9f, 0x61, 0x55, 0x41,
	0xc5, 0xa4, 0x58, 0xbe, 0x8d, 0x45, 0xfc, 0xe0, 0x0b, 0x74, 0x0d, 0x72, 0xa6, 0x88, 0x9e, 0x34,
	0xc4, 0x71, 0x2d, 0x47, 0x41, 0xe8, 0x7b, 0xb0, 0x66, 0xe2, 0x23, 0x7d, 0x6a, 0xfb, 0xdc, 0x5c,
	0x53, 0xcc, 0x42, 0x9e, 0x3b, 0x3b, 0x2d, 0x17, 0xb1, 0x63, 0xb8, 0xa6, 0xe5, 0x0c, 0x77, 0x28,
	0xa2, 0xaa, 0xea, 0x9f, 0xee, 0xf3, 0xa0, 0x4e, 0x05, 0x30, 0x0e, 0x6a, 0xc5, 0xf4, 0x76, 0x3d,
	0x6c, 0x10, 0xec, 0xb3, 0x00, 0x92, 0x51, 0xc5, 0x8a, 0x1e, 0x00, 0x3f, 0xb4, 0x3c, 0xdf, 0x63,
	0xc1, 0xa1, 0x70, 0xfe, 0x00, 0x0a, 0xc3, 0xaa, 0x82, 0xaa, 0xf4, 0x17, 0x12, 0xa4, 0xf8, 0x99,
	0xd0, 0x0b, 0xb0, 0x66, 0xb8, 0x8e, 0x8f, 0x1d, 0x5f, 0xa3, 0xca, 0x60, 0x1a, 0xc8, 0x52, 0x13,
	0x64, 0xb0, 0xc1, 0x6c, 0xc2, 0x6c, 0xea, 0xc8, 0x25, 0x63, 0xdd, 0x17, 0xe7, 0x15, 0x2b, 0x74,
	0x03, 0xe4, 0x80, 0x35, 0xd8, 0x3e, 0xdb, 0x57, 0x56, 0x5d, 0x17, 0x70, 0x45, 0x80, 0xd1, 0xb3,
	0x90, 0xb5, 0x3c, 0xed, 0x50, 0xf7, 0xf0, 0x77, 0xde, 0x12, 0x77, 0x9b, 0xb1, 0xbc, 0x3a, 0x5b,
	0xd3, 0x04, 0x32, 0xd6, 0x1f, 0x6a, 0x36, 0x76, 0x86, 0xfe, 0x88, 0x29, 0x25, 0xaf, 0x66, 0xc7,
	0xfa, 0xc3, 0x36, 0x03, 0x54, 0xea, 0x90, 0xe2, 0xdb, 0x47, 0x39, 0x48, 0xb7, 0x3a, 0x1f, 0xd6,
	0xda, 0xad, 0xa6, 0x7c, 0x09, 0x65, 0x20, 0xb1, 0x7f, 0xd0, 0x1f, 0xc8, 0x12, 0x4a, 0x43, 0x7c,
	0xbf, 0xf6, 0x40, 0x8e, 0xa1, 0x35, 0xc8, 0xb4, 0xf6, 0x7b, 0xed, 0x56, 0xa3, 0x35, 0x90, 0xe3,
	0x08, 0x20, 0xd5, 0xa8, 0x75, 0x3a, 0xdd, 0x81, 0x9c, 0xa8, 0x7c, 0x19, 0x87, 0xc2, 0x3c, 0xad,
	0xb0, 0x04, 0x58, 0x05, 0x88, 0x24, 0x24, 0x69, 0x65, 0x42, 0x8a, 0x50, 0xd0, 0x5d, 0x46, 0x82,
	0x30, 0x77, 0x82, 0xac, 0x17, 0x86, 0xdf, 0x3b, 0x90, 0x8b, 0x46, 0xa2, 0xcc, 0x05, 0xae, 0x56,
	0xc8, 0x63, 0x37, 0x7b, 0x15, 0x32, 0x61, 0xb2, 0x89, 0x33, 0xdb, 0x4c, 0x1f, 0x8b, 0x2c, 0x73,
	0x15, 0x32, 0x4b, 0x09, 0x2b, 0x3d, 0x15, 0xa9, 0xea, 0x06, 0xc8, 0x73, 0xf7, 0x62, 0x0e, 0x19,
	0xa4, 0xaa, 0xf5, 0x10, 0xbe, 0xcb, 0xc0, 0xe8, 0x5d, 0xc8, 0x4d, 0x42, 0xf7, 0xf6, 0x8a, 0xa9,
	0x6b, 0xf1, 0x79, 0x02, 0x9a, 0xfb, 0xbd, 0xf0, 0x9f, 0x28, 0x29, 0xda, 0x83, 0x0d, 0xdd, 0x38,
	0x66, 0xc7, 0xd2, 0x7c, 0x3c, 0x9e, 0xd8, 0xba, 0x8f, 0xf9, 0x3d, 0x3f, 0xe1, 0x7c, 0xeb, 0xba,
	0x71, 0x4c, 0x0f, 0x37, 0x10, 0x4c, 0xa8, 0x09, 0x68, 0xbe, 0xdd, 0x50, 0x54, 0x96, 0xf9, 0xdc,
	0xe5, 0xea, 0x72, 0x60, 0x65, 0x09, 0x71, 0x23, 0x64, 0x08, 0xa4, 0x54, 0xfe, 0x20, 0x06, 0xf9,
	0x01, 0xd1, 0x1d, 0x8f, 0x9a, 0x61, 0x70, 0x95, 0x26, 0x26, 0xd6, 0x89, 0xfe, 0xb8, 0xab, 0x9c,
	0x53, 0xa0, 0xd7, 0x20, 0xeb, 0x07, 0x02, 0x44, 0x98, 0xce, 0x9f, 0x9d, 0x96, 0xb3, 0xa1, 0x54,
	0x75, 0x8e, 0x7f, 0x72, 0x00, 0x66, 0x1a, 0x0b, 0x03, 0xf0, 0xdb, 0x90, 0x9f, 0x4e, 0x58, 0x62,
	0x12, 0xa9, 0x3e, 0xf1, 0x88, 0x54, 0xbf, 0xc6, 0xc9, 0x44, 0xa6, 0x7f, 0x07, 0x0a, 0x93, 0xe9,
	0xa1, 0x6d, 0x79, 0xa3, 0x80, 0x2f, 0xf9, 0xa8, 0x12, 0x41, 0xd0, 0x71, 0x50, 0xe5, 0x5f, 0xe3,
	0x50, 0x68, 0x86, 0x47, 0x63, 0xea, 0xb8, 0x7d, 0xce, 0xb2, 0x73, 0xb7, 0xb6, 0xb8, 0x9c, 0x45,
	0x1f, 0x10, 0x7b, 0x8f, 0x5a, 0x79, 0x15, 0x36, 0x09, 0x1e, 0x5a, 0x1e, 0xcd, 0xe6, 0xe7, 0xcc,
	0x7d, 0x23, 0x40, 0xcd, 0xab, 0x8e, 0x0e, 0x6c, 0x2d, 0xd3, 0x33, 0xfb, 0xbf, 0x88, 0x7d, 0xa0,
	0x45, 0x71, 0xcc, 0x0f, 0xda, 0x70, 0x39, 0x94, 0x67, 0x39, 0x96, 0x6f, 0xe9, 0x36, 0x17, 0x18,
	0xbf, 0x88, 0xc1, 0x05, 0xac, 0x2d, 0xce, 0x89, 0xde, 0x03, 0x08, 0x2f, 0xd2, 0x2b, 0x26, 0x98,
	0xcd, 0x6f, 0x72, 0x4d, 0x2c, 0x58, 0x50, 0xa0, 0x88, 0x39, 0x31, 0xba, 0x4d, 0x6b, 0x36, 0x9d,
	0x98, 0x73, 0x3b, 0xe5, 0x17, 0xb2, 0x59, 0x0d, 0x12, 0x37, 0xcf, 0xd7, 0x41, 0xd9, 0xa6, 0x13,
	0x33, 0xb4, 0xf3, 0x16, 0x3d, 0x84, 0xe1, 0x9e, 0x60, 0x32, 0xd3, 0x6c, 0x77, 0x38, 0x17, 0x91,
	0x7a, 0x9c, 0xa9, 0x6f, 0x06, 0x3c, 0x6d, 0x77, 0x18, 0x1a, 0xfb, 0x1f, 0xc6, 0xa0, 0xc0, 0x3c,
	0x98, 0x97, 0xb7, 0xf4, 0x8a, 0x10, 0x24, 0x8e, 0xf1, 0x2c, 0x48, 0x61, 0xec, 0x99, 0x86, 0xe8,
	0x13, 0xdd, 0x9e, 0x62, 0xaf, 0x18, 0x63, 0x50, 0xb1, 0xa2, 0xe9, 0xd9, 0x74, 0x8d, 0xe9, 0x18,
	0x3b, 0xbe, 0x88, 0xec, 0xe1, 0x1a, 0xb9, 0xb0, 0xc1, 0x42, 0x86, 0x66, 0xb8, 0xce, 0x91, 0x35,
	0xe4, 0x6a, 0xe6, 0x3a, 0xba, 0xc1, 0x75, 0xb4, 0xf8, 0xc7, 0x7c, 0xd9, 0x60, 0xc4, 0xf4, 0xae,
	0x14, 0xc7, 0x27, 0xb3, 0xfa, 0x73, 0x3f, 0xfe, 0xe6, 0x71, 0xd9, 0xeb, 0x68, 0xce, 0x53, 0xaa,
	0xc3, 0xd6, 0x2a, 0x11, 0xb4, 0xd6, 0xa0, 0x29, 0x5f, 0xd4, 0x1a, 0xc7, 0x78, 0x46, 0x13, 0x2c,
	0x3b, 0x40, 0x50, 0x6b, 0xb0, 0xc5, 0xed, 0xd8, 0xbb, 0x52, 0xe5, 0xe7, 0x09, 0xc8, 0x35, 0xf4,
	0x89, 0x3f, 0x25, 0x98, 0xd9, 0xfa, 0xcb, 0x90, 0x36, 0xf8, 0x52, 0xf8, 0x7d, 0xee, 0xec, 0xb4,
	0x9c, 0x16, 0x14, 0x6a, 0x80, 0x43, 0xef, 0x40, 0x1e, 0x3b, 0xe6, 0xc4, 0xb5, 0x82, 0x34, 0x17,
	0x63, 0x79, 0x12, 0xf1, 0x73, 0x2a, 0x02, 0x45, 0xb3, 0x9d, 0xba, 0x86, 0x23, 0x2b, 0xb4, 0x0b,
	0x28, 0x64, 0xf4, 0x26, 0xd8, 0xb8, 0xb8, 0x31, 0x86, 0x72, 0xd8, 0x3e, 0xdf, 0x86, 0xcc, 0xa1,
	0xe5, 0x50, 0xc2, 0xc0, 0x0e, 0xaf, 0x0a, 0x8f, 0x9c, 0x1f, 0xa6, 0x5a, 0xe7, 0x14, 0x6a, 0x48,
	0x4a, 0x03, 0xbc, 0xe5, 0xf8, 0x98, 0x9c, 0xe8, 0x76, 0x58, 0x30, 0x27, 0x59, 0x82, 0x5c, 0x0f,
	0xe0, 0x41, 0xbd, 0x7c, 0xde, 0x60, 0x53, 0xbf, 0xbc, 0xc1, 0xa6, 0x9f, 0xd6, 0x60, 0x4b, 0x3f,
	0x95, 0x20, 0x2d, 0xce, 0x41, 0x95, 0x47, 0x70, 0xd0, 0x8f, 0x84, 0xca, 0x93, 0x2e, 0xa2, 0xbc,
	0x80, 0x8f, 0x29, 0xef, 0x45, 0xc8, 0x87, 0x72, 0x26, 0xba, 0x3f, 0x12, 0x46, 0x1e, 0x12, 0xf5,
	0x74, 0x7f, 0xb4, 0x14, 0xf5, 0xe2, 0x4f, 0x13, 0xf5, 0x2a, 0xff, 0x99, 0x84, 0xcd, 0x7d, 0xdd,
	0xc7, 0xc4, 0xd2, 0x6d, 0xeb, 0x87, 0xf3, 0x48, 0x7a, 0x07, 0xd6, 0xc7, 0x8b, 0x60, 0xb1, 0xfb,
	0xcd, 0xb3, 0xd3, 0xf2, 0xfa, 0x12, 0x87, 0xba, 0x4c, 0xfb, 0x7f, 0x6f, 0x75, 0x77, 0xce, 0x59,
	0xdd, 0x0b, 0xfc, 0xbf, 0x57, 0x1c, 0x76, 0x85, 0xf5, 0xfd, 0x6a, 0xc4, 0xc0, 0xd2, 0xcf, 0x62,
	0xff, 0xff, 0x4c, 0x0a, 0x35, 0x68, 0x53, 0x4c, 0xa3, 0xab, 0x17, 0xc4, 0x4f, 0x51, 0x09, 0x6c,
	0xad, 0x8a, 0xad, 0x42, 0x40, 0xe1, 0x68, 0x31, 0xd4, 0xbf, 0x08, 0x79, 0x13, 0xdb, 0xbe, 0xae,
	0xf1, 0x5a, 0xc1, 0x0b, 0xda, 0x22, 0x06, 0x3c, 0xe0, 0xb0, 0x68, 0x81, 0x92, 0x7a, 0x72, 0x81,
	0x52, 0xf9, 0xef, 0x24, 0x40, 0xb7, 0x36, 0xf5, 0x47, 0xb7, 0x98, 0x22, 0x58, 0x9b, 0xed, 0x9e,
	0x58, 0x26, 0x0e, 0xba, 0xbd, 0x70, 0x8d, 0x6e, 0xc2, 0x86, 0x3e, 0xf5, 0x47, 0xda, 0x94, 0xd8,
	0xf3, 0xfb, 0xe3, 0x21, 0x79, 0x9d, 0x22, 0x0e, 0x88, 0x1d, 0xde, 0xf7, 0x7b, 0x70, 0x55, 0x37,
	0x0c, 0xec, 0x79, 0x9a, 0xef, 0x1e, 0x63, 0x67, 0x91, 0x87, 0xa7, 0x9e, 0x2b, 0x9c, 0x60, 0x40,
	0xf1, 0x51, 0xd6, 0x2a, 0x6c, 0x2e, 0xb0, 0x8e, 0xb1, 0x3f, 0x72, 0x4d, 0x36, 0x43, 0xc8, 0xaa,
	0x1b, 0x11, 0xa6, 0x7d, 0x86, 0x60, 0xdb, 0x8a, 0xd2, 0x1f, 0xba, 0xe6, 0x4c, 0x54, 0xc6, 0xeb,
	0x11, 0xea, 0xba, 0x6b, 0xce, 0x50, 0x7f, 0x69, 0x5b, 0x23, 0xac, 0x9b, 0x98, 0x78, 0xdc, 0x6c,
	0x92, 0x17, 0x29, 0x52, 0x22, 0x12, 0xf7, 0x38, 0x33, 0xfa, 0x0d, 0xd8, 0x5e, 0x10, 0x4a, 0xb0,
	0x37, 0x71, 0x1d, 0x0f, 0x6b, 0x63, 0x7d, 0x72, 0xf1, 0xce, 0x2e, 0xaa, 0x0e, 0x55, 0x48, 0xd8,
	0xd7, 0x27, 0xe8, 0x7d, 0x28, 0x11, 0x7c, 0x44, 0xb0, 0x37, 0x5a, 0xa5, 0x4a, 0xde, 0x60, 0x3d,
	0x23, 0x28, 0xce, 0xe9, 0xf2, 0x0d, 0x5a, 0x8f, 0x45, 0x99, 0x85, 0x32, 0xd7, 0xf8, 0x64, 0x24,
	0xca, 0x26, 0xb4, 0xc9, 0xa6, 0x32, 0x51, 0x0e, 0xa6, 0x4e, 0x3e, 0x64, 0x92, 0xa3, 0xf4, 0x4c,
	0x9f, 0x07, 0xcb, 0x9b, 0x5b, 0x50, 0x68, 0xf6, 0x02, 0xc7, 0xde, 0x8c, 0xca, 0x0c, 0x34, 0xfa,
	0x03, 0x28, 0x2f, 0x8a, 0x3d, 0xaf, 0x52, 0xb8, 0x80, 0xec, 0x05, 0xb5, 0x44, 0x74, 0x5a, 0xf9,
	0xf3, 0x38, 0x64, 0x06, 0xd8, 0xe3, 0x51, 0x11, 0x41, 0xc2, 0xc7, 0x5e, 0x30, 0xf4, 0x64, 0xcf,
	0x68, 0x07, 0x92, 0x9e, 0x8f, 0x27, 0xbc, 0x7e, 0x9a, 0x17, 0x89, 0x82, 0xa5, 0xda, 0xf7, 0xf1,
	0x44, 0x38, 0x12, 0xa7, 0x2b, 0xfd, 0x4b, 0x0c, 0x12, 0x14, 0x8a, 0xde, 0x86, 0x2c, 0x85, 0xf0,
	0x00, 0x2f, 0xb1, 0x00, 0x5f, 0x5c, 0xc1, 0x5d, 0x65, 0x61, 0x3e, 0x43, 0x49, 0x59, 0x88, 0xa7,
	0xed, 0x24, 0x65, 0xb3, 0x1c, 0x13, 0x3f, 0x14, 0xf3, 0x63, 0x26, 0xa8, 0x45, 0x01, 0xcb, 0xc3,
	0x84, 0xf8, 0xf9, 0x61, 0x42, 0x20, 0xc0, 0x33, 0xdc, 0x49, 0x30, 0x89, 0x60, 0x02, 0xfa, 0x14,
	0xb0, 0xd4, 0xde, 0x26, 0x9f, 0xd8, 0xde, 0xbe, 0x02, 0xeb, 0xa6, 0x6b, 0xf0, 0x7b, 0xd4, 0x6c,
	0xcb, 0xc1, 0x1e, 0x37, 0x62, 0x35, 0x4f, 0xc1, 0xb4, 0x58, 0x6b, 0x53, 0x20, 0xba, 0x03, 0x10,
	0x19, 0xc5, 0xa6, 0x2f, 0x32, 0x8a, 0x8d, 0x30, 0x54, 0xb6, 0x21, 0xc1, 0x8e, 0x0f, 0x90, 0x6a,
	0x75, 0xee, 0x2a, 0xfd, 0x81, 0x7c, 0x89, 0x3e, 0x7f, 0xa8, 0xa8, 0xad, 0xdd, 0x07, 0xb2, 0x54,
	0xf9, 0x13, 0x09, 0xb2, 0xaa, 0xee, 0x0c, 0x79, 0x94, 0x7e, 0x16, 0xb2, 0xb4, 0x2b, 0xe6, 0x73,
	0x77, 0xaa, 0xa3, 0xb4, 0x4a, 0xdb, 0xe4, 0x3a, 0x1b, 0xbd, 0x3f, 0x03, 0xb4, 0x45, 0xd6, 0xb0,
	0x63, 0x32, 0xf5, 0xa4, 0xd5, 0xd4, 0x31, 0x9e, 0x29, 0x8e, 0x89, 0x2a, 0x90, 0x17, 0x83, 0x48,
	0xc1, 0x99, 0x60, 0xe8, 0x1c, 0x61, 0x73, 0x48, 0xce, 0xbc, 0x0d, 0xb9, 0x80, 0x86, 0x0a, 0x48,
	0x32, 0x8a, 0x2c, 0xa7, 0x50, 0x1c, 0xf3, 0xb6, 0xfc, 0xd9, 0xe7, 0xe5, 0x4b, 0x0b, 0xe3, 0xf3,
	0xbf, 0x8d, 0x41, 0x41, 0x84, 0x54, 0x15, 0xff, 0xf6, 0x94, 0x1a, 0xcd, 0x5b, 0xf3, 0xc8, 0xbb,
	0xd0, 0x65, 0x2d, 0x8e, 0x18, 0x97, 0x3b, 0xc4, 0x37, 0x00, 0x68, 0x96, 0xb1, 0xa7, 0xe1, 0x24,
	0x9c, 0xb6, 0x79, 0xa1, 0x06, 0xb9, 0x4b, 0xa8, 0x11, 0x1a, 0xf4, 0x1a, 0x24, 0x09, 0xd5, 0x89,
	0x48, 0x41, 0x62, 0xe8, 0x15, 0xaa, 0x29, 0x30, 0x4c, 0x46, 0x83, 0x76, 0x21, 0xe5, 0x1e, 0x1d,
	0x79, 0x98, 0x4f, 0x6b, 0xe2, 0xf5, 0xea, 0xd9, 0x69, 0xf9, 0xe6, 0x45, 0xe6, 0x99, 0x5d, 0xc6,
	0xa5, 0x0a, 0x6e, 0xb4, 0x0f, 0x80, 0x1d, 0x53, 0x13, 0xb2, 0x92, 0xdf, 0x4a, 0x56, 0x16, 0x3b,
	0x26, 0x7f, 0xac, 0xfc, 0x65, 0x02, 0xd6, 0x43, 0xf5, 0x71, 0xc7, 0x44, 0xd7, 0x21, 0xe5, 0xf9,
	0xba, 0x3f, 0xf5, 0x84, 0xdf, 0xc8, 0x91, 0xba, 0x82, 0xc1, 0x55, 0x81, 0xa7, 0x94, 0x3c, 0xd0,
	0x3c, 0x52, 0x5f, 0x02, 0x8f, 0x5e, 0x86, 0x82, 0x8f, 0xc9, 0xd8, 0x72, 0x74, 0x5b, 0xc3, 0x84,
	0xb8, 0x44, 0xf8, 0x4e, 0x3e, 0x80, 0x2a, 0x14, 0x88, 0x3e, 0x80, 0x35, 0x36, 0x8b, 0xf6, 0x47,
	0xc4, 0x9d, 0x0e, 0x47, 0xdf, 0x52, 0x57, 0x39, 0x2a, 0x63, 0xc0, 0x45, 0x50, 0x85, 0x7d, 0x4a,
	0x2c, 0x1f, 0xb3, 0x90, 0xf8, 0x6d, 0x15, 0xc6, 0x24, 0xd0, 0x23, 0xa1, 0x32, 0x24, 0x75, 0x82,
	0x1d, 0x9d, 0xb9, 0xe1, 0x5a, 0x3d, 0x7b, 0x76, 0x5a, 0x4e, 0xd6, 0x28, 0x40, 0xe5, 0x70, 0x54,
	0x85, 0x6c, 0xe8, 0xb1, 0xc5, 0x34, 0x0b, 0x5b, 0x39, 0x91, 0xf9, 0x6d, 0x2b, 0x1c, 0x85, 0x66,
	0x02, 0xf7, 0x45, 0x7b, 0x90, 0xe6, 0x97, 0xe9, 0x15, 0x33, 0xd7, 0xe2, 0xdf, 0x62, 0x73, 0x01,
	0x3b, 0x7a, 0x0b, 0x80, 0x4f, 0xa4, 0x74, 0xe2, 0x7b, 0xc5, 0x2c, 0xfb, 0x6b, 0x61, 0x94, 0xe1,
	0xbb, 0xae, 0x60, 0x12, 0xcb, 0x46, 0x55, 0xec, 0xe5, 0xd7, 0x1b, 0x34, 0x72, 0x18, 0xc7, 0xd8,
	0x64, 0x03, 0x5e, 0x78, 0xd4, 0x86, 0xb3, 0x9c, 0xe8, 0x3e, 0x9e, 0x55, 0xfe, 0x58, 0x02, 0xb9,
	0x49, 0xac, 0x13, 0x4c, 0x1a, 0x23, 0x6c, 0x1c, 0xb3, 0xba, 0x16, 0x75, 0xe0, 0x8a, 0xc9, 0x60,
	0x9a, 0x11, 0x02, 0xe7, 0x55, 0xe0, 0xda, 0x13, 0x32, 0x84, 0x6c, 0x2e, 0xcb, 0xab, 0xc2, 0x26,
	0x39, 0x32, 0xde, 0x79, 0xf3, 0xbd, 0xef, 0x68, 0x63, 0x4c, 0x86, 0xac, 0x1c, 0x34, 0x46, 0xcc,
	0xce, 0x32, 0xea, 0x86, 0x40, 0xed, 0x53, 0x4c, 0x8f, 0x22, 0x2a, 0xff, 0x25, 0x01, 0x28, 0x0f,
	0x7d, 0xa2, 0x1b, 0x7e, 0xad, 0xd7, 0x2a, 0xfd, 0xae, 0x04, 0x29, 0xde, 0xd0, 0x2e, 0x0c, 0xea,
	0xa4, 0xc5, 0x41, 0xdd, 0xd2, 0x74, 0x30, 0xf6, 0x94, 0xd3, 0xc1, 0xe7, 0x01, 0x78, 0x31, 0x19,
	0x99, 0x0f, 0x66, 0x19, 0xa4, 0xe7, 0x13, 0xaf, 0xf2, 0x00, 0x12, 0x0d, 0xd7, 0xc4, 0x8b, 0xf3,
	0xd1, 0x3c, 0x64, 0x1b, 0xdd, 0xce, 0x6e, 0xeb, 0xee, 0x81, 0xaa, 0xc8, 0x12, 0xc5, 0x29, 0x1f,
	0x0f, 0xd4, 0x5a, 0x63, 0x20, 0xc7, 0x10, 0x82, 0x82, 0x58, 0x28, 0x4d, 0x8d, 0x5e, 0x99, 0x1c,
	0x47, 0x5b, 0x20, 0xcf, 0x61, 0xbb, 0x2d, 0xa5, 0xdd, 0xec, 0xcb, 0x89, 0xca, 0x67, 0x09, 0x80,
	0x86, 0x3b, 0x3e, 0xb4, 0x1c, 0x4c, 0x4f, 0xfb, 0x57, 0xf3, 0xd3, 0x2e, 0x1d, 0x49, 0xfa, 0x25,
	0x06, 0x9e, 0xb1, 0xc5, 0x81, 0xe7, 0xe3, 0x4f, 0x4b, 0x4b, 0x1c, 0xae, 0x66, 0x5b, 0x37, 0xf0,
	0xc8, 0xb5, 0x4d, 0x4c, 0x22, 0xb3, 0x51, 0xc4, 0x54, 0x3e, 0x47, 0xf5, 0x7c, 0x52, 0xfa, 0x1d,
	0x48, 0xd2, 0x78, 0xe2, 0xa1, 0x57, 0x20, 0x61, 0xe3, 0x23, 0x5f, 0x44, 0x6b, 0xd1, 0x87, 0x35,
	0x5d, 0xc3, 0xab, 0x39, 0x66, 0x7d, 0xe6, 0x63, 0x4f, 0x65, 0x78, 0x74, 0x1d, 0x92, 0xc4, 0x1a,
	0x8e, 0x7c, 0x11, 0x6d, 0x56, 0x11, 0x72, 0x02, 0xf4, 0x12, 0xc4, 0xdd, 0xa9, 0x2f, 0x02, 0xf3,
	0x2a, 0x3a, 0x8a, 0xae, 0xfc, 0xb3, 0x74, 0x81, 0x1b, 0x5a, 0x87, 0x9c, 0xaa, 0x34, 0x0f, 0x1a,
	0x8a, 0xd6, 0x56, 0x76, 0xe9, 0x2d, 0x6d, 0x40, 0xbe, 0xd1, 0xdd, 0xaf, 0xb7, 0x3a, 0x8a, 0xa6,
	0xb6, 0xee, 0xee, 0x0d, 0xe4, 0x38, 0x92, 0x21, 0xd7, 0x54, 0x6b, 0xad, 0x8e, 0xd6, 0xd8, 0x3b,
	0xe8, 0xdc, 0x97, 0xbf, 0x90, 0xd0, 0x36, 0x5c, 0x65, 0x10, 0xa5, 0xa9, 0x09, 0xe2, 0xa6, 0xd6,
	0xec, 0x36, 0x0e, 0xf6, 0x95, 0xce, 0x40, 0xfe, 0x52, 0x42, 0xcf, 0x43, 0x31, 0xc0, 0x73, 0xe9,
	0x11, 0xf4, 0x3f, 0x48, 0xa1, 0x40, 0xa5, 0xa9, 0xdd, 0x57, 0x1e, 0xc8, 0x3f, 0x93, 0xd0, 0x26,
	0x14, 0x02, 0x88, 0xb0, 0x82, 0x7f, 0x94, 0x10, 0x82, 0x7c, 0x00, 0xec, 0x0f, 0x6a, 0x83, 0xbe,
	0xfc, 0x4f, 0x52, 0xe5, 0xeb, 0x1c, 0x64, 0xd9, 0xe4, 0x91, 0x59, 0xc6, 0x07, 0x90, 0xe8, 0x4e,
	0xb0, 0xc3, 0xca, 0x49, 0xd7, 0x38, 0xf6, 0xcc, 0x43, 0x0d, 0x3b, 0x27, 0xda, 0x18, 0x8f, 0x03,
	0x77, 0x48, 0xa9, 0xb2, 0xc0, 0x28, 0xce, 0xc9, 0x3e, 0x83, 0xd3, 0x04, 0x6f, 0xbb, 0x86, 0x6e,
	0x6b, 0xa6, 0x25, 0x5e, 0x98, 0xa9, 0x19, 0x06, 0x68, 0x5a, 0xa4, 0xf4, 0xdd, 0xd0, 0xd6, 0xde,
	0x3a, 0x37, 0xe0, 0x0d, 0x73, 0xed, 0xe2, 0xec, 0x33, 0x3a, 0xe6, 0x2d, 0x3d, 0x84, 0x6c, 0xd3,
	0x35, 0x78, 0x7e, 0x40, 0x2f, 0x42, 0x82, 0x5a, 0x86, 0x60, 0x5e, 0x8e, 0x56, 0x2a, 0x43, 0x52,
	0xcb, 0x8b, 0x84, 0x28, 0xba, 0x9f, 0xb5, 0x48, 0x3c, 0x42, 0xaf, 0xc2, 0x7a, 0x38, 0x21, 0x14,
	0x85, 0x5b, 0x9c, 0x15, 0x6e, 0x85, 0x10, 0xcc, 0xaa, 0xb7, 0xd2, 0xd7, 0x12, 0xa4, 0x5a, 0xce,
	0x89, 0x7b, 0x8c, 0x57, 0xf1, 0x48, 0xab, 0x78, 0x68, 0xe2, 0xe2, 0xad, 0xa7, 0x17, 0x28, 0x8d,
	0xbd, 0xf6, 0x0f, 0xde, 0x4e, 0x7b, 0x42, 0x63, 0x11, 0x32, 0xf1, 0xc2, 0x84, 0x6e, 0x21, 0x11,
	0x92, 0xf1, 0x97, 0x26, 0xe8, 0x06, 0xc8, 0xc1, 0x30, 0x34, 0x94, 0x97, 0x60, 0xf2, 0xc2, 0x21,
	0x69, 0x20, 0x71, 0x81, 0x54, 0xc8, 0x4c, 0x32, 0x99, 0x73, 0x52, 0x2e, 0xb5, 0xa4, 0x40, 0xba,
	0x47, 0xf0, 0x44, 0x27, 0x98, 0xf5, 0xc6, 0x61, 0x10, 0x0d, 0xaf, 0x24, 0xcc, 0xdf, 0xf3, 0x00,
	0x1b, 0xf6, 0xc6, 0x21, 0xa4, 0xf4, 0x3f, 0xf1, 0xc0, 0x21, 0x9b, 0x0b, 0x03, 0x5a, 0x89, 0xe5,
	0x84, 0x97, 0x22, 0x17, 0x4b, 0x4d, 0x8b, 0xd5, 0x02, 0x5e, 0x64, 0x60, 0x4b, 0x97, 0x0b, 0xb3,
	0xda, 0x1a, 0x64, 0xc3, 0x9d, 0x0a, 0x97, 0x7d, 0x71, 0xb5, 0x10, 0x35, 0x98, 0x38, 0x33, 0x19,
	0x73, 0x2e, 0x74, 0x13, 0x52, 0xee, 0xd4, 0x9f, 0x3c, 0xd6, 0x95, 0x05, 0x45, 0xe9, 0x07, 0x90,
	0xe3, 0x97, 0xcb, 0xcf, 0x30, 0x67, 0x95, 0x9e, 0xc4, 0x4a, 0x1b, 0x7a, 0xdf, 0xf5, 0x23, 0xc3,
	0x3c, 0xba, 0x5b, 0x49, 0x5d, 0x63, 0x40, 0x31, 0xc9, 0x2b, 0xfd, 0x54, 0x82, 0xc2, 0xe2, 0x69,
	0x69, 0x40, 0xb2, 0x9c, 0xc7, 0xff, 0x05, 0x27, 0x40, 0xef, 0x41, 0x8a, 0x0f, 0x0b, 0x84, 0x22,
	0x5e, 0x58, 0xad, 0x88, 0xc8, 0x01, 0x54, 0xc1, 0x80, 0xde, 0x87, 0xb4, 0x78, 0xb7, 0x20, 0x94,
	0x70, 0x01, 0xde, 0x80, 0xa3, 0x74, 0x03, 0xf2, 0x0b, 0xca, 0x45, 0x45, 0x48, 0x1b, 0x04, 0xeb,
	0x3e, 0x36, 0x85, 0xc1, 0x07, 0xcb, 0xca, 0x9f, 0xc6, 0x57, 0x45, 0xc3, 0x0c, 0x24, 0xba, 0x3d,
	0xa5, 0x23, 0x4b, 0xe8, 0x0a, 0x20, 0x55, 0xe9, 0x0f, 0xba, 0xaa, 0xa2, 0x35, 0xf6, 0x94, 0xc6,
	0xfd, 0x5e, 0xb7, 0xd5, 0xa1, 0xf1, 0x70, 0x21, 0x5e, 0xc6, 0xd1, 0x65, 0xd8, 0xa8, 0x2b, 0x77,
	0x5b, 0x1d, 0x6d, 0xa0, 0xd6, 0x3a, 0xfd, 0x5a, 0x63, 0xd0, 0xea, 0x76, 0xe4, 0x04, 0x2a, 0xc2,
	0x56, 0x47, 0xf9, 0x78, 0x10, 0x46, 0x39, 0x6d, 0x4f, 0xa9, 0x35, 0x15, 0x55, 0x4e, 0x52, 0xb9,
	0x8b, 0x98, 0x7a, 0xb7, 0xf9, 0x40, 0x4e, 0xa1, 0x02, 0xc0, 0x40, 0xad, 0xed, 0xf7, 0xba, 0xed,
	0x56, 0x47, 0x91, 0xd3, 0x54, 0xf0, 0x7c, 0xad, 0xb5, 0x3a, 0x1f, 0x76, 0xef, 0x2b, 0x72, 0x86,
	0x82, 0x77, 0xdb, 0x07, 0xfd, 0xbd, 0x85, 0xff, 0xcb, 0xa2, 0x67, 0x60, 0x93, 0x81, 0x95, 0xe6,
	0x02, 0x02, 0x28, 0x7d, 0x4f, 0x55, 0x7a, 0x35, 0x55, 0xd1, 0x06, 0x5d, 0x1a, 0x9c, 0xf7, 0x5b,
	0x03, 0x39, 0x87, 0x36, 0x61, 0xbd, 0xd1, 0x56, 0x6a, 0xaa, 0xa6, 0x2a, 0x77, 0x5b, 0xfd, 0x81,
	0xa2, 0xf6, 0xe5, 0xb5, 0x5f, 0xa9, 0xb8, 0x7e, 0x96, 0x80, 0x4c, 0x7d, 0x6a, 0xd9, 0x26, 0x0d,
	0xeb, 0x5f, 0xc6, 0xa2, 0xe5, 0x4d, 0xf8, 0x09, 0x81, 0xb4, 0xf0, 0x09, 0x01, 0x7a, 0x0e, 0xb2,
	0xa6, 0x45, 0x58, 0xcf, 0x37, 0x0b, 0x5e, 0x8d, 0x86, 0x00, 0xf6, 0xd6, 0x9a, 0x05, 0x27, 0x51,
	0x8a, 0x8b, 0x15, 0xba, 0x05, 0x39, 0x31, 0x81, 0x63, 0xbd, 0x73, 0x82, 0xf5, 0x00, 0x1b, 0xc1,
	0x7c, 0x2d, 0x7c, 0xff, 0xac, 0x02, 0xa7, 0x62, 0x7d, 0xe3, 0x0e, 0x6c, 0xce, 0x3f, 0x52, 0xd2,
	0x86, 0xd8, 0xc1, 0x24, 0x98, 0x4b, 0x66, 0x54, 0x34, 0x47, 0xdd, 0x15, 0x18, 0xf4, 0x3a, 0x44,
	0xa0, 0x9a, 0xe1, 0x8e, 0x27, 0x96, 0x18, 0x94, 0x65, 0xd4, 0x8d, 0x39, 0xa6, 0xc1, 0x11, 0x4b,
	0xe4, 0x34, 0xf4, 0xeb, 0x43, 0x2c, 0xde, 0xb6, 0x47, 0xc8, 0x7b, 0x1c, 0x81, 0x5e, 0x83, 0x0d,
	0xc3, 0x75, 0x1c, 0x76, 0x50, 0xcd, 0xc1, 0xfe, 0xa7, 0x2e, 0x39, 0x0e, 0x66, 0x27, 0x21, 0xa2,
	0xc3, 0xe1, 0xa5, 0xdf, 0x82, 0xe4, 0x2e, 0xf6, 0x8d, 0x11, 0x7a, 0x01, 0xc2, 0x39, 0xa3, 0x36,
	0x25, 0xe2, 0xc3, 0x13, 0xda, 0x4c, 0x88, 0x0f, 0x91, 0x88, 0x8d, 0xde, 0x5a, 0x7a, 0x2d, 0x1f,
	0x7b, 0x94, 0x72, 0xa2, 0x6f, 0xea, 0x2b, 0x7f, 0x17, 0xd4, 0x19, 0x59, 0x48, 0x32, 0xdf, 0xe0,
	0x7e, 0xd5, 0xeb, 0xb6, 0xdb, 0xb2, 0xb4, 0x64, 0xe7, 0x31, 0x5a, 0xf1, 0x45, 0xec, 0x7c, 0x57,
	0x19, 0x34, 0xf6, 0xe4, 0x38, 0x2a, 0xc3, 0xb3, 0x11, 0x28, 0xf3, 0xce, 0xda, 0x40, 0xd1, 0x1a,
	0xb5, 0xde, 0x80, 0xfa, 0x5d, 0x02, 0xbd, 0x0a, 0x2f, 0xae, 0x22, 0xd8, 0xaf, 0x0d, 0x14, 0xb5,
	0x55, 0x6b, 0xb7, 0xbe, 0x5f, 0x63, 0x0e, 0x90, 0xa4, 0xff, 0xdc, 0xec, 0x76, 0x14, 0x39, 0x45,
	0xff, 0x89, 0x3e, 0x69, 0x1f, 0xb5, 0x06, 0x7b, 0x9a, 0xa2, 0xaa, 0x5d, 0xb5, 0x2f, 0xa7, 0x69,
	0x15, 0xda, 0xa8, 0x0d, 0x6a, 0xed, 0xee, 0x5d, 0xad, 0xdf, 0xd8, 0x53, 0xf6, 0x6b, 0xb2, 0x59,
	0xd9, 0x84, 0x0d, 0x15, 0x7b, 0xd8, 0xa7, 0x31, 0x24, 0xe8, 0xb3, 0x2b, 0x5b, 0x80, 0xa2, 0x40,
	0xde, 0x3d, 0x56, 0xee, 0x00, 0xaa, 0x99, 0x27, 0xba, 0x63, 0xe0, 0x81, 0x35, 0x0e, 0x7b, 0xf2,
	0x57, 0x61, 0x5d, 0xe7, 0xd0, 0x30, 0xc6, 0x4a, 0x2c, 0x99, 0x15, 0x04, 0x58, 0x44, 0xd9, 0xca,
	0x65, 0xd8, 0x5c, 0x60, 0x17, 0x52, 0xdf, 0x85, 0xb5, 0x68, 0x58, 0x45, 0x08, 0x12, 0xb4, 0x83,
	0x12, 0x31, 0x8c, 0x3d, 0xb3, 0x4f, 0x01, 0x29, 0x52, 0x8c, 0x6d, 0xf8, 0xa2, 0xf2, 0x23, 0x09,
	0xf2, 0x2d, 0x67, 0x88, 0x3d, 0x3f, 0xd8, 0xcb, 0xd3, 0x7e, 0x62, 0x10, 0xf5, 0xb0, 0xd8, 0xa2,
	0x87, 0xad, 0x18, 0xcf, 0xc4, 0x57, 0x8c, 0x67, 0x2a, 0x3f, 0x8f, 0x41, 0x21, 0xd8, 0x84, 0xe8,
	0xb2, 0xff, 0x46, 0x82, 0x4d, 0xf1, 0x89, 0x92, 0x36, 0x6f, 0x50, 0x83, 0x6c, 0xfb, 0x5a, 0xf0,
	0xa9, 0x48, 0x94, 0x27, 0x98, 0x60, 0x7c, 0x14, 0x74, 0xa3, 0x1e, 0x7f, 0xd9, 0xf7, 0x9b, 0x3f,
	0xfa, 0xe6, 0xa9, 0xbe, 0x8d, 0xfa, 0xf1, 0x37, 0x4f, 0xd5, 0x60, 0x6e, 0x7c, 0xb2, 0xfc, 0xb7,
	0xe8, 0xbb, 0xb0, 0x16, 0xec, 0x1d, 0xfb, 0x86, 0x29, 0x92, 0xda, 0xe5, 0xe5, 0xf6, 0xbf, 0xaa,
	0xf8, 0x86, 0x19, 0x7c, 0xbc, 0x20, 0x18, 0x28, 0xa8, 0xd4, 0x84, 0x2b, 0xab, 0xcf, 0xf2, 0xa4,
	0xb7, 0x8e, 0xf1, 0xc8, 0x5b, 0xc7, 0x9b, 0x1f, 0xc2, 0x5a, 0xf4, 0x6d, 0xcd, 0x62, 0xe2, 0x02,
	0x48, 0xf5, 0x3f, 0x68, 0xb7, 0x06, 0xd4, 0xa5, 0xe6, 0x63, 0xad, 0x38, 0x35, 0xef, 0x5a, 0x4b,
	0xad, 0x3f, 0x18, 0x28, 0x5a, 0xbf, 0x7b, 0xa0, 0x36, 0x68, 0x6a, 0xc9, 0x43, 0x76, 0xb7, 0xdd,
	0xfd, 0x48, 0xeb, 0xb7, 0x3a, 0xf7, 0xe5, 0xcc, 0xcd, 0x0e, 0x14, 0xda, 0xee, 0xb0, 0x8d, 0x4f,
	0xb0, 0xbd, 0xcb, 0x3e, 0x95, 0x43, 0x69, 0x88, 0x77, 0x77, 0x77, 0xe5, 0x4b, 0xd4, 0x83, 0x99,
	0xa3, 0xc8, 0x12, 0xf5, 0xa3, 0x8f, 0x6a, 0x6a, 0x47, 0x8e, 0xd1, 0xa7, 0x56, 0x67, 0xb7, 0x2b,
	0xc7, 0x29, 0xba, 0xa9, 0xd4, 0x0f, 0xee, 0xca, 0x09, 0xfa, 0x48, 0xdb, 0x36, 0x45, 0x4e, 0xde,
	0x3c, 0x81, 0x5c, 0x24, 0x36, 0xd0, 0x6d, 0x0a, 0x07, 0x93, 0x2f, 0xd1, 0xf6, 0xe2, 0x5e, 0xbf,
	0xdb, 0x09, 0x5c, 0x4d, 0x62, 0x69, 0xee, 0x41, 0x4f, 0xe9, 0x37, 0xd4, 0x56, 0x6f, 0xa0, 0xed,
	0x77, 0x9b, 0x07, 0x6d, 0x7a, 0x84, 0x75, 0xc8, 0x75, 0x7a, 0xfb, 0x5a, 0xaf, 0xd6, 0xb8, 0x5f,
	0xbb, 0xab, 0x88, 0xef, 0x68, 0x58, 0xda, 0x95, 0x13, 0x94, 0x27, 0xc8, 0x32, 0x7d, 0x6d, 0xb7,
	0xf5, 0x31, 0x0b, 0x09, 0xc9, 0x5b, 0x4d, 0xc8, 0x88, 0xd9, 0x0e, 0x41, 0xef, 0xce, 0xbf, 0x0c,
	0xdd, 0x5a, 0x78, 0x11, 0x21, 0xbc, 0xa2, 0x74, 0x79, 0x09, 0xca, 0x4d, 0xee, 0x0d, 0xe9, 0xd6,
	0xdf, 0x4b, 0x90, 0x1e, 0x60, 0xcf, 0xb7, 0x9c, 0x21, 0xfa, 0x1e, 0xc0, 0xdc, 0xe5, 0xd1, 0x33,
	0x62, 0xe2, 0xb5, 0x1c, 0x19, 0x4a, 0xc5, 0xf3, 0x08, 0x61, 0xf5, 0x75, 0xc8, 0x45, 0xdc, 0x1b,
	0x09, 0xc2, 0xf3, 0x01, 0xa3, 0x74, 0x75, 0x05, 0x46, 0xc8, 0x78, 0x93, 0x56, 0xf1, 0xd4, 0x2f,
	0xd0, 0xe6, 0xa2, 0x97, 0x70, 0xce, 0xad, 0x55, 0xae, 0x53, 0x7f, 0xff, 0x8b, 0x7f, 0xdb, 0xbe,
	0xf4, 0xc5, 0x2f, 0xb6, 0xa5, 0xaf, 0x7e, 0xb1, 0x2d, 0x7d, 0xfe, 0xef, 0xdb, 0xd2, 0xf7, 0x6f,
	0x0c, 0x2d, 0x7f, 0x34, 0x3d, 0xac, 0x1a, 0xee, 0x78, 0x07, 0x7b, 0xfe, 0x54, 0x27, 0x33, 0xfe,
	0x11, 0xf3, 0xb9, 0xcf, 0x9a, 0x0f, 0x53, 0x6c, 0xfd, 0xe6, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff,
	0x3f, 0x21, 0x3a, 0x39, 0xf2, 0x2c, 0x00, 0x00,
}

func (this *UUIDParts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UUIDParts)
	if !ok {
		that2, ok := that.(UUIDParts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProducerAndFlags != that1.ProducerAndFlags {
		return false
	}
	if this.Clock != that1.Clock {
		return false
	}
	return true
}
func (this *LambdaSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LambdaSpec)
	if !ok {
		that2, ok := that.(LambdaSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Typescript != that1.Typescript {
		return false
	}
	if this.Remote != that1.Remote {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Shuffle) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Shuffle)
	if !ok {
		that2, ok := that.(Shuffle)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupName != that1.GroupName {
		return false
	}
	if this.SourceCollection != that1.SourceCollection {
		return false
	}
	if !this.SourcePartitions.Equal(&that1.SourcePartitions) {
		return false
	}
	if this.SourceUuidPtr != that1.SourceUuidPtr {
		return false
	}
	if len(this.ShuffleKeyPtrs) != len(that1.ShuffleKeyPtrs) {
		return false
	}
	for i := range this.ShuffleKeyPtrs {
		if this.ShuffleKeyPtrs[i] != that1.ShuffleKeyPtrs[i] {
			return false
		}
	}
	if this.UsesSourceKey != that1.UsesSourceKey {
		return false
	}
	if !this.ShuffleLambda.Equal(that1.ShuffleLambda) {
		return false
	}
	if this.SourceSchemaUri != that1.SourceSchemaUri {
		return false
	}
	if this.UsesSourceSchema != that1.UsesSourceSchema {
		return false
	}
	if this.DeprecatedValidateSchemaAtRead != that1.DeprecatedValidateSchemaAtRead {
		return false
	}
	if this.FilterRClocks != that1.FilterRClocks {
		return false
	}
	if this.ReadDelaySeconds != that1.ReadDelaySeconds {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if this.ValidateSchemaJson != that1.ValidateSchemaJson {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *JournalShuffle) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JournalShuffle)
	if !ok {
		that2, ok := that.(JournalShuffle)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Journal != that1.Journal {
		return false
	}
	if this.Coordinator != that1.Coordinator {
		return false
	}
	if !this.Shuffle.Equal(that1.Shuffle) {
		return false
	}
	if this.Replay != that1.Replay {
		return false
	}
	if this.BuildId != that1.BuildId {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ShufflerClient is the client API for Shuffler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ShufflerClient interface {
	Shuffle(ctx context.Context, in *ShuffleRequest, opts ...grpc.CallOption) (Shuffler_ShuffleClient, error)
}

type shufflerClient struct {
	cc *grpc.ClientConn
}

func NewShufflerClient(cc *grpc.ClientConn) ShufflerClient {
	return &shufflerClient{cc}
}

func (c *shufflerClient) Shuffle(ctx context.Context, in *ShuffleRequest, opts ...grpc.CallOption) (Shuffler_ShuffleClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Shuffler_serviceDesc.Streams[0], "/flow.Shuffler/Shuffle", opts...)
	if err != nil {
		return nil, err
	}
	x := &shufflerShuffleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Shuffler_ShuffleClient interface {
	Recv() (*ShuffleResponse, error)
	grpc.ClientStream
}

type shufflerShuffleClient struct {
	grpc.ClientStream
}

func (x *shufflerShuffleClient) Recv() (*ShuffleResponse, error) {
	m := new(ShuffleResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ShufflerServer is the server API for Shuffler service.
type ShufflerServer interface {
	Shuffle(*ShuffleRequest, Shuffler_ShuffleServer) error
}

// UnimplementedShufflerServer can be embedded to have forward compatible implementations.
type UnimplementedShufflerServer struct {
}

func (*UnimplementedShufflerServer) Shuffle(req *ShuffleRequest, srv Shuffler_ShuffleServer) error {
	return status.Errorf(codes.Unimplemented, "method Shuffle not implemented")
}

func RegisterShufflerServer(s *grpc.Server, srv ShufflerServer) {
	s.RegisterService(&_Shuffler_serviceDesc, srv)
}

func _Shuffler_Shuffle_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ShuffleRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ShufflerServer).Shuffle(m, &shufflerShuffleServer{stream})
}

type Shuffler_ShuffleServer interface {
	Send(*ShuffleResponse) error
	grpc.ServerStream
}

type shufflerShuffleServer struct {
	grpc.ServerStream
}

func (x *shufflerShuffleServer) Send(m *ShuffleResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Shuffler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "flow.Shuffler",
	HandlerType: (*ShufflerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Shuffle",
			Handler:       _Shuffler_Shuffle_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "go/protocols/flow/flow.proto",
}

// TestingClient is the client API for Testing service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TestingClient interface {
	ResetState(ctx context.Context, in *ResetStateRequest, opts ...grpc.CallOption) (*ResetStateResponse, error)
	AdvanceTime(ctx context.Context, in *AdvanceTimeRequest, opts ...grpc.CallOption) (*AdvanceTimeResponse, error)
	Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error)
}

type testingClient struct {
	cc *grpc.ClientConn
}

func NewTestingClient(cc *grpc.ClientConn) TestingClient {
	return &testingClient{cc}
}

func (c *testingClient) ResetState(ctx context.Context, in *ResetStateRequest, opts ...grpc.CallOption) (*ResetStateResponse, error) {
	out := new(ResetStateResponse)
	err := c.cc.Invoke(ctx, "/flow.Testing/ResetState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testingClient) AdvanceTime(ctx context.Context, in *AdvanceTimeRequest, opts ...grpc.CallOption) (*AdvanceTimeResponse, error) {
	out := new(AdvanceTimeResponse)
	err := c.cc.Invoke(ctx, "/flow.Testing/AdvanceTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testingClient) Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error) {
	out := new(IngestResponse)
	err := c.cc.Invoke(ctx, "/flow.Testing/Ingest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TestingServer is the server API for Testing service.
type TestingServer interface {
	ResetState(context.Context, *ResetStateRequest) (*ResetStateResponse, error)
	AdvanceTime(context.Context, *AdvanceTimeRequest) (*AdvanceTimeResponse, error)
	Ingest(context.Context, *IngestRequest) (*IngestResponse, error)
}

// UnimplementedTestingServer can be embedded to have forward compatible implementations.
type UnimplementedTestingServer struct {
}

func (*UnimplementedTestingServer) ResetState(ctx context.Context, req *ResetStateRequest) (*ResetStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetState not implemented")
}
func (*UnimplementedTestingServer) AdvanceTime(ctx context.Context, req *AdvanceTimeRequest) (*AdvanceTimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdvanceTime not implemented")
}
func (*UnimplementedTestingServer) Ingest(ctx context.Context, req *IngestRequest) (*IngestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ingest not implemented")
}

func RegisterTestingServer(s *grpc.Server, srv TestingServer) {
	s.RegisterService(&_Testing_serviceDesc, srv)
}

func _Testing_ResetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestingServer).ResetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.Testing/ResetState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestingServer).ResetState(ctx, req.(*ResetStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Testing_AdvanceTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdvanceTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestingServer).AdvanceTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.Testing/AdvanceTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestingServer).AdvanceTime(ctx, req.(*AdvanceTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Testing_Ingest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestingServer).Ingest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.Testing/Ingest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestingServer).Ingest(ctx, req.(*IngestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Testing_serviceDesc = grpc.ServiceDesc{
	ServiceName: "flow.Testing",
	HandlerType: (*TestingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResetState",
			Handler:    _Testing_ResetState_Handler,
		},
		{
			MethodName: "AdvanceTime",
			Handler:    _Testing_AdvanceTime_Handler,
		},
		{
			MethodName: "Ingest",
			Handler:    _Testing_Ingest_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/protocols/flow/flow.proto",
}

func (m *Slice) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Slice) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Slice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Begin != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Begin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UUIDParts) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UUIDParts) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UUIDParts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Clock != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Clock))
		i--
		dAtA[i] = 0x11
	}
	if m.ProducerAndFlags != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ProducerAndFlags))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *LambdaSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LambdaSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LambdaSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Remote) > 0 {
		i -= len(m.Remote)
		copy(dAtA[i:], m.Remote)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Remote)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Typescript) > 0 {
		i -= len(m.Typescript)
		copy(dAtA[i:], m.Typescript)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Typescript)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Shuffle) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shuffle) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Shuffle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ValidateSchemaJson) > 0 {
		i -= len(m.ValidateSchemaJson)
		copy(dAtA[i:], m.ValidateSchemaJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ValidateSchemaJson)))
		i--
		dAtA[i] = 0x72
	}
	if m.Priority != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x68
	}
	if m.ReadDelaySeconds != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ReadDelaySeconds))
		i--
		dAtA[i] = 0x60
	}
	if m.FilterRClocks {
		i--
		if m.FilterRClocks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.DeprecatedValidateSchemaAtRead {
		i--
		if m.DeprecatedValidateSchemaAtRead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.UsesSourceSchema {
		i--
		if m.UsesSourceSchema {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.SourceSchemaUri) > 0 {
		i -= len(m.SourceSchemaUri)
		copy(dAtA[i:], m.SourceSchemaUri)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.SourceSchemaUri)))
		i--
		dAtA[i] = 0x42
	}
	if m.ShuffleLambda != nil {
		{
			size, err := m.ShuffleLambda.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.UsesSourceKey {
		i--
		if m.UsesSourceKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.ShuffleKeyPtrs) > 0 {
		for iNdEx := len(m.ShuffleKeyPtrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ShuffleKeyPtrs[iNdEx])
			copy(dAtA[i:], m.ShuffleKeyPtrs[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.ShuffleKeyPtrs[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.SourceUuidPtr) > 0 {
		i -= len(m.SourceUuidPtr)
		copy(dAtA[i:], m.SourceUuidPtr)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.SourceUuidPtr)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.SourcePartitions.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.SourceCollection) > 0 {
		i -= len(m.SourceCollection)
		copy(dAtA[i:], m.SourceCollection)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.SourceCollection)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.GroupName) > 0 {
		i -= len(m.GroupName)
		copy(dAtA[i:], m.GroupName)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.GroupName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JournalShuffle) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JournalShuffle) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JournalShuffle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BuildId) > 0 {
		i -= len(m.BuildId)
		copy(dAtA[i:], m.BuildId)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.BuildId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Replay {
		i--
		if m.Replay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Shuffle != nil {
		{
			size, err := m.Shuffle.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Coordinator) > 0 {
		i -= len(m.Coordinator)
		copy(dAtA[i:], m.Coordinator)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Coordinator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Journal) > 0 {
		i -= len(m.Journal)
		copy(dAtA[i:], m.Journal)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Journal)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Projection) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Projection) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Projection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Inference.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.IsPrimaryKey {
		i--
		if m.IsPrimaryKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.IsPartitionKey {
		i--
		if m.IsPartitionKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Explicit {
		i--
		if m.Explicit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Field) > 0 {
		i -= len(m.Field)
		copy(dAtA[i:], m.Field)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Field)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ptr) > 0 {
		i -= len(m.Ptr)
		copy(dAtA[i:], m.Ptr)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Ptr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Inference) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Inference) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Inference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Exists != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Exists))
		i--
		dAtA[i] = 0x40
	}
	if m.Secret {
		i--
		if m.Secret {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.DefaultJson) > 0 {
		i -= len(m.DefaultJson)
		copy(dAtA[i:], m.DefaultJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.DefaultJson)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x22
	}
	if m.String_ != nil {
		{
			size, err := m.String_.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Types[iNdEx])
			copy(dAtA[i:], m.Types[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.Types[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Inference_String) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Inference_String) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Inference_String) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ContentEncoding) > 0 {
		i -= len(m.ContentEncoding)
		copy(dAtA[i:], m.ContentEncoding)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ContentEncoding)))
		i--
		dAtA[i] = 0x3a
	}
	if m.MaxLength != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.MaxLength))
		i--
		dAtA[i] = 0x30
	}
	if m.IsBase64 {
		i--
		if m.IsBase64 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *CollectionSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PartitionTemplate != nil {
		{
			size, err := m.PartitionTemplate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SchemaJson) > 0 {
		i -= len(m.SchemaJson)
		copy(dAtA[i:], m.SchemaJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.SchemaJson)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AckJsonTemplate) > 0 {
		i -= len(m.AckJsonTemplate)
		copy(dAtA[i:], m.AckJsonTemplate)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.AckJsonTemplate)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Projections) > 0 {
		for iNdEx := len(m.Projections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Projections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.PartitionFields) > 0 {
		for iNdEx := len(m.PartitionFields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionFields[iNdEx])
			copy(dAtA[i:], m.PartitionFields[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.PartitionFields[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.UuidPtr) > 0 {
		i -= len(m.UuidPtr)
		copy(dAtA[i:], m.UuidPtr)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.UuidPtr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.KeyPtrs) > 0 {
		for iNdEx := len(m.KeyPtrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyPtrs[iNdEx])
			copy(dAtA[i:], m.KeyPtrs[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.KeyPtrs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SchemaUri) > 0 {
		i -= len(m.SchemaUri)
		copy(dAtA[i:], m.SchemaUri)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.SchemaUri)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Collection) > 0 {
		i -= len(m.Collection)
		copy(dAtA[i:], m.Collection)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Collection)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransformSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransformSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransformSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PublishLambda != nil {
		{
			size, err := m.PublishLambda.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.UpdateLambda != nil {
		{
			size, err := m.UpdateLambda.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Shuffle.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Transform) > 0 {
		i -= len(m.Transform)
		copy(dAtA[i:], m.Transform)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Transform)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Derivation) > 0 {
		i -= len(m.Derivation)
		copy(dAtA[i:], m.Derivation)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Derivation)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DerivationSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DerivationSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DerivationSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RegisterSchemaJson) > 0 {
		i -= len(m.RegisterSchemaJson)
		copy(dAtA[i:], m.RegisterSchemaJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.RegisterSchemaJson)))
		i--
		dAtA[i] = 0x3a
	}
	if m.RecoveryLogTemplate != nil {
		{
			size, err := m.RecoveryLogTemplate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ShardTemplate != nil {
		{
			size, err := m.ShardTemplate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Transforms) > 0 {
		for iNdEx := len(m.Transforms) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Transforms[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RegisterInitialJson) > 0 {
		i -= len(m.RegisterInitialJson)
		copy(dAtA[i:], m.RegisterInitialJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.RegisterInitialJson)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RegisterSchemaUri) > 0 {
		i -= len(m.RegisterSchemaUri)
		copy(dAtA[i:], m.RegisterSchemaUri)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.RegisterSchemaUri)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Collection.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FieldSelection) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldSelection) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldSelection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FieldConfigJson) > 0 {
		for k := range m.FieldConfigJson {
			v := m.FieldConfigJson[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintFlow(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFlow(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFlow(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Document) > 0 {
		i -= len(m.Document)
		copy(dAtA[i:], m.Document)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Document)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CaptureSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptureSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CaptureSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RecoveryLogTemplate != nil {
		{
			size, err := m.RecoveryLogTemplate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.ShardTemplate != nil {
		{
			size, err := m.ShardTemplate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.IntervalSeconds != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.IntervalSeconds))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Bindings) > 0 {
		for iNdEx := len(m.Bindings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bindings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.EndpointSpecJson) > 0 {
		i -= len(m.EndpointSpecJson)
		copy(dAtA[i:], m.EndpointSpecJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.EndpointSpecJson)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EndpointType != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.EndpointType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Capture) > 0 {
		i -= len(m.Capture)
		copy(dAtA[i:], m.Capture)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Capture)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CaptureSpec_Binding) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptureSpec_Binding) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CaptureSpec_Binding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Collection.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.ResourcePath) > 0 {
		for iNdEx := len(m.ResourcePath) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResourcePath[iNdEx])
			copy(dAtA[i:], m.ResourcePath[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.ResourcePath[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ResourceSpecJson) > 0 {
		i -= len(m.ResourceSpecJson)
		copy(dAtA[i:], m.ResourceSpecJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ResourceSpecJson)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MaterializationSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaterializationSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaterializationSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RecoveryLogTemplate != nil {
		{
			size, err := m.RecoveryLogTemplate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ShardTemplate != nil {
		{
			size, err := m.ShardTemplate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Bindings) > 0 {
		for iNdEx := len(m.Bindings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bindings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.EndpointSpecJson) > 0 {
		i -= len(m.EndpointSpecJson)
		copy(dAtA[i:], m.EndpointSpecJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.EndpointSpecJson)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EndpointType != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.EndpointType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Materialization) > 0 {
		i -= len(m.Materialization)
		copy(dAtA[i:], m.Materialization)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Materialization)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MaterializationSpec_Binding) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaterializationSpec_Binding) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaterializationSpec_Binding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Shuffle.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.DeltaUpdates {
		i--
		if m.DeltaUpdates {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.FieldSelection.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Collection.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.ResourcePath) > 0 {
		for iNdEx := len(m.ResourcePath) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResourcePath[iNdEx])
			copy(dAtA[i:], m.ResourcePath[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.ResourcePath[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ResourceSpecJson) > 0 {
		i -= len(m.ResourceSpecJson)
		copy(dAtA[i:], m.ResourceSpecJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ResourceSpecJson)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OAuth2Spec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OAuth2Spec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OAuth2Spec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RefreshTokenMethod) > 0 {
		i -= len(m.RefreshTokenMethod)
		copy(dAtA[i:], m.RefreshTokenMethod)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.RefreshTokenMethod)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.AccessTokenMethod) > 0 {
		i -= len(m.AccessTokenMethod)
		copy(dAtA[i:], m.AccessTokenMethod)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.AccessTokenMethod)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.RefreshTokenResponseMapJson) > 0 {
		i -= len(m.RefreshTokenResponseMapJson)
		copy(dAtA[i:], m.RefreshTokenResponseMapJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.RefreshTokenResponseMapJson)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.RefreshTokenHeadersJson) > 0 {
		i -= len(m.RefreshTokenHeadersJson)
		copy(dAtA[i:], m.RefreshTokenHeadersJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.RefreshTokenHeadersJson)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.RefreshTokenBody) > 0 {
		i -= len(m.RefreshTokenBody)
		copy(dAtA[i:], m.RefreshTokenBody)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.RefreshTokenBody)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RefreshTokenUrlTemplate) > 0 {
		i -= len(m.RefreshTokenUrlTemplate)
		copy(dAtA[i:], m.RefreshTokenUrlTemplate)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.RefreshTokenUrlTemplate)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AccessTokenResponseMapJson) > 0 {
		i -= len(m.AccessTokenResponseMapJson)
		copy(dAtA[i:], m.AccessTokenResponseMapJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.AccessTokenResponseMapJson)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AccessTokenHeadersJson) > 0 {
		i -= len(m.AccessTokenHeadersJson)
		copy(dAtA[i:], m.AccessTokenHeadersJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.AccessTokenHeadersJson)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AccessTokenBody) > 0 {
		i -= len(m.AccessTokenBody)
		copy(dAtA[i:], m.AccessTokenBody)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.AccessTokenBody)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AccessTokenUrlTemplate) > 0 {
		i -= len(m.AccessTokenUrlTemplate)
		copy(dAtA[i:], m.AccessTokenUrlTemplate)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.AccessTokenUrlTemplate)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AuthUrlTemplate) > 0 {
		i -= len(m.AuthUrlTemplate)
		copy(dAtA[i:], m.AuthUrlTemplate)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.AuthUrlTemplate)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Steps) > 0 {
		for iNdEx := len(m.Steps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Steps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Test) > 0 {
		i -= len(m.Test)
		copy(dAtA[i:], m.Test)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Test)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestSpec_Step) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSpec_Step) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSpec_Step) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Partitions.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.DocsJsonLines) > 0 {
		i -= len(m.DocsJsonLines)
		copy(dAtA[i:], m.DocsJsonLines)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.DocsJsonLines)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Collection) > 0 {
		i -= len(m.Collection)
		copy(dAtA[i:], m.Collection)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Collection)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StepScope) > 0 {
		i -= len(m.StepScope)
		copy(dAtA[i:], m.StepScope)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.StepScope)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.StepIndex != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.StepIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.StepType != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.StepType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RangeSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RClockEnd != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RClockEnd))
		i--
		dAtA[i] = 0x2d
	}
	if m.RClockBegin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RClockBegin))
		i--
		dAtA[i] = 0x25
	}
	if m.KeyEnd != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.KeyEnd))
		i--
		dAtA[i] = 0x1d
	}
	if m.KeyBegin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.KeyBegin))
		i--
		dAtA[i] = 0x15
	}
	return len(dAtA) - i, nil
}

func (m *ShuffleRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShuffleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShuffleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndOffset != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.EndOffset))
		i--
		dAtA[i] = 0x28
	}
	if m.Offset != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Resolution != nil {
		{
			size, err := m.Resolution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Shuffle.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ShuffleResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShuffleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShuffleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PackedKey) > 0 {
		for iNdEx := len(m.PackedKey) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PackedKey[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.UuidParts) > 0 {
		for iNdEx := len(m.UuidParts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UuidParts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Offsets) > 0 {
		dAtA26 := make([]byte, len(m.Offsets)*10)
		var j25 int
		for _, num1 := range m.Offsets {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		i -= j25
		copy(dAtA[i:], dAtA26[:j25])
		i = encodeVarintFlow(dAtA, i, uint64(j25))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DocsJson) > 0 {
		for iNdEx := len(m.DocsJson) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DocsJson[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Arena) > 0 {
		i -= len(m.Arena)
		copy(dAtA[i:], m.Arena)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Arena)))
		i--
		dAtA[i] = 0x32
	}
	if m.WriteHead != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.WriteHead))
		i--
		dAtA[i] = 0x28
	}
	if m.ReadThrough != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ReadThrough))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TerminalError) > 0 {
		i -= len(m.TerminalError)
		copy(dAtA[i:], m.TerminalError)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.TerminalError)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DriverCheckpoint) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DriverCheckpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DriverCheckpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rfc7396MergePatch {
		i--
		if m.Rfc7396MergePatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.DriverCheckpointJson) > 0 {
		i -= len(m.DriverCheckpointJson)
		copy(dAtA[i:], m.DriverCheckpointJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.DriverCheckpointJson)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExtractAPI) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtractAPI) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtractAPI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ExtractAPI_Config) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtractAPI_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtractAPI_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FieldPtrs) > 0 {
		for iNdEx := len(m.FieldPtrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FieldPtrs[iNdEx])
			copy(dAtA[i:], m.FieldPtrs[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.FieldPtrs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SchemaJson) > 0 {
		i -= len(m.SchemaJson)
		copy(dAtA[i:], m.SchemaJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.SchemaJson)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UuidPtr) > 0 {
		i -= len(m.UuidPtr)
		copy(dAtA[i:], m.UuidPtr)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.UuidPtr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CombineAPI) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineAPI) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombineAPI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *CombineAPI_Config) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineAPI_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombineAPI_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UuidPlaceholderPtr) > 0 {
		i -= len(m.UuidPlaceholderPtr)
		copy(dAtA[i:], m.UuidPlaceholderPtr)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.UuidPlaceholderPtr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FieldPtrs) > 0 {
		for iNdEx := len(m.FieldPtrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FieldPtrs[iNdEx])
			copy(dAtA[i:], m.FieldPtrs[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.FieldPtrs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.KeyPtrs) > 0 {
		for iNdEx := len(m.KeyPtrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyPtrs[iNdEx])
			copy(dAtA[i:], m.KeyPtrs[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.KeyPtrs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SchemaJson) > 0 {
		i -= len(m.SchemaJson)
		copy(dAtA[i:], m.SchemaJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.SchemaJson)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CombineAPI_Stats) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineAPI_Stats) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombineAPI_Stats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Out != nil {
		{
			size, err := m.Out.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Right != nil {
		{
			size, err := m.Right.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Left != nil {
		{
			size, err := m.Left.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveAPI) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveAPI) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveAPI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeriveAPI_Open) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveAPI_Open) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveAPI_Open) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LocalDir) > 0 {
		i -= len(m.LocalDir)
		copy(dAtA[i:], m.LocalDir)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.LocalDir)))
		i--
		dAtA[i] = 0x12
	}
	if m.RocksdbEnvMemptr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RocksdbEnvMemptr))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *DeriveAPI_Config) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveAPI_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveAPI_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Derivation != nil {
		{
			size, err := m.Derivation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveAPI_DocHeader) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveAPI_DocHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveAPI_DocHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TransformIndex != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.TransformIndex))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PackedKey) > 0 {
		i -= len(m.PackedKey)
		copy(dAtA[i:], m.PackedKey)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.PackedKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.Uuid != nil {
		{
			size, err := m.Uuid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveAPI_Invoke) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveAPI_Invoke) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveAPI_Invoke) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RegistersLength != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.RegistersLength))
		i--
		dAtA[i] = 0x28
	}
	if m.RegistersMemptr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RegistersMemptr))
		i--
		dAtA[i] = 0x21
	}
	if m.SourcesLength != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.SourcesLength))
		i--
		dAtA[i] = 0x18
	}
	if m.SourcesMemptr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SourcesMemptr))
		i--
		dAtA[i] = 0x11
	}
	if m.TransformIndex != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.TransformIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeriveAPI_Prepare) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveAPI_Prepare) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveAPI_Prepare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeriveAPI_Stats) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveAPI_Stats) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveAPI_Stats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Registers != nil {
		{
			size, err := m.Registers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Transforms) > 0 {
		for iNdEx := len(m.Transforms) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Transforms[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeriveAPI_Stats_InvokeStats) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveAPI_Stats_InvokeStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveAPI_Stats_InvokeStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TotalSeconds != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TotalSeconds))))
		i--
		dAtA[i] = 0x11
	}
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveAPI_Stats_TransformStats) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveAPI_Stats_TransformStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveAPI_Stats_TransformStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Publish != nil {
		{
			size, err := m.Publish.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Update != nil {
		{
			size, err := m.Update.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Input != nil {
		{
			size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveAPI_Stats_RegisterStats) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveAPI_Stats_RegisterStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveAPI_Stats_RegisterStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Created != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Created))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BuildAPI) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildAPI) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildAPI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *BuildAPI_Config) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildAPI_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildAPI_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ConnectorNetwork) > 0 {
		i -= len(m.ConnectorNetwork)
		copy(dAtA[i:], m.ConnectorNetwork)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ConnectorNetwork)))
		i--
		dAtA[i] = 0x42
	}
	if m.TypescriptPackage {
		i--
		if m.TypescriptPackage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.TypescriptCompile {
		i--
		if m.TypescriptCompile {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.TypescriptGenerate {
		i--
		if m.TypescriptGenerate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.SourceType != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.SourceType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Directory) > 0 {
		i -= len(m.Directory)
		copy(dAtA[i:], m.Directory)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Directory)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BuildId) > 0 {
		i -= len(m.BuildId)
		copy(dAtA[i:], m.BuildId)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.BuildId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BuildAPI_Fetch) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildAPI_Fetch) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildAPI_Fetch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ContentType != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ContentType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ResourceUrl) > 0 {
		i -= len(m.ResourceUrl)
		copy(dAtA[i:], m.ResourceUrl)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ResourceUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResetStateRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetStateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetStateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ResetStateResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetStateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetStateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *AdvanceTimeRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvanceTimeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvanceTimeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AdvanceSeconds != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.AdvanceSeconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AdvanceTimeResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvanceTimeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvanceTimeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DocsAndBytes) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocsAndBytes) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DocsAndBytes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Bytes != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Bytes))
		i--
		dAtA[i] = 0x10
	}
	if m.Docs != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Docs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IngestRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DocsJsonLines) > 0 {
		i -= len(m.DocsJsonLines)
		copy(dAtA[i:], m.DocsJsonLines)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.DocsJsonLines)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BuildId) > 0 {
		i -= len(m.BuildId)
		copy(dAtA[i:], m.BuildId)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.BuildId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Collection) > 0 {
		i -= len(m.Collection)
		copy(dAtA[i:], m.Collection)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Collection)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IngestResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.JournalEtcd.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.JournalWriteHeads) > 0 {
		for k := range m.JournalWriteHeads {
			v := m.JournalWriteHeads[k]
			baseI := i
			i = encodeVarintFlow(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFlow(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFlow(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintFlow(dAtA []byte, offset int, v uint64) int {
	offset -= sovFlow(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Slice) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != 0 {
		n += 1 + sovFlow(uint64(m.Begin))
	}
	if m.End != 0 {
		n += 1 + sovFlow(uint64(m.End))
	}
	return n
}

func (m *UUIDParts) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProducerAndFlags != 0 {
		n += 9
	}
	if m.Clock != 0 {
		n += 9
	}
	return n
}

func (m *LambdaSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Typescript)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Remote)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Shuffle) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GroupName)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.SourceCollection)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = m.SourcePartitions.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	l = len(m.SourceUuidPtr)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.ShuffleKeyPtrs) > 0 {
		for _, s := range m.ShuffleKeyPtrs {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.UsesSourceKey {
		n += 2
	}
	if m.ShuffleLambda != nil {
		l = m.ShuffleLambda.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.SourceSchemaUri)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.UsesSourceSchema {
		n += 2
	}
	if m.DeprecatedValidateSchemaAtRead {
		n += 2
	}
	if m.FilterRClocks {
		n += 2
	}
	if m.ReadDelaySeconds != 0 {
		n += 1 + sovFlow(uint64(m.ReadDelaySeconds))
	}
	if m.Priority != 0 {
		n += 1 + sovFlow(uint64(m.Priority))
	}
	l = len(m.ValidateSchemaJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JournalShuffle) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Coordinator)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Shuffle != nil {
		l = m.Shuffle.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Replay {
		n += 2
	}
	l = len(m.BuildId)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Projection) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ptr)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Field)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Explicit {
		n += 2
	}
	if m.IsPartitionKey {
		n += 2
	}
	if m.IsPrimaryKey {
		n += 2
	}
	l = m.Inference.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Inference) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Types) > 0 {
		for _, s := range m.Types {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.String_ != nil {
		l = m.String_.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.DefaultJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Secret {
		n += 2
	}
	if m.Exists != 0 {
		n += 1 + sovFlow(uint64(m.Exists))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Inference_String) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.IsBase64 {
		n += 2
	}
	if m.MaxLength != 0 {
		n += 1 + sovFlow(uint64(m.MaxLength))
	}
	l = len(m.ContentEncoding)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CollectionSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Collection)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.SchemaUri)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.KeyPtrs) > 0 {
		for _, s := range m.KeyPtrs {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = len(m.UuidPtr)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.PartitionFields) > 0 {
		for _, s := range m.PartitionFields {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.Projections) > 0 {
		for _, e := range m.Projections {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = len(m.AckJsonTemplate)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.SchemaJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.PartitionTemplate != nil {
		l = m.PartitionTemplate.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransformSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Derivation)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Transform)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = m.Shuffle.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.UpdateLambda != nil {
		l = m.UpdateLambda.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.PublishLambda != nil {
		l = m.PublishLambda.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DerivationSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Collection.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	l = len(m.RegisterSchemaUri)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.RegisterInitialJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Transforms) > 0 {
		for _, e := range m.Transforms {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.ShardTemplate != nil {
		l = m.ShardTemplate.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.RecoveryLogTemplate != nil {
		l = m.RecoveryLogTemplate.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.RegisterSchemaJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FieldSelection) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = len(m.Document)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.FieldConfigJson) > 0 {
		for k, v := range m.FieldConfigJson {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CaptureSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Capture)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.EndpointType != 0 {
		n += 1 + sovFlow(uint64(m.EndpointType))
	}
	l = len(m.EndpointSpecJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Bindings) > 0 {
		for _, e := range m.Bindings {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.IntervalSeconds != 0 {
		n += 1 + sovFlow(uint64(m.IntervalSeconds))
	}
	if m.ShardTemplate != nil {
		l = m.ShardTemplate.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.RecoveryLogTemplate != nil {
		l = m.RecoveryLogTemplate.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CaptureSpec_Binding) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceSpecJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.ResourcePath) > 0 {
		for _, s := range m.ResourcePath {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = m.Collection.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaterializationSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Materialization)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.EndpointType != 0 {
		n += 1 + sovFlow(uint64(m.EndpointType))
	}
	l = len(m.EndpointSpecJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Bindings) > 0 {
		for _, e := range m.Bindings {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.ShardTemplate != nil {
		l = m.ShardTemplate.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.RecoveryLogTemplate != nil {
		l = m.RecoveryLogTemplate.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaterializationSpec_Binding) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceSpecJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.ResourcePath) > 0 {
		for _, s := range m.ResourcePath {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = m.Collection.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	l = m.FieldSelection.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.DeltaUpdates {
		n += 2
	}
	l = m.Shuffle.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OAuth2Spec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.AuthUrlTemplate)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.AccessTokenUrlTemplate)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.AccessTokenBody)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.AccessTokenHeadersJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.AccessTokenResponseMapJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.RefreshTokenUrlTemplate)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.RefreshTokenBody)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.RefreshTokenHeadersJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.RefreshTokenResponseMapJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.AccessTokenMethod)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.RefreshTokenMethod)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Test)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestSpec_Step) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StepType != 0 {
		n += 1 + sovFlow(uint64(m.StepType))
	}
	if m.StepIndex != 0 {
		n += 1 + sovFlow(uint64(m.StepIndex))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.StepScope)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Collection)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.DocsJsonLines)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = m.Partitions.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RangeSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyBegin != 0 {
		n += 5
	}
	if m.KeyEnd != 0 {
		n += 5
	}
	if m.RClockBegin != 0 {
		n += 5
	}
	if m.RClockEnd != 0 {
		n += 5
	}
	return n
}

func (m *ShuffleRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Shuffle.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.Resolution != nil {
		l = m.Resolution.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = m.Range.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.Offset != 0 {
		n += 1 + sovFlow(uint64(m.Offset))
	}
	if m.EndOffset != 0 {
		n += 1 + sovFlow(uint64(m.EndOffset))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShuffleResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovFlow(uint64(m.Status))
	}
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.TerminalError)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.ReadThrough != 0 {
		n += 1 + sovFlow(uint64(m.ReadThrough))
	}
	if m.WriteHead != 0 {
		n += 1 + sovFlow(uint64(m.WriteHead))
	}
	l = len(m.Arena)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.DocsJson) > 0 {
		for _, e := range m.DocsJson {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.Offsets) > 0 {
		l = 0
		for _, e := range m.Offsets {
			l += sovFlow(uint64(e))
		}
		n += 1 + sovFlow(uint64(l)) + l
	}
	if len(m.UuidParts) > 0 {
		for _, e := range m.UuidParts {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.PackedKey) > 0 {
		for _, e := range m.PackedKey {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DriverCheckpoint) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DriverCheckpointJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Rfc7396MergePatch {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtractAPI) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtractAPI_Config) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UuidPtr)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.SchemaJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.FieldPtrs) > 0 {
		for _, s := range m.FieldPtrs {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CombineAPI) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CombineAPI_Config) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SchemaJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.KeyPtrs) > 0 {
		for _, s := range m.KeyPtrs {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.FieldPtrs) > 0 {
		for _, s := range m.FieldPtrs {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = len(m.UuidPlaceholderPtr)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CombineAPI_Stats) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Left != nil {
		l = m.Left.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Right != nil {
		l = m.Right.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Out != nil {
		l = m.Out.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveAPI) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveAPI_Open) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RocksdbEnvMemptr != 0 {
		n += 9
	}
	l = len(m.LocalDir)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveAPI_Config) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Derivation != nil {
		l = m.Derivation.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveAPI_DocHeader) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uuid != nil {
		l = m.Uuid.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.PackedKey)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.TransformIndex != 0 {
		n += 1 + sovFlow(uint64(m.TransformIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveAPI_Invoke) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TransformIndex != 0 {
		n += 1 + sovFlow(uint64(m.TransformIndex))
	}
	if m.SourcesMemptr != 0 {
		n += 9
	}
	if m.SourcesLength != 0 {
		n += 1 + sovFlow(uint64(m.SourcesLength))
	}
	if m.RegistersMemptr != 0 {
		n += 9
	}
	if m.RegistersLength != 0 {
		n += 1 + sovFlow(uint64(m.RegistersLength))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveAPI_Prepare) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Checkpoint.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveAPI_Stats) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Transforms) > 0 {
		for _, e := range m.Transforms {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.Registers != nil {
		l = m.Registers.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Output != nil {
		l = m.Output.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveAPI_Stats_InvokeStats) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.TotalSeconds != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveAPI_Stats_TransformStats) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		l = m.Input.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Update != nil {
		l = m.Update.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Publish != nil {
		l = m.Publish.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveAPI_Stats_RegisterStats) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Created != 0 {
		n += 1 + sovFlow(uint64(m.Created))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuildAPI) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuildAPI_Config) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BuildId)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Directory)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.SourceType != 0 {
		n += 1 + sovFlow(uint64(m.SourceType))
	}
	if m.TypescriptGenerate {
		n += 2
	}
	if m.TypescriptCompile {
		n += 2
	}
	if m.TypescriptPackage {
		n += 2
	}
	l = len(m.ConnectorNetwork)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuildAPI_Fetch) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceUrl)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.ContentType != 0 {
		n += 1 + sovFlow(uint64(m.ContentType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResetStateRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResetStateResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdvanceTimeRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdvanceSeconds != 0 {
		n += 1 + sovFlow(uint64(m.AdvanceSeconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdvanceTimeResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DocsAndBytes) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Docs != 0 {
		n += 1 + sovFlow(uint64(m.Docs))
	}
	if m.Bytes != 0 {
		n += 1 + sovFlow(uint64(m.Bytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngestRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Collection)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.BuildId)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.DocsJsonLines)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngestResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.JournalWriteHeads) > 0 {
		for k, v := range m.JournalWriteHeads {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + sovFlow(uint64(v))
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	l = m.JournalEtcd.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFlow(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFlow(x uint64) (n int) {
	return sovFlow(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Slice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Slice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Slice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UUIDParts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UUIDParts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UUIDParts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerAndFlags", wireType)
			}
			m.ProducerAndFlags = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ProducerAndFlags = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clock", wireType)
			}
			m.Clock = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Clock = go_gazette_dev_core_message.Clock(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LambdaSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LambdaSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LambdaSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typescript", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Typescript = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shuffle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shuffle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shuffle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCollection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceCollection = Collection(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcePartitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SourcePartitions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceUuidPtr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceUuidPtr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleKeyPtrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShuffleKeyPtrs = append(m.ShuffleKeyPtrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesSourceKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsesSourceKey = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleLambda", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShuffleLambda == nil {
				m.ShuffleLambda = &LambdaSpec{}
			}
			if err := m.ShuffleLambda.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceSchemaUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceSchemaUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesSourceSchema", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsesSourceSchema = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedValidateSchemaAtRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeprecatedValidateSchemaAtRead = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterRClocks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FilterRClocks = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadDelaySeconds", wireType)
			}
			m.ReadDelaySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadDelaySeconds |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidateSchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidateSchemaJson = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JournalShuffle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JournalShuffle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JournalShuffle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = go_gazette_dev_core_broker_protocol.Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coordinator = go_gazette_dev_core_consumer_protocol.ShardID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shuffle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shuffle == nil {
				m.Shuffle = &Shuffle{}
			}
			if err := m.Shuffle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Replay = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Projection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Projection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Projection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ptr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ptr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Explicit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Explicit = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPartitionKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPartitionKey = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimaryKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrimaryKey = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Inference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Inference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Inference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Inference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.String_ == nil {
				m.String_ = &Inference_String{}
			}
			if err := m.String_.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Secret = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exists", wireType)
			}
			m.Exists = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exists |= Inference_Exists(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Inference_String) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: String: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: String: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBase64", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBase64 = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLength", wireType)
			}
			m.MaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLength |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentEncoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collection = Collection(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPtrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyPtrs = append(m.KeyPtrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidPtr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidPtr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionFields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionFields = append(m.PartitionFields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Projections = append(m.Projections, Projection{})
			if err := m.Projections[len(m.Projections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckJsonTemplate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AckJsonTemplate = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionTemplate == nil {
				m.PartitionTemplate = &protocol.JournalSpec{}
			}
			if err := m.PartitionTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransformSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransformSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransformSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Derivation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Derivation = Collection(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transform = Transform(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shuffle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shuffle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateLambda", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateLambda == nil {
				m.UpdateLambda = &LambdaSpec{}
			}
			if err := m.UpdateLambda.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishLambda", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishLambda == nil {
				m.PublishLambda = &LambdaSpec{}
			}
			if err := m.PublishLambda.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DerivationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DerivationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DerivationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisterSchemaUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegisterSchemaUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisterInitialJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegisterInitialJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transforms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transforms = append(m.Transforms, TransformSpec{})
			if err := m.Transforms[len(m.Transforms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardTemplate == nil {
				m.ShardTemplate = &protocol1.ShardSpec{}
			}
			if err := m.ShardTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryLogTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecoveryLogTemplate == nil {
				m.RecoveryLogTemplate = &protocol.JournalSpec{}
			}
			if err := m.RecoveryLogTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisterSchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegisterSchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldSelection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldSelection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldSelection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Document", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Document = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldConfigJson", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldConfigJson == nil {
				m.FieldConfigJson = make(map[string]encoding_json.RawMessage)
			}
			var mapkey string
			var mapvalue encoding_json.RawMessage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = encoding_json.RawMessage(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlow(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFlow
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FieldConfigJson[mapkey] = ((encoding_json.RawMessage)(mapvalue))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptureSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptureSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptureSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Capture = Capture(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointType", wireType)
			}
			m.EndpointType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndpointType |= EndpointType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSpecJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointSpecJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bindings = append(m.Bindings, &CaptureSpec_Binding{})
			if err := m.Bindings[len(m.Bindings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalSeconds", wireType)
			}
			m.IntervalSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalSeconds |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardTemplate == nil {
				m.ShardTemplate = &protocol1.ShardSpec{}
			}
			if err := m.ShardTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryLogTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecoveryLogTemplate == nil {
				m.RecoveryLogTemplate = &protocol.JournalSpec{}
			}
			if err := m.RecoveryLogTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptureSpec_Binding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Binding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Binding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceSpecJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceSpecJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourcePath = append(m.ResourcePath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaterializationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaterializationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaterializationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Materialization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Materialization = Materialization(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointType", wireType)
			}
			m.EndpointType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndpointType |= EndpointType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSpecJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointSpecJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bindings = append(m.Bindings, &MaterializationSpec_Binding{})
			if err := m.Bindings[len(m.Bindings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardTemplate == nil {
				m.ShardTemplate = &protocol1.ShardSpec{}
			}
			if err := m.ShardTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryLogTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecoveryLogTemplate == nil {
				m.RecoveryLogTemplate = &protocol.JournalSpec{}
			}
			if err := m.RecoveryLogTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaterializationSpec_Binding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Binding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Binding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceSpecJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceSpecJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourcePath = append(m.ResourcePath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldSelection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FieldSelection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaUpdates", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeltaUpdates = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shuffle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shuffle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OAuth2Spec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OAuth2Spec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OAuth2Spec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthUrlTemplate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthUrlTemplate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessTokenUrlTemplate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessTokenUrlTemplate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessTokenBody", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessTokenBody = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessTokenHeadersJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessTokenHeadersJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessTokenResponseMapJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessTokenResponseMapJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTokenUrlTemplate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshTokenUrlTemplate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTokenBody", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshTokenBody = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTokenHeadersJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshTokenHeadersJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTokenResponseMapJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshTokenResponseMapJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessTokenMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessTokenMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTokenMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshTokenMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Test", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Test = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, TestSpec_Step{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestSpec_Step) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Step: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Step: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepType", wireType)
			}
			m.StepType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepType |= TestSpec_Step_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepIndex", wireType)
			}
			m.StepIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepScope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepScope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collection = Collection(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocsJsonLines", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocsJsonLines = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Partitions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBegin", wireType)
			}
			m.KeyBegin = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyBegin = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyEnd", wireType)
			}
			m.KeyEnd = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyEnd = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RClockBegin", wireType)
			}
			m.RClockBegin = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.RClockBegin = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RClockEnd", wireType)
			}
			m.RClockEnd = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.RClockEnd = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShuffleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShuffleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShuffleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shuffle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shuffle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resolution == nil {
				m.Resolution = &protocol.Header{}
			}
			if err := m.Resolution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndOffset", wireType)
			}
			m.EndOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndOffset |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShuffleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShuffleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShuffleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= protocol1.Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &protocol.Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TerminalError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TerminalError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadThrough", wireType)
			}
			m.ReadThrough = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadThrough |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteHead", wireType)
			}
			m.WriteHead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteHead |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arena", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arena = append(m.Arena[:0], dAtA[iNdEx:postIndex]...)
			if m.Arena == nil {
				m.Arena = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocsJson", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocsJson = append(m.DocsJson, Slice{})
			if err := m.DocsJson[len(m.DocsJson)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v go_gazette_dev_core_broker_protocol.Offset
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Offsets = append(m.Offsets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlow
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlow
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Offsets) == 0 {
					m.Offsets = make([]go_gazette_dev_core_broker_protocol.Offset, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v go_gazette_dev_core_broker_protocol.Offset
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Offsets = append(m.Offsets, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Offsets", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidParts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidParts = append(m.UuidParts, UUIDParts{})
			if err := m.UuidParts[len(m.UuidParts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackedKey = append(m.PackedKey, Slice{})
			if err := m.PackedKey[len(m.PackedKey)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DriverCheckpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DriverCheckpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DriverCheckpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriverCheckpointJson", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DriverCheckpointJson = append(m.DriverCheckpointJson[:0], dAtA[iNdEx:postIndex]...)
			if m.DriverCheckpointJson == nil {
				m.DriverCheckpointJson = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rfc7396MergePatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rfc7396MergePatch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtractAPI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtractAPI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtractAPI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtractAPI_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidPtr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidPtr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPtrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPtrs = append(m.FieldPtrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineAPI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombineAPI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombineAPI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineAPI_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPtrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyPtrs = append(m.KeyPtrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPtrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPtrs = append(m.FieldPtrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidPlaceholderPtr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidPlaceholderPtr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineAPI_Stats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Left == nil {
				m.Left = &DocsAndBytes{}
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Right == nil {
				m.Right = &DocsAndBytes{}
			}
			if err := m.Right.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Out", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Out == nil {
				m.Out = &DocsAndBytes{}
			}
			if err := m.Out.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveAPI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeriveAPI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeriveAPI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveAPI_Open) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Open: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Open: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksdbEnvMemptr", wireType)
			}
			m.RocksdbEnvMemptr = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.RocksdbEnvMemptr = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveAPI_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Derivation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Derivation == nil {
				m.Derivation = &DerivationSpec{}
			}
			if err := m.Derivation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveAPI_DocHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uuid == nil {
				m.Uuid = &UUIDParts{}
			}
			if err := m.Uuid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackedKey = append(m.PackedKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PackedKey == nil {
				m.PackedKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransformIndex", wireType)
			}
			m.TransformIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransformIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveAPI_Invoke) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Invoke: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Invoke: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransformIndex", wireType)
			}
			m.TransformIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransformIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcesMemptr", wireType)
			}
			m.SourcesMemptr = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SourcesMemptr = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcesLength", wireType)
			}
			m.SourcesLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourcesLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistersMemptr", wireType)
			}
			m.RegistersMemptr = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.RegistersMemptr = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistersLength", wireType)
			}
			m.RegistersLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegistersLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveAPI_Prepare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveAPI_Stats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transforms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transforms = append(m.Transforms, &DeriveAPI_Stats_TransformStats{})
			if err := m.Transforms[len(m.Transforms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Registers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Registers == nil {
				m.Registers = &DeriveAPI_Stats_RegisterStats{}
			}
			if err := m.Registers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &DocsAndBytes{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveAPI_Stats_InvokeStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvokeStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvokeStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &DocsAndBytes{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TotalSeconds = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveAPI_Stats_TransformStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransformStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransformStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &DocsAndBytes{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Update == nil {
				m.Update = &DeriveAPI_Stats_InvokeStats{}
			}
			if err := m.Update.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Publish == nil {
				m.Publish = &DeriveAPI_Stats_InvokeStats{}
			}
			if err := m.Publish.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveAPI_Stats_RegisterStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildAPI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildAPI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildAPI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildAPI_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Directory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Directory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			m.SourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceType |= ContentType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypescriptGenerate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TypescriptGenerate = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypescriptCompile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TypescriptCompile = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypescriptPackage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TypescriptPackage = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorNetwork", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectorNetwork = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildAPI_Fetch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fetch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fetch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			m.ContentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentType |= ContentType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetStateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetStateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetStateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetStateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetStateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetStateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvanceTimeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvanceTimeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvanceTimeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvanceSeconds", wireType)
			}
			m.AdvanceSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdvanceSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvanceTimeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvanceTimeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvanceTimeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocsAndBytes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocsAndBytes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocsAndBytes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Docs", wireType)
			}
			m.Docs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Docs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bytes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collection = Collection(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocsJsonLines", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocsJsonLines = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JournalWriteHeads", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JournalWriteHeads == nil {
				m.JournalWriteHeads = make(map[go_gazette_dev_core_broker_protocol.Journal]go_gazette_dev_core_broker_protocol.Offset)
			}
			var mapkey go_gazette_dev_core_broker_protocol.Journal
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = go_gazette_dev_core_broker_protocol.Journal(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlow(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFlow
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JournalWriteHeads[go_gazette_dev_core_broker_protocol.Journal(mapkey)] = ((go_gazette_dev_core_broker_protocol.Offset)(mapvalue))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JournalEtcd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.JournalEtcd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlow(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFlow
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFlow
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFlow
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFlow        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlow          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFlow = fmt.Errorf("proto: unexpected end of group")
)
