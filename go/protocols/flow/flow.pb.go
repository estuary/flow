// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go/protocols/flow/flow.proto

package flow

import (
	bytes "bytes"
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/golang/protobuf/ptypes/empty"
	go_gazette_dev_core_broker_protocol "go.gazette.dev/core/broker/protocol"
	protocol "go.gazette.dev/core/broker/protocol"
	go_gazette_dev_core_consumer_protocol "go.gazette.dev/core/consumer/protocol"
	protocol1 "go.gazette.dev/core/consumer/protocol"
	_ "go.gazette.dev/core/consumer/recoverylog"
	go_gazette_dev_core_message "go.gazette.dev/core/message"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Optional hash applied to extracted, packed shuffle keys. Hashes can:
// * Mitigate shard skew which might otherwise occur due to key locality
//   (many co-occurring updates to "nearby" keys).
// * Give predictable storage sizes for keys which are otherwise unbounded.
// * Allow for joins over sensitive fields, which should not be stored
//   in-the-clear at rest where possible.
// Either cryptographic or non-cryptographic functions may be appropriate
// depending on thse use case.
type Shuffle_Hash int32

const (
	// None performs no hash, returning the original key.
	Shuffle_NONE Shuffle_Hash = 0
	// MD5 returns the MD5 digest of the original key. It is not a safe
	// cryptographic hash, but is well-known and fast, with good distribution
	// properties.
	Shuffle_MD5 Shuffle_Hash = 1
)

var Shuffle_Hash_name = map[int32]string{
	0: "NONE",
	1: "MD5",
}

var Shuffle_Hash_value = map[string]int32{
	"NONE": 0,
	"MD5":  1,
}

func (x Shuffle_Hash) String() string {
	return proto.EnumName(Shuffle_Hash_name, int32(x))
}

func (Shuffle_Hash) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{2, 0}
}

// Slice represents a contiguous slice of bytes within an associated Arena.
type Slice struct {
	Begin uint32 `protobuf:"varint,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End   uint32 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *Slice) Reset()         { *m = Slice{} }
func (m *Slice) String() string { return proto.CompactTextString(m) }
func (*Slice) ProtoMessage()    {}
func (*Slice) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{0}
}
func (m *Slice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Slice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Slice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Slice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Slice.Merge(m, src)
}
func (m *Slice) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Slice) XXX_DiscardUnknown() {
	xxx_messageInfo_Slice.DiscardUnknown(m)
}

var xxx_messageInfo_Slice proto.InternalMessageInfo

// UUIDParts is a deconstructed, RFC 4122 v1 variant Universally Unique
// Identifier as used by Gazette.
type UUIDParts struct {
	// Producer is the unique node identifier portion of a v1 UUID, as the high
	// 48 bits of |producer_and_flags|. The MSB must be 1 to mark this producer
	// as "multicast" and not an actual MAC address (as per RFC 4122).
	//
	// Bits 49-54 must be zero.
	//
	// The low 10 bits are the 10 least-significant bits of the v1 UUID clock
	// sequence, used by Gazette to represent flags over message transaction
	// semantics.
	ProducerAndFlags uint64 `protobuf:"fixed64,1,opt,name=producer_and_flags,json=producerAndFlags,proto3" json:"producer_and_flags,omitempty"`
	// Clock is a v1 UUID 60-bit timestamp (60 MSBs), followed by 4 bits of
	// sequence counter.
	Clock go_gazette_dev_core_message.Clock `protobuf:"fixed64,2,opt,name=clock,proto3,casttype=go.gazette.dev/core/message.Clock" json:"clock,omitempty"`
}

func (m *UUIDParts) Reset()         { *m = UUIDParts{} }
func (m *UUIDParts) String() string { return proto.CompactTextString(m) }
func (*UUIDParts) ProtoMessage()    {}
func (*UUIDParts) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{1}
}
func (m *UUIDParts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UUIDParts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UUIDParts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UUIDParts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UUIDParts.Merge(m, src)
}
func (m *UUIDParts) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UUIDParts) XXX_DiscardUnknown() {
	xxx_messageInfo_UUIDParts.DiscardUnknown(m)
}

var xxx_messageInfo_UUIDParts proto.InternalMessageInfo

// Shuffle is a description of a document shuffle, where each document
// is mapped into:
//  * An extracted, packed composite key (a "shuffle key").
//  * A rotated Clock value (an "r-clock").
// The packed key and r-clock can then be compared to a reader RangeSpec.
type Shuffle struct {
	// Composite key over which shuffling occurs, specified as one or more
	// JSON-Pointers indicating a message location to extract.
	ShuffleKeyPtr []string `protobuf:"bytes,1,rep,name=shuffle_key_ptr,json=shuffleKeyPtr,proto3" json:"shuffle_key_ptr,omitempty"`
	// uses_source_key is true if shuffle_key_ptr is the source's native key,
	// and false if it's some other key. When shuffling using the source's key,
	// we can minimize data movement by assigning a shard coordinator for each
	// journal such that the shard's key range overlap that of the journal.
	UsesSourceKey bool `protobuf:"varint,2,opt,name=uses_source_key,json=usesSourceKey,proto3" json:"uses_source_key,omitempty"`
	// filter_r_clocks is true if the shuffle coordinator should filter documents
	// sent to each subscriber based on its covered r-clock ranges and the
	// individual document clocks. If false, the subscriber's r-clock range is
	// ignored and all documents which match the key range are sent.
	//
	// filter_r_clocks is set 'true' when reading on behalf of transforms having
	// a "publish" but not an "update" lambda, as such documents have no
	// side-effects on the reader's state store, and would not be published anyway
	// for falling outside of the reader's r-clock range.
	FilterRClocks bool         `protobuf:"varint,3,opt,name=filter_r_clocks,json=filterRClocks,proto3" json:"filter_r_clocks,omitempty"`
	Hash          Shuffle_Hash `protobuf:"varint,4,opt,name=hash,proto3,enum=flow.Shuffle_Hash" json:"hash,omitempty"`
	// Number of seconds for which documents of this collection are delayed
	// while reading, relative to other documents (when back-filling) and the
	// present wall-clock time (when tailing).
	ReadDelaySeconds     uint32   `protobuf:"varint,5,opt,name=read_delay_seconds,json=readDelaySeconds,proto3" json:"read_delay_seconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Shuffle) Reset()         { *m = Shuffle{} }
func (m *Shuffle) String() string { return proto.CompactTextString(m) }
func (*Shuffle) ProtoMessage()    {}
func (*Shuffle) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{2}
}
func (m *Shuffle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Shuffle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Shuffle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Shuffle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Shuffle.Merge(m, src)
}
func (m *Shuffle) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Shuffle) XXX_DiscardUnknown() {
	xxx_messageInfo_Shuffle.DiscardUnknown(m)
}

var xxx_messageInfo_Shuffle proto.InternalMessageInfo

// JournalShuffle is a Shuffle of a Journal by a Coordinator shard.
type JournalShuffle struct {
	// Journal to be shuffled.
	Journal go_gazette_dev_core_broker_protocol.Journal `protobuf:"bytes,1,opt,name=journal,proto3,casttype=go.gazette.dev/core/broker/protocol.Journal" json:"journal,omitempty"`
	// Coordinator is the Shard ID which is responsible for reads of this journal.
	Coordinator go_gazette_dev_core_consumer_protocol.ShardID `protobuf:"bytes,2,opt,name=coordinator,proto3,casttype=go.gazette.dev/core/consumer/protocol.ShardID" json:"coordinator,omitempty"`
	// Shuffle of this JournalShuffle.
	Shuffle `protobuf:"bytes,3,opt,name=shuffle,proto3,embedded=shuffle" json:"shuffle"`
	// Is this a reply of the journal's content?
	// We separate ongoing vs replayed reads of a journal's content into
	// distinct rings, so that ongoing reads cannot deadlock a replay read.
	//
	// If we didn't do this, a shard might issue a replay read while
	// *also* having a full recv queue of its ongoing read. Then, the
	// the server would on sending yet another ongoing read, such that
	// it's unable to service the replay read that would ultimately
	// unblock the shard / allow it to drain new ongoing reads.
	Replay               bool     `protobuf:"varint,4,opt,name=replay,proto3" json:"replay,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JournalShuffle) Reset()         { *m = JournalShuffle{} }
func (m *JournalShuffle) String() string { return proto.CompactTextString(m) }
func (*JournalShuffle) ProtoMessage()    {}
func (*JournalShuffle) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{3}
}
func (m *JournalShuffle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JournalShuffle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JournalShuffle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JournalShuffle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JournalShuffle.Merge(m, src)
}
func (m *JournalShuffle) XXX_Size() int {
	return m.ProtoSize()
}
func (m *JournalShuffle) XXX_DiscardUnknown() {
	xxx_messageInfo_JournalShuffle.DiscardUnknown(m)
}

var xxx_messageInfo_JournalShuffle proto.InternalMessageInfo

// Projection is a mapping between a document location, specified as a
// JSON-Pointer, and a corresponding field string in a flattened
// (i.e. tabular or SQL) namespace which aliases it.
type Projection struct {
	// Document location of this projection, as a JSON-Pointer.
	Ptr string `protobuf:"bytes,1,opt,name=ptr,proto3" json:"ptr,omitempty"`
	// Field is the flattened, tabular alias of this projection.
	Field string `protobuf:"bytes,2,opt,name=field,proto3" json:"field,omitempty"`
	// Was this projection user provided ?
	UserProvided bool `protobuf:"varint,3,opt,name=user_provided,json=userProvided,proto3" json:"user_provided,omitempty"`
	// Does this projection constitute a logical partitioning of the collection?
	IsPartitionKey bool `protobuf:"varint,4,opt,name=is_partition_key,json=isPartitionKey,proto3" json:"is_partition_key,omitempty"`
	// Does this location form (part of) the collection key?
	IsPrimaryKey bool `protobuf:"varint,5,opt,name=is_primary_key,json=isPrimaryKey,proto3" json:"is_primary_key,omitempty"`
	// Inference of this projection.
	Inference            *Inference `protobuf:"bytes,6,opt,name=inference,proto3" json:"inference,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Projection) Reset()         { *m = Projection{} }
func (m *Projection) String() string { return proto.CompactTextString(m) }
func (*Projection) ProtoMessage()    {}
func (*Projection) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{4}
}
func (m *Projection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Projection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Projection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Projection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Projection.Merge(m, src)
}
func (m *Projection) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Projection) XXX_DiscardUnknown() {
	xxx_messageInfo_Projection.DiscardUnknown(m)
}

var xxx_messageInfo_Projection proto.InternalMessageInfo

// Inference details type information which is statically known
// about a given document location.
type Inference struct {
	// The possible types for this location.
	// Subset of ["null", "boolean", "object", "array", "integer", "numeric", "string"].
	Types []string `protobuf:"bytes,1,rep,name=types,proto3" json:"types,omitempty"`
	// Whether the projection must always exist (either as a location within)
	// the source document, or as a null-able column in the database.
	MustExist bool              `protobuf:"varint,2,opt,name=must_exist,json=mustExist,proto3" json:"must_exist,omitempty"`
	String_   *Inference_String `protobuf:"bytes,3,opt,name=string,proto3" json:"string,omitempty"`
	// The title from the schema, if provided
	Title string `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	// The description from the schema, if provided
	Description          string   `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Inference) Reset()         { *m = Inference{} }
func (m *Inference) String() string { return proto.CompactTextString(m) }
func (*Inference) ProtoMessage()    {}
func (*Inference) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{5}
}
func (m *Inference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Inference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Inference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Inference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Inference.Merge(m, src)
}
func (m *Inference) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Inference) XXX_DiscardUnknown() {
	xxx_messageInfo_Inference.DiscardUnknown(m)
}

var xxx_messageInfo_Inference proto.InternalMessageInfo

// String type-specific inferences.
type Inference_String struct {
	// Annotated Content-Type when the projection is of "string" type.
	ContentType string `protobuf:"bytes,3,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	// Annotated format when the projection is of "string" type.
	Format string `protobuf:"bytes,4,opt,name=format,proto3" json:"format,omitempty"`
	// Whether the value is base64-encoded when the projection is of "string" type.
	IsBase64 bool `protobuf:"varint,5,opt,name=is_base64,json=isBase64,proto3" json:"is_base64,omitempty"`
	// Maximum length when the projection is of "string" type. Zero for no limit.
	MaxLength            uint32   `protobuf:"varint,6,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Inference_String) Reset()         { *m = Inference_String{} }
func (m *Inference_String) String() string { return proto.CompactTextString(m) }
func (*Inference_String) ProtoMessage()    {}
func (*Inference_String) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{5, 0}
}
func (m *Inference_String) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Inference_String) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Inference_String.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Inference_String) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Inference_String.Merge(m, src)
}
func (m *Inference_String) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Inference_String) XXX_DiscardUnknown() {
	xxx_messageInfo_Inference_String.DiscardUnknown(m)
}

var xxx_messageInfo_Inference_String proto.InternalMessageInfo

type CollectionSpec struct {
	// Name of this collection.
	Name Collection `protobuf:"bytes,1,opt,name=name,proto3,casttype=Collection" json:"name,omitempty"`
	// Schema against which collection documents are validated,
	// and which provides reduction annotations.
	SchemaUri string `protobuf:"bytes,2,opt,name=schema_uri,json=schemaUri,proto3" json:"schema_uri,omitempty"`
	// Composite key of the collection, as JSON-Pointers.
	KeyPtrs []string `protobuf:"bytes,3,rep,name=key_ptrs,json=keyPtrs,proto3" json:"key_ptrs,omitempty"`
	// JSON pointer locating the UUID of each collection document.
	UuidPtr string `protobuf:"bytes,4,opt,name=uuid_ptr,json=uuidPtr,proto3" json:"uuid_ptr,omitempty"`
	// Logical partition fields of this collection.
	PartitionFields []string `protobuf:"bytes,5,rep,name=partition_fields,json=partitionFields,proto3" json:"partition_fields,omitempty"`
	// Logical projections of this collection
	Projections []*Projection `protobuf:"bytes,6,rep,name=projections,proto3" json:"projections,omitempty"`
	// JournalSpec used for dynamically-created journals of this collection.
	JournalSpec protocol.JournalSpec `protobuf:"bytes,7,opt,name=journal_spec,json=journalSpec,proto3" json:"journal_spec"`
	// JSON-encoded document template for creating Gazette consumer
	// transaction acknowledgements of writes into this collection.
	AckJsonTemplate      []byte   `protobuf:"bytes,8,opt,name=ack_json_template,json=ackJsonTemplate,proto3" json:"ack_json_template,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CollectionSpec) Reset()         { *m = CollectionSpec{} }
func (m *CollectionSpec) String() string { return proto.CompactTextString(m) }
func (*CollectionSpec) ProtoMessage()    {}
func (*CollectionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{6}
}
func (m *CollectionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionSpec.Merge(m, src)
}
func (m *CollectionSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CollectionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionSpec proto.InternalMessageInfo

// Transform describes a specific transform of a derived collection.
type TransformSpec struct {
	// Stable name of this transform, scoped to it's Derivation.
	Name Transform `protobuf:"bytes,1,opt,name=name,proto3,casttype=Transform" json:"name,omitempty"`
	// ID of this transform within the present catalog DB.
	// This ID is *not* stable /across/ different catalog DBs.
	// Instead, use |name| for equality testing.
	CatalogDbId int32                `protobuf:"varint,2,opt,name=catalog_db_id,json=catalogDbId,proto3" json:"catalog_db_id,omitempty"`
	Source      TransformSpec_Source `protobuf:"bytes,3,opt,name=source,proto3" json:"source"`
	// Shuffle applied to source documents for this transform.
	// Note that the Shuffle embeds the Transform name.
	Shuffle              Shuffle                  `protobuf:"bytes,4,opt,name=shuffle,proto3" json:"shuffle"`
	Derivation           TransformSpec_Derivation `protobuf:"bytes,5,opt,name=derivation,proto3" json:"derivation"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TransformSpec) Reset()         { *m = TransformSpec{} }
func (m *TransformSpec) String() string { return proto.CompactTextString(m) }
func (*TransformSpec) ProtoMessage()    {}
func (*TransformSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{7}
}
func (m *TransformSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransformSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransformSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransformSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransformSpec.Merge(m, src)
}
func (m *TransformSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransformSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TransformSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TransformSpec proto.InternalMessageInfo

// Source collection read by this transform.
type TransformSpec_Source struct {
	// Name of the collection.
	Name Collection `protobuf:"bytes,1,opt,name=name,proto3,casttype=Collection" json:"name,omitempty"`
	// Selector of partitions of the collection which this transform reads.
	Partitions           protocol.LabelSelector `protobuf:"bytes,2,opt,name=partitions,proto3" json:"partitions"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TransformSpec_Source) Reset()         { *m = TransformSpec_Source{} }
func (m *TransformSpec_Source) String() string { return proto.CompactTextString(m) }
func (*TransformSpec_Source) ProtoMessage()    {}
func (*TransformSpec_Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{7, 0}
}
func (m *TransformSpec_Source) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransformSpec_Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransformSpec_Source.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransformSpec_Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransformSpec_Source.Merge(m, src)
}
func (m *TransformSpec_Source) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransformSpec_Source) XXX_DiscardUnknown() {
	xxx_messageInfo_TransformSpec_Source.DiscardUnknown(m)
}

var xxx_messageInfo_TransformSpec_Source proto.InternalMessageInfo

// Derived collection produced by this transform.
type TransformSpec_Derivation struct {
	Name                 Collection `protobuf:"bytes,1,opt,name=name,proto3,casttype=Collection" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TransformSpec_Derivation) Reset()         { *m = TransformSpec_Derivation{} }
func (m *TransformSpec_Derivation) String() string { return proto.CompactTextString(m) }
func (*TransformSpec_Derivation) ProtoMessage()    {}
func (*TransformSpec_Derivation) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{7, 1}
}
func (m *TransformSpec_Derivation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransformSpec_Derivation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransformSpec_Derivation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransformSpec_Derivation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransformSpec_Derivation.Merge(m, src)
}
func (m *TransformSpec_Derivation) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransformSpec_Derivation) XXX_DiscardUnknown() {
	xxx_messageInfo_TransformSpec_Derivation.DiscardUnknown(m)
}

var xxx_messageInfo_TransformSpec_Derivation proto.InternalMessageInfo

// RangeSpec describes the ranges of shuffle keys and r-clocks which a reader
// is responsible for.
type RangeSpec struct {
	// Byte [begin, end) exclusive range of keys to be shuffled to this reader.
	KeyBegin []byte `protobuf:"bytes,2,opt,name=key_begin,json=keyBegin,proto3" json:"key_begin,omitempty"`
	KeyEnd   []byte `protobuf:"bytes,3,opt,name=key_end,json=keyEnd,proto3" json:"key_end,omitempty"`
	// Rotated [begin, end) exclusive ranges of Clocks to be shuffled to this
	// reader.
	RClockBegin          uint64   `protobuf:"varint,4,opt,name=r_clock_begin,json=rClockBegin,proto3" json:"r_clock_begin,omitempty"`
	RClockEnd            uint64   `protobuf:"varint,5,opt,name=r_clock_end,json=rClockEnd,proto3" json:"r_clock_end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RangeSpec) Reset()         { *m = RangeSpec{} }
func (m *RangeSpec) String() string { return proto.CompactTextString(m) }
func (*RangeSpec) ProtoMessage()    {}
func (*RangeSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{8}
}
func (m *RangeSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RangeSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RangeSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeSpec.Merge(m, src)
}
func (m *RangeSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RangeSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RangeSpec proto.InternalMessageInfo

// ShuffleRequest is the request message of a Shuffle RPC.
type ShuffleRequest struct {
	Shuffle JournalShuffle `protobuf:"bytes,1,opt,name=shuffle,proto3" json:"shuffle"`
	Range   RangeSpec      `protobuf:"bytes,2,opt,name=range,proto3" json:"range"`
	// Offset to begin reading the journal from.
	Offset go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,3,opt,name=offset,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"offset,omitempty"`
	// Offset to stop reading the journal at, or zero if unbounded.
	EndOffset go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,4,opt,name=end_offset,json=endOffset,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"end_offset,omitempty"`
	// Resolution header of the |config.coordinator_index| shard.
	Resolution           *protocol.Header `protobuf:"bytes,5,opt,name=resolution,proto3" json:"resolution,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ShuffleRequest) Reset()         { *m = ShuffleRequest{} }
func (m *ShuffleRequest) String() string { return proto.CompactTextString(m) }
func (*ShuffleRequest) ProtoMessage()    {}
func (*ShuffleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{9}
}
func (m *ShuffleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShuffleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShuffleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShuffleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShuffleRequest.Merge(m, src)
}
func (m *ShuffleRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShuffleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ShuffleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ShuffleRequest proto.InternalMessageInfo

// ShuffleResponse is the streamed response message of a Shuffle RPC.
type ShuffleResponse struct {
	// Status of the Shuffle RPC.
	Status protocol1.Status `protobuf:"varint,1,opt,name=status,proto3,enum=consumer.Status" json:"status,omitempty"`
	// Header of the response.
	Header *protocol.Header `protobuf:"bytes,2,opt,name=header,proto3" json:"header,omitempty"`
	// Terminal error encountered while serving this ShuffleRequest. A terminal
	// error is only sent if a future ShuffleRequest of this same configuration
	// and offset will fail in the exact same way, and operator intervention is
	// required to properly recover. Such errors are returned so that the caller
	// can also abort with a useful, contextual error message.
	//
	// Examples of terminal errors include the requested journal not existing,
	// or data corruption. Errors *not* returned as |terminal_error| include
	// network errors, process failures, and other conditions which can be
	// retried.
	TerminalError string `protobuf:"bytes,3,opt,name=terminal_error,json=terminalError,proto3" json:"terminal_error,omitempty"`
	// Offset which was read through to produce this ShuffleResponse.
	ReadThrough go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,4,opt,name=read_through,json=readThrough,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"read_through,omitempty"`
	// WriteHead of the journal as reported by the broker, as of the creation of
	// this ShuffleResponse.
	WriteHead go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,5,opt,name=write_head,json=writeHead,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"write_head,omitempty"`
	// Memory arena of this message.
	Arena Arena `protobuf:"bytes,6,opt,name=arena,proto3,casttype=Arena" json:"arena,omitempty"`
	// Shuffled documents, each encoded in the 'application/json'
	// media-type.
	DocsJson []Slice `protobuf:"bytes,7,rep,name=docs_json,json=docsJson,proto3" json:"docs_json"`
	// The begin offset of each document within the requested journal.
	Begin []go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,8,rep,packed,name=begin,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"begin,omitempty"`
	// The end offset of each document within the journal.
	End []go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,9,rep,packed,name=end,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"end,omitempty"`
	// UUIDParts of each document.
	UuidParts []UUIDParts `protobuf:"bytes,10,rep,name=uuid_parts,json=uuidParts,proto3" json:"uuid_parts"`
	// Packed, embedded encoding of the shuffle key into a byte string.
	// If the Shuffle specified a Hash to use, it's applied as well.
	PackedKey            []Slice  `protobuf:"bytes,11,rep,name=packed_key,json=packedKey,proto3" json:"packed_key"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShuffleResponse) Reset()         { *m = ShuffleResponse{} }
func (m *ShuffleResponse) String() string { return proto.CompactTextString(m) }
func (*ShuffleResponse) ProtoMessage()    {}
func (*ShuffleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{10}
}
func (m *ShuffleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShuffleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShuffleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShuffleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShuffleResponse.Merge(m, src)
}
func (m *ShuffleResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShuffleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ShuffleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ShuffleResponse proto.InternalMessageInfo

type ExtractAPI struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtractAPI) Reset()         { *m = ExtractAPI{} }
func (m *ExtractAPI) String() string { return proto.CompactTextString(m) }
func (*ExtractAPI) ProtoMessage()    {}
func (*ExtractAPI) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{11}
}
func (m *ExtractAPI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtractAPI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtractAPI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtractAPI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtractAPI.Merge(m, src)
}
func (m *ExtractAPI) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExtractAPI) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtractAPI.DiscardUnknown(m)
}

var xxx_messageInfo_ExtractAPI proto.InternalMessageInfo

type ExtractAPI_Config struct {
	// JSON pointer of the document UUID to extract.
	// If empty, UUIDParts are not extracted.
	UuidPtr string `protobuf:"bytes,1,opt,name=uuid_ptr,json=uuidPtr,proto3" json:"uuid_ptr,omitempty"`
	// Field JSON pointers to extract from documents and return.
	// If empty, no fields are extracted.
	FieldPtrs            []string `protobuf:"bytes,2,rep,name=field_ptrs,json=fieldPtrs,proto3" json:"field_ptrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtractAPI_Config) Reset()         { *m = ExtractAPI_Config{} }
func (m *ExtractAPI_Config) String() string { return proto.CompactTextString(m) }
func (*ExtractAPI_Config) ProtoMessage()    {}
func (*ExtractAPI_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{11, 0}
}
func (m *ExtractAPI_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtractAPI_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtractAPI_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtractAPI_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtractAPI_Config.Merge(m, src)
}
func (m *ExtractAPI_Config) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExtractAPI_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtractAPI_Config.DiscardUnknown(m)
}

var xxx_messageInfo_ExtractAPI_Config proto.InternalMessageInfo

type CombineAPI struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CombineAPI) Reset()         { *m = CombineAPI{} }
func (m *CombineAPI) String() string { return proto.CompactTextString(m) }
func (*CombineAPI) ProtoMessage()    {}
func (*CombineAPI) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{12}
}
func (m *CombineAPI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombineAPI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombineAPI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombineAPI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombineAPI.Merge(m, src)
}
func (m *CombineAPI) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CombineAPI) XXX_DiscardUnknown() {
	xxx_messageInfo_CombineAPI.DiscardUnknown(m)
}

var xxx_messageInfo_CombineAPI proto.InternalMessageInfo

type CombineAPI_Config struct {
	// Memory address of a 'static SchemaIndex to use for combining.
	// Applicable only to the CGO bridged CombinerService.
	SchemaIndexMemptr uint64 `protobuf:"fixed64,1,opt,name=schema_index_memptr,json=schemaIndexMemptr,proto3" json:"schema_index_memptr,omitempty"`
	// Schema against which documents are to be validated,
	// and which provides reduction annotations.
	SchemaUri string `protobuf:"bytes,2,opt,name=schema_uri,json=schemaUri,proto3" json:"schema_uri,omitempty"`
	// Composite key used to group documents to be combined, specified as one or
	// more JSON-Pointers indicating a message location to extract.
	// If empty, all request documents are combined into a single response
	// document.
	KeyPtr []string `protobuf:"bytes,3,rep,name=key_ptr,json=keyPtr,proto3" json:"key_ptr,omitempty"`
	// Field JSON pointers to be extracted from combined documents and returned.
	// If empty, no fields are extracted.
	FieldPtrs []string `protobuf:"bytes,4,rep,name=field_ptrs,json=fieldPtrs,proto3" json:"field_ptrs,omitempty"`
	// JSON-Pointer at which a placeholder UUID should be inserted into
	// returned documents. If empty, no placeholder is inserted.
	UuidPlaceholderPtr string `protobuf:"bytes,5,opt,name=uuid_placeholder_ptr,json=uuidPlaceholderPtr,proto3" json:"uuid_placeholder_ptr,omitempty"`
	// Prune is true if this CombineRequest includes the root-most
	// (equivalently, left-most) document of each key. Depending on the
	// reduction strategy, additional pruning can be done in this case
	// (i.e., removing tombstones) that isn't possible in a partial
	// non-root reduction.
	Prune                bool     `protobuf:"varint,6,opt,name=prune,proto3" json:"prune,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CombineAPI_Config) Reset()         { *m = CombineAPI_Config{} }
func (m *CombineAPI_Config) String() string { return proto.CompactTextString(m) }
func (*CombineAPI_Config) ProtoMessage()    {}
func (*CombineAPI_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{12, 0}
}
func (m *CombineAPI_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombineAPI_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombineAPI_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombineAPI_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombineAPI_Config.Merge(m, src)
}
func (m *CombineAPI_Config) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CombineAPI_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_CombineAPI_Config.DiscardUnknown(m)
}

var xxx_messageInfo_CombineAPI_Config proto.InternalMessageInfo

// DeriveAPI is a meta-message which name spaces messages of the Derive API bridge.
type DeriveAPI struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveAPI) Reset()         { *m = DeriveAPI{} }
func (m *DeriveAPI) String() string { return proto.CompactTextString(m) }
func (*DeriveAPI) ProtoMessage()    {}
func (*DeriveAPI) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{13}
}
func (m *DeriveAPI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveAPI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveAPI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveAPI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveAPI.Merge(m, src)
}
func (m *DeriveAPI) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveAPI) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveAPI.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveAPI proto.InternalMessageInfo

// Config configures an instance of the derive service.
type DeriveAPI_Config struct {
	// Path to the catalog database.
	CatalogPath string `protobuf:"bytes,1,opt,name=catalog_path,json=catalogPath,proto3" json:"catalog_path,omitempty"`
	// Name of the collection to derive.
	Derivation string `protobuf:"bytes,2,opt,name=derivation,proto3" json:"derivation,omitempty"`
	// Local directory for ephemeral processing state.
	LocalDir string `protobuf:"bytes,3,opt,name=local_dir,json=localDir,proto3" json:"local_dir,omitempty"`
	// Memory address of an RocksDB Environment to use (as a *rocksdb_env_t).
	// Ownership of the environment is transferred with this message.
	RocksdbEnvMemptr     uint64   `protobuf:"fixed64,4,opt,name=rocksdb_env_memptr,json=rocksdbEnvMemptr,proto3" json:"rocksdb_env_memptr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveAPI_Config) Reset()         { *m = DeriveAPI_Config{} }
func (m *DeriveAPI_Config) String() string { return proto.CompactTextString(m) }
func (*DeriveAPI_Config) ProtoMessage()    {}
func (*DeriveAPI_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{13, 0}
}
func (m *DeriveAPI_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveAPI_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveAPI_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveAPI_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveAPI_Config.Merge(m, src)
}
func (m *DeriveAPI_Config) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveAPI_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveAPI_Config.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveAPI_Config proto.InternalMessageInfo

// DocHeader preceds a JSON-encoded document.
type DeriveAPI_DocHeader struct {
	Uuid                 *UUIDParts `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	PackedKey            []byte     `protobuf:"bytes,2,opt,name=packed_key,json=packedKey,proto3" json:"packed_key,omitempty"`
	TransformId          int32      `protobuf:"varint,3,opt,name=transform_id,json=transformId,proto3" json:"transform_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DeriveAPI_DocHeader) Reset()         { *m = DeriveAPI_DocHeader{} }
func (m *DeriveAPI_DocHeader) String() string { return proto.CompactTextString(m) }
func (*DeriveAPI_DocHeader) ProtoMessage()    {}
func (*DeriveAPI_DocHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{13, 1}
}
func (m *DeriveAPI_DocHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveAPI_DocHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveAPI_DocHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveAPI_DocHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveAPI_DocHeader.Merge(m, src)
}
func (m *DeriveAPI_DocHeader) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveAPI_DocHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveAPI_DocHeader.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveAPI_DocHeader proto.InternalMessageInfo

// Flush the transaction pipeline.
type DeriveAPI_Flush struct {
	// JSON-Pointer of the UUID placeholder in returned documents.
	UuidPlaceholderPtr string `protobuf:"bytes,1,opt,name=uuid_placeholder_ptr,json=uuidPlaceholderPtr,proto3" json:"uuid_placeholder_ptr,omitempty"`
	// Field JSON pointers to be extracted from combined documents and returned.
	// If empty, no fields are extracted.
	FieldPtrs            []string `protobuf:"bytes,2,rep,name=field_ptrs,json=fieldPtrs,proto3" json:"field_ptrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveAPI_Flush) Reset()         { *m = DeriveAPI_Flush{} }
func (m *DeriveAPI_Flush) String() string { return proto.CompactTextString(m) }
func (*DeriveAPI_Flush) ProtoMessage()    {}
func (*DeriveAPI_Flush) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{13, 2}
}
func (m *DeriveAPI_Flush) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveAPI_Flush) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveAPI_Flush.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveAPI_Flush) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveAPI_Flush.Merge(m, src)
}
func (m *DeriveAPI_Flush) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveAPI_Flush) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveAPI_Flush.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveAPI_Flush proto.InternalMessageInfo

// Prepare a commit of the transaction.
type DeriveAPI_Prepare struct {
	// Checkpoint to commit.
	Checkpoint           protocol1.Checkpoint `protobuf:"bytes,1,opt,name=checkpoint,proto3" json:"checkpoint"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *DeriveAPI_Prepare) Reset()         { *m = DeriveAPI_Prepare{} }
func (m *DeriveAPI_Prepare) String() string { return proto.CompactTextString(m) }
func (*DeriveAPI_Prepare) ProtoMessage()    {}
func (*DeriveAPI_Prepare) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{13, 3}
}
func (m *DeriveAPI_Prepare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveAPI_Prepare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveAPI_Prepare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveAPI_Prepare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveAPI_Prepare.Merge(m, src)
}
func (m *DeriveAPI_Prepare) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveAPI_Prepare) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveAPI_Prepare.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveAPI_Prepare proto.InternalMessageInfo

// IngestRequest describes documents to ingest into collections.
type IngestRequest struct {
	Collections          []IngestRequest_Collection `protobuf:"bytes,1,rep,name=collections,proto3" json:"collections"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *IngestRequest) Reset()         { *m = IngestRequest{} }
func (m *IngestRequest) String() string { return proto.CompactTextString(m) }
func (*IngestRequest) ProtoMessage()    {}
func (*IngestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{14}
}
func (m *IngestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngestRequest.Merge(m, src)
}
func (m *IngestRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IngestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IngestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IngestRequest proto.InternalMessageInfo

// Collection describes an ingest into a collection.
type IngestRequest_Collection struct {
	// Name of the collection into which to ingest.
	Name Collection `protobuf:"bytes,1,opt,name=name,proto3,casttype=Collection" json:"name,omitempty"`
	// Newline-separated JSON documents to ingest.
	DocsJsonLines        []byte   `protobuf:"bytes,2,opt,name=docs_json_lines,json=docsJsonLines,proto3" json:"docs_json_lines,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IngestRequest_Collection) Reset()         { *m = IngestRequest_Collection{} }
func (m *IngestRequest_Collection) String() string { return proto.CompactTextString(m) }
func (*IngestRequest_Collection) ProtoMessage()    {}
func (*IngestRequest_Collection) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{14, 0}
}
func (m *IngestRequest_Collection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngestRequest_Collection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngestRequest_Collection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngestRequest_Collection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngestRequest_Collection.Merge(m, src)
}
func (m *IngestRequest_Collection) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IngestRequest_Collection) XXX_DiscardUnknown() {
	xxx_messageInfo_IngestRequest_Collection.DiscardUnknown(m)
}

var xxx_messageInfo_IngestRequest_Collection proto.InternalMessageInfo

// IngestResponse is the result of an Ingest RPC.
type IngestResponse struct {
	// Journals appended to by this ingestion, and their maximum offset on commit.
	JournalWriteHeads map[go_gazette_dev_core_broker_protocol.Journal]go_gazette_dev_core_broker_protocol.Offset `protobuf:"bytes,1,rep,name=journal_write_heads,json=journalWriteHeads,proto3,castkey=go.gazette.dev/core/broker/protocol.Journal,castvalue=go.gazette.dev/core/broker/protocol.Offset" json:"journal_write_heads,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Etcd header which describes current journal partitions.
	JournalEtcd          protocol.Header_Etcd `protobuf:"bytes,2,opt,name=journal_etcd,json=journalEtcd,proto3" json:"journal_etcd"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *IngestResponse) Reset()         { *m = IngestResponse{} }
func (m *IngestResponse) String() string { return proto.CompactTextString(m) }
func (*IngestResponse) ProtoMessage()    {}
func (*IngestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{15}
}
func (m *IngestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngestResponse.Merge(m, src)
}
func (m *IngestResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IngestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IngestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IngestResponse proto.InternalMessageInfo

// AdvanceTimeRequest is a testing-only request to modify effective test time.
type AdvanceTimeRequest struct {
	// Number of seconds to add to the current clock delta.
	AddClockDeltaSeconds uint64   `protobuf:"varint,1,opt,name=add_clock_delta_seconds,json=addClockDeltaSeconds,proto3" json:"add_clock_delta_seconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AdvanceTimeRequest) Reset()         { *m = AdvanceTimeRequest{} }
func (m *AdvanceTimeRequest) String() string { return proto.CompactTextString(m) }
func (*AdvanceTimeRequest) ProtoMessage()    {}
func (*AdvanceTimeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{16}
}
func (m *AdvanceTimeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvanceTimeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdvanceTimeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdvanceTimeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvanceTimeRequest.Merge(m, src)
}
func (m *AdvanceTimeRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AdvanceTimeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvanceTimeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdvanceTimeRequest proto.InternalMessageInfo

// AdvanceTimeRequest is a testing-only response to modify effective test time.
type AdvanceTimeResponse struct {
	// Current effective delta from wall-clock time, in seconds.
	ClockDeltaSeconds    uint64   `protobuf:"varint,1,opt,name=clock_delta_seconds,json=clockDeltaSeconds,proto3" json:"clock_delta_seconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AdvanceTimeResponse) Reset()         { *m = AdvanceTimeResponse{} }
func (m *AdvanceTimeResponse) String() string { return proto.CompactTextString(m) }
func (*AdvanceTimeResponse) ProtoMessage()    {}
func (*AdvanceTimeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{17}
}
func (m *AdvanceTimeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvanceTimeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdvanceTimeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdvanceTimeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvanceTimeResponse.Merge(m, src)
}
func (m *AdvanceTimeResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AdvanceTimeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvanceTimeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdvanceTimeResponse proto.InternalMessageInfo

// ClearRegistersRequest is a testing-only request to remove all registers of a shard.
type ClearRegistersRequest struct {
	Header               *protocol.Header                              `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	ShardId              go_gazette_dev_core_consumer_protocol.ShardID `protobuf:"bytes,2,opt,name=shard_id,json=shardId,proto3,casttype=go.gazette.dev/core/consumer/protocol.ShardID" json:"shard_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                      `json:"-"`
	XXX_unrecognized     []byte                                        `json:"-"`
	XXX_sizecache        int32                                         `json:"-"`
}

func (m *ClearRegistersRequest) Reset()         { *m = ClearRegistersRequest{} }
func (m *ClearRegistersRequest) String() string { return proto.CompactTextString(m) }
func (*ClearRegistersRequest) ProtoMessage()    {}
func (*ClearRegistersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{18}
}
func (m *ClearRegistersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearRegistersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearRegistersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearRegistersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearRegistersRequest.Merge(m, src)
}
func (m *ClearRegistersRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ClearRegistersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearRegistersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClearRegistersRequest proto.InternalMessageInfo

// ClearRegistersResponse is a testing-only response to remove all registers of a shard.
type ClearRegistersResponse struct {
	Status               protocol1.Status `protobuf:"varint,1,opt,name=status,proto3,enum=consumer.Status" json:"status,omitempty"`
	Header               protocol.Header  `protobuf:"bytes,2,opt,name=header,proto3" json:"header"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ClearRegistersResponse) Reset()         { *m = ClearRegistersResponse{} }
func (m *ClearRegistersResponse) String() string { return proto.CompactTextString(m) }
func (*ClearRegistersResponse) ProtoMessage()    {}
func (*ClearRegistersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{19}
}
func (m *ClearRegistersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearRegistersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearRegistersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearRegistersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearRegistersResponse.Merge(m, src)
}
func (m *ClearRegistersResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ClearRegistersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearRegistersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClearRegistersResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("flow.Shuffle_Hash", Shuffle_Hash_name, Shuffle_Hash_value)
	proto.RegisterType((*Slice)(nil), "flow.Slice")
	proto.RegisterType((*UUIDParts)(nil), "flow.UUIDParts")
	proto.RegisterType((*Shuffle)(nil), "flow.Shuffle")
	proto.RegisterType((*JournalShuffle)(nil), "flow.JournalShuffle")
	proto.RegisterType((*Projection)(nil), "flow.Projection")
	proto.RegisterType((*Inference)(nil), "flow.Inference")
	proto.RegisterType((*Inference_String)(nil), "flow.Inference.String")
	proto.RegisterType((*CollectionSpec)(nil), "flow.CollectionSpec")
	proto.RegisterType((*TransformSpec)(nil), "flow.TransformSpec")
	proto.RegisterType((*TransformSpec_Source)(nil), "flow.TransformSpec.Source")
	proto.RegisterType((*TransformSpec_Derivation)(nil), "flow.TransformSpec.Derivation")
	proto.RegisterType((*RangeSpec)(nil), "flow.RangeSpec")
	proto.RegisterType((*ShuffleRequest)(nil), "flow.ShuffleRequest")
	proto.RegisterType((*ShuffleResponse)(nil), "flow.ShuffleResponse")
	proto.RegisterType((*ExtractAPI)(nil), "flow.ExtractAPI")
	proto.RegisterType((*ExtractAPI_Config)(nil), "flow.ExtractAPI.Config")
	proto.RegisterType((*CombineAPI)(nil), "flow.CombineAPI")
	proto.RegisterType((*CombineAPI_Config)(nil), "flow.CombineAPI.Config")
	proto.RegisterType((*DeriveAPI)(nil), "flow.DeriveAPI")
	proto.RegisterType((*DeriveAPI_Config)(nil), "flow.DeriveAPI.Config")
	proto.RegisterType((*DeriveAPI_DocHeader)(nil), "flow.DeriveAPI.DocHeader")
	proto.RegisterType((*DeriveAPI_Flush)(nil), "flow.DeriveAPI.Flush")
	proto.RegisterType((*DeriveAPI_Prepare)(nil), "flow.DeriveAPI.Prepare")
	proto.RegisterType((*IngestRequest)(nil), "flow.IngestRequest")
	proto.RegisterType((*IngestRequest_Collection)(nil), "flow.IngestRequest.Collection")
	proto.RegisterType((*IngestResponse)(nil), "flow.IngestResponse")
	proto.RegisterMapType((map[go_gazette_dev_core_broker_protocol.Journal]go_gazette_dev_core_broker_protocol.Offset)(nil), "flow.IngestResponse.JournalWriteHeadsEntry")
	proto.RegisterType((*AdvanceTimeRequest)(nil), "flow.AdvanceTimeRequest")
	proto.RegisterType((*AdvanceTimeResponse)(nil), "flow.AdvanceTimeResponse")
	proto.RegisterType((*ClearRegistersRequest)(nil), "flow.ClearRegistersRequest")
	proto.RegisterType((*ClearRegistersResponse)(nil), "flow.ClearRegistersResponse")
}

func init() { proto.RegisterFile("go/protocols/flow/flow.proto", fileDescriptor_d0677502142fec31) }

var fileDescriptor_d0677502142fec31 = []byte{
	// 2237 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0xcf, 0x6f, 0x1b, 0xc7,
	0xf5, 0xd7, 0x8a, 0x14, 0xc9, 0x7d, 0x14, 0x29, 0x7a, 0x2c, 0x3b, 0x0c, 0x9d, 0x88, 0x32, 0xf3,
	0x8d, 0xa1, 0xc4, 0x5f, 0xaf, 0x1c, 0xc5, 0x29, 0x0c, 0x07, 0x69, 0x6b, 0x8a, 0x34, 0xa2, 0xd8,
	0x4e, 0xd8, 0x95, 0x8c, 0x06, 0x05, 0x8a, 0xc5, 0x68, 0x77, 0x48, 0xae, 0xb9, 0xdc, 0x61, 0x67,
	0x86, 0x8a, 0xd9, 0x4b, 0xd1, 0x02, 0x05, 0x8a, 0x5e, 0xda, 0x53, 0x51, 0xf4, 0x94, 0x06, 0xbd,
	0xf4, 0xd8, 0x63, 0x8b, 0xfe, 0x01, 0x3e, 0x1a, 0x68, 0x81, 0xf6, 0xa4, 0xa0, 0x29, 0x50, 0xf4,
	0xd6, 0x6b, 0xa1, 0x53, 0x31, 0x3f, 0x76, 0xf9, 0xc3, 0x72, 0x6c, 0xeb, 0x42, 0xec, 0xbc, 0xf7,
	0xe6, 0xcd, 0xfb, 0x35, 0xef, 0xf3, 0x86, 0xf0, 0x5a, 0x8f, 0x6e, 0x8f, 0x18, 0x15, 0xd4, 0xa7,
	0x11, 0xdf, 0xee, 0x46, 0xf4, 0x33, 0xf5, 0xe3, 0x28, 0x1a, 0xca, 0xca, 0xef, 0xda, 0xc6, 0x21,
	0xa3, 0x03, 0xc2, 0x52, 0xb9, 0xf4, 0x43, 0x4b, 0xd5, 0x36, 0x7d, 0x1a, 0xf3, 0xf1, 0xf0, 0x6b,
	0x24, 0xae, 0xa4, 0x12, 0x8c, 0xf8, 0xf4, 0x88, 0xb0, 0x49, 0x44, 0x7b, 0xea, 0x9b, 0x05, 0x24,
	0xf0, 0xe8, 0xc8, 0xc8, 0x55, 0x47, 0x62, 0x32, 0x22, 0x7c, 0x9b, 0x0c, 0x47, 0x62, 0xa2, 0x7f,
	0x0d, 0x67, 0xbd, 0x47, 0x7b, 0x54, 0x7d, 0x6e, 0xcb, 0x2f, 0x4d, 0x6d, 0x7c, 0x00, 0x2b, 0xfb,
	0x51, 0xe8, 0x13, 0xb4, 0x0e, 0x2b, 0x87, 0xa4, 0x17, 0xc6, 0x55, 0x6b, 0xd3, 0xda, 0x2a, 0xb9,
	0x7a, 0x81, 0x2a, 0x90, 0x21, 0x71, 0x50, 0x5d, 0x56, 0x34, 0xf9, 0x79, 0x6b, 0xf5, 0xc9, 0x6f,
	0xeb, 0x4b, 0xbf, 0xfc, 0xa2, 0xbe, 0xf4, 0xeb, 0x2f, 0xea, 0x4b, 0x8d, 0x9f, 0x59, 0x60, 0x3f,
	0x78, 0xb0, 0xd7, 0xea, 0x60, 0x26, 0x38, 0xfa, 0x7f, 0x40, 0x23, 0x46, 0x83, 0xb1, 0x4f, 0x98,
	0x87, 0xe3, 0xc0, 0xeb, 0x46, 0xb8, 0xc7, 0x95, 0xc2, 0x9c, 0x5b, 0x49, 0x38, 0xb7, 0xe3, 0xe0,
	0x8e, 0xa4, 0xa3, 0xf7, 0x61, 0xc5, 0x8f, 0xa8, 0x3f, 0x50, 0xda, 0x73, 0xcd, 0x37, 0x4f, 0x8e,
	0xeb, 0x97, 0x7b, 0xd4, 0xe9, 0xe1, 0x1f, 0x12, 0x21, 0x88, 0x13, 0x90, 0xa3, 0x6d, 0x9f, 0x32,
	0xb2, 0x3d, 0x24, 0x9c, 0xe3, 0x1e, 0x71, 0x76, 0xa5, 0xb0, 0xab, 0xf7, 0xdc, 0xaa, 0xfc, 0xfb,
	0xf3, 0xba, 0x35, 0x67, 0xca, 0x7f, 0x2d, 0xc8, 0xef, 0xf7, 0xc7, 0xdd, 0x6e, 0x44, 0xd0, 0x15,
	0x58, 0xe3, 0xfa, 0xd3, 0x1b, 0x90, 0x89, 0x37, 0x12, 0xac, 0x6a, 0x6d, 0x66, 0xb6, 0x6c, 0xb7,
	0x64, 0xc8, 0x77, 0xc9, 0xa4, 0x23, 0x98, 0x94, 0x1b, 0x73, 0xc2, 0x3d, 0x4e, 0xc7, 0xcc, 0x57,
	0xb2, 0xca, 0x98, 0x82, 0x5b, 0x92, 0xe4, 0x7d, 0x45, 0xbd, 0x4b, 0x26, 0x52, 0xae, 0x1b, 0x46,
	0x82, 0x30, 0x8f, 0x79, 0xea, 0x7c, 0x5e, 0xcd, 0x68, 0x39, 0x4d, 0x76, 0x95, 0x6d, 0x1c, 0x5d,
	0x81, 0x6c, 0x1f, 0xf3, 0x7e, 0x35, 0xbb, 0x69, 0x6d, 0x95, 0x77, 0x90, 0xa3, 0x0a, 0xc1, 0x18,
	0xe5, 0x7c, 0x88, 0x79, 0xdf, 0x55, 0x7c, 0x19, 0x28, 0x46, 0x70, 0xe0, 0x05, 0x24, 0xc2, 0x13,
	0x8f, 0x13, 0x9f, 0xc6, 0x01, 0xaf, 0xae, 0xa8, 0x28, 0x57, 0x24, 0xa7, 0x25, 0x19, 0xfb, 0x9a,
	0xde, 0x78, 0x15, 0xb2, 0x72, 0x2f, 0x2a, 0x40, 0xf6, 0xe3, 0x4f, 0x3e, 0x6e, 0x57, 0x96, 0x50,
	0x1e, 0x32, 0xf7, 0x5b, 0xef, 0x55, 0xac, 0x5b, 0x59, 0x19, 0x86, 0xc6, 0x8f, 0x97, 0xa1, 0xfc,
	0x11, 0x1d, 0xb3, 0x18, 0x47, 0x49, 0x04, 0xf6, 0x20, 0xff, 0x50, 0x53, 0x54, 0xfc, 0xed, 0xe6,
	0xf6, 0xc9, 0x71, 0xfd, 0xea, 0x69, 0xe1, 0x5d, 0x28, 0x4d, 0xc7, 0x28, 0x72, 0x93, 0xfd, 0x68,
	0x1f, 0x8a, 0x3e, 0xa5, 0x2c, 0x08, 0x63, 0x2c, 0x28, 0x53, 0x01, 0xb2, 0x9b, 0xef, 0x9c, 0x1c,
	0xd7, 0xaf, 0x9d, 0xa6, 0xee, 0xa9, 0x4a, 0x76, 0xf6, 0xfb, 0x98, 0x05, 0x7b, 0x2d, 0x77, 0x56,
	0x0b, 0x7a, 0x07, 0xf2, 0x26, 0x15, 0x2a, 0x92, 0xc5, 0x9d, 0xd2, 0x5c, 0xb0, 0x9a, 0x85, 0xc7,
	0xc7, 0xf5, 0xa5, 0x27, 0xc7, 0x75, 0xcb, 0x4d, 0xe4, 0xd0, 0x45, 0xc8, 0x31, 0x32, 0x8a, 0xf0,
	0x44, 0x85, 0xb7, 0xe0, 0x9a, 0x95, 0x89, 0xc1, 0xdf, 0x2d, 0x80, 0x0e, 0xa3, 0x0f, 0x89, 0x2f,
	0x42, 0xaa, 0x0a, 0x57, 0x67, 0xdd, 0xda, 0xb2, 0x5d, 0xf9, 0x29, 0x0b, 0xbc, 0x1b, 0x92, 0x48,
	0x17, 0xb3, 0xed, 0xea, 0x05, 0x7a, 0x03, 0x64, 0xaa, 0x99, 0x37, 0x62, 0xf4, 0x28, 0x0c, 0x48,
	0x60, 0xf2, 0xba, 0x2a, 0x89, 0x1d, 0x43, 0x43, 0x5b, 0x50, 0x09, 0xb9, 0x37, 0xc2, 0x4c, 0x84,
	0x52, 0xb9, 0xaa, 0x13, 0x6d, 0x43, 0x39, 0xe4, 0x9d, 0x84, 0x2c, 0x0b, 0xe5, 0xff, 0xa0, 0x2c,
	0x25, 0x59, 0x38, 0xc4, 0x6c, 0xa2, 0xe4, 0x56, 0xb4, 0xbe, 0x90, 0x77, 0x34, 0x51, 0x4a, 0x5d,
	0x03, 0x3b, 0x8c, 0xbb, 0x84, 0x91, 0xd8, 0x27, 0xd5, 0x9c, 0x72, 0x7f, 0x4d, 0xbb, 0xbf, 0x97,
	0x90, 0xdd, 0xa9, 0x44, 0xe3, 0xf7, 0xcb, 0x60, 0xa7, 0x0c, 0xe9, 0x87, 0xba, 0xe2, 0xa6, 0xa2,
	0xf5, 0x02, 0xbd, 0x0e, 0x30, 0x1c, 0x73, 0xe1, 0x91, 0x47, 0x21, 0x17, 0xa6, 0x88, 0x6d, 0x49,
	0x69, 0x4b, 0x02, 0x72, 0x20, 0xc7, 0x05, 0x0b, 0xe3, 0x9e, 0x89, 0xf6, 0xc5, 0x85, 0xe3, 0x9c,
	0x7d, 0xc5, 0x75, 0x8d, 0x94, 0x3a, 0x24, 0x14, 0x11, 0x51, 0x6e, 0xca, 0x43, 0xe4, 0x02, 0x6d,
	0x42, 0x31, 0x20, 0xdc, 0x67, 0xe1, 0x48, 0xfa, 0xab, 0x5c, 0xb3, 0xdd, 0x59, 0x52, 0xed, 0x47,
	0x90, 0xd3, 0x9a, 0xd0, 0x65, 0x58, 0xf5, 0x69, 0x2c, 0x48, 0x2c, 0x3c, 0x69, 0xa1, 0x3a, 0xd7,
	0x96, 0x35, 0xa0, 0x68, 0x07, 0x93, 0x91, 0x4a, 0x68, 0x97, 0xb2, 0x21, 0x16, 0xe6, 0x14, 0xb3,
	0x42, 0x97, 0xc0, 0x0e, 0xb9, 0x77, 0x88, 0x39, 0xf9, 0xc6, 0x0d, 0x13, 0xbf, 0x42, 0xc8, 0x9b,
	0x6a, 0xad, 0x1c, 0xc5, 0x8f, 0xbc, 0x88, 0xc4, 0x3d, 0xd1, 0x57, 0xc1, 0x2b, 0xb9, 0xf6, 0x10,
	0x3f, 0xba, 0xa7, 0x08, 0x8d, 0xbf, 0x2e, 0x43, 0x79, 0x97, 0x46, 0x91, 0x2e, 0x83, 0xfd, 0x11,
	0xf1, 0x51, 0x03, 0xb2, 0x31, 0x1e, 0x12, 0x73, 0x0f, 0xca, 0x27, 0xc7, 0x75, 0x98, 0x4a, 0xb8,
	0x8a, 0x27, 0xb5, 0x72, 0xbf, 0x4f, 0x86, 0xd8, 0x1b, 0xb3, 0xd0, 0x54, 0x88, 0xad, 0x29, 0x0f,
	0x58, 0x88, 0x5e, 0x85, 0x82, 0xe9, 0x23, 0xf2, 0xe2, 0xcb, 0xb0, 0xe7, 0x07, 0xaa, 0x83, 0x70,
	0xc9, 0x1a, 0x8f, 0xc3, 0x40, 0xf5, 0x18, 0xed, 0x46, 0x5e, 0xae, 0x65, 0x77, 0x79, 0x0b, 0x2a,
	0xd3, 0x9a, 0x51, 0xe5, 0x26, 0xef, 0xb8, 0xdc, 0xbd, 0x96, 0xd2, 0xef, 0x28, 0x32, 0xda, 0x81,
	0xe2, 0x28, 0x2d, 0x5e, 0x5e, 0xcd, 0x6d, 0x66, 0xb6, 0x8a, 0x3b, 0x15, 0x9d, 0xa4, 0x69, 0x55,
	0xbb, 0xb3, 0x42, 0xe8, 0x9b, 0xb0, 0x6a, 0xae, 0xa8, 0xc7, 0x47, 0xc4, 0xaf, 0xe6, 0x55, 0x66,
	0x2f, 0x38, 0x8b, 0x37, 0x59, 0x06, 0xa1, 0x99, 0x95, 0xf7, 0xc9, 0x2d, 0x3e, 0x9c, 0x92, 0xd0,
	0xdb, 0x70, 0x0e, 0xfb, 0x03, 0xef, 0x21, 0xa7, 0xb1, 0x27, 0xc8, 0x70, 0x14, 0x61, 0x41, 0xaa,
	0x85, 0x4d, 0x6b, 0x6b, 0xd5, 0x5d, 0xc3, 0xfe, 0xe0, 0x23, 0x4e, 0xe3, 0x03, 0x43, 0x6e, 0xfc,
	0x2e, 0x03, 0xa5, 0x03, 0x86, 0x63, 0x2e, 0x53, 0xa4, 0x76, 0x5f, 0x9e, 0x8b, 0x6a, 0xe9, 0xe4,
	0xb8, 0x6e, 0xa7, 0x02, 0x26, 0xa8, 0x0d, 0x28, 0xf9, 0x58, 0xe0, 0x88, 0xf6, 0xbc, 0xe0, 0xd0,
	0x0b, 0xf5, 0xcd, 0x5b, 0x71, 0x8b, 0x86, 0xd8, 0x3a, 0xdc, 0x0b, 0xd0, 0x4d, 0xc8, 0xe9, 0xe6,
	0x6b, 0x0a, 0xb3, 0xa6, 0x7d, 0x9e, 0x3b, 0xcb, 0xd1, 0x8d, 0xd8, 0xf8, 0x60, 0xe4, 0xd1, 0xb5,
	0x69, 0x07, 0xc9, 0x9e, 0xd6, 0x41, 0xb4, 0x74, 0xda, 0x3d, 0x5a, 0x00, 0x01, 0x61, 0xe1, 0x11,
	0x4e, 0x4b, 0xb7, 0xb8, 0xb3, 0x71, 0xda, 0x61, 0xad, 0x54, 0xca, 0xa8, 0x98, 0xd9, 0x57, 0x1b,
	0x40, 0x4e, 0x1b, 0xf3, 0x42, 0x55, 0xf5, 0x01, 0x40, 0x9a, 0x68, 0xae, 0xbc, 0x2f, 0xee, 0xbc,
	0x32, 0xcd, 0xcf, 0x3d, 0x7c, 0x48, 0xa2, 0x7d, 0x22, 0xf7, 0x50, 0x96, 0x1c, 0x36, 0xdd, 0x50,
	0xbb, 0x0e, 0x30, 0x35, 0xe6, 0x45, 0x0e, 0x6c, 0xfc, 0xd4, 0x02, 0xdb, 0xc5, 0x71, 0x8f, 0xa8,
	0x14, 0x5d, 0x02, 0x5b, 0x56, 0xad, 0x86, 0xf5, 0x65, 0x95, 0x58, 0x59, 0xc6, 0x4d, 0x85, 0xec,
	0xaf, 0x80, 0x2c, 0x61, 0x4f, 0xa2, 0x7b, 0x46, 0xb1, 0x72, 0x03, 0x32, 0x69, 0xc7, 0x81, 0xcc,
	0x9a, 0x01, 0x39, 0xb3, 0x53, 0x46, 0x37, 0xeb, 0x16, 0x99, 0xc2, 0x38, 0xbd, 0x79, 0x03, 0x8a,
	0x89, 0x8c, 0x54, 0xb0, 0xa2, 0x24, 0x6c, 0x2d, 0xd1, 0x8e, 0x83, 0xc6, 0x9f, 0x97, 0xa1, 0x6c,
	0xf2, 0xe0, 0x92, 0x1f, 0x8c, 0x09, 0x17, 0xe8, 0xc6, 0x34, 0x5d, 0x96, 0x0a, 0xc4, 0xba, 0x0e,
	0xfe, 0x3c, 0x6e, 0x2d, 0x66, 0xed, 0x2a, 0xac, 0x30, 0xe9, 0x8f, 0x09, 0x9e, 0xe9, 0x92, 0xa9,
	0x8b, 0x46, 0x5c, 0xcb, 0xa0, 0x3b, 0x90, 0xa3, 0xdd, 0x2e, 0x27, 0x42, 0x79, 0x94, 0x69, 0x3a,
	0x27, 0xc7, 0xf5, 0xb7, 0x5f, 0x04, 0xf2, 0x3e, 0x51, 0xbb, 0x5c, 0xb3, 0x1b, 0xdd, 0x07, 0x20,
	0x71, 0xe0, 0x19, 0x5d, 0xd9, 0x33, 0xe9, 0xb2, 0x49, 0x1c, 0xe8, 0x4f, 0x74, 0x1d, 0x80, 0x11,
	0x4e, 0xa3, 0xf1, 0x4c, 0xe5, 0x55, 0xa6, 0x55, 0xf0, 0x21, 0xc1, 0x01, 0x61, 0xee, 0x8c, 0x4c,
	0xe3, 0x3f, 0x59, 0x58, 0x4b, 0xc3, 0xc7, 0x47, 0x34, 0xe6, 0x04, 0x6d, 0xc9, 0x0e, 0x8e, 0xc5,
	0x58, 0xcf, 0x53, 0xe5, 0x9d, 0x8a, 0x93, 0x20, 0xad, 0xb3, 0xaf, 0xe8, 0xae, 0xe1, 0x4b, 0xc9,
	0xbe, 0xd2, 0x69, 0x82, 0xf6, 0xf4, 0x59, 0x86, 0x8f, 0xde, 0x84, 0xb2, 0x20, 0x6c, 0x18, 0xca,
	0x16, 0x42, 0x18, 0xa3, 0xcc, 0x74, 0xe9, 0x52, 0x42, 0x6d, 0x4b, 0x22, 0xfa, 0x0e, 0xac, 0xaa,
	0x69, 0x45, 0xf4, 0x19, 0x1d, 0xf7, 0xfa, 0x67, 0x8c, 0x48, 0x51, 0xea, 0x38, 0xd0, 0x2a, 0x64,
	0x88, 0x3f, 0x63, 0xa1, 0x20, 0x9e, 0xb4, 0x44, 0xc5, 0xe4, 0x0c, 0x21, 0x56, 0x1a, 0xa4, 0x4b,
	0xa8, 0x0e, 0x2b, 0x98, 0x91, 0x18, 0x2b, 0x3c, 0x58, 0x6d, 0xda, 0x27, 0xc7, 0xf5, 0x95, 0xdb,
	0x92, 0xe0, 0x6a, 0x3a, 0x72, 0xc0, 0x0e, 0xa8, 0xcf, 0x55, 0xb3, 0xab, 0xe6, 0x55, 0x77, 0x2d,
	0x9a, 0x76, 0x21, 0xa7, 0x5f, 0x53, 0x47, 0x05, 0x29, 0x23, 0xfb, 0x1e, 0x6a, 0x25, 0xd3, 0x70,
	0x61, 0x33, 0x73, 0x06, 0xd3, 0xcc, 0xf4, 0xfc, 0x6d, 0x3d, 0x3d, 0xdb, 0x67, 0xd2, 0x21, 0xb7,
	0xa2, 0x1b, 0x00, 0x1a, 0x5d, 0xe4, 0x7c, 0x5d, 0x05, 0x65, 0xb8, 0xb9, 0x04, 0xe9, 0xd8, 0x6d,
	0x8c, 0xb7, 0x15, 0xec, 0xa8, 0x39, 0xfc, 0xba, 0xec, 0x3b, 0xfe, 0x80, 0x04, 0x6a, 0x02, 0x29,
	0x3e, 0xcb, 0x5d, 0x5b, 0x0b, 0xdd, 0x25, 0x93, 0x46, 0x07, 0xa0, 0xfd, 0x48, 0x30, 0xec, 0x8b,
	0xdb, 0x9d, 0xbd, 0x5a, 0x13, 0x72, 0xbb, 0x34, 0xee, 0x86, 0xbd, 0x39, 0x74, 0xb3, 0xe6, 0xd1,
	0xed, 0x75, 0x00, 0x85, 0x69, 0x1a, 0x15, 0x97, 0x15, 0xae, 0xd9, 0x8a, 0x22, 0x71, 0xb1, 0xf1,
	0x2f, 0x0b, 0x60, 0x97, 0x0e, 0x0f, 0xc3, 0x98, 0x48, 0x95, 0x7f, 0xb3, 0x52, 0x9d, 0x0e, 0x9c,
	0x37, 0x58, 0x1b, 0xc6, 0x01, 0x79, 0xe4, 0x0d, 0xe5, 0x2b, 0x85, 0x99, 0x67, 0xc2, 0x39, 0xcd,
	0xda, 0x93, 0x9c, 0xfb, 0x8a, 0xf1, 0x3c, 0x6c, 0x36, 0x8d, 0x4c, 0xaa, 0xd0, 0xd0, 0x9c, 0xd3,
	0xd0, 0xbc, 0x60, 0x60, 0x76, 0xc1, 0x40, 0x74, 0x1d, 0xd6, 0xb5, 0x6b, 0x11, 0xf6, 0x49, 0x9f,
	0x46, 0x81, 0x9c, 0x02, 0x05, 0x33, 0x53, 0x0d, 0x52, 0x6e, 0x4e, 0x59, 0x1d, 0x3d, 0x41, 0x8e,
	0xd8, 0x38, 0xd6, 0x23, 0x5b, 0xc1, 0xd5, 0x8b, 0xc6, 0x1f, 0x33, 0x60, 0xab, 0x36, 0xad, 0xfc,
	0xfc, 0xd5, 0xd4, 0x4f, 0x39, 0x01, 0x19, 0xf8, 0x1b, 0x61, 0xd1, 0x37, 0xf1, 0x4b, 0xd0, 0xaf,
	0x83, 0x45, 0x1f, 0x6d, 0xcc, 0x81, 0x92, 0x76, 0x6d, 0x86, 0x22, 0x3b, 0x78, 0x44, 0x7d, 0x1c,
	0x79, 0x41, 0x98, 0xdc, 0xcd, 0x82, 0x22, 0xb4, 0x42, 0xa6, 0x1e, 0x11, 0xf2, 0xd5, 0x11, 0x1c,
	0x7a, 0x24, 0x3e, 0x4a, 0xc2, 0x98, 0xd5, 0xaf, 0x2d, 0xc3, 0x69, 0xc7, 0x47, 0x3a, 0x8a, 0x35,
	0x06, 0x76, 0x8b, 0xfa, 0xba, 0x01, 0xa0, 0x37, 0x20, 0x2b, 0xfd, 0x33, 0x9d, 0x78, 0xb1, 0xa0,
	0x5c, 0xc5, 0x94, 0xf1, 0x9b, 0xa9, 0x22, 0x8d, 0x1f, 0xd3, 0x92, 0x91, 0xee, 0x89, 0x04, 0x38,
	0x25, 0xb8, 0x67, 0x34, 0xb8, 0xa7, 0xb4, 0xbd, 0xa0, 0xf6, 0x29, 0xac, 0xdc, 0x89, 0xc6, 0xbc,
	0xff, 0xcc, 0x58, 0x5b, 0xcf, 0x8c, 0xf5, 0xd7, 0x57, 0x57, 0xad, 0x0d, 0xf9, 0x0e, 0x23, 0x23,
	0xcc, 0x08, 0xba, 0x05, 0xe0, 0xf7, 0x89, 0x3f, 0x18, 0xd1, 0x30, 0x16, 0x29, 0xb6, 0xa4, 0xcd,
	0x71, 0x37, 0xe5, 0x25, 0x08, 0x3b, 0x95, 0x6e, 0xfc, 0xc1, 0x82, 0xd2, 0x5e, 0xdc, 0x23, 0x5c,
	0x24, 0x30, 0x75, 0x47, 0x3e, 0x76, 0x12, 0x54, 0xd5, 0x33, 0x76, 0x3a, 0x27, 0xcc, 0x49, 0x3a,
	0x53, 0xf0, 0x4d, 0x86, 0xab, 0x99, 0x8d, 0xb5, 0x4f, 0x61, 0x06, 0x9d, 0x5f, 0x68, 0x58, 0xb8,
	0x02, 0x6b, 0x69, 0x8b, 0xf2, 0xa2, 0x30, 0x26, 0xdc, 0xc4, 0xbc, 0x94, 0x74, 0xa5, 0x7b, 0x92,
	0xd8, 0xf8, 0xcb, 0x32, 0x94, 0x13, 0x4b, 0x0c, 0x36, 0xfc, 0xc9, 0x82, 0xf3, 0xc9, 0x28, 0x38,
	0x6d, 0xab, 0x89, 0xf5, 0x57, 0xe7, 0xad, 0xd7, 0x7b, 0x12, 0xdc, 0xfd, 0x6e, 0xd2, 0x43, 0x79,
	0x3b, 0x16, 0x6c, 0xd2, 0xfc, 0xfe, 0x4f, 0xbe, 0x7c, 0xa9, 0x67, 0xe2, 0xcf, 0xbf, 0x7c, 0xa9,
	0xa6, 0x76, 0xee, 0xe1, 0xe2, 0xb1, 0xb3, 0x63, 0x2c, 0x11, 0x7e, 0x60, 0x40, 0xeb, 0xc2, 0x22,
	0x68, 0x39, 0x6d, 0xe1, 0x07, 0x0b, 0x63, 0xac, 0x24, 0xd5, 0x5a, 0x70, 0xf1, 0x74, 0x5f, 0xe4,
	0x1b, 0x50, 0x56, 0xae, 0x79, 0x03, 0x0e, 0xc8, 0x44, 0xde, 0xe0, 0x23, 0x1c, 0x8d, 0xf5, 0x38,
	0x91, 0x71, 0xf5, 0xe2, 0xd6, 0xf2, 0x4d, 0xab, 0x71, 0x17, 0xd0, 0xed, 0xe0, 0x08, 0xc7, 0x3e,
	0x39, 0x08, 0x87, 0xe9, 0xd0, 0xf2, 0x1e, 0xbc, 0x82, 0x83, 0xc0, 0x4c, 0x3a, 0x01, 0x89, 0x04,
	0x4e, 0x1f, 0xeb, 0x96, 0x9a, 0x79, 0xd6, 0x71, 0x10, 0xa8, 0xa9, 0xa7, 0x25, 0x99, 0xc9, 0x83,
	0xbd, 0x0d, 0xe7, 0xe7, 0x94, 0x99, 0x34, 0x39, 0x70, 0xfe, 0xd9, 0x9a, 0xce, 0xf9, 0x4f, 0xa9,
	0xf9, 0x85, 0x05, 0x17, 0x76, 0x23, 0x82, 0x99, 0x4b, 0x7a, 0x21, 0x17, 0x84, 0xf1, 0xc4, 0xae,
	0x29, 0xc4, 0x5b, 0xcf, 0x81, 0xf8, 0x7b, 0x50, 0xe0, 0xf2, 0xfd, 0x9d, 0x8c, 0xdf, 0x67, 0x7a,
	0xb9, 0xe7, 0x95, 0x8a, 0xbd, 0xa0, 0xc1, 0xe0, 0xe2, 0xa2, 0x41, 0x2f, 0x3d, 0x9e, 0x38, 0xcf,
	0x1b, 0x4f, 0x92, 0x39, 0x5f, 0x4b, 0xed, 0xb4, 0xa0, 0x60, 0x66, 0x21, 0x86, 0x6e, 0x4e, 0xff,
	0xe2, 0x59, 0x9f, 0x9b, 0xf6, 0x4d, 0x60, 0x6a, 0x17, 0x16, 0xa8, 0xda, 0xba, 0xeb, 0xd6, 0xce,
	0xb7, 0xa0, 0xa0, 0x2f, 0x00, 0x61, 0xe8, 0x5d, 0xc8, 0xe9, 0x6f, 0x74, 0xfe, 0x94, 0x8b, 0x5d,
	0x5b, 0x3f, 0xed, 0xbe, 0xec, 0xfc, 0xc6, 0x82, 0xfc, 0x01, 0xe1, 0x42, 0xbe, 0x6d, 0x9b, 0x50,
	0x9c, 0xc9, 0x2f, 0xaa, 0xea, 0x0d, 0x4f, 0xd7, 0x4f, 0xed, 0xd5, 0x53, 0x38, 0x26, 0x60, 0x77,
	0xa1, 0x3c, 0x1f, 0x4a, 0x74, 0x49, 0x0b, 0x9f, 0x9a, 0xf1, 0xda, 0x6b, 0xa7, 0x33, 0xb5, 0xb2,
	0xe6, 0xfb, 0x8f, 0xff, 0xb1, 0xb1, 0xf4, 0xf8, 0xab, 0x0d, 0xeb, 0xc9, 0x57, 0x1b, 0xd6, 0xe7,
	0xff, 0xdc, 0xb0, 0xbe, 0xf7, 0x56, 0x2f, 0x14, 0xfd, 0xf1, 0xa1, 0xe3, 0xd3, 0xe1, 0x36, 0xe1,
	0x62, 0x8c, 0xd9, 0x44, 0xff, 0x37, 0xf9, 0xd4, 0xbf, 0x95, 0x87, 0x39, 0xb5, 0x7e, 0xf7, 0x7f,
	0x01, 0x00, 0x00, 0xff, 0xff, 0x62, 0xa3, 0x55, 0xf5, 0xc9, 0x14, 0x00, 0x00,
}

func (this *UUIDParts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UUIDParts)
	if !ok {
		that2, ok := that.(UUIDParts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProducerAndFlags != that1.ProducerAndFlags {
		return false
	}
	if this.Clock != that1.Clock {
		return false
	}
	return true
}
func (this *Shuffle) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Shuffle)
	if !ok {
		that2, ok := that.(Shuffle)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ShuffleKeyPtr) != len(that1.ShuffleKeyPtr) {
		return false
	}
	for i := range this.ShuffleKeyPtr {
		if this.ShuffleKeyPtr[i] != that1.ShuffleKeyPtr[i] {
			return false
		}
	}
	if this.UsesSourceKey != that1.UsesSourceKey {
		return false
	}
	if this.FilterRClocks != that1.FilterRClocks {
		return false
	}
	if this.Hash != that1.Hash {
		return false
	}
	if this.ReadDelaySeconds != that1.ReadDelaySeconds {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *JournalShuffle) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JournalShuffle)
	if !ok {
		that2, ok := that.(JournalShuffle)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Journal != that1.Journal {
		return false
	}
	if this.Coordinator != that1.Coordinator {
		return false
	}
	if !this.Shuffle.Equal(&that1.Shuffle) {
		return false
	}
	if this.Replay != that1.Replay {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ShufflerClient is the client API for Shuffler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ShufflerClient interface {
	Shuffle(ctx context.Context, in *ShuffleRequest, opts ...grpc.CallOption) (Shuffler_ShuffleClient, error)
}

type shufflerClient struct {
	cc *grpc.ClientConn
}

func NewShufflerClient(cc *grpc.ClientConn) ShufflerClient {
	return &shufflerClient{cc}
}

func (c *shufflerClient) Shuffle(ctx context.Context, in *ShuffleRequest, opts ...grpc.CallOption) (Shuffler_ShuffleClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Shuffler_serviceDesc.Streams[0], "/flow.Shuffler/Shuffle", opts...)
	if err != nil {
		return nil, err
	}
	x := &shufflerShuffleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Shuffler_ShuffleClient interface {
	Recv() (*ShuffleResponse, error)
	grpc.ClientStream
}

type shufflerShuffleClient struct {
	grpc.ClientStream
}

func (x *shufflerShuffleClient) Recv() (*ShuffleResponse, error) {
	m := new(ShuffleResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ShufflerServer is the server API for Shuffler service.
type ShufflerServer interface {
	Shuffle(*ShuffleRequest, Shuffler_ShuffleServer) error
}

// UnimplementedShufflerServer can be embedded to have forward compatible implementations.
type UnimplementedShufflerServer struct {
}

func (*UnimplementedShufflerServer) Shuffle(req *ShuffleRequest, srv Shuffler_ShuffleServer) error {
	return status.Errorf(codes.Unimplemented, "method Shuffle not implemented")
}

func RegisterShufflerServer(s *grpc.Server, srv ShufflerServer) {
	s.RegisterService(&_Shuffler_serviceDesc, srv)
}

func _Shuffler_Shuffle_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ShuffleRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ShufflerServer).Shuffle(m, &shufflerShuffleServer{stream})
}

type Shuffler_ShuffleServer interface {
	Send(*ShuffleResponse) error
	grpc.ServerStream
}

type shufflerShuffleServer struct {
	grpc.ServerStream
}

func (x *shufflerShuffleServer) Send(m *ShuffleResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Shuffler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "flow.Shuffler",
	HandlerType: (*ShufflerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Shuffle",
			Handler:       _Shuffler_Shuffle_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "go/protocols/flow/flow.proto",
}

// IngesterClient is the client API for Ingester service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IngesterClient interface {
	Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error)
}

type ingesterClient struct {
	cc *grpc.ClientConn
}

func NewIngesterClient(cc *grpc.ClientConn) IngesterClient {
	return &ingesterClient{cc}
}

func (c *ingesterClient) Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error) {
	out := new(IngestResponse)
	err := c.cc.Invoke(ctx, "/flow.Ingester/Ingest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IngesterServer is the server API for Ingester service.
type IngesterServer interface {
	Ingest(context.Context, *IngestRequest) (*IngestResponse, error)
}

// UnimplementedIngesterServer can be embedded to have forward compatible implementations.
type UnimplementedIngesterServer struct {
}

func (*UnimplementedIngesterServer) Ingest(ctx context.Context, req *IngestRequest) (*IngestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ingest not implemented")
}

func RegisterIngesterServer(s *grpc.Server, srv IngesterServer) {
	s.RegisterService(&_Ingester_serviceDesc, srv)
}

func _Ingester_Ingest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IngesterServer).Ingest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.Ingester/Ingest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IngesterServer).Ingest(ctx, req.(*IngestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Ingester_serviceDesc = grpc.ServiceDesc{
	ServiceName: "flow.Ingester",
	HandlerType: (*IngesterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ingest",
			Handler:    _Ingester_Ingest_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/protocols/flow/flow.proto",
}

// TestingClient is the client API for Testing service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TestingClient interface {
	AdvanceTime(ctx context.Context, in *AdvanceTimeRequest, opts ...grpc.CallOption) (*AdvanceTimeResponse, error)
	ClearRegisters(ctx context.Context, in *ClearRegistersRequest, opts ...grpc.CallOption) (*ClearRegistersResponse, error)
}

type testingClient struct {
	cc *grpc.ClientConn
}

func NewTestingClient(cc *grpc.ClientConn) TestingClient {
	return &testingClient{cc}
}

func (c *testingClient) AdvanceTime(ctx context.Context, in *AdvanceTimeRequest, opts ...grpc.CallOption) (*AdvanceTimeResponse, error) {
	out := new(AdvanceTimeResponse)
	err := c.cc.Invoke(ctx, "/flow.Testing/AdvanceTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testingClient) ClearRegisters(ctx context.Context, in *ClearRegistersRequest, opts ...grpc.CallOption) (*ClearRegistersResponse, error) {
	out := new(ClearRegistersResponse)
	err := c.cc.Invoke(ctx, "/flow.Testing/ClearRegisters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TestingServer is the server API for Testing service.
type TestingServer interface {
	AdvanceTime(context.Context, *AdvanceTimeRequest) (*AdvanceTimeResponse, error)
	ClearRegisters(context.Context, *ClearRegistersRequest) (*ClearRegistersResponse, error)
}

// UnimplementedTestingServer can be embedded to have forward compatible implementations.
type UnimplementedTestingServer struct {
}

func (*UnimplementedTestingServer) AdvanceTime(ctx context.Context, req *AdvanceTimeRequest) (*AdvanceTimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdvanceTime not implemented")
}
func (*UnimplementedTestingServer) ClearRegisters(ctx context.Context, req *ClearRegistersRequest) (*ClearRegistersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearRegisters not implemented")
}

func RegisterTestingServer(s *grpc.Server, srv TestingServer) {
	s.RegisterService(&_Testing_serviceDesc, srv)
}

func _Testing_AdvanceTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdvanceTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestingServer).AdvanceTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.Testing/AdvanceTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestingServer).AdvanceTime(ctx, req.(*AdvanceTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Testing_ClearRegisters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearRegistersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestingServer).ClearRegisters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.Testing/ClearRegisters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestingServer).ClearRegisters(ctx, req.(*ClearRegistersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Testing_serviceDesc = grpc.ServiceDesc{
	ServiceName: "flow.Testing",
	HandlerType: (*TestingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AdvanceTime",
			Handler:    _Testing_AdvanceTime_Handler,
		},
		{
			MethodName: "ClearRegisters",
			Handler:    _Testing_ClearRegisters_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/protocols/flow/flow.proto",
}

func (m *Slice) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Slice) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Slice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Begin != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Begin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UUIDParts) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UUIDParts) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UUIDParts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Clock != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Clock))
		i--
		dAtA[i] = 0x11
	}
	if m.ProducerAndFlags != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ProducerAndFlags))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Shuffle) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shuffle) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Shuffle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReadDelaySeconds != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ReadDelaySeconds))
		i--
		dAtA[i] = 0x28
	}
	if m.Hash != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Hash))
		i--
		dAtA[i] = 0x20
	}
	if m.FilterRClocks {
		i--
		if m.FilterRClocks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.UsesSourceKey {
		i--
		if m.UsesSourceKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ShuffleKeyPtr) > 0 {
		for iNdEx := len(m.ShuffleKeyPtr) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ShuffleKeyPtr[iNdEx])
			copy(dAtA[i:], m.ShuffleKeyPtr[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.ShuffleKeyPtr[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *JournalShuffle) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JournalShuffle) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JournalShuffle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Replay {
		i--
		if m.Replay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Shuffle.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Coordinator) > 0 {
		i -= len(m.Coordinator)
		copy(dAtA[i:], m.Coordinator)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Coordinator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Journal) > 0 {
		i -= len(m.Journal)
		copy(dAtA[i:], m.Journal)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Journal)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Projection) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Projection) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Projection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Inference != nil {
		{
			size, err := m.Inference.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.IsPrimaryKey {
		i--
		if m.IsPrimaryKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.IsPartitionKey {
		i--
		if m.IsPartitionKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.UserProvided {
		i--
		if m.UserProvided {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Field) > 0 {
		i -= len(m.Field)
		copy(dAtA[i:], m.Field)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Field)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ptr) > 0 {
		i -= len(m.Ptr)
		copy(dAtA[i:], m.Ptr)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Ptr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Inference) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Inference) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Inference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x22
	}
	if m.String_ != nil {
		{
			size, err := m.String_.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MustExist {
		i--
		if m.MustExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Types[iNdEx])
			copy(dAtA[i:], m.Types[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.Types[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Inference_String) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Inference_String) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Inference_String) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxLength != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.MaxLength))
		i--
		dAtA[i] = 0x30
	}
	if m.IsBase64 {
		i--
		if m.IsBase64 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *CollectionSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AckJsonTemplate) > 0 {
		i -= len(m.AckJsonTemplate)
		copy(dAtA[i:], m.AckJsonTemplate)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.AckJsonTemplate)))
		i--
		dAtA[i] = 0x42
	}
	{
		size, err := m.JournalSpec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.Projections) > 0 {
		for iNdEx := len(m.Projections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Projections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.PartitionFields) > 0 {
		for iNdEx := len(m.PartitionFields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionFields[iNdEx])
			copy(dAtA[i:], m.PartitionFields[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.PartitionFields[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.UuidPtr) > 0 {
		i -= len(m.UuidPtr)
		copy(dAtA[i:], m.UuidPtr)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.UuidPtr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.KeyPtrs) > 0 {
		for iNdEx := len(m.KeyPtrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyPtrs[iNdEx])
			copy(dAtA[i:], m.KeyPtrs[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.KeyPtrs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SchemaUri) > 0 {
		i -= len(m.SchemaUri)
		copy(dAtA[i:], m.SchemaUri)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.SchemaUri)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransformSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransformSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransformSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Derivation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Shuffle.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.CatalogDbId != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.CatalogDbId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransformSpec_Source) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransformSpec_Source) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransformSpec_Source) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Partitions.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransformSpec_Derivation) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransformSpec_Derivation) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransformSpec_Derivation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RangeSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RClockEnd != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.RClockEnd))
		i--
		dAtA[i] = 0x28
	}
	if m.RClockBegin != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.RClockBegin))
		i--
		dAtA[i] = 0x20
	}
	if len(m.KeyEnd) > 0 {
		i -= len(m.KeyEnd)
		copy(dAtA[i:], m.KeyEnd)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.KeyEnd)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.KeyBegin) > 0 {
		i -= len(m.KeyBegin)
		copy(dAtA[i:], m.KeyBegin)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.KeyBegin)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *ShuffleRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShuffleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShuffleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Resolution != nil {
		{
			size, err := m.Resolution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.EndOffset != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.EndOffset))
		i--
		dAtA[i] = 0x20
	}
	if m.Offset != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Shuffle.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ShuffleResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShuffleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShuffleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PackedKey) > 0 {
		for iNdEx := len(m.PackedKey) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PackedKey[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.UuidParts) > 0 {
		for iNdEx := len(m.UuidParts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UuidParts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.End) > 0 {
		dAtA13 := make([]byte, len(m.End)*10)
		var j12 int
		for _, num1 := range m.End {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintFlow(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Begin) > 0 {
		dAtA15 := make([]byte, len(m.Begin)*10)
		var j14 int
		for _, num1 := range m.Begin {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintFlow(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DocsJson) > 0 {
		for iNdEx := len(m.DocsJson) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DocsJson[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Arena) > 0 {
		i -= len(m.Arena)
		copy(dAtA[i:], m.Arena)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Arena)))
		i--
		dAtA[i] = 0x32
	}
	if m.WriteHead != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.WriteHead))
		i--
		dAtA[i] = 0x28
	}
	if m.ReadThrough != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ReadThrough))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TerminalError) > 0 {
		i -= len(m.TerminalError)
		copy(dAtA[i:], m.TerminalError)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.TerminalError)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExtractAPI) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtractAPI) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtractAPI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ExtractAPI_Config) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtractAPI_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtractAPI_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FieldPtrs) > 0 {
		for iNdEx := len(m.FieldPtrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FieldPtrs[iNdEx])
			copy(dAtA[i:], m.FieldPtrs[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.FieldPtrs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.UuidPtr) > 0 {
		i -= len(m.UuidPtr)
		copy(dAtA[i:], m.UuidPtr)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.UuidPtr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CombineAPI) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineAPI) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombineAPI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *CombineAPI_Config) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineAPI_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombineAPI_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Prune {
		i--
		if m.Prune {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.UuidPlaceholderPtr) > 0 {
		i -= len(m.UuidPlaceholderPtr)
		copy(dAtA[i:], m.UuidPlaceholderPtr)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.UuidPlaceholderPtr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FieldPtrs) > 0 {
		for iNdEx := len(m.FieldPtrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FieldPtrs[iNdEx])
			copy(dAtA[i:], m.FieldPtrs[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.FieldPtrs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.KeyPtr) > 0 {
		for iNdEx := len(m.KeyPtr) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyPtr[iNdEx])
			copy(dAtA[i:], m.KeyPtr[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.KeyPtr[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SchemaUri) > 0 {
		i -= len(m.SchemaUri)
		copy(dAtA[i:], m.SchemaUri)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.SchemaUri)))
		i--
		dAtA[i] = 0x12
	}
	if m.SchemaIndexMemptr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SchemaIndexMemptr))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *DeriveAPI) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveAPI) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveAPI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeriveAPI_Config) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveAPI_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveAPI_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RocksdbEnvMemptr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RocksdbEnvMemptr))
		i--
		dAtA[i] = 0x21
	}
	if len(m.LocalDir) > 0 {
		i -= len(m.LocalDir)
		copy(dAtA[i:], m.LocalDir)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.LocalDir)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Derivation) > 0 {
		i -= len(m.Derivation)
		copy(dAtA[i:], m.Derivation)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Derivation)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CatalogPath) > 0 {
		i -= len(m.CatalogPath)
		copy(dAtA[i:], m.CatalogPath)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.CatalogPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveAPI_DocHeader) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveAPI_DocHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveAPI_DocHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TransformId != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.TransformId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PackedKey) > 0 {
		i -= len(m.PackedKey)
		copy(dAtA[i:], m.PackedKey)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.PackedKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.Uuid != nil {
		{
			size, err := m.Uuid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveAPI_Flush) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveAPI_Flush) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveAPI_Flush) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FieldPtrs) > 0 {
		for iNdEx := len(m.FieldPtrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FieldPtrs[iNdEx])
			copy(dAtA[i:], m.FieldPtrs[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.FieldPtrs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.UuidPlaceholderPtr) > 0 {
		i -= len(m.UuidPlaceholderPtr)
		copy(dAtA[i:], m.UuidPlaceholderPtr)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.UuidPlaceholderPtr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveAPI_Prepare) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveAPI_Prepare) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveAPI_Prepare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IngestRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Collections) > 0 {
		for iNdEx := len(m.Collections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Collections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IngestRequest_Collection) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestRequest_Collection) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestRequest_Collection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DocsJsonLines) > 0 {
		i -= len(m.DocsJsonLines)
		copy(dAtA[i:], m.DocsJsonLines)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.DocsJsonLines)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IngestResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.JournalEtcd.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.JournalWriteHeads) > 0 {
		for k := range m.JournalWriteHeads {
			v := m.JournalWriteHeads[k]
			baseI := i
			i = encodeVarintFlow(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFlow(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFlow(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AdvanceTimeRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvanceTimeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvanceTimeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AddClockDeltaSeconds != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.AddClockDeltaSeconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AdvanceTimeResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvanceTimeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvanceTimeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ClockDeltaSeconds != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ClockDeltaSeconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClearRegistersRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearRegistersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearRegistersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ShardId) > 0 {
		i -= len(m.ShardId)
		copy(dAtA[i:], m.ShardId)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ShardId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClearRegistersResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearRegistersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearRegistersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Status != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFlow(dAtA []byte, offset int, v uint64) int {
	offset -= sovFlow(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Slice) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != 0 {
		n += 1 + sovFlow(uint64(m.Begin))
	}
	if m.End != 0 {
		n += 1 + sovFlow(uint64(m.End))
	}
	return n
}

func (m *UUIDParts) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProducerAndFlags != 0 {
		n += 9
	}
	if m.Clock != 0 {
		n += 9
	}
	return n
}

func (m *Shuffle) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ShuffleKeyPtr) > 0 {
		for _, s := range m.ShuffleKeyPtr {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.UsesSourceKey {
		n += 2
	}
	if m.FilterRClocks {
		n += 2
	}
	if m.Hash != 0 {
		n += 1 + sovFlow(uint64(m.Hash))
	}
	if m.ReadDelaySeconds != 0 {
		n += 1 + sovFlow(uint64(m.ReadDelaySeconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JournalShuffle) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Coordinator)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = m.Shuffle.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.Replay {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Projection) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ptr)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Field)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.UserProvided {
		n += 2
	}
	if m.IsPartitionKey {
		n += 2
	}
	if m.IsPrimaryKey {
		n += 2
	}
	if m.Inference != nil {
		l = m.Inference.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Inference) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Types) > 0 {
		for _, s := range m.Types {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.MustExist {
		n += 2
	}
	if m.String_ != nil {
		l = m.String_.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Inference_String) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.IsBase64 {
		n += 2
	}
	if m.MaxLength != 0 {
		n += 1 + sovFlow(uint64(m.MaxLength))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CollectionSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.SchemaUri)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.KeyPtrs) > 0 {
		for _, s := range m.KeyPtrs {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = len(m.UuidPtr)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.PartitionFields) > 0 {
		for _, s := range m.PartitionFields {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.Projections) > 0 {
		for _, e := range m.Projections {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = m.JournalSpec.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	l = len(m.AckJsonTemplate)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransformSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.CatalogDbId != 0 {
		n += 1 + sovFlow(uint64(m.CatalogDbId))
	}
	l = m.Source.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	l = m.Shuffle.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	l = m.Derivation.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransformSpec_Source) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = m.Partitions.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransformSpec_Derivation) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RangeSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyBegin)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.KeyEnd)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.RClockBegin != 0 {
		n += 1 + sovFlow(uint64(m.RClockBegin))
	}
	if m.RClockEnd != 0 {
		n += 1 + sovFlow(uint64(m.RClockEnd))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShuffleRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Shuffle.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	l = m.Range.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.Offset != 0 {
		n += 1 + sovFlow(uint64(m.Offset))
	}
	if m.EndOffset != 0 {
		n += 1 + sovFlow(uint64(m.EndOffset))
	}
	if m.Resolution != nil {
		l = m.Resolution.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShuffleResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovFlow(uint64(m.Status))
	}
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.TerminalError)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.ReadThrough != 0 {
		n += 1 + sovFlow(uint64(m.ReadThrough))
	}
	if m.WriteHead != 0 {
		n += 1 + sovFlow(uint64(m.WriteHead))
	}
	l = len(m.Arena)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.DocsJson) > 0 {
		for _, e := range m.DocsJson {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.Begin) > 0 {
		l = 0
		for _, e := range m.Begin {
			l += sovFlow(uint64(e))
		}
		n += 1 + sovFlow(uint64(l)) + l
	}
	if len(m.End) > 0 {
		l = 0
		for _, e := range m.End {
			l += sovFlow(uint64(e))
		}
		n += 1 + sovFlow(uint64(l)) + l
	}
	if len(m.UuidParts) > 0 {
		for _, e := range m.UuidParts {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.PackedKey) > 0 {
		for _, e := range m.PackedKey {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtractAPI) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtractAPI_Config) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UuidPtr)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.FieldPtrs) > 0 {
		for _, s := range m.FieldPtrs {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CombineAPI) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CombineAPI_Config) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaIndexMemptr != 0 {
		n += 9
	}
	l = len(m.SchemaUri)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.KeyPtr) > 0 {
		for _, s := range m.KeyPtr {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.FieldPtrs) > 0 {
		for _, s := range m.FieldPtrs {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = len(m.UuidPlaceholderPtr)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Prune {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveAPI) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveAPI_Config) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CatalogPath)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Derivation)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.LocalDir)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.RocksdbEnvMemptr != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveAPI_DocHeader) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uuid != nil {
		l = m.Uuid.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.PackedKey)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.TransformId != 0 {
		n += 1 + sovFlow(uint64(m.TransformId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveAPI_Flush) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UuidPlaceholderPtr)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.FieldPtrs) > 0 {
		for _, s := range m.FieldPtrs {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveAPI_Prepare) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Checkpoint.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngestRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Collections) > 0 {
		for _, e := range m.Collections {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngestRequest_Collection) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.DocsJsonLines)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngestResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.JournalWriteHeads) > 0 {
		for k, v := range m.JournalWriteHeads {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + sovFlow(uint64(v))
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	l = m.JournalEtcd.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdvanceTimeRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddClockDeltaSeconds != 0 {
		n += 1 + sovFlow(uint64(m.AddClockDeltaSeconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdvanceTimeResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClockDeltaSeconds != 0 {
		n += 1 + sovFlow(uint64(m.ClockDeltaSeconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClearRegistersRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.ShardId)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClearRegistersResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovFlow(uint64(m.Status))
	}
	l = m.Header.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFlow(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFlow(x uint64) (n int) {
	return sovFlow(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Slice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Slice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Slice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UUIDParts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UUIDParts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UUIDParts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerAndFlags", wireType)
			}
			m.ProducerAndFlags = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ProducerAndFlags = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clock", wireType)
			}
			m.Clock = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Clock = go_gazette_dev_core_message.Clock(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shuffle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shuffle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shuffle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleKeyPtr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShuffleKeyPtr = append(m.ShuffleKeyPtr, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesSourceKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsesSourceKey = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterRClocks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FilterRClocks = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			m.Hash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hash |= Shuffle_Hash(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadDelaySeconds", wireType)
			}
			m.ReadDelaySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadDelaySeconds |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JournalShuffle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JournalShuffle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JournalShuffle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = go_gazette_dev_core_broker_protocol.Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coordinator = go_gazette_dev_core_consumer_protocol.ShardID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shuffle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shuffle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Replay = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Projection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Projection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Projection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ptr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ptr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProvided", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserProvided = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPartitionKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPartitionKey = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimaryKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrimaryKey = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inference == nil {
				m.Inference = &Inference{}
			}
			if err := m.Inference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Inference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Inference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Inference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustExist = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.String_ == nil {
				m.String_ = &Inference_String{}
			}
			if err := m.String_.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Inference_String) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: String: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: String: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBase64", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBase64 = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLength", wireType)
			}
			m.MaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLength |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = Collection(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPtrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyPtrs = append(m.KeyPtrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidPtr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidPtr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionFields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionFields = append(m.PartitionFields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Projections = append(m.Projections, &Projection{})
			if err := m.Projections[len(m.Projections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JournalSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.JournalSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckJsonTemplate", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AckJsonTemplate = append(m.AckJsonTemplate[:0], dAtA[iNdEx:postIndex]...)
			if m.AckJsonTemplate == nil {
				m.AckJsonTemplate = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransformSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransformSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransformSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = Transform(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatalogDbId", wireType)
			}
			m.CatalogDbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CatalogDbId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shuffle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shuffle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Derivation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Derivation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransformSpec_Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = Collection(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Partitions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransformSpec_Derivation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Derivation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Derivation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = Collection(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBegin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyBegin = append(m.KeyBegin[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyBegin == nil {
				m.KeyBegin = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyEnd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyEnd = append(m.KeyEnd[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyEnd == nil {
				m.KeyEnd = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RClockBegin", wireType)
			}
			m.RClockBegin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RClockBegin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RClockEnd", wireType)
			}
			m.RClockEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RClockEnd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShuffleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShuffleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShuffleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shuffle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shuffle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndOffset", wireType)
			}
			m.EndOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndOffset |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resolution == nil {
				m.Resolution = &protocol.Header{}
			}
			if err := m.Resolution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShuffleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShuffleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShuffleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= protocol1.Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &protocol.Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TerminalError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TerminalError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadThrough", wireType)
			}
			m.ReadThrough = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadThrough |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteHead", wireType)
			}
			m.WriteHead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteHead |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arena", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arena = append(m.Arena[:0], dAtA[iNdEx:postIndex]...)
			if m.Arena == nil {
				m.Arena = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocsJson", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocsJson = append(m.DocsJson, Slice{})
			if err := m.DocsJson[len(m.DocsJson)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v go_gazette_dev_core_broker_protocol.Offset
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Begin = append(m.Begin, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlow
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlow
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Begin) == 0 {
					m.Begin = make([]go_gazette_dev_core_broker_protocol.Offset, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v go_gazette_dev_core_broker_protocol.Offset
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Begin = append(m.Begin, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
		case 9:
			if wireType == 0 {
				var v go_gazette_dev_core_broker_protocol.Offset
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.End = append(m.End, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlow
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlow
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.End) == 0 {
					m.End = make([]go_gazette_dev_core_broker_protocol.Offset, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v go_gazette_dev_core_broker_protocol.Offset
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.End = append(m.End, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidParts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidParts = append(m.UuidParts, UUIDParts{})
			if err := m.UuidParts[len(m.UuidParts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackedKey = append(m.PackedKey, Slice{})
			if err := m.PackedKey[len(m.PackedKey)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtractAPI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtractAPI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtractAPI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtractAPI_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidPtr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidPtr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPtrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPtrs = append(m.FieldPtrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineAPI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombineAPI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombineAPI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineAPI_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaIndexMemptr", wireType)
			}
			m.SchemaIndexMemptr = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaIndexMemptr = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPtr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyPtr = append(m.KeyPtr, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPtrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPtrs = append(m.FieldPtrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidPlaceholderPtr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidPlaceholderPtr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prune", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Prune = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveAPI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeriveAPI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeriveAPI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveAPI_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatalogPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CatalogPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Derivation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Derivation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksdbEnvMemptr", wireType)
			}
			m.RocksdbEnvMemptr = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.RocksdbEnvMemptr = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveAPI_DocHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uuid == nil {
				m.Uuid = &UUIDParts{}
			}
			if err := m.Uuid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackedKey = append(m.PackedKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PackedKey == nil {
				m.PackedKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransformId", wireType)
			}
			m.TransformId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransformId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveAPI_Flush) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flush: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flush: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidPlaceholderPtr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidPlaceholderPtr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPtrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPtrs = append(m.FieldPtrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveAPI_Prepare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collections = append(m.Collections, IngestRequest_Collection{})
			if err := m.Collections[len(m.Collections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestRequest_Collection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Collection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Collection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = Collection(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocsJsonLines", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocsJsonLines = append(m.DocsJsonLines[:0], dAtA[iNdEx:postIndex]...)
			if m.DocsJsonLines == nil {
				m.DocsJsonLines = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JournalWriteHeads", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JournalWriteHeads == nil {
				m.JournalWriteHeads = make(map[go_gazette_dev_core_broker_protocol.Journal]go_gazette_dev_core_broker_protocol.Offset)
			}
			var mapkey go_gazette_dev_core_broker_protocol.Journal
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = go_gazette_dev_core_broker_protocol.Journal(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlow(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFlow
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JournalWriteHeads[go_gazette_dev_core_broker_protocol.Journal(mapkey)] = ((go_gazette_dev_core_broker_protocol.Offset)(mapvalue))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JournalEtcd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.JournalEtcd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvanceTimeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvanceTimeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvanceTimeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddClockDeltaSeconds", wireType)
			}
			m.AddClockDeltaSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddClockDeltaSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvanceTimeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvanceTimeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvanceTimeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockDeltaSeconds", wireType)
			}
			m.ClockDeltaSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClockDeltaSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearRegistersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearRegistersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearRegistersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &protocol.Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardId = go_gazette_dev_core_consumer_protocol.ShardID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearRegistersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearRegistersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearRegistersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= protocol1.Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlow(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFlow
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFlow
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFlow
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFlow        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlow          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFlow = fmt.Errorf("proto: unexpected end of group")
)
