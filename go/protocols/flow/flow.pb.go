// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go/protocols/flow/flow.proto

package flow

import (
	context "context"
	encoding_binary "encoding/binary"
	encoding_json "encoding/json"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	go_gazette_dev_core_broker_protocol "go.gazette.dev/core/broker/protocol"
	protocol "go.gazette.dev/core/broker/protocol"
	go_gazette_dev_core_consumer_protocol "go.gazette.dev/core/consumer/protocol"
	protocol1 "go.gazette.dev/core/consumer/protocol"
	go_gazette_dev_core_message "go.gazette.dev/core/message"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ContentType enumerates the content types understood by Flow.
type ContentType int32

const (
	ContentType_CATALOG           ContentType = 0
	ContentType_JSON_SCHEMA       ContentType = 1
	ContentType_CONFIG            ContentType = 4
	ContentType_DOCUMENTS_FIXTURE ContentType = 5
)

var ContentType_name = map[int32]string{
	0: "CATALOG",
	1: "JSON_SCHEMA",
	4: "CONFIG",
	5: "DOCUMENTS_FIXTURE",
}

var ContentType_value = map[string]int32{
	"CATALOG":           0,
	"JSON_SCHEMA":       1,
	"CONFIG":            4,
	"DOCUMENTS_FIXTURE": 5,
}

func (x ContentType) String() string {
	return proto.EnumName(ContentType_name, int32(x))
}

func (ContentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{0}
}

// Exists enumerates the possible states of existence for a location.
type Inference_Exists int32

const (
	Inference_INVALID Inference_Exists = 0
	// The location must exist.
	Inference_MUST Inference_Exists = 1
	// The location may exist or be undefined.
	// Its schema has explicit keywords which allow it to exist
	// and which may constrain its shape, such as additionalProperties,
	// items, unevaluatedProperties, or unevaluatedItems.
	Inference_MAY Inference_Exists = 2
	// The location may exist or be undefined.
	// Its schema omits any associated keywords, but the specification's
	// default behavior allows the location to exist.
	Inference_IMPLICIT Inference_Exists = 3
	// The location cannot exist. For example, it's outside of permitted
	// array bounds, or is a disallowed property, or has an impossible type.
	Inference_CANNOT Inference_Exists = 4
)

var Inference_Exists_name = map[int32]string{
	0: "INVALID",
	1: "MUST",
	2: "MAY",
	3: "IMPLICIT",
	4: "CANNOT",
}

var Inference_Exists_value = map[string]int32{
	"INVALID":  0,
	"MUST":     1,
	"MAY":      2,
	"IMPLICIT": 3,
	"CANNOT":   4,
}

func (x Inference_Exists) String() string {
	return proto.EnumName(Inference_Exists_name, int32(x))
}

func (Inference_Exists) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{3, 0}
}

type CollectionSpec_Derivation_ConnectorType int32

const (
	CollectionSpec_Derivation_INVALID_CONNECTOR_TYPE CollectionSpec_Derivation_ConnectorType = 0
	CollectionSpec_Derivation_SQLITE                 CollectionSpec_Derivation_ConnectorType = 1
	CollectionSpec_Derivation_TYPESCRIPT             CollectionSpec_Derivation_ConnectorType = 2
	CollectionSpec_Derivation_IMAGE                  CollectionSpec_Derivation_ConnectorType = 3
)

var CollectionSpec_Derivation_ConnectorType_name = map[int32]string{
	0: "INVALID_CONNECTOR_TYPE",
	1: "SQLITE",
	2: "TYPESCRIPT",
	3: "IMAGE",
}

var CollectionSpec_Derivation_ConnectorType_value = map[string]int32{
	"INVALID_CONNECTOR_TYPE": 0,
	"SQLITE":                 1,
	"TYPESCRIPT":             2,
	"IMAGE":                  3,
}

func (x CollectionSpec_Derivation_ConnectorType) String() string {
	return proto.EnumName(CollectionSpec_Derivation_ConnectorType_name, int32(x))
}

func (CollectionSpec_Derivation_ConnectorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{5, 0, 0}
}

// JSON types of shuffle key components extracted by the transforms of this derivation.
type CollectionSpec_Derivation_ShuffleType int32

const (
	CollectionSpec_Derivation_INVALID_SHUFFLE_TYPE CollectionSpec_Derivation_ShuffleType = 0
	CollectionSpec_Derivation_BOOLEAN              CollectionSpec_Derivation_ShuffleType = 1
	CollectionSpec_Derivation_INTEGER              CollectionSpec_Derivation_ShuffleType = 2
	CollectionSpec_Derivation_STRING               CollectionSpec_Derivation_ShuffleType = 3
)

var CollectionSpec_Derivation_ShuffleType_name = map[int32]string{
	0: "INVALID_SHUFFLE_TYPE",
	1: "BOOLEAN",
	2: "INTEGER",
	3: "STRING",
}

var CollectionSpec_Derivation_ShuffleType_value = map[string]int32{
	"INVALID_SHUFFLE_TYPE": 0,
	"BOOLEAN":              1,
	"INTEGER":              2,
	"STRING":               3,
}

func (x CollectionSpec_Derivation_ShuffleType) String() string {
	return proto.EnumName(CollectionSpec_Derivation_ShuffleType_name, int32(x))
}

func (CollectionSpec_Derivation_ShuffleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{5, 0, 1}
}

// Type of the capture's connector.
type CaptureSpec_ConnectorType int32

const (
	CaptureSpec_INVALID CaptureSpec_ConnectorType = 0
	CaptureSpec_IMAGE   CaptureSpec_ConnectorType = 7
)

var CaptureSpec_ConnectorType_name = map[int32]string{
	0: "INVALID",
	7: "IMAGE",
}

var CaptureSpec_ConnectorType_value = map[string]int32{
	"INVALID": 0,
	"IMAGE":   7,
}

func (x CaptureSpec_ConnectorType) String() string {
	return proto.EnumName(CaptureSpec_ConnectorType_name, int32(x))
}

func (CaptureSpec_ConnectorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{7, 0}
}

// Type of the materialization's connector.
type MaterializationSpec_ConnectorType int32

const (
	MaterializationSpec_INVALID MaterializationSpec_ConnectorType = 0
	MaterializationSpec_SQLITE  MaterializationSpec_ConnectorType = 2
	MaterializationSpec_IMAGE   MaterializationSpec_ConnectorType = 8
)

var MaterializationSpec_ConnectorType_name = map[int32]string{
	0: "INVALID",
	2: "SQLITE",
	8: "IMAGE",
}

var MaterializationSpec_ConnectorType_value = map[string]int32{
	"INVALID": 0,
	"SQLITE":  2,
	"IMAGE":   8,
}

func (x MaterializationSpec_ConnectorType) String() string {
	return proto.EnumName(MaterializationSpec_ConnectorType_name, int32(x))
}

func (MaterializationSpec_ConnectorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{8, 0}
}

// Type of this step.
type TestSpec_Step_Type int32

const (
	TestSpec_Step_INGEST TestSpec_Step_Type = 0
	TestSpec_Step_VERIFY TestSpec_Step_Type = 1
)

var TestSpec_Step_Type_name = map[int32]string{
	0: "INGEST",
	1: "VERIFY",
}

var TestSpec_Step_Type_value = map[string]int32{
	"INGEST": 0,
	"VERIFY": 1,
}

func (x TestSpec_Step_Type) String() string {
	return proto.EnumName(TestSpec_Step_Type_name, int32(x))
}

func (TestSpec_Step_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{10, 0, 0}
}

// Code labels message codes passed over the CGO bridge.
type ExtractAPI_Code int32

const (
	ExtractAPI_INVALID ExtractAPI_Code = 0
	// Configure or re-configure the extractor (Go -> Rust).
	ExtractAPI_CONFIGURE ExtractAPI_Code = 1
	// Extract from a document (Go -> Rust).
	ExtractAPI_EXTRACT ExtractAPI_Code = 2
	// UUID extracted from a document (Rust -> Go).
	ExtractAPI_EXTRACTED_UUID ExtractAPI_Code = 3
	// Fields extracted from a document (Rust -> Go).
	ExtractAPI_EXTRACTED_FIELDS ExtractAPI_Code = 4
)

var ExtractAPI_Code_name = map[int32]string{
	0: "INVALID",
	1: "CONFIGURE",
	2: "EXTRACT",
	3: "EXTRACTED_UUID",
	4: "EXTRACTED_FIELDS",
}

var ExtractAPI_Code_value = map[string]int32{
	"INVALID":          0,
	"CONFIGURE":        1,
	"EXTRACT":          2,
	"EXTRACTED_UUID":   3,
	"EXTRACTED_FIELDS": 4,
}

func (x ExtractAPI_Code) String() string {
	return proto.EnumName(ExtractAPI_Code_name, int32(x))
}

func (ExtractAPI_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{13, 0}
}

// Code labels message codes passed over the CGO bridge.
type CombineAPI_Code int32

const (
	CombineAPI_INVALID CombineAPI_Code = 0
	// Configure or re-configure the combiner (Go -> Rust).
	// A combiner may be configured only on first initialization,
	// or immediately after having drained.
	CombineAPI_CONFIGURE CombineAPI_Code = 1
	// Reduce a left-hand side document (Go -> Rust).
	CombineAPI_REDUCE_LEFT CombineAPI_Code = 2
	// Combine a right-hand side document (Go -> Rust).
	CombineAPI_COMBINE_RIGHT CombineAPI_Code = 3
	// Drain the combiner (Go -> Rust).
	CombineAPI_DRAIN_CHUNK CombineAPI_Code = 200
	// Next drained document is partially combined (Rust -> Go).
	CombineAPI_DRAINED_COMBINED_DOCUMENT CombineAPI_Code = 201
	// Next drained document is fully reduced (Rust -> Go).
	CombineAPI_DRAINED_REDUCED_DOCUMENT CombineAPI_Code = 202
	// Next drained key (follows drained document; Rust -> Go).
	CombineAPI_DRAINED_KEY CombineAPI_Code = 203
	// Next drained fields (follows key; Rust -> Go).
	CombineAPI_DRAINED_FIELDS CombineAPI_Code = 204
	// Drain stats, sent after all documents have been drained. (Rust -> Go)
	CombineAPI_DRAINED_STATS CombineAPI_Code = 205
)

var CombineAPI_Code_name = map[int32]string{
	0:   "INVALID",
	1:   "CONFIGURE",
	2:   "REDUCE_LEFT",
	3:   "COMBINE_RIGHT",
	200: "DRAIN_CHUNK",
	201: "DRAINED_COMBINED_DOCUMENT",
	202: "DRAINED_REDUCED_DOCUMENT",
	203: "DRAINED_KEY",
	204: "DRAINED_FIELDS",
	205: "DRAINED_STATS",
}

var CombineAPI_Code_value = map[string]int32{
	"INVALID":                   0,
	"CONFIGURE":                 1,
	"REDUCE_LEFT":               2,
	"COMBINE_RIGHT":             3,
	"DRAIN_CHUNK":               200,
	"DRAINED_COMBINED_DOCUMENT": 201,
	"DRAINED_REDUCED_DOCUMENT":  202,
	"DRAINED_KEY":               203,
	"DRAINED_FIELDS":            204,
	"DRAINED_STATS":             205,
}

func (x CombineAPI_Code) String() string {
	return proto.EnumName(CombineAPI_Code_name, int32(x))
}

func (CombineAPI_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{14, 0}
}

// Status represents the high-level response to an Open request. If OK, then
// the connection may proceed. Any other status indicates the reason for refusal.
// This enum is a superset of the consumer.Status enum used by the Shards service,
// though some statuses have taken on broader meanings.
type TaskNetworkProxyResponse_Status int32

const (
	TaskNetworkProxyResponse_OK TaskNetworkProxyResponse_Status = 0
	// The named shard does not exist.
	TaskNetworkProxyResponse_SHARD_NOT_FOUND TaskNetworkProxyResponse_Status = 1
	// There is no current primary consumer process for the shard. This is a
	// temporary condition which should quickly resolve, assuming sufficient
	// consumer capacity.
	TaskNetworkProxyResponse_NO_SHARD_PRIMARY TaskNetworkProxyResponse_Status = 2
	// The present consumer process is not the assigned primary for the shard,
	// and was not instructed to proxy the request.
	TaskNetworkProxyResponse_NOT_SHARD_PRIMARY TaskNetworkProxyResponse_Status = 3
	// Used to indicate an error in the proxying machinery.
	// This corresponds to consumer.Status_ETCD_TRANSACTION_FAILED, which is considered
	// a specific case of the broader category of "internal" errors, since the proxy API
	// doesn't directly expose anything about etcd.
	TaskNetworkProxyResponse_INTERNAL_ERROR TaskNetworkProxyResponse_Status = 4
	// Either the shard itself is stopped or failed, or else the container is.
	TaskNetworkProxyResponse_SHARD_STOPPED TaskNetworkProxyResponse_Status = 5
	// The client is not allowed to connect to the port given in the request.
	// This could be either because the port does not exist or for any other
	// reason, such as if we implement IP-based access policies.
	TaskNetworkProxyResponse_PORT_NOT_ALLOWED TaskNetworkProxyResponse_Status = 1000
)

var TaskNetworkProxyResponse_Status_name = map[int32]string{
	0:    "OK",
	1:    "SHARD_NOT_FOUND",
	2:    "NO_SHARD_PRIMARY",
	3:    "NOT_SHARD_PRIMARY",
	4:    "INTERNAL_ERROR",
	5:    "SHARD_STOPPED",
	1000: "PORT_NOT_ALLOWED",
}

var TaskNetworkProxyResponse_Status_value = map[string]int32{
	"OK":                0,
	"SHARD_NOT_FOUND":   1,
	"NO_SHARD_PRIMARY":  2,
	"NOT_SHARD_PRIMARY": 3,
	"INTERNAL_ERROR":    4,
	"SHARD_STOPPED":     5,
	"PORT_NOT_ALLOWED":  1000,
}

func (x TaskNetworkProxyResponse_Status) String() string {
	return proto.EnumName(TaskNetworkProxyResponse_Status_name, int32(x))
}

func (TaskNetworkProxyResponse_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{24, 0}
}

// Slice represents a contiguous slice of bytes within an associated Arena.
type Slice struct {
	Begin uint32 `protobuf:"varint,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End   uint32 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *Slice) Reset()         { *m = Slice{} }
func (m *Slice) String() string { return proto.CompactTextString(m) }
func (*Slice) ProtoMessage()    {}
func (*Slice) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{0}
}
func (m *Slice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Slice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Slice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Slice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Slice.Merge(m, src)
}
func (m *Slice) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Slice) XXX_DiscardUnknown() {
	xxx_messageInfo_Slice.DiscardUnknown(m)
}

var xxx_messageInfo_Slice proto.InternalMessageInfo

// UUIDParts is a deconstructed, RFC 4122 v1 variant Universally Unique
// Identifier as used by Gazette.
type UUIDParts struct {
	// "Node" identifier portion of a v1 UUID.
	//
	// A unique producer ID is encoded in the high 48 bits (MSB).
	// Within them, the most-significant bit must be 1 to mark this producer
	// as "multicast" and not an actual MAC address (as per RFC 4122).
	//
	// Bits 49-54 must be zero.
	//
	// The low 10 bits are the 10 least-significant bits of the v1 UUID clock
	// sequence, used by Gazette to represent flags over message transaction
	// semantics.
	Node uint64 `protobuf:"fixed64,1,opt,name=node,proto3" json:"node,omitempty"`
	// Clock is a v1 UUID 60-bit timestamp (60 MSBs), followed by 4 bits of
	// sequence counter.
	Clock go_gazette_dev_core_message.Clock `protobuf:"fixed64,2,opt,name=clock,proto3,casttype=go.gazette.dev/core/message.Clock" json:"clock,omitempty"`
}

func (m *UUIDParts) Reset()         { *m = UUIDParts{} }
func (m *UUIDParts) String() string { return proto.CompactTextString(m) }
func (*UUIDParts) ProtoMessage()    {}
func (*UUIDParts) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{1}
}
func (m *UUIDParts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UUIDParts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UUIDParts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UUIDParts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UUIDParts.Merge(m, src)
}
func (m *UUIDParts) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UUIDParts) XXX_DiscardUnknown() {
	xxx_messageInfo_UUIDParts.DiscardUnknown(m)
}

var xxx_messageInfo_UUIDParts proto.InternalMessageInfo

// Projection is a mapping between a document location, specified as a
// JSON-Pointer, and a corresponding field string in a flattened
// (i.e. tabular or SQL) namespace which aliases it.
type Projection struct {
	// Document location of this projection, as a JSON-Pointer.
	Ptr string `protobuf:"bytes,1,opt,name=ptr,proto3" json:"ptr,omitempty"`
	// Field is the flattened, tabular alias of this projection.
	Field string `protobuf:"bytes,2,opt,name=field,proto3" json:"field,omitempty"`
	// Was this projection explicitly provided ?
	// (As opposed to implicitly created through static analysis of the schema).
	Explicit bool `protobuf:"varint,3,opt,name=explicit,proto3" json:"explicit,omitempty"`
	// Does this projection constitute a logical partitioning of the collection?
	IsPartitionKey bool `protobuf:"varint,4,opt,name=is_partition_key,json=isPartitionKey,proto3" json:"is_partition_key,omitempty"`
	// Does this location form (part of) the collection key?
	IsPrimaryKey bool `protobuf:"varint,5,opt,name=is_primary_key,json=isPrimaryKey,proto3" json:"is_primary_key,omitempty"`
	// Inference of this projection.
	Inference            Inference `protobuf:"bytes,6,opt,name=inference,proto3" json:"inference"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Projection) Reset()         { *m = Projection{} }
func (m *Projection) String() string { return proto.CompactTextString(m) }
func (*Projection) ProtoMessage()    {}
func (*Projection) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{2}
}
func (m *Projection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Projection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Projection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Projection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Projection.Merge(m, src)
}
func (m *Projection) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Projection) XXX_DiscardUnknown() {
	xxx_messageInfo_Projection.DiscardUnknown(m)
}

var xxx_messageInfo_Projection proto.InternalMessageInfo

// Inference details type information which is statically known
// about a given document location.
type Inference struct {
	// The possible types for this location.
	// Subset of ["null", "boolean", "object", "array", "integer", "numeric",
	// "string"].
	Types   []string          `protobuf:"bytes,1,rep,name=types,proto3" json:"types,omitempty"`
	String_ *Inference_String `protobuf:"bytes,3,opt,name=string,proto3" json:"string,omitempty"`
	// The title from the schema, if provided.
	Title string `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	// The description from the schema, if provided.
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// The default value from the schema, if provided.
	DefaultJson encoding_json.RawMessage `protobuf:"bytes,6,opt,name=default_json,json=default,proto3,casttype=encoding/json.RawMessage" json:"default_json,omitempty"`
	// Whether this location is marked as a secret, like a credential or password.
	Secret bool `protobuf:"varint,7,opt,name=secret,proto3" json:"secret,omitempty"`
	// Existence of this document location.
	Exists               Inference_Exists `protobuf:"varint,8,opt,name=exists,proto3,enum=flow.Inference_Exists" json:"exists,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Inference) Reset()         { *m = Inference{} }
func (m *Inference) String() string { return proto.CompactTextString(m) }
func (*Inference) ProtoMessage()    {}
func (*Inference) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{3}
}
func (m *Inference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Inference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Inference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Inference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Inference.Merge(m, src)
}
func (m *Inference) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Inference) XXX_DiscardUnknown() {
	xxx_messageInfo_Inference.DiscardUnknown(m)
}

var xxx_messageInfo_Inference proto.InternalMessageInfo

// String type-specific inferences, or nil iff types doesn't include "string".
type Inference_String struct {
	// Annotated Content-Type when the projection is of "string" type.
	ContentType string `protobuf:"bytes,3,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	// Annotated format when the projection is of "string" type.
	Format string `protobuf:"bytes,4,opt,name=format,proto3" json:"format,omitempty"`
	// Annotated Content-Encoding when the projection is of "string" type.
	ContentEncoding string `protobuf:"bytes,7,opt,name=content_encoding,json=contentEncoding,proto3" json:"content_encoding,omitempty"`
	// Maximum length when the projection is of "string" type. Zero for no
	// limit.
	MaxLength            uint32   `protobuf:"varint,6,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Inference_String) Reset()         { *m = Inference_String{} }
func (m *Inference_String) String() string { return proto.CompactTextString(m) }
func (*Inference_String) ProtoMessage()    {}
func (*Inference_String) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{3, 0}
}
func (m *Inference_String) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Inference_String) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Inference_String.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Inference_String) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Inference_String.Merge(m, src)
}
func (m *Inference_String) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Inference_String) XXX_DiscardUnknown() {
	xxx_messageInfo_Inference_String.DiscardUnknown(m)
}

var xxx_messageInfo_Inference_String proto.InternalMessageInfo

type NetworkPort struct {
	// Number of this port, in the standard 1..65536 range.
	Number uint32 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	// ALPN protocol of this port, if known.
	Protocol string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Is this port public?
	// When true, unauthenticated requests are allowed.
	// Otherwise only authenticated users with access to the task will be permitted.
	Public               bool     `protobuf:"varint,3,opt,name=public,proto3" json:"public,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkPort) Reset()         { *m = NetworkPort{} }
func (m *NetworkPort) String() string { return proto.CompactTextString(m) }
func (*NetworkPort) ProtoMessage()    {}
func (*NetworkPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{4}
}
func (m *NetworkPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkPort.Merge(m, src)
}
func (m *NetworkPort) XXX_Size() int {
	return m.ProtoSize()
}
func (m *NetworkPort) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkPort.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkPort proto.InternalMessageInfo

type CollectionSpec struct {
	// Name of this collection.
	Name Collection `protobuf:"bytes,1,opt,name=name,proto3,casttype=Collection" json:"name,omitempty"`
	// Bundled write-time JSON Schema of the collection.
	WriteSchemaJson encoding_json.RawMessage `protobuf:"bytes,8,opt,name=write_schema_json,json=writeSchema,proto3,casttype=encoding/json.RawMessage" json:"write_schema_json,omitempty"`
	// Bundled read-time JSON Schema of the collection.
	// Optional. If not set then `write_schema_json` should be used.
	ReadSchemaJson encoding_json.RawMessage `protobuf:"bytes,11,opt,name=read_schema_json,json=readSchema,proto3,casttype=encoding/json.RawMessage" json:"read_schema_json,omitempty"`
	// Composite key of the collection, as JSON-Pointers.
	Key []string `protobuf:"bytes,3,rep,name=key,proto3" json:"key,omitempty"`
	// JSON pointer locating the UUID of each collection document.
	UuidPtr string `protobuf:"bytes,4,opt,name=uuid_ptr,json=uuidPtr,proto3" json:"uuid_ptr,omitempty"`
	// Logical partition fields of this collection, and their applied order.
	// At present partitions are always in ascending lexicographic order on
	// their field name, but this could change at some point.
	PartitionFields []string `protobuf:"bytes,5,rep,name=partition_fields,json=partitionFields,proto3" json:"partition_fields,omitempty"`
	// Logical projections of this collection, ordered on ascending field.
	Projections []Projection `protobuf:"bytes,6,rep,name=projections,proto3" json:"projections"`
	// JSON-encoded document template for creating Gazette consumer
	// transaction acknowledgements of writes into this collection.
	AckTemplateJson encoding_json.RawMessage `protobuf:"bytes,7,opt,name=ack_template_json,json=ackTemplate,proto3,casttype=encoding/json.RawMessage" json:"ack_template_json,omitempty"`
	// Template for partitions of this collection.
	PartitionTemplate    *protocol.JournalSpec      `protobuf:"bytes,9,opt,name=partition_template,json=partitionTemplate,proto3" json:"partition_template,omitempty"`
	Derivation           *CollectionSpec_Derivation `protobuf:"bytes,12,opt,name=derivation,proto3" json:"derivation,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *CollectionSpec) Reset()         { *m = CollectionSpec{} }
func (m *CollectionSpec) String() string { return proto.CompactTextString(m) }
func (*CollectionSpec) ProtoMessage()    {}
func (*CollectionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{5}
}
func (m *CollectionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionSpec.Merge(m, src)
}
func (m *CollectionSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CollectionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionSpec proto.InternalMessageInfo

// A Derivation is a collection that builds itself through transformation
// of other sourced collections.
// When a CollectionSpec is inlined into a CaptureSpec or MaterializationSpec,
// its derivation is cleared even if it is, in fact, a derivation.
type CollectionSpec_Derivation struct {
	// Type of the derivation's connector.
	ConnectorType CollectionSpec_Derivation_ConnectorType `protobuf:"varint,1,opt,name=connector_type,json=connectorType,proto3,enum=flow.CollectionSpec_Derivation_ConnectorType" json:"connector_type,omitempty"`
	// JSON-encoded connector configuration of this derivation.
	ConfigJson      encoding_json.RawMessage                `protobuf:"bytes,2,opt,name=config_json,json=config,proto3,casttype=encoding/json.RawMessage" json:"config_json,omitempty"`
	Transforms      []CollectionSpec_Derivation_Transform   `protobuf:"bytes,3,rep,name=transforms,proto3" json:"transforms"`
	ShuffleKeyTypes []CollectionSpec_Derivation_ShuffleType `protobuf:"varint,4,rep,packed,name=shuffle_key_types,json=shuffleKeyTypes,proto3,enum=flow.CollectionSpec_Derivation_ShuffleType" json:"shuffle_key_types,omitempty"`
	// Template for shards of this derivation.
	ShardTemplate *protocol1.ShardSpec `protobuf:"bytes,5,opt,name=shard_template,json=shardTemplate,proto3" json:"shard_template,omitempty"`
	// Template for recovery logs of shards of this derivation.
	RecoveryLogTemplate *protocol.JournalSpec `protobuf:"bytes,6,opt,name=recovery_log_template,json=recoveryLogTemplate,proto3" json:"recovery_log_template,omitempty"`
	// Network ports of this derivation.
	NetworkPorts         []*NetworkPort `protobuf:"bytes,7,rep,name=network_ports,json=networkPorts,proto3" json:"network_ports,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CollectionSpec_Derivation) Reset()         { *m = CollectionSpec_Derivation{} }
func (m *CollectionSpec_Derivation) String() string { return proto.CompactTextString(m) }
func (*CollectionSpec_Derivation) ProtoMessage()    {}
func (*CollectionSpec_Derivation) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{5, 0}
}
func (m *CollectionSpec_Derivation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionSpec_Derivation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionSpec_Derivation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionSpec_Derivation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionSpec_Derivation.Merge(m, src)
}
func (m *CollectionSpec_Derivation) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CollectionSpec_Derivation) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionSpec_Derivation.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionSpec_Derivation proto.InternalMessageInfo

// Transforms of the derivation.
type CollectionSpec_Derivation_Transform struct {
	// Stable name of this transform.
	Name Transform `protobuf:"bytes,1,opt,name=name,proto3,casttype=Transform" json:"name,omitempty"`
	// Source collection which is read by this transform.
	Collection CollectionSpec `protobuf:"bytes,2,opt,name=collection,proto3" json:"collection"`
	// Selector of collection partitions which this materialization reads.
	PartitionSelector protocol.LabelSelector `protobuf:"bytes,3,opt,name=partition_selector,json=partitionSelector,proto3" json:"partition_selector"`
	// Priority of this transform, with respect to other transforms of the derivation.
	// Higher values imply higher priority.
	Priority uint32 `protobuf:"varint,4,opt,name=priority,proto3" json:"priority,omitempty"`
	// Number of seconds for which documents of this transformed are delayed
	// while reading, relative to other documents (when back-filling) and the
	// present wall-clock time (when tailing).
	ReadDelaySeconds uint32 `protobuf:"varint,5,opt,name=read_delay_seconds,json=readDelaySeconds,proto3" json:"read_delay_seconds,omitempty"`
	// Shuffle key of this transform, or empty if a shuffle key is not defined.
	ShuffleKey []string `protobuf:"bytes,6,rep,name=shuffle_key,json=shuffleKey,proto3" json:"shuffle_key,omitempty"`
	/// JSON-encoded shuffle lambda of this transform, or empty if a shuffle lambda is not defined.
	ShuffleLambdaConfigJson encoding_json.RawMessage `protobuf:"bytes,7,opt,name=shuffle_lambda_config_json,json=shuffleLambdaConfig,proto3,casttype=encoding/json.RawMessage" json:"shuffle_lambda_config_json,omitempty"`
	// JSON-encoded lambda of this transform.
	LambdaConfigJson encoding_json.RawMessage `protobuf:"bytes,8,opt,name=lambda_config_json,json=lambdaConfig,proto3,casttype=encoding/json.RawMessage" json:"lambda_config_json,omitempty"`
	// Is this transform known to always be read-only?
	ReadOnly bool `protobuf:"varint,9,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	// Stable, unique value used to suffix journal read checkpoints of this transform.
	// Computed as "derive/{derivation}/{transform}".
	JournalReadSuffix string `protobuf:"bytes,10,opt,name=journal_read_suffix,json=journalReadSuffix,proto3" json:"journal_read_suffix,omitempty"`
	// When set, documents before this timestamp are not processed.
	NotBefore *types.Timestamp `protobuf:"bytes,11,opt,name=not_before,json=notBefore,proto3" json:"not_before,omitempty"`
	// When set, documents after this timestamp are not processed.
	NotAfter             *types.Timestamp `protobuf:"bytes,12,opt,name=not_after,json=notAfter,proto3" json:"not_after,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *CollectionSpec_Derivation_Transform) Reset()         { *m = CollectionSpec_Derivation_Transform{} }
func (m *CollectionSpec_Derivation_Transform) String() string { return proto.CompactTextString(m) }
func (*CollectionSpec_Derivation_Transform) ProtoMessage()    {}
func (*CollectionSpec_Derivation_Transform) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{5, 0, 0}
}
func (m *CollectionSpec_Derivation_Transform) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionSpec_Derivation_Transform) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionSpec_Derivation_Transform.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionSpec_Derivation_Transform) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionSpec_Derivation_Transform.Merge(m, src)
}
func (m *CollectionSpec_Derivation_Transform) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CollectionSpec_Derivation_Transform) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionSpec_Derivation_Transform.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionSpec_Derivation_Transform proto.InternalMessageInfo

// FieldSelection is a selection of a collection's projection fields.
type FieldSelection struct {
	// Fields for each key component of the collection. Included key fields appear
	// in the collection's key component order, and a given key pointer will be
	// included at most once.
	Keys []string `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	// All other selected fields, other than those in keys and the document field.
	// Entries are in ascending sorted order, and may be empty.
	Values []string `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
	// Field having a document pointer located at the document root.
	Document string `protobuf:"bytes,3,opt,name=document,proto3" json:"document,omitempty"`
	// Additional configuration, keyed by fields included in |keys|, |values|, or
	// |document|. Values are arbitrary JSON-encoded objects.
	FieldConfigJsonMap   map[string]encoding_json.RawMessage `protobuf:"bytes,4,rep,name=field_config_json_map,json=fieldConfig,proto3,castvalue=encoding/json.RawMessage" json:"field_config_json_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *FieldSelection) Reset()         { *m = FieldSelection{} }
func (m *FieldSelection) String() string { return proto.CompactTextString(m) }
func (*FieldSelection) ProtoMessage()    {}
func (*FieldSelection) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{6}
}
func (m *FieldSelection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldSelection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldSelection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldSelection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldSelection.Merge(m, src)
}
func (m *FieldSelection) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FieldSelection) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldSelection.DiscardUnknown(m)
}

var xxx_messageInfo_FieldSelection proto.InternalMessageInfo

// CaptureSpec describes a collection and its capture from an endpoint.
type CaptureSpec struct {
	// Name of this capture.
	Name          Capture                   `protobuf:"bytes,1,opt,name=name,proto3,casttype=Capture" json:"name,omitempty"`
	ConnectorType CaptureSpec_ConnectorType `protobuf:"varint,2,opt,name=connector_type,json=connectorType,proto3,enum=flow.CaptureSpec_ConnectorType" json:"connector_type,omitempty"`
	// JSON-encoded connector configuration of this capture.
	ConfigJson encoding_json.RawMessage `protobuf:"bytes,3,opt,name=config_json,json=config,proto3,casttype=encoding/json.RawMessage" json:"config_json,omitempty"`
	Bindings   []*CaptureSpec_Binding   `protobuf:"bytes,4,rep,name=bindings,proto3" json:"bindings,omitempty"`
	// Minimum interval of time between successive invocations of the capture.
	IntervalSeconds uint32 `protobuf:"varint,5,opt,name=interval_seconds,json=intervalSeconds,proto3" json:"interval_seconds,omitempty"`
	// Template for shards of this capture.
	ShardTemplate *protocol1.ShardSpec `protobuf:"bytes,6,opt,name=shard_template,json=shardTemplate,proto3" json:"shard_template,omitempty"`
	// Template for recovery logs of shards of this capture.
	RecoveryLogTemplate *protocol.JournalSpec `protobuf:"bytes,7,opt,name=recovery_log_template,json=recoveryLogTemplate,proto3" json:"recovery_log_template,omitempty"`
	// Network ports of this capture.
	NetworkPorts         []*NetworkPort `protobuf:"bytes,8,rep,name=network_ports,json=networkPorts,proto3" json:"network_ports,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CaptureSpec) Reset()         { *m = CaptureSpec{} }
func (m *CaptureSpec) String() string { return proto.CompactTextString(m) }
func (*CaptureSpec) ProtoMessage()    {}
func (*CaptureSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{7}
}
func (m *CaptureSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CaptureSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CaptureSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CaptureSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CaptureSpec.Merge(m, src)
}
func (m *CaptureSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CaptureSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CaptureSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CaptureSpec proto.InternalMessageInfo

// Bindings of endpoint resources and collections into which they're captured.
// Bindings are ordered and unique on the bound collection name,
// and are also unique on the resource path.
type CaptureSpec_Binding struct {
	// JSON-encoded configuration of the bound resource.
	ResourceConfigJson encoding_json.RawMessage `protobuf:"bytes,1,opt,name=resource_config_json,json=resourceConfig,proto3,casttype=encoding/json.RawMessage" json:"resource_config_json,omitempty"`
	// Driver-supplied path components which fully qualify the
	// subresource being captured.
	ResourcePath []string `protobuf:"bytes,2,rep,name=resource_path,json=resourcePath,proto3" json:"resource_path,omitempty"`
	// Collection to be captured into.
	Collection           CollectionSpec `protobuf:"bytes,3,opt,name=collection,proto3" json:"collection"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CaptureSpec_Binding) Reset()         { *m = CaptureSpec_Binding{} }
func (m *CaptureSpec_Binding) String() string { return proto.CompactTextString(m) }
func (*CaptureSpec_Binding) ProtoMessage()    {}
func (*CaptureSpec_Binding) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{7, 0}
}
func (m *CaptureSpec_Binding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CaptureSpec_Binding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CaptureSpec_Binding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CaptureSpec_Binding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CaptureSpec_Binding.Merge(m, src)
}
func (m *CaptureSpec_Binding) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CaptureSpec_Binding) XXX_DiscardUnknown() {
	xxx_messageInfo_CaptureSpec_Binding.DiscardUnknown(m)
}

var xxx_messageInfo_CaptureSpec_Binding proto.InternalMessageInfo

// MaterializationSpec describes a collection and its materialization to an
// endpoint.
type MaterializationSpec struct {
	// Name of this materialization.
	Name          Materialization                   `protobuf:"bytes,1,opt,name=name,proto3,casttype=Materialization" json:"name,omitempty"`
	ConnectorType MaterializationSpec_ConnectorType `protobuf:"varint,2,opt,name=connector_type,json=connectorType,proto3,enum=flow.MaterializationSpec_ConnectorType" json:"connector_type,omitempty"`
	// JSON-encoded connector configuration of this materialization.
	ConfigJson encoding_json.RawMessage       `protobuf:"bytes,3,opt,name=config_json,json=config,proto3,casttype=encoding/json.RawMessage" json:"config_json,omitempty"`
	Bindings   []*MaterializationSpec_Binding `protobuf:"bytes,4,rep,name=bindings,proto3" json:"bindings,omitempty"`
	// Template for shards of this materialization.
	ShardTemplate *protocol1.ShardSpec `protobuf:"bytes,5,opt,name=shard_template,json=shardTemplate,proto3" json:"shard_template,omitempty"`
	// Template for recovery logs of shards of this materialization.
	RecoveryLogTemplate *protocol.JournalSpec `protobuf:"bytes,6,opt,name=recovery_log_template,json=recoveryLogTemplate,proto3" json:"recovery_log_template,omitempty"`
	// Network ports of this materialization.
	NetworkPorts         []*NetworkPort `protobuf:"bytes,7,rep,name=network_ports,json=networkPorts,proto3" json:"network_ports,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *MaterializationSpec) Reset()         { *m = MaterializationSpec{} }
func (m *MaterializationSpec) String() string { return proto.CompactTextString(m) }
func (*MaterializationSpec) ProtoMessage()    {}
func (*MaterializationSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{8}
}
func (m *MaterializationSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaterializationSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaterializationSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaterializationSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaterializationSpec.Merge(m, src)
}
func (m *MaterializationSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MaterializationSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MaterializationSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MaterializationSpec proto.InternalMessageInfo

// Bindings of endpoint resources and collections from which they're
// materialized. Bindings are ordered and unique on the bound collection name,
// and are also unique on the resource path.
type MaterializationSpec_Binding struct {
	// JSON-encoded configuration of the bound resource.
	ResourceConfigJson encoding_json.RawMessage `protobuf:"bytes,1,opt,name=resource_config_json,json=resourceConfig,proto3,casttype=encoding/json.RawMessage" json:"resource_config_json,omitempty"`
	// Driver-supplied path components which fully qualify the
	// subresource being materialized.
	ResourcePath []string `protobuf:"bytes,2,rep,name=resource_path,json=resourcePath,proto3" json:"resource_path,omitempty"`
	// Collection to be materialized.
	Collection CollectionSpec `protobuf:"bytes,3,opt,name=collection,proto3" json:"collection"`
	// Selector of collection partitions which this materialization reads.
	PartitionSelector protocol.LabelSelector `protobuf:"bytes,7,opt,name=partition_selector,json=partitionSelector,proto3" json:"partition_selector"`
	// Priority of this binding, with respect to other bindings of the materialization.
	// Higher values imply higher priority.
	Priority uint32 `protobuf:"varint,9,opt,name=priority,proto3" json:"priority,omitempty"`
	// Resolved fields selected for materialization.
	FieldSelection FieldSelection `protobuf:"bytes,4,opt,name=field_selection,json=fieldSelection,proto3" json:"field_selection"`
	// Materialize delta updates of documents rather than full reductions.
	DeltaUpdates      bool                                           `protobuf:"varint,5,opt,name=delta_updates,json=deltaUpdates,proto3" json:"delta_updates,omitempty"`
	DeprecatedShuffle *MaterializationSpec_Binding_DeprecatedShuffle `protobuf:"bytes,6,opt,name=deprecated_shuffle,json=deprecatedShuffle,proto3" json:"deprecated_shuffle,omitempty"`
	// Stable, unique value used to suffix journal read checkpoints of this binding.
	// Computed as "materialize/{materialization}/{encoded-resource-path}".
	JournalReadSuffix string `protobuf:"bytes,8,opt,name=journal_read_suffix,json=journalReadSuffix,proto3" json:"journal_read_suffix,omitempty"`
	// When set, documents before this timestamp are not processed.
	NotBefore *types.Timestamp `protobuf:"bytes,10,opt,name=not_before,json=notBefore,proto3" json:"not_before,omitempty"`
	// When set, documents after this timestamp are not processed.
	NotAfter             *types.Timestamp `protobuf:"bytes,11,opt,name=not_after,json=notAfter,proto3" json:"not_after,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *MaterializationSpec_Binding) Reset()         { *m = MaterializationSpec_Binding{} }
func (m *MaterializationSpec_Binding) String() string { return proto.CompactTextString(m) }
func (*MaterializationSpec_Binding) ProtoMessage()    {}
func (*MaterializationSpec_Binding) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{8, 0}
}
func (m *MaterializationSpec_Binding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaterializationSpec_Binding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaterializationSpec_Binding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaterializationSpec_Binding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaterializationSpec_Binding.Merge(m, src)
}
func (m *MaterializationSpec_Binding) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MaterializationSpec_Binding) XXX_DiscardUnknown() {
	xxx_messageInfo_MaterializationSpec_Binding.DiscardUnknown(m)
}

var xxx_messageInfo_MaterializationSpec_Binding proto.InternalMessageInfo

// Deprecated shuffle message which holds an alternate location for `partition_selector`.
type MaterializationSpec_Binding_DeprecatedShuffle struct {
	GroupName            string                 `protobuf:"bytes,1,opt,name=group_name,json=groupName,proto3" json:"group_name,omitempty"`
	PartitionSelector    protocol.LabelSelector `protobuf:"bytes,3,opt,name=partition_selector,json=partitionSelector,proto3" json:"partition_selector"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *MaterializationSpec_Binding_DeprecatedShuffle) Reset() {
	*m = MaterializationSpec_Binding_DeprecatedShuffle{}
}
func (m *MaterializationSpec_Binding_DeprecatedShuffle) String() string {
	return proto.CompactTextString(m)
}
func (*MaterializationSpec_Binding_DeprecatedShuffle) ProtoMessage() {}
func (*MaterializationSpec_Binding_DeprecatedShuffle) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{8, 0, 0}
}
func (m *MaterializationSpec_Binding_DeprecatedShuffle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaterializationSpec_Binding_DeprecatedShuffle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaterializationSpec_Binding_DeprecatedShuffle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaterializationSpec_Binding_DeprecatedShuffle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaterializationSpec_Binding_DeprecatedShuffle.Merge(m, src)
}
func (m *MaterializationSpec_Binding_DeprecatedShuffle) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MaterializationSpec_Binding_DeprecatedShuffle) XXX_DiscardUnknown() {
	xxx_messageInfo_MaterializationSpec_Binding_DeprecatedShuffle.DiscardUnknown(m)
}

var xxx_messageInfo_MaterializationSpec_Binding_DeprecatedShuffle proto.InternalMessageInfo

// OAuth2 describes an OAuth2 provider
type OAuth2 struct {
	// Name of the OAuth2 provider. This is a machine-readable key and must stay
	// consistent. One example use case is to map providers to their respective
	// style of buttons in the UI
	Provider string `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	// Template for authorization URL, this is the first step of the OAuth2 flow
	// where the user is redirected to the OAuth2 provider to authorize access to
	// their account
	AuthUrlTemplate string `protobuf:"bytes,2,opt,name=auth_url_template,json=authUrlTemplate,proto3" json:"auth_url_template,omitempty"`
	// Template for access token URL, this is the second step of the OAuth2 flow,
	// where we request an access token from the provider
	AccessTokenUrlTemplate string `protobuf:"bytes,3,opt,name=access_token_url_template,json=accessTokenUrlTemplate,proto3" json:"access_token_url_template,omitempty"`
	// The method used to send access_token request. POST by default.
	AccessTokenMethod string `protobuf:"bytes,11,opt,name=access_token_method,json=accessTokenMethod,proto3" json:"access_token_method,omitempty"`
	// The POST body of the access_token request
	AccessTokenBody string `protobuf:"bytes,4,opt,name=access_token_body,json=accessTokenBody,proto3" json:"access_token_body,omitempty"`
	// Headers for the access_token request
	AccessTokenHeadersJsonMap map[string]encoding_json.RawMessage `protobuf:"bytes,5,rep,name=access_token_headers_json_map,json=accessTokenHeaders,proto3,castvalue=encoding/json.RawMessage" json:"access_token_headers_json_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// A json map that maps the response from the OAuth provider for Access Token
	// request to keys in the connector endpoint configuration.
	// If the connector supports refresh tokens, must include `refresh_token` and
	// `expires_in`. If this mapping is not provided, the keys from the response
	// are passed as-is to the connector config.
	AccessTokenResponseJsonMap map[string]encoding_json.RawMessage `protobuf:"bytes,6,rep,name=access_token_response_json_map,json=accessTokenResponseMap,proto3,castvalue=encoding/json.RawMessage" json:"access_token_response_json_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Template for refresh token URL, some providers require that the access
	// token be refreshed.
	RefreshTokenUrlTemplate string `protobuf:"bytes,7,opt,name=refresh_token_url_template,json=refreshTokenUrlTemplate,proto3" json:"refresh_token_url_template,omitempty"`
	// The method used to send refresh_token request. POST by default.
	RefreshTokenMethod string `protobuf:"bytes,12,opt,name=refresh_token_method,json=refreshTokenMethod,proto3" json:"refresh_token_method,omitempty"`
	// The POST body of the refresh_token request
	RefreshTokenBody string `protobuf:"bytes,8,opt,name=refresh_token_body,json=refreshTokenBody,proto3" json:"refresh_token_body,omitempty"`
	// Headers for the refresh_token request
	RefreshTokenHeadersJsonMap map[string]encoding_json.RawMessage `protobuf:"bytes,9,rep,name=refresh_token_headers_json_map,json=refreshTokenHeaders,proto3,castvalue=encoding/json.RawMessage" json:"refresh_token_headers_json_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// A json map that maps the response from the OAuth provider for Refresh Token
	// request to keys in the connector endpoint configuration.
	// If the connector supports refresh tokens, must include `refresh_token` and
	// `expires_in`. If this mapping is not provided, the keys from the response
	// are passed as-is to the connector config.
	RefreshTokenResponseJsonMap map[string]encoding_json.RawMessage `protobuf:"bytes,10,rep,name=refresh_token_response_json_map,json=refreshTokenResponseMap,proto3,castvalue=encoding/json.RawMessage" json:"refresh_token_response_json_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral        struct{}                            `json:"-"`
	XXX_unrecognized            []byte                              `json:"-"`
	XXX_sizecache               int32                               `json:"-"`
}

func (m *OAuth2) Reset()         { *m = OAuth2{} }
func (m *OAuth2) String() string { return proto.CompactTextString(m) }
func (*OAuth2) ProtoMessage()    {}
func (*OAuth2) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{9}
}
func (m *OAuth2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OAuth2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OAuth2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OAuth2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OAuth2.Merge(m, src)
}
func (m *OAuth2) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OAuth2) XXX_DiscardUnknown() {
	xxx_messageInfo_OAuth2.DiscardUnknown(m)
}

var xxx_messageInfo_OAuth2 proto.InternalMessageInfo

// TestSpec describes a catalog test.
type TestSpec struct {
	// Name of this test.
	Name                 string          `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Steps                []TestSpec_Step `protobuf:"bytes,2,rep,name=steps,proto3" json:"steps"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *TestSpec) Reset()         { *m = TestSpec{} }
func (m *TestSpec) String() string { return proto.CompactTextString(m) }
func (*TestSpec) ProtoMessage()    {}
func (*TestSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{10}
}
func (m *TestSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSpec.Merge(m, src)
}
func (m *TestSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TestSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TestSpec proto.InternalMessageInfo

// Steps of the test.
type TestSpec_Step struct {
	StepType TestSpec_Step_Type `protobuf:"varint,1,opt,name=step_type,json=stepType,proto3,enum=flow.TestSpec_Step_Type" json:"step_type,omitempty"`
	// Index of this step within the test.
	StepIndex uint32 `protobuf:"varint,2,opt,name=step_index,json=stepIndex,proto3" json:"step_index,omitempty"`
	// Description of this step.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Scope of the test definition location.
	StepScope string `protobuf:"bytes,4,opt,name=step_scope,json=stepScope,proto3" json:"step_scope,omitempty"`
	// Collection ingested or verified by this step.
	Collection Collection `protobuf:"bytes,5,opt,name=collection,proto3,casttype=Collection" json:"collection,omitempty"`
	// JSON documents to ingest or verify.
	DocsJsonVec []encoding_json.RawMessage `protobuf:"bytes,6,rep,name=docs_json_vec,json=docs,proto3,casttype=encoding/json.RawMessage" json:"docs_json_vec,omitempty"`
	// When verifying, selector over logical partitions of the collection.
	Partitions           protocol.LabelSelector `protobuf:"bytes,7,opt,name=partitions,proto3" json:"partitions"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TestSpec_Step) Reset()         { *m = TestSpec_Step{} }
func (m *TestSpec_Step) String() string { return proto.CompactTextString(m) }
func (*TestSpec_Step) ProtoMessage()    {}
func (*TestSpec_Step) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{10, 0}
}
func (m *TestSpec_Step) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSpec_Step) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSpec_Step.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSpec_Step) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSpec_Step.Merge(m, src)
}
func (m *TestSpec_Step) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TestSpec_Step) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSpec_Step.DiscardUnknown(m)
}

var xxx_messageInfo_TestSpec_Step proto.InternalMessageInfo

// RangeSpec describes the ranges of shuffle keys and r-clocks which a reader
// is responsible for.
type RangeSpec struct {
	// [begin, end] inclusive range of keys to be shuffled to this reader.
	// Ranges are with respect to a 32-bit hash of a packed document key.
	//
	// The choice of hash function is important: while it need not be
	// cryptographically secure, it must demonstrate a strong "avalanche effect"
	// (ideally meeting the strict avalanche criterion), to ensure that small
	// pertubations of input keys are equally likely to independently affect
	// hash output bits. Particularly the higest bits of the hash result,
	// which dominate the selection of a shuffled shard.
	//
	// At present, Flow uses the high 32 bits of a HighWayHash 64-bit
	// checksum, using a fixed 32-byte key.
	KeyBegin uint32 `protobuf:"fixed32,2,opt,name=key_begin,json=keyBegin,proto3" json:"key_begin,omitempty"`
	KeyEnd   uint32 `protobuf:"fixed32,3,opt,name=key_end,json=keyEnd,proto3" json:"key_end,omitempty"`
	// Rotated [begin, end] inclusive ranges of Clocks.
	RClockBegin uint32 `protobuf:"fixed32,4,opt,name=r_clock_begin,json=rClockBegin,proto3" json:"r_clock_begin,omitempty"`
	RClockEnd   uint32 `protobuf:"fixed32,5,opt,name=r_clock_end,json=rClockEnd,proto3" json:"r_clock_end,omitempty"`
}

func (m *RangeSpec) Reset()      { *m = RangeSpec{} }
func (*RangeSpec) ProtoMessage() {}
func (*RangeSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{11}
}
func (m *RangeSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RangeSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RangeSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeSpec.Merge(m, src)
}
func (m *RangeSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RangeSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RangeSpec proto.InternalMessageInfo

type ConnectorState struct {
	// Update of the connector state, to be persisted by the Flow runtime
	// and supplied in the Open of a future connector invocation.
	UpdatedJson encoding_json.RawMessage `protobuf:"bytes,1,opt,name=updated_json,json=updated,proto3,casttype=encoding/json.RawMessage" json:"updated_json,omitempty"`
	// If true, then this state is applied to a previous state
	// as a RFC7396 Merge Patch.
	MergePatch           bool     `protobuf:"varint,2,opt,name=merge_patch,json=mergePatch,proto3" json:"merge_patch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectorState) Reset()         { *m = ConnectorState{} }
func (m *ConnectorState) String() string { return proto.CompactTextString(m) }
func (*ConnectorState) ProtoMessage()    {}
func (*ConnectorState) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{12}
}
func (m *ConnectorState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorState.Merge(m, src)
}
func (m *ConnectorState) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ConnectorState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorState.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorState proto.InternalMessageInfo

type ExtractAPI struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtractAPI) Reset()         { *m = ExtractAPI{} }
func (m *ExtractAPI) String() string { return proto.CompactTextString(m) }
func (*ExtractAPI) ProtoMessage()    {}
func (*ExtractAPI) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{13}
}
func (m *ExtractAPI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtractAPI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtractAPI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtractAPI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtractAPI.Merge(m, src)
}
func (m *ExtractAPI) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExtractAPI) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtractAPI.DiscardUnknown(m)
}

var xxx_messageInfo_ExtractAPI proto.InternalMessageInfo

type ExtractAPI_Config struct {
	// JSON pointer of the document UUID to extract.
	UuidPtr string `protobuf:"bytes,1,opt,name=uuid_ptr,json=uuidPtr,proto3" json:"uuid_ptr,omitempty"`
	// JSON schema to validate non-ACK documents against.
	// If empty then schema validation is not performed.
	SchemaJson encoding_json.RawMessage `protobuf:"bytes,2,opt,name=schema_json,json=schemaJson,proto3,casttype=encoding/json.RawMessage" json:"schema_json,omitempty"`
	// Field JSON pointers to extract from documents and return as packed
	// tuples.
	FieldPtrs []string `protobuf:"bytes,3,rep,name=field_ptrs,json=fieldPtrs,proto3" json:"field_ptrs,omitempty"`
	// A set of Projections which must include `field_ptrs`.
	// TODO(johnny): This is a kludge as we seek to remove this API.
	Projections          []Projection `protobuf:"bytes,4,rep,name=projections,proto3" json:"projections"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ExtractAPI_Config) Reset()         { *m = ExtractAPI_Config{} }
func (m *ExtractAPI_Config) String() string { return proto.CompactTextString(m) }
func (*ExtractAPI_Config) ProtoMessage()    {}
func (*ExtractAPI_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{13, 0}
}
func (m *ExtractAPI_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtractAPI_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtractAPI_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtractAPI_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtractAPI_Config.Merge(m, src)
}
func (m *ExtractAPI_Config) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExtractAPI_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtractAPI_Config.DiscardUnknown(m)
}

var xxx_messageInfo_ExtractAPI_Config proto.InternalMessageInfo

type CombineAPI struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CombineAPI) Reset()         { *m = CombineAPI{} }
func (m *CombineAPI) String() string { return proto.CompactTextString(m) }
func (*CombineAPI) ProtoMessage()    {}
func (*CombineAPI) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{14}
}
func (m *CombineAPI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombineAPI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombineAPI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombineAPI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombineAPI.Merge(m, src)
}
func (m *CombineAPI) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CombineAPI) XXX_DiscardUnknown() {
	xxx_messageInfo_CombineAPI.DiscardUnknown(m)
}

var xxx_messageInfo_CombineAPI proto.InternalMessageInfo

type CombineAPI_Config struct {
	// JSON schema against which documents are to be validated,
	// and which provides reduction annotations.
	SchemaJson encoding_json.RawMessage `protobuf:"bytes,1,opt,name=schema_json,json=schemaJson,proto3,casttype=encoding/json.RawMessage" json:"schema_json,omitempty"`
	// Composite key used to group documents to be combined, specified as one or
	// more JSON-Pointers indicating a message location to extract.
	KeyPtrs []string `protobuf:"bytes,2,rep,name=key_ptrs,json=keyPtrs,proto3" json:"key_ptrs,omitempty"`
	// Fields to be extracted from combined documents and returned.
	// If empty, no fields are extracted.
	Fields []string `protobuf:"bytes,3,rep,name=fields,proto3" json:"fields,omitempty"`
	// JSON-Pointer at which a placeholder UUID should be inserted into
	// returned documents. If empty, no placeholder is inserted.
	UuidPlaceholderPtr string `protobuf:"bytes,4,opt,name=uuid_placeholder_ptr,json=uuidPlaceholderPtr,proto3" json:"uuid_placeholder_ptr,omitempty"`
	// A set of Projections which must include `key_ptrs` and `fields`.
	// TODO(johnny): This is a kludge as we seek to remove this API.
	Projections []Projection `protobuf:"bytes,5,rep,name=projections,proto3" json:"projections"`
	// The name of the collection that's being written to.
	CollectionName string `protobuf:"bytes,6,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	// JSON-encoded string representing the JSON schema to start inference
	// from. If empty, do not emit inferred schemas.
	InferSchemaJson      string   `protobuf:"bytes,7,opt,name=infer_schema_json,json=inferSchemaJson,proto3" json:"infer_schema_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CombineAPI_Config) Reset()         { *m = CombineAPI_Config{} }
func (m *CombineAPI_Config) String() string { return proto.CompactTextString(m) }
func (*CombineAPI_Config) ProtoMessage()    {}
func (*CombineAPI_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{14, 0}
}
func (m *CombineAPI_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombineAPI_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombineAPI_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombineAPI_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombineAPI_Config.Merge(m, src)
}
func (m *CombineAPI_Config) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CombineAPI_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_CombineAPI_Config.DiscardUnknown(m)
}

var xxx_messageInfo_CombineAPI_Config proto.InternalMessageInfo

// Stats holds statistics relating to one or more combiner transactions.
type CombineAPI_Stats struct {
	Left                 *DocsAndBytes `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right                *DocsAndBytes `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	Out                  *DocsAndBytes `protobuf:"bytes,3,opt,name=out,proto3" json:"out,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *CombineAPI_Stats) Reset()         { *m = CombineAPI_Stats{} }
func (m *CombineAPI_Stats) String() string { return proto.CompactTextString(m) }
func (*CombineAPI_Stats) ProtoMessage()    {}
func (*CombineAPI_Stats) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{14, 1}
}
func (m *CombineAPI_Stats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombineAPI_Stats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombineAPI_Stats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombineAPI_Stats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombineAPI_Stats.Merge(m, src)
}
func (m *CombineAPI_Stats) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CombineAPI_Stats) XXX_DiscardUnknown() {
	xxx_messageInfo_CombineAPI_Stats.DiscardUnknown(m)
}

var xxx_messageInfo_CombineAPI_Stats proto.InternalMessageInfo

// BuildAPI is deprecated and will be removed.
// We're currently keeping Config around only to
// avoid churning various Go snapshot tests.
type BuildAPI struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuildAPI) Reset()         { *m = BuildAPI{} }
func (m *BuildAPI) String() string { return proto.CompactTextString(m) }
func (*BuildAPI) ProtoMessage()    {}
func (*BuildAPI) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{15}
}
func (m *BuildAPI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildAPI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildAPI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildAPI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildAPI.Merge(m, src)
}
func (m *BuildAPI) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BuildAPI) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildAPI.DiscardUnknown(m)
}

var xxx_messageInfo_BuildAPI proto.InternalMessageInfo

type BuildAPI_Config struct {
	// Identifier of this build.
	// The path of the output database is determined by joining the
	// configured directory and configured build ID.
	BuildId string `protobuf:"bytes,1,opt,name=build_id,json=buildId,proto3" json:"build_id,omitempty"`
	// Path to the output build database that should be written.
	BuildDb string `protobuf:"bytes,2,opt,name=build_db,json=buildDb,proto3" json:"build_db,omitempty"`
	// Root catalog source specification. This may be either a local path
	// relative to the current working directory, or an absolute URL.
	Source string `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	// Content type of the source.
	SourceType ContentType `protobuf:"varint,4,opt,name=source_type,json=sourceType,proto3,enum=flow.ContentType" json:"source_type,omitempty"`
	// The Docker network the connectors are given access to during catalog
	// builds.
	ConnectorNetwork string `protobuf:"bytes,5,opt,name=connector_network,json=connectorNetwork,proto3" json:"connector_network,omitempty"`
	// URL which roots the Flow project.
	ProjectRoot          string   `protobuf:"bytes,6,opt,name=project_root,json=projectRoot,proto3" json:"project_root,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuildAPI_Config) Reset()         { *m = BuildAPI_Config{} }
func (m *BuildAPI_Config) String() string { return proto.CompactTextString(m) }
func (*BuildAPI_Config) ProtoMessage()    {}
func (*BuildAPI_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{15, 0}
}
func (m *BuildAPI_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildAPI_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildAPI_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildAPI_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildAPI_Config.Merge(m, src)
}
func (m *BuildAPI_Config) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BuildAPI_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildAPI_Config.DiscardUnknown(m)
}

var xxx_messageInfo_BuildAPI_Config proto.InternalMessageInfo

// ResetStateRequest is the request of the Testing.ResetState RPC.
type ResetStateRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResetStateRequest) Reset()         { *m = ResetStateRequest{} }
func (m *ResetStateRequest) String() string { return proto.CompactTextString(m) }
func (*ResetStateRequest) ProtoMessage()    {}
func (*ResetStateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{16}
}
func (m *ResetStateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetStateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResetStateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResetStateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetStateRequest.Merge(m, src)
}
func (m *ResetStateRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ResetStateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetStateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResetStateRequest proto.InternalMessageInfo

// ResetStateResponse is the response of the Testing.ResetState RPC.
type ResetStateResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResetStateResponse) Reset()         { *m = ResetStateResponse{} }
func (m *ResetStateResponse) String() string { return proto.CompactTextString(m) }
func (*ResetStateResponse) ProtoMessage()    {}
func (*ResetStateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{17}
}
func (m *ResetStateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetStateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResetStateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResetStateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetStateResponse.Merge(m, src)
}
func (m *ResetStateResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ResetStateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetStateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResetStateResponse proto.InternalMessageInfo

// AdvanceTimeRequest is the request of the Testing.AdvanceTime RPC.
type AdvanceTimeRequest struct {
	AdvanceSeconds       uint64   `protobuf:"varint,1,opt,name=advance_seconds,json=advanceSeconds,proto3" json:"advance_seconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AdvanceTimeRequest) Reset()         { *m = AdvanceTimeRequest{} }
func (m *AdvanceTimeRequest) String() string { return proto.CompactTextString(m) }
func (*AdvanceTimeRequest) ProtoMessage()    {}
func (*AdvanceTimeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{18}
}
func (m *AdvanceTimeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvanceTimeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdvanceTimeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdvanceTimeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvanceTimeRequest.Merge(m, src)
}
func (m *AdvanceTimeRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AdvanceTimeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvanceTimeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdvanceTimeRequest proto.InternalMessageInfo

// AdvanceTimeResponse is the response of the Testing.AdvanceTime RPC.
type AdvanceTimeResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AdvanceTimeResponse) Reset()         { *m = AdvanceTimeResponse{} }
func (m *AdvanceTimeResponse) String() string { return proto.CompactTextString(m) }
func (*AdvanceTimeResponse) ProtoMessage()    {}
func (*AdvanceTimeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{19}
}
func (m *AdvanceTimeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvanceTimeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdvanceTimeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdvanceTimeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvanceTimeResponse.Merge(m, src)
}
func (m *AdvanceTimeResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AdvanceTimeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvanceTimeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdvanceTimeResponse proto.InternalMessageInfo

// DocsAndBytes represents a count of JSON documents, and their cumulative total
// size in bytes. This is used by the various Stats messages.
// Deprecated (johnny).
type DocsAndBytes struct {
	Docs                 uint32   `protobuf:"varint,1,opt,name=docs,proto3" json:"docs,omitempty"`
	Bytes                uint64   `protobuf:"varint,2,opt,name=bytes,proto3" json:"bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DocsAndBytes) Reset()         { *m = DocsAndBytes{} }
func (m *DocsAndBytes) String() string { return proto.CompactTextString(m) }
func (*DocsAndBytes) ProtoMessage()    {}
func (*DocsAndBytes) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{20}
}
func (m *DocsAndBytes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocsAndBytes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocsAndBytes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocsAndBytes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocsAndBytes.Merge(m, src)
}
func (m *DocsAndBytes) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DocsAndBytes) XXX_DiscardUnknown() {
	xxx_messageInfo_DocsAndBytes.DiscardUnknown(m)
}

var xxx_messageInfo_DocsAndBytes proto.InternalMessageInfo

type IngestRequest struct {
	// Name of the collection into which to ingest.
	Collection Collection `protobuf:"bytes,1,opt,name=collection,proto3,casttype=Collection" json:"collection,omitempty"`
	// Build ID of the ingested collection.
	BuildId string `protobuf:"bytes,2,opt,name=build_id,json=buildId,proto3" json:"build_id,omitempty"`
	// JSON documents to ingest or verify.
	DocsJsonVec          []encoding_json.RawMessage `protobuf:"bytes,3,rep,name=docs_json_vec,json=docs,proto3,casttype=encoding/json.RawMessage" json:"docs_json_vec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *IngestRequest) Reset()         { *m = IngestRequest{} }
func (m *IngestRequest) String() string { return proto.CompactTextString(m) }
func (*IngestRequest) ProtoMessage()    {}
func (*IngestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{21}
}
func (m *IngestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngestRequest.Merge(m, src)
}
func (m *IngestRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IngestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IngestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IngestRequest proto.InternalMessageInfo

// IngestResponse is the response of the Testing.Ingest RPC.
type IngestResponse struct {
	// Journals appended to by this ingestion, and their maximum offset on commit.
	JournalWriteHeads map[go_gazette_dev_core_broker_protocol.Journal]go_gazette_dev_core_broker_protocol.Offset `protobuf:"bytes,1,rep,name=journal_write_heads,json=journalWriteHeads,proto3,castkey=go.gazette.dev/core/broker/protocol.Journal,castvalue=go.gazette.dev/core/broker/protocol.Offset" json:"journal_write_heads,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Etcd header which describes current journal partitions.
	JournalEtcd          protocol.Header_Etcd `protobuf:"bytes,2,opt,name=journal_etcd,json=journalEtcd,proto3" json:"journal_etcd"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *IngestResponse) Reset()         { *m = IngestResponse{} }
func (m *IngestResponse) String() string { return proto.CompactTextString(m) }
func (*IngestResponse) ProtoMessage()    {}
func (*IngestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{22}
}
func (m *IngestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngestResponse.Merge(m, src)
}
func (m *IngestResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IngestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IngestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IngestResponse proto.InternalMessageInfo

type TaskNetworkProxyRequest struct {
	Open                 *TaskNetworkProxyRequest_Open `protobuf:"bytes,1,opt,name=open,proto3" json:"open,omitempty"`
	Data                 []byte                        `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *TaskNetworkProxyRequest) Reset()         { *m = TaskNetworkProxyRequest{} }
func (m *TaskNetworkProxyRequest) String() string { return proto.CompactTextString(m) }
func (*TaskNetworkProxyRequest) ProtoMessage()    {}
func (*TaskNetworkProxyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{23}
}
func (m *TaskNetworkProxyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskNetworkProxyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskNetworkProxyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskNetworkProxyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskNetworkProxyRequest.Merge(m, src)
}
func (m *TaskNetworkProxyRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TaskNetworkProxyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskNetworkProxyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TaskNetworkProxyRequest proto.InternalMessageInfo

type TaskNetworkProxyRequest_Open struct {
	// Header contains information about the shard resolution that was done by the client
	Header  *protocol.Header                              `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	ShardId go_gazette_dev_core_consumer_protocol.ShardID `protobuf:"bytes,2,opt,name=shard_id,json=shardId,proto3,casttype=go.gazette.dev/core/consumer/protocol.ShardID" json:"shard_id,omitempty"`
	// The port number inside the container that the client wishes to connect to.
	TargetPort uint32 `protobuf:"varint,3,opt,name=target_port,json=targetPort,proto3" json:"target_port,omitempty"`
	// The network address of the client that is establishing the connection.
	ClientAddr           string   `protobuf:"bytes,4,opt,name=client_addr,json=clientAddr,proto3" json:"client_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TaskNetworkProxyRequest_Open) Reset()         { *m = TaskNetworkProxyRequest_Open{} }
func (m *TaskNetworkProxyRequest_Open) String() string { return proto.CompactTextString(m) }
func (*TaskNetworkProxyRequest_Open) ProtoMessage()    {}
func (*TaskNetworkProxyRequest_Open) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{23, 0}
}
func (m *TaskNetworkProxyRequest_Open) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskNetworkProxyRequest_Open) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskNetworkProxyRequest_Open.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskNetworkProxyRequest_Open) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskNetworkProxyRequest_Open.Merge(m, src)
}
func (m *TaskNetworkProxyRequest_Open) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TaskNetworkProxyRequest_Open) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskNetworkProxyRequest_Open.DiscardUnknown(m)
}

var xxx_messageInfo_TaskNetworkProxyRequest_Open proto.InternalMessageInfo

type TaskNetworkProxyResponse struct {
	OpenResponse         *TaskNetworkProxyResponse_OpenResponse `protobuf:"bytes,1,opt,name=open_response,json=openResponse,proto3" json:"open_response,omitempty"`
	Data                 []byte                                 `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                               `json:"-"`
	XXX_unrecognized     []byte                                 `json:"-"`
	XXX_sizecache        int32                                  `json:"-"`
}

func (m *TaskNetworkProxyResponse) Reset()         { *m = TaskNetworkProxyResponse{} }
func (m *TaskNetworkProxyResponse) String() string { return proto.CompactTextString(m) }
func (*TaskNetworkProxyResponse) ProtoMessage()    {}
func (*TaskNetworkProxyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{24}
}
func (m *TaskNetworkProxyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskNetworkProxyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskNetworkProxyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskNetworkProxyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskNetworkProxyResponse.Merge(m, src)
}
func (m *TaskNetworkProxyResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TaskNetworkProxyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskNetworkProxyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TaskNetworkProxyResponse proto.InternalMessageInfo

type TaskNetworkProxyResponse_OpenResponse struct {
	Status               TaskNetworkProxyResponse_Status `protobuf:"varint,1,opt,name=status,proto3,enum=flow.TaskNetworkProxyResponse_Status" json:"status,omitempty"`
	Header               *protocol.Header                `protobuf:"bytes,2,opt,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *TaskNetworkProxyResponse_OpenResponse) Reset()         { *m = TaskNetworkProxyResponse_OpenResponse{} }
func (m *TaskNetworkProxyResponse_OpenResponse) String() string { return proto.CompactTextString(m) }
func (*TaskNetworkProxyResponse_OpenResponse) ProtoMessage()    {}
func (*TaskNetworkProxyResponse_OpenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0677502142fec31, []int{24, 0}
}
func (m *TaskNetworkProxyResponse_OpenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskNetworkProxyResponse_OpenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskNetworkProxyResponse_OpenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskNetworkProxyResponse_OpenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskNetworkProxyResponse_OpenResponse.Merge(m, src)
}
func (m *TaskNetworkProxyResponse_OpenResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TaskNetworkProxyResponse_OpenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskNetworkProxyResponse_OpenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TaskNetworkProxyResponse_OpenResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("flow.ContentType", ContentType_name, ContentType_value)
	proto.RegisterEnum("flow.Inference_Exists", Inference_Exists_name, Inference_Exists_value)
	proto.RegisterEnum("flow.CollectionSpec_Derivation_ConnectorType", CollectionSpec_Derivation_ConnectorType_name, CollectionSpec_Derivation_ConnectorType_value)
	proto.RegisterEnum("flow.CollectionSpec_Derivation_ShuffleType", CollectionSpec_Derivation_ShuffleType_name, CollectionSpec_Derivation_ShuffleType_value)
	proto.RegisterEnum("flow.CaptureSpec_ConnectorType", CaptureSpec_ConnectorType_name, CaptureSpec_ConnectorType_value)
	proto.RegisterEnum("flow.MaterializationSpec_ConnectorType", MaterializationSpec_ConnectorType_name, MaterializationSpec_ConnectorType_value)
	proto.RegisterEnum("flow.TestSpec_Step_Type", TestSpec_Step_Type_name, TestSpec_Step_Type_value)
	proto.RegisterEnum("flow.ExtractAPI_Code", ExtractAPI_Code_name, ExtractAPI_Code_value)
	proto.RegisterEnum("flow.CombineAPI_Code", CombineAPI_Code_name, CombineAPI_Code_value)
	proto.RegisterEnum("flow.TaskNetworkProxyResponse_Status", TaskNetworkProxyResponse_Status_name, TaskNetworkProxyResponse_Status_value)
	proto.RegisterType((*Slice)(nil), "flow.Slice")
	proto.RegisterType((*UUIDParts)(nil), "flow.UUIDParts")
	proto.RegisterType((*Projection)(nil), "flow.Projection")
	proto.RegisterType((*Inference)(nil), "flow.Inference")
	proto.RegisterType((*Inference_String)(nil), "flow.Inference.String")
	proto.RegisterType((*NetworkPort)(nil), "flow.NetworkPort")
	proto.RegisterType((*CollectionSpec)(nil), "flow.CollectionSpec")
	proto.RegisterType((*CollectionSpec_Derivation)(nil), "flow.CollectionSpec.Derivation")
	proto.RegisterType((*CollectionSpec_Derivation_Transform)(nil), "flow.CollectionSpec.Derivation.Transform")
	proto.RegisterType((*FieldSelection)(nil), "flow.FieldSelection")
	proto.RegisterMapType((map[string]encoding_json.RawMessage)(nil), "flow.FieldSelection.FieldConfigJsonMapEntry")
	proto.RegisterType((*CaptureSpec)(nil), "flow.CaptureSpec")
	proto.RegisterType((*CaptureSpec_Binding)(nil), "flow.CaptureSpec.Binding")
	proto.RegisterType((*MaterializationSpec)(nil), "flow.MaterializationSpec")
	proto.RegisterType((*MaterializationSpec_Binding)(nil), "flow.MaterializationSpec.Binding")
	proto.RegisterType((*MaterializationSpec_Binding_DeprecatedShuffle)(nil), "flow.MaterializationSpec.Binding.DeprecatedShuffle")
	proto.RegisterType((*OAuth2)(nil), "flow.OAuth2")
	proto.RegisterMapType((map[string]encoding_json.RawMessage)(nil), "flow.OAuth2.AccessTokenHeadersJsonMapEntry")
	proto.RegisterMapType((map[string]encoding_json.RawMessage)(nil), "flow.OAuth2.AccessTokenResponseJsonMapEntry")
	proto.RegisterMapType((map[string]encoding_json.RawMessage)(nil), "flow.OAuth2.RefreshTokenHeadersJsonMapEntry")
	proto.RegisterMapType((map[string]encoding_json.RawMessage)(nil), "flow.OAuth2.RefreshTokenResponseJsonMapEntry")
	proto.RegisterType((*TestSpec)(nil), "flow.TestSpec")
	proto.RegisterType((*TestSpec_Step)(nil), "flow.TestSpec.Step")
	proto.RegisterType((*RangeSpec)(nil), "flow.RangeSpec")
	proto.RegisterType((*ConnectorState)(nil), "flow.ConnectorState")
	proto.RegisterType((*ExtractAPI)(nil), "flow.ExtractAPI")
	proto.RegisterType((*ExtractAPI_Config)(nil), "flow.ExtractAPI.Config")
	proto.RegisterType((*CombineAPI)(nil), "flow.CombineAPI")
	proto.RegisterType((*CombineAPI_Config)(nil), "flow.CombineAPI.Config")
	proto.RegisterType((*CombineAPI_Stats)(nil), "flow.CombineAPI.Stats")
	proto.RegisterType((*BuildAPI)(nil), "flow.BuildAPI")
	proto.RegisterType((*BuildAPI_Config)(nil), "flow.BuildAPI.Config")
	proto.RegisterType((*ResetStateRequest)(nil), "flow.ResetStateRequest")
	proto.RegisterType((*ResetStateResponse)(nil), "flow.ResetStateResponse")
	proto.RegisterType((*AdvanceTimeRequest)(nil), "flow.AdvanceTimeRequest")
	proto.RegisterType((*AdvanceTimeResponse)(nil), "flow.AdvanceTimeResponse")
	proto.RegisterType((*DocsAndBytes)(nil), "flow.DocsAndBytes")
	proto.RegisterType((*IngestRequest)(nil), "flow.IngestRequest")
	proto.RegisterType((*IngestResponse)(nil), "flow.IngestResponse")
	proto.RegisterMapType((map[go_gazette_dev_core_broker_protocol.Journal]go_gazette_dev_core_broker_protocol.Offset)(nil), "flow.IngestResponse.JournalWriteHeadsEntry")
	proto.RegisterType((*TaskNetworkProxyRequest)(nil), "flow.TaskNetworkProxyRequest")
	proto.RegisterType((*TaskNetworkProxyRequest_Open)(nil), "flow.TaskNetworkProxyRequest.Open")
	proto.RegisterType((*TaskNetworkProxyResponse)(nil), "flow.TaskNetworkProxyResponse")
	proto.RegisterType((*TaskNetworkProxyResponse_OpenResponse)(nil), "flow.TaskNetworkProxyResponse.OpenResponse")
}

func init() { proto.RegisterFile("go/protocols/flow/flow.proto", fileDescriptor_d0677502142fec31) }

var fileDescriptor_d0677502142fec31 = []byte{
	// 3686 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x3a, 0x4d, 0x6c, 0x1b, 0xd9,
	0x79, 0x1a, 0xfe, 0xf3, 0xe3, 0x8f, 0x46, 0x4f, 0xb2, 0x4d, 0x33, 0x6b, 0x51, 0x66, 0x92, 0xae,
	0x76, 0x37, 0x4b, 0xa7, 0x32, 0x92, 0xee, 0xda, 0x70, 0x03, 0xfe, 0xc9, 0xa6, 0x4d, 0x91, 0xec,
	0x90, 0xca, 0xc6, 0x01, 0x8a, 0xc1, 0x70, 0xe6, 0x91, 0x9a, 0xd5, 0x70, 0x86, 0x9d, 0x79, 0x94,
	0xcd, 0x5c, 0x5a, 0xb4, 0x05, 0x0a, 0x2c, 0x5a, 0x20, 0x87, 0x06, 0xc9, 0xad, 0xdb, 0x00, 0x05,
	0x7a, 0xeb, 0xa5, 0x28, 0xd0, 0xf6, 0x52, 0xa0, 0x97, 0xed, 0x1f, 0x1a, 0xb4, 0xe8, 0xa5, 0x07,
	0x2f, 0x9a, 0x1e, 0x92, 0x53, 0x4f, 0x3d, 0xf9, 0x54, 0xbc, 0x9f, 0x19, 0x0e, 0x45, 0x59, 0xa2,
	0x92, 0xf4, 0x90, 0x0b, 0x31, 0xef, 0xfb, 0x9b, 0xf7, 0xbe, 0xff, 0xf9, 0x1e, 0xe1, 0xad, 0xb1,
	0x73, 0x6f, 0xea, 0x3a, 0xc4, 0xd1, 0x1d, 0xcb, 0xbb, 0x37, 0xb2, 0x9c, 0x17, 0xec, 0xa7, 0xc2,
	0x60, 0x28, 0x46, 0x9f, 0x8b, 0xbb, 0x43, 0xd7, 0x39, 0xc5, 0x6e, 0x40, 0x17, 0x3c, 0x70, 0xaa,
	0xe2, 0x9e, 0xee, 0xd8, 0xde, 0x6c, 0x72, 0x09, 0xc5, 0xce, 0xd8, 0x19, 0x3b, 0xec, 0xf1, 0x1e,
	0x7d, 0x12, 0xd0, 0xd2, 0xd8, 0x71, 0xc6, 0x16, 0xe6, 0xc4, 0xc3, 0xd9, 0xe8, 0x1e, 0x31, 0x27,
	0xd8, 0x23, 0xda, 0x64, 0xca, 0x09, 0xca, 0x8f, 0x20, 0xde, 0xb7, 0x4c, 0x1d, 0xa3, 0x1d, 0x88,
	0x0f, 0xf1, 0xd8, 0xb4, 0x0b, 0xd2, 0x9e, 0xb4, 0x9f, 0x53, 0xf8, 0x02, 0xc9, 0x10, 0xc5, 0xb6,
	0x51, 0x88, 0x30, 0x18, 0x7d, 0x7c, 0x90, 0xfd, 0xd1, 0x9f, 0x96, 0x36, 0xbe, 0xfb, 0xc3, 0xd2,
	0xc6, 0x0f, 0x7e, 0x58, 0xda, 0x28, 0xdb, 0x90, 0x3e, 0x3e, 0x6e, 0x35, 0x7a, 0x9a, 0x4b, 0x3c,
	0x84, 0x20, 0x66, 0x3b, 0x06, 0x66, 0x12, 0x12, 0x0a, 0x7b, 0x46, 0x0f, 0x21, 0xae, 0x5b, 0x8e,
	0x7e, 0xca, 0x44, 0x24, 0x6a, 0x5f, 0x7e, 0xfd, 0xaa, 0x74, 0x77, 0xec, 0x54, 0xc6, 0xda, 0x77,
	0x30, 0x21, 0xb8, 0x62, 0xe0, 0xb3, 0x7b, 0xba, 0xe3, 0xe2, 0x7b, 0x13, 0xec, 0x79, 0xda, 0x18,
	0x57, 0xea, 0x94, 0x58, 0xe1, 0x3c, 0x0f, 0xe4, 0x9f, 0x7e, 0x5a, 0x92, 0x96, 0xde, 0xf7, 0x1f,
	0x12, 0x40, 0xcf, 0x75, 0x3e, 0xc6, 0x3a, 0x31, 0x1d, 0xb6, 0xbd, 0x29, 0x71, 0xd9, 0x0b, 0xd3,
	0x0a, 0x7d, 0xa4, 0xc7, 0x18, 0x99, 0xd8, 0xe2, 0x5b, 0x4e, 0x2b, 0x7c, 0x81, 0x8a, 0x90, 0xc2,
	0x2f, 0xa7, 0x96, 0xa9, 0x9b, 0xa4, 0x10, 0xdd, 0x93, 0xf6, 0x53, 0x4a, 0xb0, 0x46, 0xfb, 0x20,
	0x9b, 0x9e, 0x3a, 0xd5, 0x5c, 0x62, 0x52, 0x99, 0xea, 0x29, 0x9e, 0x17, 0x62, 0x8c, 0x26, 0x6f,
	0x7a, 0x3d, 0x1f, 0xfc, 0x0c, 0xcf, 0xd1, 0x97, 0x20, 0x4f, 0x29, 0x5d, 0x73, 0xa2, 0xb9, 0x73,
	0x46, 0x17, 0x67, 0x74, 0x59, 0xd3, 0xeb, 0x71, 0x20, 0xa5, 0xba, 0x0f, 0x69, 0xd3, 0x1e, 0x61,
	0x17, 0xdb, 0x3a, 0x2e, 0x24, 0xf6, 0xa4, 0xfd, 0xcc, 0xc1, 0x66, 0x85, 0x19, 0xbc, 0xe5, 0x83,
	0x6b, 0xb1, 0xcf, 0x5e, 0x95, 0x36, 0x94, 0x05, 0x5d, 0xf9, 0x7f, 0xa3, 0x90, 0x0e, 0xd0, 0xf4,
	0x10, 0x64, 0x3e, 0xc5, 0x5e, 0x41, 0xda, 0x8b, 0xd2, 0x43, 0xb0, 0x05, 0xaa, 0x40, 0xc2, 0x23,
	0xae, 0x69, 0x8f, 0xd9, 0x11, 0x32, 0x07, 0x37, 0xcf, 0x49, 0xad, 0xf4, 0x19, 0x56, 0x11, 0x54,
	0x4c, 0x8a, 0x49, 0x2c, 0xcc, 0x4e, 0x43, 0xa5, 0xd0, 0x05, 0xda, 0x83, 0x8c, 0x81, 0x3d, 0xdd,
	0x35, 0xa7, 0xf4, 0x58, 0xec, 0x04, 0x69, 0x25, 0x0c, 0x42, 0x0f, 0x21, 0x6b, 0xe0, 0x91, 0x36,
	0xb3, 0x88, 0xfa, 0xb1, 0xe7, 0xd8, 0xec, 0x0c, 0xe9, 0xda, 0x5b, 0xaf, 0x5f, 0x95, 0x0a, 0xd8,
	0xd6, 0x1d, 0xc3, 0xb4, 0xc7, 0xf7, 0x28, 0xa2, 0xa2, 0x68, 0x2f, 0x8e, 0xb8, 0xd9, 0x94, 0xa4,
	0xe0, 0x40, 0x37, 0x21, 0xe1, 0x61, 0xdd, 0xc5, 0xa4, 0x90, 0x64, 0xba, 0x11, 0x2b, 0xba, 0x79,
	0xfc, 0xd2, 0xf4, 0x88, 0x57, 0x48, 0xed, 0x49, 0xfb, 0xf9, 0xd5, 0xcd, 0x37, 0x19, 0x56, 0x11,
	0x54, 0xc5, 0x3f, 0x91, 0x20, 0xc1, 0xcf, 0x83, 0xee, 0x42, 0x56, 0x77, 0x6c, 0x82, 0x6d, 0xa2,
	0x52, 0x45, 0xb0, 0xd3, 0xa7, 0x95, 0x8c, 0x80, 0x0d, 0xe6, 0x53, 0x4c, 0xdf, 0x3a, 0x72, 0xdc,
	0x89, 0x46, 0xc4, 0x59, 0xc5, 0x0a, 0xbd, 0x03, 0xb2, 0xcf, 0xea, 0x6f, 0x9d, 0xed, 0x2b, 0xad,
	0x6c, 0x0a, 0x78, 0x53, 0x80, 0xd1, 0x1d, 0x80, 0x89, 0xf6, 0x52, 0xb5, 0xb0, 0x3d, 0x26, 0x27,
	0xec, 0xcc, 0x39, 0x25, 0x3d, 0xd1, 0x5e, 0xb6, 0x19, 0xe0, 0x69, 0x2c, 0x25, 0xc9, 0x91, 0xa7,
	0xb1, 0x54, 0x44, 0x8e, 0x3e, 0x8d, 0xa5, 0xe2, 0x72, 0xa2, 0x5c, 0x83, 0x04, 0xdf, 0x33, 0xca,
	0x40, 0xb2, 0xd5, 0xf9, 0x66, 0xb5, 0xdd, 0x6a, 0xc8, 0x1b, 0x28, 0x05, 0xb1, 0xa3, 0xe3, 0xfe,
	0x40, 0x96, 0x50, 0x12, 0xa2, 0x47, 0xd5, 0xe7, 0x72, 0x04, 0x65, 0x21, 0xd5, 0x3a, 0xea, 0xb5,
	0x5b, 0xf5, 0xd6, 0x40, 0x8e, 0x22, 0x80, 0x44, 0xbd, 0xda, 0xe9, 0x74, 0x07, 0x72, 0xac, 0xfc,
	0x1c, 0x32, 0x1d, 0x4c, 0x5e, 0x38, 0xee, 0x69, 0xcf, 0x71, 0x99, 0xf2, 0xec, 0xd9, 0x64, 0x88,
	0x5d, 0x11, 0x84, 0x62, 0x45, 0xdd, 0xd7, 0x8f, 0x76, 0xe1, 0xd7, 0xc1, 0x9a, 0xf2, 0x4c, 0x67,
	0x43, 0xcb, 0xd4, 0x85, 0x63, 0x8b, 0x55, 0xf9, 0x5f, 0xf3, 0x90, 0xaf, 0x3b, 0x96, 0xc5, 0x23,
	0xa5, 0x3f, 0xc5, 0x3a, 0x2a, 0x43, 0xcc, 0xd6, 0x26, 0x3c, 0x3e, 0xd3, 0xb5, 0xfc, 0xeb, 0x57,
	0x25, 0x58, 0x50, 0x28, 0x0c, 0x87, 0x1a, 0xb0, 0xf5, 0xc2, 0x35, 0x09, 0x56, 0x3d, 0xfd, 0x04,
	0x4f, 0x34, 0xee, 0x01, 0xa9, 0x35, 0x3c, 0x20, 0xc3, 0xd8, 0xfa, 0x8c, 0x0b, 0xd5, 0x40, 0x76,
	0xb1, 0x66, 0x2c, 0x09, 0xc9, 0xac, 0x21, 0x04, 0x28, 0x97, 0x90, 0x21, 0x43, 0x94, 0x86, 0x58,
	0x94, 0x85, 0x00, 0x7d, 0x44, 0xb7, 0x21, 0x35, 0x9b, 0x99, 0x86, 0x4a, 0x43, 0x9e, 0xdb, 0x39,
	0x49, 0xd7, 0x3d, 0xe2, 0x52, 0x43, 0x2f, 0x22, 0x98, 0xc5, 0xbc, 0x57, 0x88, 0x33, 0xce, 0xcd,
	0x00, 0x7e, 0xc8, 0xc0, 0xe8, 0x03, 0xc8, 0x4c, 0x83, 0x0c, 0xe2, 0x15, 0x12, 0x7b, 0xd1, 0xfd,
	0xcc, 0x81, 0xcc, 0xdd, 0x71, 0x91, 0x5a, 0x44, 0x88, 0x86, 0x49, 0xa9, 0x6e, 0x34, 0xfd, 0x54,
	0x25, 0x78, 0x32, 0xb5, 0x34, 0x82, 0xf9, 0xb1, 0x92, 0xeb, 0xe8, 0x46, 0xd3, 0x4f, 0x07, 0x82,
	0x0b, 0x35, 0x00, 0x2d, 0xb6, 0xea, 0xcb, 0x2a, 0xa4, 0x59, 0x48, 0xdf, 0xa8, 0x04, 0x59, 0xfd,
	0xa9, 0x33, 0x73, 0x6d, 0xcd, 0xa2, 0x86, 0x53, 0xb6, 0x02, 0x86, 0x40, 0xca, 0x37, 0x00, 0x0c,
	0xec, 0x9a, 0x67, 0x1a, 0x8b, 0xe2, 0x2c, 0xe3, 0x2e, 0xf1, 0x43, 0x2c, 0x5b, 0xbd, 0xd2, 0x08,
	0xc8, 0x94, 0x10, 0x4b, 0xf1, 0x2f, 0x00, 0x60, 0x81, 0x42, 0x03, 0xc8, 0xeb, 0x8e, 0x6d, 0x63,
	0x9d, 0x38, 0x2e, 0x0f, 0x33, 0x89, 0xc5, 0xe9, 0xfb, 0x57, 0xc8, 0xac, 0xd4, 0x7d, 0x2e, 0x1a,
	0x88, 0x4a, 0x4e, 0x0f, 0x2f, 0xd1, 0x87, 0x40, 0xc3, 0x74, 0x64, 0x8e, 0xb9, 0xae, 0x22, 0x6b,
	0xe8, 0x2a, 0xc1, 0x19, 0x50, 0x17, 0x80, 0xb8, 0x9a, 0xed, 0xd1, 0x48, 0xf6, 0x98, 0x17, 0x64,
	0x0e, 0xde, 0xb9, 0x6a, 0x33, 0x03, 0x9f, 0x43, 0x98, 0x2f, 0x24, 0x02, 0x7d, 0x04, 0x5b, 0xde,
	0xc9, 0x6c, 0x34, 0xb2, 0x30, 0x4d, 0xdd, 0x2a, 0x4f, 0xb0, 0xb1, 0xbd, 0xe8, 0x7e, 0xfe, 0xe0,
	0xbd, 0xab, 0xe4, 0xf6, 0x39, 0x23, 0x3b, 0xe2, 0xa6, 0x90, 0xf2, 0x0c, 0xcf, 0x07, 0x2c, 0x2f,
	0x3f, 0x80, 0xbc, 0x77, 0xa2, 0xb9, 0xc6, 0xc2, 0x98, 0x71, 0x66, 0x8e, 0xed, 0x8a, 0x5f, 0xb4,
	0x2b, 0x7d, 0x8a, 0x67, 0xa6, 0xcc, 0x31, 0xd2, 0xc0, 0x8c, 0x2d, 0xb8, 0xe1, 0x62, 0xdd, 0x39,
	0xc3, 0xee, 0x5c, 0xb5, 0x9c, 0xf1, 0x42, 0x44, 0xe2, 0x32, 0x7f, 0xd8, 0xf6, 0x79, 0xda, 0xce,
	0x38, 0x10, 0xf5, 0x75, 0xc8, 0xd9, 0x3c, 0x97, 0xa8, 0x53, 0xc7, 0x25, 0x5e, 0x21, 0xc9, 0x74,
	0xb6, 0xc5, 0xcf, 0x16, 0x4a, 0x33, 0x4a, 0xd6, 0x5e, 0x2c, 0xbc, 0xe2, 0xef, 0xc5, 0x21, 0x1d,
	0xe8, 0x0d, 0xdd, 0x5d, 0xca, 0x11, 0xb9, 0xd7, 0xaf, 0x4a, 0x0b, 0xa4, 0x48, 0x11, 0x0f, 0x00,
	0xf4, 0x40, 0x53, 0xcc, 0xa6, 0x99, 0x83, 0x9d, 0x8b, 0x34, 0xe8, 0x1b, 0x61, 0x41, 0x8d, 0xda,
	0x61, 0xe7, 0xf7, 0xb0, 0xc5, 0x5c, 0x45, 0xd4, 0xb3, 0x5b, 0x8b, 0xc3, 0xb6, 0xb5, 0x21, 0xb6,
	0xfa, 0x02, 0x2d, 0xc4, 0x2c, 0x82, 0xc0, 0x47, 0xf0, 0xbc, 0x68, 0x3a, 0xae, 0x49, 0x78, 0xc9,
	0xce, 0x29, 0xc1, 0x1a, 0x7d, 0x05, 0x10, 0x4b, 0x41, 0x06, 0xb6, 0xb4, 0xb9, 0xea, 0x61, 0xdd,
	0xb1, 0x59, 0x4e, 0xa0, 0x54, 0x2c, 0x39, 0x35, 0x28, 0xa2, 0xcf, 0xe1, 0xa8, 0x04, 0x99, 0x90,
	0x73, 0xb0, 0xa4, 0x90, 0x56, 0x60, 0x61, 0x69, 0x74, 0x0c, 0x45, 0x9f, 0xc0, 0xd2, 0x26, 0x43,
	0x43, 0x53, 0xc3, 0x8e, 0xbd, 0x4e, 0x12, 0xd8, 0x16, 0xfc, 0x6d, 0xc6, 0x5e, 0xe7, 0x5e, 0x7e,
	0x08, 0xe8, 0x02, 0x71, 0xeb, 0xe4, 0xdb, 0xac, 0x15, 0x96, 0xf3, 0x05, 0x48, 0xb3, 0xd3, 0x3a,
	0xb6, 0x35, 0x67, 0xb9, 0x24, 0xa5, 0xa4, 0x28, 0xa0, 0x6b, 0x5b, 0x73, 0x54, 0x81, 0xed, 0x8f,
	0xb9, 0xf7, 0xa8, 0x3c, 0x2b, 0xcf, 0x46, 0x23, 0xf3, 0x65, 0x01, 0x58, 0x0a, 0xdd, 0x12, 0x28,
	0x85, 0x66, 0x5e, 0x86, 0x40, 0x1f, 0x02, 0xd8, 0x0e, 0x51, 0x87, 0x78, 0xe4, 0xb8, 0x98, 0xe5,
	0xed, 0xcc, 0x41, 0xb1, 0xc2, 0x3b, 0xc9, 0x8a, 0xdf, 0x49, 0x56, 0x06, 0x7e, 0x27, 0xa9, 0xa4,
	0x6d, 0x87, 0xd4, 0x18, 0x31, 0xfa, 0x35, 0xa0, 0x0b, 0x55, 0x1b, 0x11, 0xec, 0x8a, 0xac, 0x74,
	0x19, 0x67, 0xca, 0x76, 0x48, 0x95, 0xd2, 0x96, 0x15, 0xc8, 0x2d, 0x65, 0x12, 0x54, 0x84, 0x9b,
	0xa2, 0xa8, 0xaa, 0xf5, 0x6e, 0xa7, 0xd3, 0xac, 0x0f, 0xba, 0x8a, 0x3a, 0x78, 0xde, 0x6b, 0xca,
	0x1b, 0xb4, 0x84, 0xf6, 0x7f, 0xa3, 0xdd, 0x1a, 0x34, 0x65, 0x09, 0xe5, 0x01, 0x28, 0xb4, 0x5f,
	0x57, 0x5a, 0xbd, 0x81, 0x1c, 0x41, 0x69, 0x88, 0xb7, 0x8e, 0xaa, 0x8f, 0x9b, 0x72, 0xb4, 0x7c,
	0x04, 0x99, 0x50, 0xe0, 0xa2, 0x02, 0xec, 0xf8, 0x12, 0xfb, 0x4f, 0x8e, 0x0f, 0x0f, 0xdb, 0x4d,
	0x5f, 0x5e, 0x06, 0x92, 0xb5, 0x6e, 0xb7, 0xdd, 0xac, 0x76, 0x64, 0x89, 0x57, 0xf3, 0x41, 0xf3,
	0x71, 0x53, 0x91, 0x23, 0xec, 0x4d, 0x03, 0xa5, 0xd5, 0x79, 0x2c, 0x47, 0xcb, 0xdf, 0x8f, 0x40,
	0x9e, 0xd5, 0x10, 0xee, 0x7f, 0xd4, 0x9d, 0x11, 0xc4, 0x4e, 0xf1, 0xdc, 0xef, 0xd3, 0xd8, 0x33,
	0x2d, 0xc8, 0x67, 0x9a, 0x35, 0xc3, 0x5e, 0x21, 0xc2, 0xa0, 0x62, 0x45, 0x9d, 0xd5, 0x70, 0xf4,
	0xd9, 0x04, 0xdb, 0x44, 0xb4, 0x30, 0xc1, 0x1a, 0x9d, 0xc1, 0x0d, 0x56, 0xb4, 0xc2, 0x5e, 0xa0,
	0x4e, 0xb4, 0x29, 0xcb, 0x4f, 0x99, 0x83, 0xaf, 0xf0, 0xe8, 0x5a, 0x7e, 0x39, 0x5f, 0x72, 0xfb,
	0x3f, 0xf5, 0x1c, 0xfb, 0x48, 0x9b, 0x36, 0x6d, 0xe2, 0xce, 0x6b, 0x6f, 0x7d, 0xf2, 0xf9, 0x65,
	0xb5, 0x68, 0xb4, 0x60, 0x2b, 0x36, 0xe1, 0xd6, 0x1b, 0xa4, 0xf8, 0xe5, 0x57, 0xb4, 0xd6, 0xb4,
	0xfc, 0xee, 0x40, 0x9c, 0x1d, 0xc5, 0x6f, 0xad, 0xd9, 0xe2, 0x41, 0xe4, 0x03, 0xa9, 0xfc, 0x97,
	0x71, 0xc8, 0xd4, 0xb5, 0x29, 0x99, 0xb9, 0x98, 0x35, 0x1a, 0xa5, 0xa5, 0x24, 0x92, 0x79, 0xfd,
	0xaa, 0x94, 0x14, 0x68, 0x91, 0x42, 0x0e, 0x57, 0xaa, 0x4d, 0x84, 0x55, 0x1b, 0xbf, 0x82, 0x2d,
	0x64, 0x5d, 0xab, 0xbe, 0x44, 0xaf, 0x51, 0x5f, 0xbe, 0x06, 0xa9, 0xa1, 0x69, 0x53, 0x12, 0x4f,
	0x68, 0xf9, 0xf6, 0xea, 0xcb, 0x6b, 0x9c, 0x42, 0x09, 0x48, 0x69, 0xa3, 0x61, 0xda, 0x04, 0xbb,
	0x67, 0x9a, 0x75, 0x2e, 0xa9, 0x6c, 0xfa, 0x70, 0x3f, 0xa7, 0xac, 0xd6, 0x85, 0xc4, 0xcf, 0x5f,
	0x17, 0x92, 0x3f, 0x7f, 0x5d, 0x48, 0xad, 0x57, 0x17, 0xfe, 0x4a, 0x82, 0xa4, 0x38, 0x3f, 0x7a,
	0x0a, 0x3b, 0x2e, 0xf6, 0x9c, 0x99, 0xab, 0xe3, 0xa5, 0x44, 0x25, 0xad, 0xa1, 0xf0, 0xbc, 0xcf,
	0x29, 0x52, 0xd5, 0x17, 0x21, 0x17, 0xc8, 0x9a, 0x6a, 0xe4, 0x44, 0x84, 0x49, 0xd6, 0x07, 0xf6,
	0x34, 0x72, 0x72, 0xae, 0xc6, 0x44, 0xaf, 0x53, 0x63, 0xca, 0x6f, 0x9f, 0x4f, 0x25, 0x4b, 0xfd,
	0x79, 0x90, 0x1f, 0x92, 0xe5, 0x3f, 0x06, 0xd8, 0x3e, 0xd2, 0x08, 0x76, 0x4d, 0xcd, 0x32, 0xbf,
	0xa3, 0x05, 0x7d, 0xf2, 0xdb, 0x4b, 0xee, 0xbb, 0xfd, 0xfa, 0x55, 0x69, 0xf3, 0x1c, 0x99, 0x70,
	0xe3, 0xce, 0x1b, 0xdc, 0xf8, 0x6d, 0xbe, 0xd3, 0x0b, 0x64, 0xff, 0xbf, 0xb9, 0xf3, 0xa3, 0x15,
	0x77, 0xbe, 0xfb, 0xe6, 0x4d, 0xac, 0xba, 0xf5, 0x2f, 0x79, 0x0f, 0xf3, 0xbd, 0xc4, 0x2f, 0xa7,
	0xaf, 0xbe, 0xa1, 0x1f, 0x4a, 0xfe, 0x02, 0xfa, 0xa1, 0xf4, 0xb9, 0x7e, 0xa8, 0x0e, 0x9b, 0xbc,
	0xc4, 0x78, 0x7e, 0x01, 0x61, 0x2d, 0x53, 0xb0, 0xd5, 0xe5, 0xe2, 0x22, 0xde, 0x91, 0x1f, 0x2d,
	0xd7, 0xbb, 0x2f, 0x42, 0xce, 0xc0, 0x16, 0xd1, 0xd4, 0xd9, 0xd4, 0xd0, 0x08, 0xf6, 0xfc, 0x01,
	0x08, 0x03, 0x1e, 0x73, 0x18, 0x1a, 0x02, 0x32, 0xf0, 0xd4, 0xc5, 0xba, 0x46, 0xb0, 0xa1, 0x8a,
	0xae, 0x47, 0x38, 0xc3, 0xfd, 0x2b, 0x9d, 0xb2, 0xd2, 0x08, 0x78, 0x45, 0xf1, 0x56, 0xb6, 0x8c,
	0xf3, 0xa0, 0x37, 0xb5, 0x34, 0xa9, 0xf5, 0x5a, 0x1a, 0xf8, 0x99, 0x5b, 0x9a, 0xcc, 0xfa, 0x2d,
	0x4d, 0xf1, 0x77, 0x24, 0xd8, 0x5a, 0x39, 0x0c, 0xba, 0x03, 0x30, 0x76, 0x9d, 0xd9, 0x54, 0x5d,
	0xa4, 0x18, 0x25, 0xcd, 0x20, 0x1d, 0x9a, 0x52, 0x7e, 0xa1, 0x0d, 0x72, 0xf9, 0xfe, 0xa5, 0xa9,
	0x70, 0xd1, 0x46, 0x85, 0xda, 0xa6, 0x54, 0xf9, 0x7f, 0xd2, 0x90, 0xe8, 0x56, 0x67, 0xe4, 0xe4,
	0x40, 0x0c, 0x1e, 0xce, 0x4c, 0x03, 0xfb, 0x43, 0xb6, 0x60, 0x8d, 0xde, 0x85, 0x2d, 0x6d, 0x46,
	0x4e, 0xd4, 0x99, 0x6b, 0x2d, 0x42, 0x9e, 0xb7, 0x06, 0x9b, 0x14, 0x71, 0xec, 0x5a, 0x41, 0x5c,
	0x7f, 0x08, 0xb7, 0x35, 0x5d, 0xc7, 0x9e, 0xa7, 0x12, 0xe7, 0x14, 0xdb, 0xcb, 0x3c, 0xbc, 0x19,
	0xba, 0xc9, 0x09, 0x06, 0x14, 0x1f, 0x66, 0xad, 0xc0, 0xf6, 0x12, 0xeb, 0x04, 0x93, 0x13, 0xc7,
	0xe0, 0xd3, 0x04, 0x65, 0x2b, 0xc4, 0x74, 0xc4, 0x10, 0x6c, 0x5b, 0x61, 0xfa, 0xa1, 0x63, 0xcc,
	0xc5, 0xb4, 0x60, 0x33, 0x44, 0x5d, 0x73, 0x8c, 0x39, 0xfa, 0x7d, 0x09, 0xee, 0x2c, 0x11, 0x9f,
	0x60, 0xcd, 0xc0, 0xae, 0xb7, 0xe8, 0xbf, 0xe2, 0x2c, 0xff, 0x88, 0xef, 0x43, 0xae, 0x94, 0x4a,
	0x75, 0x21, 0xe5, 0x09, 0xa7, 0xbf, 0x46, 0xfb, 0x85, 0xb4, 0x15, 0x6e, 0xf4, 0x89, 0x04, 0xbb,
	0x4b, 0xdb, 0x70, 0xb1, 0x37, 0x75, 0x6c, 0x0f, 0x2f, 0xf6, 0x91, 0x08, 0xf7, 0x81, 0xab, 0xfb,
	0x50, 0x04, 0xc3, 0x35, 0x36, 0x12, 0xd6, 0xb7, 0xcf, 0x7e, 0xa4, 0x4d, 0xd1, 0x43, 0x28, 0xba,
	0x78, 0xe4, 0x62, 0xef, 0xe4, 0x22, 0x5b, 0xf1, 0xe1, 0xd9, 0x2d, 0x41, 0xb1, 0x62, 0xac, 0xaf,
	0xd2, 0xdc, 0x1b, 0x66, 0x16, 0xd6, 0xca, 0x32, 0x36, 0x14, 0x66, 0x13, 0xe6, 0x62, 0x9f, 0x69,
	0x61, 0x0e, 0x66, 0x2f, 0x1e, 0xc7, 0x72, 0x98, 0x9e, 0x19, 0xec, 0x0f, 0x24, 0xd8, 0x5d, 0x26,
	0x5f, 0xb1, 0x58, 0xfa, 0x02, 0x4d, 0x29, 0x21, 0x39, 0xd7, 0x37, 0xd9, 0xb6, 0xbb, 0xca, 0x8e,
	0xfe, 0x48, 0x82, 0xd2, 0xf2, 0x4e, 0x56, 0x8d, 0x06, 0x6c, 0x2b, 0xef, 0xbf, 0x71, 0x2b, 0x3f,
	0x83, 0xd5, 0x96, 0x34, 0x1f, 0x32, 0x5b, 0xb1, 0x0d, 0xbb, 0x97, 0xfb, 0xe5, 0x75, 0x1a, 0xfa,
	0xe2, 0x11, 0x94, 0xae, 0xf0, 0xae, 0xeb, 0x8a, 0xbb, 0xc2, 0x04, 0xd7, 0x12, 0xd7, 0x81, 0xbd,
	0xab, 0xd4, 0x78, 0xad, 0xcf, 0x97, 0xbf, 0x8e, 0x42, 0x6a, 0x80, 0x3d, 0xc2, 0x9a, 0x3f, 0x14,
	0x6e, 0xfe, 0x44, 0x9f, 0x77, 0x0f, 0xe2, 0x1e, 0xc1, 0x53, 0xfe, 0x45, 0x47, 0x9b, 0x22, 0x66,
	0x51, 0x9f, 0xa5, 0xd2, 0x27, 0x78, 0x2a, 0x72, 0x30, 0xa7, 0x2b, 0xfe, 0x24, 0x02, 0x31, 0x0a,
	0x45, 0x5f, 0x83, 0x34, 0x85, 0x84, 0x27, 0x6a, 0x85, 0x0b, 0xb8, 0x2b, 0xac, 0x1b, 0x4c, 0x51,
	0x52, 0x96, 0xa6, 0xef, 0x00, 0x30, 0x36, 0xd3, 0x36, 0xf0, 0x4b, 0x71, 0xfb, 0xc2, 0x04, 0xb5,
	0x28, 0xe0, 0xfc, 0x0c, 0x3f, 0xba, 0x3a, 0xc3, 0xf7, 0x05, 0x78, 0xba, 0x33, 0xf5, 0x2f, 0x00,
	0x98, 0x80, 0x3e, 0x05, 0xa0, 0xca, 0x52, 0xcb, 0x12, 0xbf, 0x70, 0x1e, 0x1c, 0x6e, 0x53, 0x3e,
	0x84, 0x9c, 0xe1, 0xe8, 0x22, 0xca, 0xce, 0xb0, 0xce, 0x07, 0x24, 0x57, 0x34, 0x53, 0x31, 0xca,
	0x82, 0x1e, 0x01, 0x04, 0x75, 0xc9, 0x5b, 0xaf, 0xb3, 0x09, 0x31, 0x94, 0x77, 0x21, 0xc6, 0x34,
	0x02, 0x90, 0x68, 0x75, 0x1e, 0x37, 0xfb, 0x03, 0x5e, 0xb7, 0xbe, 0xd9, 0x54, 0x5a, 0x87, 0xcf,
	0x65, 0xa9, 0xfc, 0x7d, 0x09, 0xd2, 0x8a, 0x66, 0x8f, 0xf9, 0x87, 0xe7, 0x17, 0x20, 0x7d, 0x8a,
	0xe7, 0x2a, 0xbf, 0xc8, 0xa2, 0x6a, 0x4b, 0x2a, 0xa9, 0x53, 0x3c, 0xaf, 0xb1, 0xbb, 0xac, 0x5b,
	0x90, 0xa4, 0x48, 0x6c, 0x1b, 0x4c, 0x63, 0x49, 0x25, 0x71, 0x8a, 0xe7, 0x4d, 0xdb, 0x40, 0x65,
	0xc8, 0xb9, 0x2a, 0xbb, 0x71, 0x12, 0x9c, 0x31, 0x86, 0xce, 0xb8, 0xec, 0x32, 0x8a, 0x33, 0xef,
	0x42, 0xc6, 0xa7, 0xa1, 0x02, 0xe2, 0x8c, 0x22, 0xcd, 0x29, 0x9a, 0xb6, 0xf1, 0x40, 0xfe, 0xc1,
	0xa7, 0xa5, 0x8d, 0x73, 0x57, 0x63, 0xf9, 0xa0, 0xf6, 0xf6, 0x09, 0xcd, 0x8e, 0x0f, 0x21, 0xcb,
	0xfb, 0x26, 0x63, 0xfd, 0x8e, 0x34, 0x29, 0x38, 0x50, 0x09, 0x32, 0x13, 0xec, 0x8e, 0x59, 0x1f,
	0xaa, 0x9f, 0xb0, 0xc3, 0xa5, 0x14, 0x60, 0xa0, 0x1e, 0x85, 0x94, 0xff, 0x2c, 0x02, 0xd0, 0x7c,
	0x49, 0x5c, 0x4d, 0x27, 0xd5, 0x5e, 0xab, 0xf8, 0xb7, 0x12, 0x24, 0x44, 0x17, 0x1b, 0x9e, 0x9b,
	0x4b, 0xcb, 0x73, 0xf3, 0x47, 0x90, 0x09, 0xcf, 0xe8, 0xd7, 0x19, 0xd0, 0x02, 0x67, 0xa0, 0xd1,
	0x46, 0xdd, 0x8c, 0x37, 0x95, 0x53, 0xe2, 0x7a, 0x62, 0x54, 0x9f, 0x66, 0x90, 0x1e, 0x71, 0x57,
	0x46, 0xed, 0xb1, 0xb5, 0x47, 0xed, 0xe5, 0xe7, 0x10, 0xab, 0x3b, 0xc6, 0xb9, 0x7e, 0x25, 0x07,
	0xe9, 0x7a, 0xb7, 0x73, 0xd8, 0x7a, 0x7c, 0xac, 0x34, 0xf9, 0xa0, 0xa6, 0xf9, 0xad, 0x81, 0x52,
	0xad, 0x0f, 0xe4, 0x08, 0x42, 0x90, 0x17, 0x8b, 0x66, 0x43, 0x3d, 0x3e, 0x6e, 0x35, 0xe4, 0x28,
	0xda, 0x01, 0x79, 0x01, 0x3b, 0x6c, 0x35, 0xdb, 0x8d, 0xbe, 0x1c, 0x2b, 0x7f, 0x1a, 0x07, 0xa8,
	0x3b, 0x93, 0xa1, 0x69, 0x63, 0xa6, 0xa7, 0x48, 0xa0, 0xa7, 0x73, 0xca, 0x90, 0xae, 0xa9, 0x8c,
	0xdb, 0x40, 0x7d, 0x8d, 0xab, 0x82, 0x7f, 0x27, 0x50, 0x7f, 0x63, 0x8a, 0xb8, 0x09, 0x09, 0x71,
	0x29, 0xc1, 0x75, 0x24, 0x56, 0xb4, 0x5e, 0x72, 0xcb, 0x58, 0x9a, 0x8e, 0x4f, 0x1c, 0xcb, 0xc0,
	0x6e, 0xe8, 0x76, 0x03, 0x31, 0x2b, 0x2d, 0x50, 0xd4, 0x60, 0xe7, 0x54, 0x1a, 0x5f, 0xff, 0xf6,
	0xe2, 0x6d, 0xd8, 0x5c, 0x44, 0x34, 0xef, 0x3e, 0xd9, 0xcd, 0x9e, 0x92, 0x5f, 0x80, 0x59, 0x0b,
	0xfa, 0x2e, 0x6c, 0xb1, 0x8b, 0xc9, 0xa5, 0xdb, 0x1b, 0x71, 0x6b, 0xc6, 0x10, 0xfd, 0xe0, 0xcc,
	0xc5, 0xdf, 0x86, 0x38, 0xf5, 0x6d, 0x0f, 0xfd, 0x0a, 0xc4, 0x2c, 0x3c, 0x22, 0x4c, 0x69, 0x99,
	0x03, 0xc4, 0x37, 0xd4, 0x70, 0x74, 0xaf, 0x6a, 0x1b, 0xb5, 0x39, 0xc1, 0x9e, 0xc2, 0xf0, 0x68,
	0x1f, 0xe2, 0xae, 0x39, 0x3e, 0x21, 0x62, 0x6e, 0x7c, 0x11, 0x21, 0x27, 0x40, 0x5f, 0x82, 0xa8,
	0x33, 0x23, 0xa2, 0xf5, 0xbd, 0x88, 0x8e, 0xa2, 0xcb, 0xff, 0x26, 0xad, 0xe1, 0x29, 0x9b, 0x90,
	0x51, 0x9a, 0x8d, 0xe3, 0x7a, 0x53, 0x6d, 0x37, 0x0f, 0xa9, 0xb7, 0x6c, 0x41, 0xae, 0xde, 0x3d,
	0xaa, 0xb5, 0x3a, 0x4d, 0x55, 0x69, 0x3d, 0x7e, 0x32, 0x90, 0xa3, 0x48, 0x86, 0x4c, 0x43, 0xa9,
	0xb6, 0x3a, 0x6a, 0xfd, 0xc9, 0x71, 0xe7, 0x99, 0xfc, 0x99, 0x84, 0x76, 0xe1, 0x36, 0x83, 0x34,
	0x1b, 0xaa, 0x20, 0x6e, 0xa8, 0x8d, 0x6e, 0xfd, 0xf8, 0xa8, 0xd9, 0x19, 0xc8, 0xff, 0x20, 0xa1,
	0x3b, 0x50, 0xf0, 0xf1, 0x5c, 0x7a, 0x08, 0xfd, 0x8f, 0x52, 0x20, 0xb0, 0xd9, 0x50, 0x9f, 0x35,
	0x9f, 0xcb, 0xff, 0x24, 0xa1, 0x6d, 0xc8, 0xfb, 0x10, 0xe1, 0x8d, 0xff, 0x2c, 0x21, 0x04, 0x39,
	0x1f, 0xd8, 0x1f, 0x54, 0x07, 0x7d, 0xf9, 0x5f, 0xa4, 0xf2, 0x4f, 0x24, 0x48, 0xd5, 0x66, 0xa6,
	0x65, 0x50, 0x07, 0xfd, 0xcf, 0xa5, 0x40, 0x1e, 0x52, 0xb0, 0x6a, 0x1a, 0x7e, 0x20, 0xb3, 0x75,
	0xcb, 0x58, 0xa0, 0x8c, 0xa1, 0x28, 0x70, 0x1c, 0xd5, 0x18, 0xb2, 0x2b, 0x59, 0xf6, 0xb5, 0x2a,
	0x0a, 0x85, 0x58, 0xa1, 0x03, 0xc8, 0x88, 0x4f, 0x5b, 0x56, 0x9d, 0x62, 0xac, 0x3a, 0x6d, 0xf9,
	0x1f, 0xae, 0xc1, 0xe5, 0xaa, 0x02, 0x9c, 0x8a, 0xa5, 0xe1, 0xf7, 0x60, 0x6b, 0x31, 0xf1, 0x10,
	0x9f, 0xe0, 0xe2, 0x0e, 0x59, 0x0e, 0x10, 0xe2, 0x3b, 0x1d, 0xdd, 0x85, 0xac, 0x70, 0x40, 0xd5,
	0x75, 0x1c, 0x22, 0xdc, 0xcd, 0x77, 0x4a, 0xc5, 0x71, 0x48, 0x79, 0x1b, 0xb6, 0x14, 0xec, 0x61,
	0xc2, 0x12, 0xa4, 0x82, 0x7f, 0x6b, 0x86, 0x3d, 0x52, 0xde, 0x01, 0x14, 0x06, 0xf2, 0xea, 0x5e,
	0x7e, 0x04, 0xa8, 0x6a, 0x9c, 0x69, 0xb6, 0x8e, 0xe9, 0xc7, 0x96, 0xa0, 0xa5, 0x5e, 0xad, 0x71,
	0x68, 0x30, 0x8e, 0xa3, 0x9a, 0x89, 0x29, 0x79, 0x01, 0x16, 0xd3, 0xb8, 0xf2, 0x0d, 0xd8, 0x5e,
	0x62, 0x17, 0x52, 0x3f, 0x80, 0x6c, 0xd8, 0xa9, 0x68, 0xf9, 0xa7, 0x65, 0x4b, 0x5c, 0xc0, 0xf2,
	0x12, 0xb6, 0x03, 0xf1, 0x21, 0x45, 0x32, 0xc5, 0xc6, 0x14, 0xbe, 0x28, 0x7f, 0x4f, 0x82, 0x5c,
	0xcb, 0x1e, 0x63, 0x8f, 0xf8, 0x7b, 0x59, 0xae, 0xaa, 0xd2, 0x95, 0x55, 0x35, 0x6c, 0xce, 0xc8,
	0xb2, 0x39, 0x57, 0x0a, 0x6e, 0x74, 0xdd, 0x82, 0x5b, 0xfe, 0xf7, 0x08, 0xe4, 0xfd, 0x7d, 0xf1,
	0x43, 0xa2, 0xbf, 0x91, 0x16, 0x9f, 0xcb, 0xfc, 0x76, 0x97, 0xb6, 0xcd, 0x7c, 0x6c, 0x1d, 0x7c,
	0xdd, 0x2c, 0xf3, 0xf8, 0xb3, 0x9a, 0x8f, 0x28, 0x39, 0x6d, 0xd8, 0x3c, 0xde, 0x9e, 0xfe, 0xe6,
	0xef, 0x7e, 0x5e, 0x7a, 0xef, 0xa2, 0x3f, 0x70, 0x9c, 0xfb, 0x03, 0x8b, 0xcf, 0xff, 0xc9, 0xe7,
	0xa5, 0x77, 0xd7, 0x21, 0xef, 0x8e, 0x46, 0x1e, 0x26, 0xc1, 0xa7, 0xfb, 0xe2, 0xb5, 0xe8, 0xd7,
	0x21, 0xeb, 0xef, 0x1d, 0x13, 0xdd, 0x10, 0x89, 0x23, 0x34, 0x55, 0xe2, 0xed, 0x64, 0xa5, 0x49,
	0x74, 0xc3, 0xcf, 0x7b, 0x82, 0x81, 0x82, 0x8a, 0x0d, 0xb8, 0x79, 0xf1, 0x59, 0xae, 0xea, 0x11,
	0xa3, 0xe1, 0x1e, 0xf1, 0xcf, 0x23, 0x70, 0x6b, 0xa0, 0x79, 0xa7, 0xfe, 0x0c, 0xca, 0x75, 0x5e,
	0xce, 0x7d, 0xbb, 0x7f, 0x1d, 0x62, 0xce, 0x14, 0xdb, 0x22, 0xf7, 0x95, 0x45, 0x7f, 0x77, 0x31,
	0x71, 0xa5, 0x3b, 0xc5, 0xb6, 0xc2, 0xe8, 0x99, 0xaf, 0x69, 0x44, 0x63, 0x2f, 0xcb, 0x2a, 0xec,
	0xb9, 0xf8, 0x77, 0x12, 0xc4, 0x28, 0x09, 0xda, 0x87, 0x04, 0xff, 0xb6, 0x11, 0x62, 0xe5, 0xf3,
	0x07, 0x56, 0x04, 0x1e, 0xb5, 0x21, 0xc5, 0x67, 0x77, 0xbe, 0x1b, 0xd5, 0x7e, 0xf5, 0xf5, 0xab,
	0xd2, 0xfb, 0x17, 0x69, 0x7d, 0xe5, 0x5f, 0x44, 0x7c, 0xaa, 0xd7, 0x6a, 0x28, 0x49, 0x26, 0xa2,
	0xc5, 0xfa, 0x0c, 0xa2, 0xb9, 0x63, 0x4c, 0xd8, 0x04, 0x8e, 0xa5, 0x8c, 0x9c, 0x02, 0x1c, 0xc4,
	0xfe, 0xa4, 0x50, 0x82, 0x8c, 0x6e, 0x99, 0xd8, 0x26, 0xaa, 0x66, 0x18, 0x7e, 0xa9, 0x02, 0x0e,
	0xaa, 0x1a, 0x86, 0x5b, 0xfe, 0xc3, 0x28, 0x14, 0x56, 0x4f, 0x2f, 0x5c, 0xb1, 0x07, 0x39, 0x7a,
	0xf6, 0xe0, 0x6b, 0x49, 0x9c, 0xee, 0xbd, 0x37, 0x29, 0x4d, 0x78, 0x23, 0xd3, 0x9a, 0x58, 0x28,
	0x59, 0x27, 0xb4, 0xba, 0x50, 0x8b, 0x2f, 0x20, 0x1b, 0xe6, 0x40, 0x8f, 0x20, 0xe1, 0x11, 0x8d,
	0xcc, 0x3c, 0xd1, 0x83, 0x7f, 0xf9, 0x8a, 0xd7, 0xf5, 0x19, 0xb1, 0x22, 0x98, 0x42, 0xb6, 0x88,
	0x5c, 0x6e, 0x8b, 0xf2, 0x77, 0xd9, 0xdf, 0x56, 0x18, 0x53, 0x02, 0x22, 0xdd, 0x67, 0xf2, 0x06,
	0xda, 0x86, 0xcd, 0xfe, 0x93, 0xaa, 0xd2, 0x50, 0x3b, 0xdd, 0x81, 0x7a, 0xd8, 0x3d, 0xee, 0x34,
	0x64, 0x89, 0xb6, 0x26, 0x9d, 0xae, 0xca, 0xe1, 0x3d, 0xa5, 0x75, 0x54, 0x55, 0x9e, 0xcb, 0x11,
	0x74, 0x03, 0xb6, 0x28, 0xd1, 0x32, 0x38, 0x4a, 0x7b, 0x9b, 0x56, 0x67, 0xd0, 0x54, 0x3a, 0xd5,
	0xb6, 0xda, 0x54, 0x94, 0xae, 0x22, 0xc7, 0x68, 0x05, 0xe3, 0x64, 0xfd, 0x41, 0xb7, 0xd7, 0x6b,
	0x36, 0xe4, 0x38, 0xba, 0x01, 0x72, 0xaf, 0xab, 0x0c, 0xd8, 0x7b, 0xaa, 0xed, 0x76, 0xf7, 0xa3,
	0x66, 0x43, 0xfe, 0x69, 0xf2, 0xdd, 0x0e, 0x64, 0x42, 0xd9, 0x9c, 0xd6, 0xc9, 0x7a, 0x75, 0x50,
	0x6d, 0x77, 0x1f, 0xcb, 0x1b, 0xb4, 0x30, 0x3e, 0xed, 0x77, 0x3b, 0x6a, 0xbf, 0xfe, 0xa4, 0x79,
	0x54, 0x95, 0x25, 0xf6, 0xe7, 0x14, 0x56, 0x38, 0xe5, 0x18, 0xdd, 0x8d, 0x5f, 0xcf, 0xfa, 0xea,
	0x61, 0xeb, 0x5b, 0x03, 0x5a, 0x4c, 0xe3, 0x07, 0x7f, 0x2f, 0x41, 0x92, 0x7e, 0xbc, 0x98, 0xf6,
	0x18, 0x7d, 0x03, 0x60, 0x91, 0xa9, 0xd1, 0x2d, 0xae, 0xd5, 0x95, 0x84, 0x5e, 0x2c, 0xac, 0x22,
	0x84, 0x61, 0x6a, 0x90, 0x09, 0x65, 0x65, 0x24, 0x08, 0x57, 0xf3, 0x7c, 0xf1, 0xf6, 0x05, 0x18,
	0x21, 0xe3, 0x3e, 0x24, 0x78, 0xee, 0x42, 0xdb, 0xcb, 0x99, 0x8c, 0x73, 0xee, 0x5c, 0x94, 0xde,
	0x0e, 0xbe, 0x0d, 0xd9, 0xb0, 0xe5, 0xd1, 0x53, 0x88, 0xf3, 0x87, 0x3b, 0x97, 0x86, 0x6f, 0x71,
	0xf7, 0x72, 0xcf, 0xd9, 0x97, 0xbe, 0x2a, 0xd5, 0x1e, 0x7e, 0xf6, 0x5f, 0xbb, 0x1b, 0x9f, 0xfd,
	0x78, 0x57, 0xfa, 0xd1, 0x8f, 0x77, 0xa5, 0x4f, 0xff, 0x7b, 0x57, 0xfa, 0xf6, 0x3b, 0x63, 0x93,
	0x9c, 0xcc, 0x86, 0x15, 0xdd, 0x99, 0xdc, 0xc3, 0x1e, 0x99, 0x69, 0xee, 0x9c, 0xff, 0x11, 0x70,
	0xe5, 0xaf, 0x81, 0xc3, 0x04, 0x5b, 0xdf, 0xff, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xda, 0x5f,
	0x89, 0x90, 0x36, 0x28, 0x00, 0x00,
}

func (this *UUIDParts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UUIDParts)
	if !ok {
		that2, ok := that.(UUIDParts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Node != that1.Node {
		return false
	}
	if this.Clock != that1.Clock {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TestingClient is the client API for Testing service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TestingClient interface {
	ResetState(ctx context.Context, in *ResetStateRequest, opts ...grpc.CallOption) (*ResetStateResponse, error)
	AdvanceTime(ctx context.Context, in *AdvanceTimeRequest, opts ...grpc.CallOption) (*AdvanceTimeResponse, error)
	Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error)
}

type testingClient struct {
	cc *grpc.ClientConn
}

func NewTestingClient(cc *grpc.ClientConn) TestingClient {
	return &testingClient{cc}
}

func (c *testingClient) ResetState(ctx context.Context, in *ResetStateRequest, opts ...grpc.CallOption) (*ResetStateResponse, error) {
	out := new(ResetStateResponse)
	err := c.cc.Invoke(ctx, "/flow.Testing/ResetState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testingClient) AdvanceTime(ctx context.Context, in *AdvanceTimeRequest, opts ...grpc.CallOption) (*AdvanceTimeResponse, error) {
	out := new(AdvanceTimeResponse)
	err := c.cc.Invoke(ctx, "/flow.Testing/AdvanceTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testingClient) Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error) {
	out := new(IngestResponse)
	err := c.cc.Invoke(ctx, "/flow.Testing/Ingest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TestingServer is the server API for Testing service.
type TestingServer interface {
	ResetState(context.Context, *ResetStateRequest) (*ResetStateResponse, error)
	AdvanceTime(context.Context, *AdvanceTimeRequest) (*AdvanceTimeResponse, error)
	Ingest(context.Context, *IngestRequest) (*IngestResponse, error)
}

// UnimplementedTestingServer can be embedded to have forward compatible implementations.
type UnimplementedTestingServer struct {
}

func (*UnimplementedTestingServer) ResetState(ctx context.Context, req *ResetStateRequest) (*ResetStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetState not implemented")
}
func (*UnimplementedTestingServer) AdvanceTime(ctx context.Context, req *AdvanceTimeRequest) (*AdvanceTimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdvanceTime not implemented")
}
func (*UnimplementedTestingServer) Ingest(ctx context.Context, req *IngestRequest) (*IngestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ingest not implemented")
}

func RegisterTestingServer(s *grpc.Server, srv TestingServer) {
	s.RegisterService(&_Testing_serviceDesc, srv)
}

func _Testing_ResetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestingServer).ResetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.Testing/ResetState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestingServer).ResetState(ctx, req.(*ResetStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Testing_AdvanceTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdvanceTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestingServer).AdvanceTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.Testing/AdvanceTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestingServer).AdvanceTime(ctx, req.(*AdvanceTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Testing_Ingest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestingServer).Ingest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.Testing/Ingest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestingServer).Ingest(ctx, req.(*IngestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Testing_serviceDesc = grpc.ServiceDesc{
	ServiceName: "flow.Testing",
	HandlerType: (*TestingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResetState",
			Handler:    _Testing_ResetState_Handler,
		},
		{
			MethodName: "AdvanceTime",
			Handler:    _Testing_AdvanceTime_Handler,
		},
		{
			MethodName: "Ingest",
			Handler:    _Testing_Ingest_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/protocols/flow/flow.proto",
}

// NetworkProxyClient is the client API for NetworkProxy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NetworkProxyClient interface {
	Proxy(ctx context.Context, opts ...grpc.CallOption) (NetworkProxy_ProxyClient, error)
}

type networkProxyClient struct {
	cc *grpc.ClientConn
}

func NewNetworkProxyClient(cc *grpc.ClientConn) NetworkProxyClient {
	return &networkProxyClient{cc}
}

func (c *networkProxyClient) Proxy(ctx context.Context, opts ...grpc.CallOption) (NetworkProxy_ProxyClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NetworkProxy_serviceDesc.Streams[0], "/flow.NetworkProxy/Proxy", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkProxyProxyClient{stream}
	return x, nil
}

type NetworkProxy_ProxyClient interface {
	Send(*TaskNetworkProxyRequest) error
	Recv() (*TaskNetworkProxyResponse, error)
	grpc.ClientStream
}

type networkProxyProxyClient struct {
	grpc.ClientStream
}

func (x *networkProxyProxyClient) Send(m *TaskNetworkProxyRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *networkProxyProxyClient) Recv() (*TaskNetworkProxyResponse, error) {
	m := new(TaskNetworkProxyResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NetworkProxyServer is the server API for NetworkProxy service.
type NetworkProxyServer interface {
	Proxy(NetworkProxy_ProxyServer) error
}

// UnimplementedNetworkProxyServer can be embedded to have forward compatible implementations.
type UnimplementedNetworkProxyServer struct {
}

func (*UnimplementedNetworkProxyServer) Proxy(srv NetworkProxy_ProxyServer) error {
	return status.Errorf(codes.Unimplemented, "method Proxy not implemented")
}

func RegisterNetworkProxyServer(s *grpc.Server, srv NetworkProxyServer) {
	s.RegisterService(&_NetworkProxy_serviceDesc, srv)
}

func _NetworkProxy_Proxy_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NetworkProxyServer).Proxy(&networkProxyProxyServer{stream})
}

type NetworkProxy_ProxyServer interface {
	Send(*TaskNetworkProxyResponse) error
	Recv() (*TaskNetworkProxyRequest, error)
	grpc.ServerStream
}

type networkProxyProxyServer struct {
	grpc.ServerStream
}

func (x *networkProxyProxyServer) Send(m *TaskNetworkProxyResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *networkProxyProxyServer) Recv() (*TaskNetworkProxyRequest, error) {
	m := new(TaskNetworkProxyRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _NetworkProxy_serviceDesc = grpc.ServiceDesc{
	ServiceName: "flow.NetworkProxy",
	HandlerType: (*NetworkProxyServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Proxy",
			Handler:       _NetworkProxy_Proxy_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "go/protocols/flow/flow.proto",
}

func (m *Slice) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Slice) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Slice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Begin != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Begin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UUIDParts) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UUIDParts) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UUIDParts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Clock != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Clock))
		i--
		dAtA[i] = 0x11
	}
	if m.Node != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Node))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Projection) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Projection) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Projection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Inference.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.IsPrimaryKey {
		i--
		if m.IsPrimaryKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.IsPartitionKey {
		i--
		if m.IsPartitionKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Explicit {
		i--
		if m.Explicit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Field) > 0 {
		i -= len(m.Field)
		copy(dAtA[i:], m.Field)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Field)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ptr) > 0 {
		i -= len(m.Ptr)
		copy(dAtA[i:], m.Ptr)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Ptr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Inference) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Inference) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Inference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Exists != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Exists))
		i--
		dAtA[i] = 0x40
	}
	if m.Secret {
		i--
		if m.Secret {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.DefaultJson) > 0 {
		i -= len(m.DefaultJson)
		copy(dAtA[i:], m.DefaultJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.DefaultJson)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x22
	}
	if m.String_ != nil {
		{
			size, err := m.String_.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Types[iNdEx])
			copy(dAtA[i:], m.Types[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.Types[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Inference_String) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Inference_String) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Inference_String) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ContentEncoding) > 0 {
		i -= len(m.ContentEncoding)
		copy(dAtA[i:], m.ContentEncoding)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ContentEncoding)))
		i--
		dAtA[i] = 0x3a
	}
	if m.MaxLength != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.MaxLength))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *NetworkPort) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Public {
		i--
		if m.Public {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x12
	}
	if m.Number != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CollectionSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Derivation != nil {
		{
			size, err := m.Derivation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.ReadSchemaJson) > 0 {
		i -= len(m.ReadSchemaJson)
		copy(dAtA[i:], m.ReadSchemaJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ReadSchemaJson)))
		i--
		dAtA[i] = 0x5a
	}
	if m.PartitionTemplate != nil {
		{
			size, err := m.PartitionTemplate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.WriteSchemaJson) > 0 {
		i -= len(m.WriteSchemaJson)
		copy(dAtA[i:], m.WriteSchemaJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.WriteSchemaJson)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AckTemplateJson) > 0 {
		i -= len(m.AckTemplateJson)
		copy(dAtA[i:], m.AckTemplateJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.AckTemplateJson)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Projections) > 0 {
		for iNdEx := len(m.Projections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Projections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.PartitionFields) > 0 {
		for iNdEx := len(m.PartitionFields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionFields[iNdEx])
			copy(dAtA[i:], m.PartitionFields[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.PartitionFields[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.UuidPtr) > 0 {
		i -= len(m.UuidPtr)
		copy(dAtA[i:], m.UuidPtr)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.UuidPtr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Key) > 0 {
		for iNdEx := len(m.Key) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Key[iNdEx])
			copy(dAtA[i:], m.Key[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.Key[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectionSpec_Derivation) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionSpec_Derivation) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionSpec_Derivation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NetworkPorts) > 0 {
		for iNdEx := len(m.NetworkPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetworkPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.RecoveryLogTemplate != nil {
		{
			size, err := m.RecoveryLogTemplate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ShardTemplate != nil {
		{
			size, err := m.ShardTemplate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ShuffleKeyTypes) > 0 {
		dAtA8 := make([]byte, len(m.ShuffleKeyTypes)*10)
		var j7 int
		for _, num := range m.ShuffleKeyTypes {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintFlow(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Transforms) > 0 {
		for iNdEx := len(m.Transforms) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Transforms[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ConfigJson) > 0 {
		i -= len(m.ConfigJson)
		copy(dAtA[i:], m.ConfigJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ConfigJson)))
		i--
		dAtA[i] = 0x12
	}
	if m.ConnectorType != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ConnectorType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CollectionSpec_Derivation_Transform) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionSpec_Derivation_Transform) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionSpec_Derivation_Transform) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NotAfter != nil {
		{
			size, err := m.NotAfter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.NotBefore != nil {
		{
			size, err := m.NotBefore.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.JournalReadSuffix) > 0 {
		i -= len(m.JournalReadSuffix)
		copy(dAtA[i:], m.JournalReadSuffix)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.JournalReadSuffix)))
		i--
		dAtA[i] = 0x52
	}
	if m.ReadOnly {
		i--
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.LambdaConfigJson) > 0 {
		i -= len(m.LambdaConfigJson)
		copy(dAtA[i:], m.LambdaConfigJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.LambdaConfigJson)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ShuffleLambdaConfigJson) > 0 {
		i -= len(m.ShuffleLambdaConfigJson)
		copy(dAtA[i:], m.ShuffleLambdaConfigJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ShuffleLambdaConfigJson)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ShuffleKey) > 0 {
		for iNdEx := len(m.ShuffleKey) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ShuffleKey[iNdEx])
			copy(dAtA[i:], m.ShuffleKey[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.ShuffleKey[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ReadDelaySeconds != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ReadDelaySeconds))
		i--
		dAtA[i] = 0x28
	}
	if m.Priority != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.PartitionSelector.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Collection.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FieldSelection) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldSelection) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldSelection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FieldConfigJsonMap) > 0 {
		for k := range m.FieldConfigJsonMap {
			v := m.FieldConfigJsonMap[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintFlow(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFlow(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFlow(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Document) > 0 {
		i -= len(m.Document)
		copy(dAtA[i:], m.Document)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Document)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CaptureSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptureSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CaptureSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NetworkPorts) > 0 {
		for iNdEx := len(m.NetworkPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetworkPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.RecoveryLogTemplate != nil {
		{
			size, err := m.RecoveryLogTemplate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.ShardTemplate != nil {
		{
			size, err := m.ShardTemplate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.IntervalSeconds != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.IntervalSeconds))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Bindings) > 0 {
		for iNdEx := len(m.Bindings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bindings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ConfigJson) > 0 {
		i -= len(m.ConfigJson)
		copy(dAtA[i:], m.ConfigJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ConfigJson)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConnectorType != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ConnectorType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CaptureSpec_Binding) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptureSpec_Binding) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CaptureSpec_Binding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Collection.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.ResourcePath) > 0 {
		for iNdEx := len(m.ResourcePath) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResourcePath[iNdEx])
			copy(dAtA[i:], m.ResourcePath[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.ResourcePath[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ResourceConfigJson) > 0 {
		i -= len(m.ResourceConfigJson)
		copy(dAtA[i:], m.ResourceConfigJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ResourceConfigJson)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MaterializationSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaterializationSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaterializationSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NetworkPorts) > 0 {
		for iNdEx := len(m.NetworkPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetworkPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.RecoveryLogTemplate != nil {
		{
			size, err := m.RecoveryLogTemplate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ShardTemplate != nil {
		{
			size, err := m.ShardTemplate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Bindings) > 0 {
		for iNdEx := len(m.Bindings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bindings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ConfigJson) > 0 {
		i -= len(m.ConfigJson)
		copy(dAtA[i:], m.ConfigJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ConfigJson)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConnectorType != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ConnectorType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MaterializationSpec_Binding) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaterializationSpec_Binding) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaterializationSpec_Binding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NotAfter != nil {
		{
			size, err := m.NotAfter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.NotBefore != nil {
		{
			size, err := m.NotBefore.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Priority != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x48
	}
	if len(m.JournalReadSuffix) > 0 {
		i -= len(m.JournalReadSuffix)
		copy(dAtA[i:], m.JournalReadSuffix)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.JournalReadSuffix)))
		i--
		dAtA[i] = 0x42
	}
	{
		size, err := m.PartitionSelector.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.DeprecatedShuffle != nil {
		{
			size, err := m.DeprecatedShuffle.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.DeltaUpdates {
		i--
		if m.DeltaUpdates {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.FieldSelection.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Collection.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.ResourcePath) > 0 {
		for iNdEx := len(m.ResourcePath) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResourcePath[iNdEx])
			copy(dAtA[i:], m.ResourcePath[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.ResourcePath[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ResourceConfigJson) > 0 {
		i -= len(m.ResourceConfigJson)
		copy(dAtA[i:], m.ResourceConfigJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ResourceConfigJson)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MaterializationSpec_Binding_DeprecatedShuffle) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaterializationSpec_Binding_DeprecatedShuffle) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaterializationSpec_Binding_DeprecatedShuffle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.PartitionSelector.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.GroupName) > 0 {
		i -= len(m.GroupName)
		copy(dAtA[i:], m.GroupName)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.GroupName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OAuth2) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OAuth2) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OAuth2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RefreshTokenMethod) > 0 {
		i -= len(m.RefreshTokenMethod)
		copy(dAtA[i:], m.RefreshTokenMethod)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.RefreshTokenMethod)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.AccessTokenMethod) > 0 {
		i -= len(m.AccessTokenMethod)
		copy(dAtA[i:], m.AccessTokenMethod)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.AccessTokenMethod)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.RefreshTokenResponseJsonMap) > 0 {
		for k := range m.RefreshTokenResponseJsonMap {
			v := m.RefreshTokenResponseJsonMap[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintFlow(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFlow(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFlow(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.RefreshTokenHeadersJsonMap) > 0 {
		for k := range m.RefreshTokenHeadersJsonMap {
			v := m.RefreshTokenHeadersJsonMap[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintFlow(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFlow(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFlow(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.RefreshTokenBody) > 0 {
		i -= len(m.RefreshTokenBody)
		copy(dAtA[i:], m.RefreshTokenBody)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.RefreshTokenBody)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RefreshTokenUrlTemplate) > 0 {
		i -= len(m.RefreshTokenUrlTemplate)
		copy(dAtA[i:], m.RefreshTokenUrlTemplate)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.RefreshTokenUrlTemplate)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AccessTokenResponseJsonMap) > 0 {
		for k := range m.AccessTokenResponseJsonMap {
			v := m.AccessTokenResponseJsonMap[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintFlow(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFlow(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFlow(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.AccessTokenHeadersJsonMap) > 0 {
		for k := range m.AccessTokenHeadersJsonMap {
			v := m.AccessTokenHeadersJsonMap[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintFlow(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFlow(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFlow(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.AccessTokenBody) > 0 {
		i -= len(m.AccessTokenBody)
		copy(dAtA[i:], m.AccessTokenBody)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.AccessTokenBody)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AccessTokenUrlTemplate) > 0 {
		i -= len(m.AccessTokenUrlTemplate)
		copy(dAtA[i:], m.AccessTokenUrlTemplate)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.AccessTokenUrlTemplate)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AuthUrlTemplate) > 0 {
		i -= len(m.AuthUrlTemplate)
		copy(dAtA[i:], m.AuthUrlTemplate)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.AuthUrlTemplate)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Steps) > 0 {
		for iNdEx := len(m.Steps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Steps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestSpec_Step) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSpec_Step) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSpec_Step) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Partitions.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.DocsJsonVec) > 0 {
		for iNdEx := len(m.DocsJsonVec) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DocsJsonVec[iNdEx])
			copy(dAtA[i:], m.DocsJsonVec[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.DocsJsonVec[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Collection) > 0 {
		i -= len(m.Collection)
		copy(dAtA[i:], m.Collection)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Collection)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StepScope) > 0 {
		i -= len(m.StepScope)
		copy(dAtA[i:], m.StepScope)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.StepScope)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.StepIndex != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.StepIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.StepType != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.StepType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RangeSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RClockEnd != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RClockEnd))
		i--
		dAtA[i] = 0x2d
	}
	if m.RClockBegin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RClockBegin))
		i--
		dAtA[i] = 0x25
	}
	if m.KeyEnd != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.KeyEnd))
		i--
		dAtA[i] = 0x1d
	}
	if m.KeyBegin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.KeyBegin))
		i--
		dAtA[i] = 0x15
	}
	return len(dAtA) - i, nil
}

func (m *ConnectorState) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorState) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectorState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MergePatch {
		i--
		if m.MergePatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.UpdatedJson) > 0 {
		i -= len(m.UpdatedJson)
		copy(dAtA[i:], m.UpdatedJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.UpdatedJson)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExtractAPI) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtractAPI) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtractAPI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ExtractAPI_Config) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtractAPI_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtractAPI_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Projections) > 0 {
		for iNdEx := len(m.Projections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Projections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.FieldPtrs) > 0 {
		for iNdEx := len(m.FieldPtrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FieldPtrs[iNdEx])
			copy(dAtA[i:], m.FieldPtrs[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.FieldPtrs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SchemaJson) > 0 {
		i -= len(m.SchemaJson)
		copy(dAtA[i:], m.SchemaJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.SchemaJson)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UuidPtr) > 0 {
		i -= len(m.UuidPtr)
		copy(dAtA[i:], m.UuidPtr)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.UuidPtr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CombineAPI) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineAPI) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombineAPI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *CombineAPI_Config) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineAPI_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombineAPI_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InferSchemaJson) > 0 {
		i -= len(m.InferSchemaJson)
		copy(dAtA[i:], m.InferSchemaJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.InferSchemaJson)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Projections) > 0 {
		for iNdEx := len(m.Projections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Projections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.UuidPlaceholderPtr) > 0 {
		i -= len(m.UuidPlaceholderPtr)
		copy(dAtA[i:], m.UuidPlaceholderPtr)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.UuidPlaceholderPtr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.KeyPtrs) > 0 {
		for iNdEx := len(m.KeyPtrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyPtrs[iNdEx])
			copy(dAtA[i:], m.KeyPtrs[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.KeyPtrs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SchemaJson) > 0 {
		i -= len(m.SchemaJson)
		copy(dAtA[i:], m.SchemaJson)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.SchemaJson)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CombineAPI_Stats) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineAPI_Stats) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombineAPI_Stats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Out != nil {
		{
			size, err := m.Out.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Right != nil {
		{
			size, err := m.Right.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Left != nil {
		{
			size, err := m.Left.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BuildAPI) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildAPI) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildAPI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *BuildAPI_Config) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildAPI_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildAPI_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProjectRoot) > 0 {
		i -= len(m.ProjectRoot)
		copy(dAtA[i:], m.ProjectRoot)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ProjectRoot)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ConnectorNetwork) > 0 {
		i -= len(m.ConnectorNetwork)
		copy(dAtA[i:], m.ConnectorNetwork)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ConnectorNetwork)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SourceType != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.SourceType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BuildDb) > 0 {
		i -= len(m.BuildDb)
		copy(dAtA[i:], m.BuildDb)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.BuildDb)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BuildId) > 0 {
		i -= len(m.BuildId)
		copy(dAtA[i:], m.BuildId)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.BuildId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResetStateRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetStateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetStateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ResetStateResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetStateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetStateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *AdvanceTimeRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvanceTimeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvanceTimeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AdvanceSeconds != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.AdvanceSeconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AdvanceTimeResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvanceTimeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvanceTimeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DocsAndBytes) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocsAndBytes) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DocsAndBytes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Bytes != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Bytes))
		i--
		dAtA[i] = 0x10
	}
	if m.Docs != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Docs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IngestRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DocsJsonVec) > 0 {
		for iNdEx := len(m.DocsJsonVec) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DocsJsonVec[iNdEx])
			copy(dAtA[i:], m.DocsJsonVec[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.DocsJsonVec[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BuildId) > 0 {
		i -= len(m.BuildId)
		copy(dAtA[i:], m.BuildId)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.BuildId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Collection) > 0 {
		i -= len(m.Collection)
		copy(dAtA[i:], m.Collection)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Collection)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IngestResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.JournalEtcd.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlow(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.JournalWriteHeads) > 0 {
		for k := range m.JournalWriteHeads {
			v := m.JournalWriteHeads[k]
			baseI := i
			i = encodeVarintFlow(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFlow(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFlow(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TaskNetworkProxyRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskNetworkProxyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskNetworkProxyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Open != nil {
		{
			size, err := m.Open.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TaskNetworkProxyRequest_Open) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskNetworkProxyRequest_Open) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskNetworkProxyRequest_Open) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ClientAddr) > 0 {
		i -= len(m.ClientAddr)
		copy(dAtA[i:], m.ClientAddr)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ClientAddr)))
		i--
		dAtA[i] = 0x22
	}
	if m.TargetPort != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.TargetPort))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ShardId) > 0 {
		i -= len(m.ShardId)
		copy(dAtA[i:], m.ShardId)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ShardId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TaskNetworkProxyResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskNetworkProxyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskNetworkProxyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.OpenResponse != nil {
		{
			size, err := m.OpenResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TaskNetworkProxyResponse_OpenResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskNetworkProxyResponse_OpenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskNetworkProxyResponse_OpenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFlow(dAtA []byte, offset int, v uint64) int {
	offset -= sovFlow(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Slice) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != 0 {
		n += 1 + sovFlow(uint64(m.Begin))
	}
	if m.End != 0 {
		n += 1 + sovFlow(uint64(m.End))
	}
	return n
}

func (m *UUIDParts) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 9
	}
	if m.Clock != 0 {
		n += 9
	}
	return n
}

func (m *Projection) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ptr)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Field)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Explicit {
		n += 2
	}
	if m.IsPartitionKey {
		n += 2
	}
	if m.IsPrimaryKey {
		n += 2
	}
	l = m.Inference.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Inference) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Types) > 0 {
		for _, s := range m.Types {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.String_ != nil {
		l = m.String_.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.DefaultJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Secret {
		n += 2
	}
	if m.Exists != 0 {
		n += 1 + sovFlow(uint64(m.Exists))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Inference_String) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.MaxLength != 0 {
		n += 1 + sovFlow(uint64(m.MaxLength))
	}
	l = len(m.ContentEncoding)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkPort) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovFlow(uint64(m.Number))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Public {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CollectionSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Key) > 0 {
		for _, s := range m.Key {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = len(m.UuidPtr)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.PartitionFields) > 0 {
		for _, s := range m.PartitionFields {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.Projections) > 0 {
		for _, e := range m.Projections {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = len(m.AckTemplateJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.WriteSchemaJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.PartitionTemplate != nil {
		l = m.PartitionTemplate.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.ReadSchemaJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Derivation != nil {
		l = m.Derivation.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CollectionSpec_Derivation) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectorType != 0 {
		n += 1 + sovFlow(uint64(m.ConnectorType))
	}
	l = len(m.ConfigJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Transforms) > 0 {
		for _, e := range m.Transforms {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.ShuffleKeyTypes) > 0 {
		l = 0
		for _, e := range m.ShuffleKeyTypes {
			l += sovFlow(uint64(e))
		}
		n += 1 + sovFlow(uint64(l)) + l
	}
	if m.ShardTemplate != nil {
		l = m.ShardTemplate.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.RecoveryLogTemplate != nil {
		l = m.RecoveryLogTemplate.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.NetworkPorts) > 0 {
		for _, e := range m.NetworkPorts {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CollectionSpec_Derivation_Transform) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = m.Collection.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	l = m.PartitionSelector.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.Priority != 0 {
		n += 1 + sovFlow(uint64(m.Priority))
	}
	if m.ReadDelaySeconds != 0 {
		n += 1 + sovFlow(uint64(m.ReadDelaySeconds))
	}
	if len(m.ShuffleKey) > 0 {
		for _, s := range m.ShuffleKey {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = len(m.ShuffleLambdaConfigJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.LambdaConfigJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.ReadOnly {
		n += 2
	}
	l = len(m.JournalReadSuffix)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.NotBefore != nil {
		l = m.NotBefore.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.NotAfter != nil {
		l = m.NotAfter.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FieldSelection) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = len(m.Document)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.FieldConfigJsonMap) > 0 {
		for k, v := range m.FieldConfigJsonMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CaptureSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.ConnectorType != 0 {
		n += 1 + sovFlow(uint64(m.ConnectorType))
	}
	l = len(m.ConfigJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Bindings) > 0 {
		for _, e := range m.Bindings {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.IntervalSeconds != 0 {
		n += 1 + sovFlow(uint64(m.IntervalSeconds))
	}
	if m.ShardTemplate != nil {
		l = m.ShardTemplate.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.RecoveryLogTemplate != nil {
		l = m.RecoveryLogTemplate.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.NetworkPorts) > 0 {
		for _, e := range m.NetworkPorts {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CaptureSpec_Binding) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceConfigJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.ResourcePath) > 0 {
		for _, s := range m.ResourcePath {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = m.Collection.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaterializationSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.ConnectorType != 0 {
		n += 1 + sovFlow(uint64(m.ConnectorType))
	}
	l = len(m.ConfigJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Bindings) > 0 {
		for _, e := range m.Bindings {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.ShardTemplate != nil {
		l = m.ShardTemplate.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.RecoveryLogTemplate != nil {
		l = m.RecoveryLogTemplate.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.NetworkPorts) > 0 {
		for _, e := range m.NetworkPorts {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaterializationSpec_Binding) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceConfigJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.ResourcePath) > 0 {
		for _, s := range m.ResourcePath {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = m.Collection.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	l = m.FieldSelection.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.DeltaUpdates {
		n += 2
	}
	if m.DeprecatedShuffle != nil {
		l = m.DeprecatedShuffle.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = m.PartitionSelector.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	l = len(m.JournalReadSuffix)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovFlow(uint64(m.Priority))
	}
	if m.NotBefore != nil {
		l = m.NotBefore.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.NotAfter != nil {
		l = m.NotAfter.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaterializationSpec_Binding_DeprecatedShuffle) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GroupName)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = m.PartitionSelector.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OAuth2) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.AuthUrlTemplate)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.AccessTokenUrlTemplate)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.AccessTokenBody)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.AccessTokenHeadersJsonMap) > 0 {
		for k, v := range m.AccessTokenHeadersJsonMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	if len(m.AccessTokenResponseJsonMap) > 0 {
		for k, v := range m.AccessTokenResponseJsonMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	l = len(m.RefreshTokenUrlTemplate)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.RefreshTokenBody)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.RefreshTokenHeadersJsonMap) > 0 {
		for k, v := range m.RefreshTokenHeadersJsonMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	if len(m.RefreshTokenResponseJsonMap) > 0 {
		for k, v := range m.RefreshTokenResponseJsonMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	l = len(m.AccessTokenMethod)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.RefreshTokenMethod)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestSpec_Step) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StepType != 0 {
		n += 1 + sovFlow(uint64(m.StepType))
	}
	if m.StepIndex != 0 {
		n += 1 + sovFlow(uint64(m.StepIndex))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.StepScope)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Collection)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.DocsJsonVec) > 0 {
		for _, s := range m.DocsJsonVec {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = m.Partitions.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RangeSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyBegin != 0 {
		n += 5
	}
	if m.KeyEnd != 0 {
		n += 5
	}
	if m.RClockBegin != 0 {
		n += 5
	}
	if m.RClockEnd != 0 {
		n += 5
	}
	return n
}

func (m *ConnectorState) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UpdatedJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.MergePatch {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtractAPI) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtractAPI_Config) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UuidPtr)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.SchemaJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.FieldPtrs) > 0 {
		for _, s := range m.FieldPtrs {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.Projections) > 0 {
		for _, e := range m.Projections {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CombineAPI) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CombineAPI_Config) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SchemaJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.KeyPtrs) > 0 {
		for _, s := range m.KeyPtrs {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = len(m.UuidPlaceholderPtr)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Projections) > 0 {
		for _, e := range m.Projections {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.InferSchemaJson)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CombineAPI_Stats) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Left != nil {
		l = m.Left.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Right != nil {
		l = m.Right.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Out != nil {
		l = m.Out.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuildAPI) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuildAPI_Config) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BuildId)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.BuildDb)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.SourceType != 0 {
		n += 1 + sovFlow(uint64(m.SourceType))
	}
	l = len(m.ConnectorNetwork)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.ProjectRoot)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResetStateRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResetStateResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdvanceTimeRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdvanceSeconds != 0 {
		n += 1 + sovFlow(uint64(m.AdvanceSeconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdvanceTimeResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DocsAndBytes) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Docs != 0 {
		n += 1 + sovFlow(uint64(m.Docs))
	}
	if m.Bytes != 0 {
		n += 1 + sovFlow(uint64(m.Bytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngestRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Collection)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.BuildId)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.DocsJsonVec) > 0 {
		for _, s := range m.DocsJsonVec {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngestResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.JournalWriteHeads) > 0 {
		for k, v := range m.JournalWriteHeads {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + sovFlow(uint64(v))
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	l = m.JournalEtcd.ProtoSize()
	n += 1 + l + sovFlow(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskNetworkProxyRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Open != nil {
		l = m.Open.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskNetworkProxyRequest_Open) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.ShardId)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.TargetPort != 0 {
		n += 1 + sovFlow(uint64(m.TargetPort))
	}
	l = len(m.ClientAddr)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskNetworkProxyResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpenResponse != nil {
		l = m.OpenResponse.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskNetworkProxyResponse_OpenResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovFlow(uint64(m.Status))
	}
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFlow(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFlow(x uint64) (n int) {
	return sovFlow(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Slice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Slice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Slice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UUIDParts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UUIDParts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UUIDParts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clock", wireType)
			}
			m.Clock = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Clock = go_gazette_dev_core_message.Clock(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Projection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Projection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Projection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ptr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ptr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Explicit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Explicit = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPartitionKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPartitionKey = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimaryKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrimaryKey = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Inference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Inference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Inference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Inference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.String_ == nil {
				m.String_ = &Inference_String{}
			}
			if err := m.String_.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Secret = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exists", wireType)
			}
			m.Exists = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exists |= Inference_Exists(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Inference_String) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: String: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: String: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLength", wireType)
			}
			m.MaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLength |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentEncoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Public", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Public = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = Collection(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidPtr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidPtr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionFields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionFields = append(m.PartitionFields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Projections = append(m.Projections, Projection{})
			if err := m.Projections[len(m.Projections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckTemplateJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AckTemplateJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteSchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WriteSchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionTemplate == nil {
				m.PartitionTemplate = &protocol.JournalSpec{}
			}
			if err := m.PartitionTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadSchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadSchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Derivation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Derivation == nil {
				m.Derivation = &CollectionSpec_Derivation{}
			}
			if err := m.Derivation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionSpec_Derivation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Derivation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Derivation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorType", wireType)
			}
			m.ConnectorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectorType |= CollectionSpec_Derivation_ConnectorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transforms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transforms = append(m.Transforms, CollectionSpec_Derivation_Transform{})
			if err := m.Transforms[len(m.Transforms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v CollectionSpec_Derivation_ShuffleType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= CollectionSpec_Derivation_ShuffleType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ShuffleKeyTypes = append(m.ShuffleKeyTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlow
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlow
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ShuffleKeyTypes) == 0 {
					m.ShuffleKeyTypes = make([]CollectionSpec_Derivation_ShuffleType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v CollectionSpec_Derivation_ShuffleType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= CollectionSpec_Derivation_ShuffleType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ShuffleKeyTypes = append(m.ShuffleKeyTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleKeyTypes", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardTemplate == nil {
				m.ShardTemplate = &protocol1.ShardSpec{}
			}
			if err := m.ShardTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryLogTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecoveryLogTemplate == nil {
				m.RecoveryLogTemplate = &protocol.JournalSpec{}
			}
			if err := m.RecoveryLogTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkPorts = append(m.NetworkPorts, &NetworkPort{})
			if err := m.NetworkPorts[len(m.NetworkPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionSpec_Derivation_Transform) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transform: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transform: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = Transform(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PartitionSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadDelaySeconds", wireType)
			}
			m.ReadDelaySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadDelaySeconds |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShuffleKey = append(m.ShuffleKey, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleLambdaConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShuffleLambdaConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LambdaConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LambdaConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JournalReadSuffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JournalReadSuffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotBefore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotBefore == nil {
				m.NotBefore = &types.Timestamp{}
			}
			if err := m.NotBefore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotAfter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotAfter == nil {
				m.NotAfter = &types.Timestamp{}
			}
			if err := m.NotAfter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldSelection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldSelection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldSelection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Document", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Document = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldConfigJsonMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldConfigJsonMap == nil {
				m.FieldConfigJsonMap = make(map[string]encoding_json.RawMessage)
			}
			var mapkey string
			var mapvalue encoding_json.RawMessage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = encoding_json.RawMessage(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlow(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFlow
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FieldConfigJsonMap[mapkey] = ((encoding_json.RawMessage)(mapvalue))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptureSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptureSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptureSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = Capture(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorType", wireType)
			}
			m.ConnectorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectorType |= CaptureSpec_ConnectorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bindings = append(m.Bindings, &CaptureSpec_Binding{})
			if err := m.Bindings[len(m.Bindings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalSeconds", wireType)
			}
			m.IntervalSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalSeconds |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardTemplate == nil {
				m.ShardTemplate = &protocol1.ShardSpec{}
			}
			if err := m.ShardTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryLogTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecoveryLogTemplate == nil {
				m.RecoveryLogTemplate = &protocol.JournalSpec{}
			}
			if err := m.RecoveryLogTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkPorts = append(m.NetworkPorts, &NetworkPort{})
			if err := m.NetworkPorts[len(m.NetworkPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptureSpec_Binding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Binding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Binding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourcePath = append(m.ResourcePath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaterializationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaterializationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaterializationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = Materialization(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorType", wireType)
			}
			m.ConnectorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectorType |= MaterializationSpec_ConnectorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bindings = append(m.Bindings, &MaterializationSpec_Binding{})
			if err := m.Bindings[len(m.Bindings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardTemplate == nil {
				m.ShardTemplate = &protocol1.ShardSpec{}
			}
			if err := m.ShardTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryLogTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecoveryLogTemplate == nil {
				m.RecoveryLogTemplate = &protocol.JournalSpec{}
			}
			if err := m.RecoveryLogTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkPorts = append(m.NetworkPorts, &NetworkPort{})
			if err := m.NetworkPorts[len(m.NetworkPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaterializationSpec_Binding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Binding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Binding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourcePath = append(m.ResourcePath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldSelection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FieldSelection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaUpdates", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeltaUpdates = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedShuffle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeprecatedShuffle == nil {
				m.DeprecatedShuffle = &MaterializationSpec_Binding_DeprecatedShuffle{}
			}
			if err := m.DeprecatedShuffle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PartitionSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JournalReadSuffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JournalReadSuffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotBefore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotBefore == nil {
				m.NotBefore = &types.Timestamp{}
			}
			if err := m.NotBefore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotAfter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotAfter == nil {
				m.NotAfter = &types.Timestamp{}
			}
			if err := m.NotAfter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaterializationSpec_Binding_DeprecatedShuffle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeprecatedShuffle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeprecatedShuffle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PartitionSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OAuth2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OAuth2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OAuth2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthUrlTemplate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthUrlTemplate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessTokenUrlTemplate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessTokenUrlTemplate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessTokenBody", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessTokenBody = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessTokenHeadersJsonMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessTokenHeadersJsonMap == nil {
				m.AccessTokenHeadersJsonMap = make(map[string]encoding_json.RawMessage)
			}
			var mapkey string
			var mapvalue encoding_json.RawMessage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = encoding_json.RawMessage(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlow(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFlow
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AccessTokenHeadersJsonMap[mapkey] = ((encoding_json.RawMessage)(mapvalue))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessTokenResponseJsonMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessTokenResponseJsonMap == nil {
				m.AccessTokenResponseJsonMap = make(map[string]encoding_json.RawMessage)
			}
			var mapkey string
			var mapvalue encoding_json.RawMessage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = encoding_json.RawMessage(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlow(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFlow
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AccessTokenResponseJsonMap[mapkey] = ((encoding_json.RawMessage)(mapvalue))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTokenUrlTemplate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshTokenUrlTemplate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTokenBody", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshTokenBody = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTokenHeadersJsonMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RefreshTokenHeadersJsonMap == nil {
				m.RefreshTokenHeadersJsonMap = make(map[string]encoding_json.RawMessage)
			}
			var mapkey string
			var mapvalue encoding_json.RawMessage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = encoding_json.RawMessage(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlow(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFlow
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RefreshTokenHeadersJsonMap[mapkey] = ((encoding_json.RawMessage)(mapvalue))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTokenResponseJsonMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RefreshTokenResponseJsonMap == nil {
				m.RefreshTokenResponseJsonMap = make(map[string]encoding_json.RawMessage)
			}
			var mapkey string
			var mapvalue encoding_json.RawMessage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = encoding_json.RawMessage(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlow(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFlow
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RefreshTokenResponseJsonMap[mapkey] = ((encoding_json.RawMessage)(mapvalue))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessTokenMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessTokenMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTokenMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshTokenMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, TestSpec_Step{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestSpec_Step) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Step: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Step: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepType", wireType)
			}
			m.StepType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepType |= TestSpec_Step_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepIndex", wireType)
			}
			m.StepIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepScope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepScope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collection = Collection(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocsJsonVec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocsJsonVec = append(m.DocsJsonVec, encoding_json.RawMessage(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Partitions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBegin", wireType)
			}
			m.KeyBegin = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyBegin = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyEnd", wireType)
			}
			m.KeyEnd = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyEnd = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RClockBegin", wireType)
			}
			m.RClockBegin = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.RClockBegin = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RClockEnd", wireType)
			}
			m.RClockEnd = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.RClockEnd = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergePatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MergePatch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtractAPI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtractAPI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtractAPI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtractAPI_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidPtr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidPtr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPtrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPtrs = append(m.FieldPtrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Projections = append(m.Projections, Projection{})
			if err := m.Projections[len(m.Projections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineAPI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombineAPI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombineAPI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineAPI_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPtrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyPtrs = append(m.KeyPtrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidPlaceholderPtr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidPlaceholderPtr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Projections = append(m.Projections, Projection{})
			if err := m.Projections[len(m.Projections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InferSchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InferSchemaJson = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineAPI_Stats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Left == nil {
				m.Left = &DocsAndBytes{}
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Right == nil {
				m.Right = &DocsAndBytes{}
			}
			if err := m.Right.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Out", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Out == nil {
				m.Out = &DocsAndBytes{}
			}
			if err := m.Out.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildAPI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildAPI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildAPI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildAPI_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildDb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildDb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			m.SourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceType |= ContentType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorNetwork", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectorNetwork = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectRoot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetStateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetStateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetStateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetStateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetStateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetStateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvanceTimeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvanceTimeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvanceTimeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvanceSeconds", wireType)
			}
			m.AdvanceSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdvanceSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvanceTimeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvanceTimeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvanceTimeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocsAndBytes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocsAndBytes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocsAndBytes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Docs", wireType)
			}
			m.Docs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Docs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collection = Collection(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocsJsonVec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocsJsonVec = append(m.DocsJsonVec, encoding_json.RawMessage(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JournalWriteHeads", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JournalWriteHeads == nil {
				m.JournalWriteHeads = make(map[go_gazette_dev_core_broker_protocol.Journal]go_gazette_dev_core_broker_protocol.Offset)
			}
			var mapkey go_gazette_dev_core_broker_protocol.Journal
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = go_gazette_dev_core_broker_protocol.Journal(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlow(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFlow
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JournalWriteHeads[go_gazette_dev_core_broker_protocol.Journal(mapkey)] = ((go_gazette_dev_core_broker_protocol.Offset)(mapvalue))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JournalEtcd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.JournalEtcd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskNetworkProxyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskNetworkProxyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskNetworkProxyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Open == nil {
				m.Open = &TaskNetworkProxyRequest_Open{}
			}
			if err := m.Open.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskNetworkProxyRequest_Open) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Open: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Open: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &protocol.Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardId = go_gazette_dev_core_consumer_protocol.ShardID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPort", wireType)
			}
			m.TargetPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskNetworkProxyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskNetworkProxyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskNetworkProxyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenResponse == nil {
				m.OpenResponse = &TaskNetworkProxyResponse_OpenResponse{}
			}
			if err := m.OpenResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskNetworkProxyResponse_OpenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TaskNetworkProxyResponse_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &protocol.Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlow(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFlow
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFlow
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFlow
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFlow        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlow          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFlow = fmt.Errorf("proto: unexpected end of group")
)
