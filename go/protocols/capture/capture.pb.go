// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go/protocols/capture/capture.proto

package capture

import (
	context "context"
	encoding_json "encoding/json"
	fmt "fmt"
	flow "github.com/estuary/flow/go/protocols/flow"
	github_com_estuary_flow_go_protocols_flow "github.com/estuary/flow/go/protocols/flow"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Request struct {
	Spec        *Request_Spec        `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	Discover    *Request_Discover    `protobuf:"bytes,2,opt,name=discover,proto3" json:"discover,omitempty"`
	Validate    *Request_Validate    `protobuf:"bytes,3,opt,name=validate,proto3" json:"validate,omitempty"`
	Apply       *Request_Apply       `protobuf:"bytes,4,opt,name=apply,proto3" json:"apply,omitempty"`
	Open        *Request_Open        `protobuf:"bytes,5,opt,name=open,proto3" json:"open,omitempty"`
	Acknowledge *Request_Acknowledge `protobuf:"bytes,6,opt,name=acknowledge,proto3" json:"acknowledge,omitempty"`
	// Reserved for internal use.
	Internal             []byte   `protobuf:"bytes,100,opt,name=internal,json=$internal,proto3" json:"internal,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{0}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

// Spec requests the specification definition of this connector.
// Notably this includes its configuration JSON schemas.
type Request_Spec struct {
	// Connector type addressed by this request.
	ConnectorType flow.CaptureSpec_ConnectorType `protobuf:"varint,1,opt,name=connector_type,json=connectorType,proto3,enum=flow.CaptureSpec_ConnectorType" json:"connector_type,omitempty"`
	// Connector configuration, as an encoded JSON object.
	// This may be a partial specification (for example, a Docker image),
	// providing only enough information to fetch the remainder of the
	// specification schema.
	ConfigJson           encoding_json.RawMessage `protobuf:"bytes,2,opt,name=config_json,json=config,proto3,casttype=encoding/json.RawMessage" json:"config_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Request_Spec) Reset()         { *m = Request_Spec{} }
func (m *Request_Spec) String() string { return proto.CompactTextString(m) }
func (*Request_Spec) ProtoMessage()    {}
func (*Request_Spec) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{0, 0}
}
func (m *Request_Spec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Spec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Spec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Spec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Spec.Merge(m, src)
}
func (m *Request_Spec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Spec) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Spec.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Spec proto.InternalMessageInfo

// Discover returns the set of resources available from this connector.
type Request_Discover struct {
	// Name of the capture being discovered.
	Name github_com_estuary_flow_go_protocols_flow.Capture `protobuf:"bytes,1,opt,name=name,proto3,casttype=github.com/estuary/flow/go/protocols/flow.Capture" json:"name,omitempty"`
	// Connector type addressed by this request.
	ConnectorType flow.CaptureSpec_ConnectorType `protobuf:"varint,2,opt,name=connector_type,json=connectorType,proto3,enum=flow.CaptureSpec_ConnectorType" json:"connector_type,omitempty"`
	// Connector configuration, as an encoded JSON object.
	ConfigJson           encoding_json.RawMessage `protobuf:"bytes,3,opt,name=config_json,json=config,proto3,casttype=encoding/json.RawMessage" json:"config_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Request_Discover) Reset()         { *m = Request_Discover{} }
func (m *Request_Discover) String() string { return proto.CompactTextString(m) }
func (*Request_Discover) ProtoMessage()    {}
func (*Request_Discover) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{0, 1}
}
func (m *Request_Discover) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Discover) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Discover.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Discover) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Discover.Merge(m, src)
}
func (m *Request_Discover) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Discover) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Discover.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Discover proto.InternalMessageInfo

// Validate a capture configuration and proposed bindings.
// Validate is run out-of-band with ongoing capture invocations.
// It's purpose is to confirm that the proposed configuration
// is likely to succeed if applied and run, or to report any
// potential issues for the user to address.
type Request_Validate struct {
	// Name of the capture being validated.
	Name github_com_estuary_flow_go_protocols_flow.Capture `protobuf:"bytes,1,opt,name=name,proto3,casttype=github.com/estuary/flow/go/protocols/flow.Capture" json:"name,omitempty"`
	// Connector type addressed by this request.
	ConnectorType flow.CaptureSpec_ConnectorType `protobuf:"varint,2,opt,name=connector_type,json=connectorType,proto3,enum=flow.CaptureSpec_ConnectorType" json:"connector_type,omitempty"`
	// Connector configuration, as an encoded JSON object.
	ConfigJson encoding_json.RawMessage    `protobuf:"bytes,3,opt,name=config_json,json=config,proto3,casttype=encoding/json.RawMessage" json:"config_json,omitempty"`
	Bindings   []*Request_Validate_Binding `protobuf:"bytes,4,rep,name=bindings,proto3" json:"bindings,omitempty"`
	// Last CaptureSpec which was validated and published.
	// Note that this CaptureSpec may not have been applied.
	LastCapture *flow.CaptureSpec `protobuf:"bytes,5,opt,name=last_capture,json=lastCapture,proto3" json:"last_capture,omitempty"`
	// Version of the last validated CaptureSpec.
	LastVersion          string   `protobuf:"bytes,6,opt,name=last_version,json=lastVersion,proto3" json:"last_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request_Validate) Reset()         { *m = Request_Validate{} }
func (m *Request_Validate) String() string { return proto.CompactTextString(m) }
func (*Request_Validate) ProtoMessage()    {}
func (*Request_Validate) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{0, 2}
}
func (m *Request_Validate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Validate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Validate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Validate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Validate.Merge(m, src)
}
func (m *Request_Validate) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Validate) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Validate.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Validate proto.InternalMessageInfo

// Bindings of endpoint resources and collections to which they would be
// captured. Bindings are ordered and unique on the bound collection name.
type Request_Validate_Binding struct {
	// JSON-encoded object which specifies the endpoint resource to be captured.
	ResourceConfigJson encoding_json.RawMessage `protobuf:"bytes,1,opt,name=resource_config_json,json=resourceConfig,proto3,casttype=encoding/json.RawMessage" json:"resource_config_json,omitempty"`
	// Collection to be captured.
	Collection flow.CollectionSpec `protobuf:"bytes,2,opt,name=collection,proto3" json:"collection"`
	// Backfill counter for this binding.
	Backfill             uint32   `protobuf:"varint,3,opt,name=backfill,proto3" json:"backfill,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request_Validate_Binding) Reset()         { *m = Request_Validate_Binding{} }
func (m *Request_Validate_Binding) String() string { return proto.CompactTextString(m) }
func (*Request_Validate_Binding) ProtoMessage()    {}
func (*Request_Validate_Binding) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{0, 2, 0}
}
func (m *Request_Validate_Binding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Validate_Binding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Validate_Binding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Validate_Binding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Validate_Binding.Merge(m, src)
}
func (m *Request_Validate_Binding) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Validate_Binding) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Validate_Binding.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Validate_Binding proto.InternalMessageInfo

// Apply an updated capture specification to its endpoint,
// in preparation for an Open of a capture session.
// Apply is run by the leader shard of a capture task
// (having key_begin: 0) while the capture is quiescent.
// Apply may be called multiple times for a given `version` and
// `last_version`, even if a prior call succeeded from the connector's
// perspective, so implementations must be idempotent. However, the next
// session will not Open until it's preceding Apply has durably completed.
type Request_Apply struct {
	// Capture to be applied.
	Capture *flow.CaptureSpec `protobuf:"bytes,1,opt,name=capture,proto3" json:"capture,omitempty"`
	// Version of the CaptureSpec being applied.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Last CaptureSpec which was successfully applied.
	LastCapture *flow.CaptureSpec `protobuf:"bytes,4,opt,name=last_capture,json=lastCapture,proto3" json:"last_capture,omitempty"`
	// Version of the last applied CaptureSpec.
	LastVersion          string   `protobuf:"bytes,5,opt,name=last_version,json=lastVersion,proto3" json:"last_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request_Apply) Reset()         { *m = Request_Apply{} }
func (m *Request_Apply) String() string { return proto.CompactTextString(m) }
func (*Request_Apply) ProtoMessage()    {}
func (*Request_Apply) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{0, 3}
}
func (m *Request_Apply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Apply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Apply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Apply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Apply.Merge(m, src)
}
func (m *Request_Apply) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Apply) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Apply.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Apply proto.InternalMessageInfo

// Open a capture for reading documents from the endpoint.
// Unless the connector requests explicit acknowledgements,
// Open is the last message which will be sent to the connector.
type Request_Open struct {
	// CaptureSpec to be pulled.
	Capture *flow.CaptureSpec `protobuf:"bytes,1,opt,name=capture,proto3" json:"capture,omitempty"`
	// Version of the opened CaptureSpec.
	// The connector may want to require that this match the version last
	// provided to a successful Apply RPC. It's possible that it won't,
	// due to expected propagation races in Flow's distributed runtime.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Range of documents to be processed by this invocation.
	Range *flow.RangeSpec `protobuf:"bytes,3,opt,name=range,proto3" json:"range,omitempty"`
	// Last-persisted connector checkpoint state from a previous invocation.
	StateJson            encoding_json.RawMessage `protobuf:"bytes,4,opt,name=state_json,json=state,proto3,casttype=encoding/json.RawMessage" json:"state_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Request_Open) Reset()         { *m = Request_Open{} }
func (m *Request_Open) String() string { return proto.CompactTextString(m) }
func (*Request_Open) ProtoMessage()    {}
func (*Request_Open) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{0, 4}
}
func (m *Request_Open) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Open) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Open.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Open) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Open.Merge(m, src)
}
func (m *Request_Open) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Open) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Open.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Open proto.InternalMessageInfo

// Tell the connector that some number of its preceding Checkpoints have
// committed to the Flow recovery log.
//
// Acknowledge is sent only if the connector set
// Response.Opened.explicit_acknowledgements.
type Request_Acknowledge struct {
	// Number of preceeding Response.Checkpoint messages which have
	// committed and are being acknowledged. Always one or more.
	Checkpoints          uint32   `protobuf:"varint,1,opt,name=checkpoints,proto3" json:"checkpoints,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request_Acknowledge) Reset()         { *m = Request_Acknowledge{} }
func (m *Request_Acknowledge) String() string { return proto.CompactTextString(m) }
func (*Request_Acknowledge) ProtoMessage()    {}
func (*Request_Acknowledge) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{0, 5}
}
func (m *Request_Acknowledge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Acknowledge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Acknowledge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Acknowledge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Acknowledge.Merge(m, src)
}
func (m *Request_Acknowledge) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Acknowledge) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Acknowledge.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Acknowledge proto.InternalMessageInfo

type Response struct {
	Spec          *Response_Spec          `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	Discovered    *Response_Discovered    `protobuf:"bytes,2,opt,name=discovered,proto3" json:"discovered,omitempty"`
	Validated     *Response_Validated     `protobuf:"bytes,3,opt,name=validated,proto3" json:"validated,omitempty"`
	Applied       *Response_Applied       `protobuf:"bytes,4,opt,name=applied,proto3" json:"applied,omitempty"`
	Opened        *Response_Opened        `protobuf:"bytes,5,opt,name=opened,proto3" json:"opened,omitempty"`
	Captured      *Response_Captured      `protobuf:"bytes,6,opt,name=captured,proto3" json:"captured,omitempty"`
	SourcedSchema *Response_SourcedSchema `protobuf:"bytes,8,opt,name=sourced_schema,json=sourcedSchema,proto3" json:"sourced_schema,omitempty"`
	Checkpoint    *Response_Checkpoint    `protobuf:"bytes,7,opt,name=checkpoint,proto3" json:"checkpoint,omitempty"`
	// Reserved for internal use.
	Internal             []byte   `protobuf:"bytes,100,opt,name=internal,json=$internal,proto3" json:"internal,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{1}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

type Response_Spec struct {
	// Protocol version must be 3032023.
	Protocol uint32 `protobuf:"varint,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// JSON schema of the connector's configuration.
	ConfigSchemaJson encoding_json.RawMessage `protobuf:"bytes,2,opt,name=config_schema_json,json=configSchema,proto3,casttype=encoding/json.RawMessage" json:"config_schema_json,omitempty"`
	// JSON schema of the connector's resource configuration.
	ResourceConfigSchemaJson encoding_json.RawMessage `protobuf:"bytes,3,opt,name=resource_config_schema_json,json=resourceConfigSchema,proto3,casttype=encoding/json.RawMessage" json:"resource_config_schema_json,omitempty"`
	// URL for connector's documentation.
	DocumentationUrl string `protobuf:"bytes,4,opt,name=documentation_url,json=documentationUrl,proto3" json:"documentation_url,omitempty"`
	// Optional OAuth2 configuration.
	Oauth2 *flow.OAuth2 `protobuf:"bytes,5,opt,name=oauth2,proto3" json:"oauth2,omitempty"`
	// One or more JSON pointers, which are used to extract resource paths
	// from resource configurations of this connector. For example,
	// a database connector might have a resource config like:
	//   {"schema": "foo", "table": "bar", "other": "config", "answer": 42}
	// The connector would specify `resource_path_pointers: ["/schema", "/table"]`,
	// which would result in a `resource_path` of `["foo", "bar"]`.
	ResourcePathPointers []string `protobuf:"bytes,6,rep,name=resource_path_pointers,json=resourcePathPointers,proto3" json:"resource_path_pointers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response_Spec) Reset()         { *m = Response_Spec{} }
func (m *Response_Spec) String() string { return proto.CompactTextString(m) }
func (*Response_Spec) ProtoMessage()    {}
func (*Response_Spec) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{1, 0}
}
func (m *Response_Spec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Spec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Spec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Spec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Spec.Merge(m, src)
}
func (m *Response_Spec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Spec) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Spec.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Spec proto.InternalMessageInfo

// Discovered responds to Request.Discover.
type Response_Discovered struct {
	Bindings             []*Response_Discovered_Binding `protobuf:"bytes,1,rep,name=bindings,proto3" json:"bindings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *Response_Discovered) Reset()         { *m = Response_Discovered{} }
func (m *Response_Discovered) String() string { return proto.CompactTextString(m) }
func (*Response_Discovered) ProtoMessage()    {}
func (*Response_Discovered) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{1, 1}
}
func (m *Response_Discovered) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Discovered) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Discovered.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Discovered) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Discovered.Merge(m, src)
}
func (m *Response_Discovered) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Discovered) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Discovered.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Discovered proto.InternalMessageInfo

// Potential bindings which the capture could provide.
// Bindings may be returned in any order.
type Response_Discovered_Binding struct {
	// The recommended name for this discovered binding,
	// which is normalized and then appended to a catalog prefix of the
	// proposed capture to form the name of its recommended collection.
	RecommendedName string `protobuf:"bytes,1,opt,name=recommended_name,json=recommendedName,proto3" json:"recommended_name,omitempty"`
	// JSON-encoded object which specifies the captured resource configuration.
	ResourceConfigJson encoding_json.RawMessage `protobuf:"bytes,2,opt,name=resource_config_json,json=resourceConfig,proto3,casttype=encoding/json.RawMessage" json:"resource_config_json,omitempty"`
	// JSON schema of documents produced by this binding.
	DocumentSchemaJson encoding_json.RawMessage `protobuf:"bytes,3,opt,name=document_schema_json,json=documentSchema,proto3,casttype=encoding/json.RawMessage" json:"document_schema_json,omitempty"`
	// Composite key of documents (if known), as JSON-Pointers.
	Key []string `protobuf:"bytes,4,rep,name=key,proto3" json:"key,omitempty"`
	// When true, this binding should be added but marked as disabled.
	// The user may explicitly enable it, but the garden-path expectation
	// for most users is that they likely wouldn't want it.
	Disable bool `protobuf:"varint,5,opt,name=disable,proto3" json:"disable,omitempty"`
	// Components of the resource path which fully qualify the resource
	// identified by this binding.
	// - For an RDBMS, this might be []{dbname, schema, table}.
	// - For Kafka, this might be []{topic}.
	// - For Redis, this might be []{key_prefix}.
	ResourcePath []string `protobuf:"bytes,6,rep,name=resource_path,json=resourcePath,proto3" json:"resource_path,omitempty"`
	// Discovered bindings should reflect the natural identifiers of the
	// endpoint resources that they serve, such as user IDs of a `users` table.
	// At times there is no known identifier: an S3 file capture might key on
	// file name and row offset. Such keys should be marked as fallback keys.
	//
	// A simple criteria for determining whether a key is a fallback key is
	// to ask "will the connector emit deletions for this key?".
	// If the answer is "yes", the key is NOT a fallback.
	//
	// For regular (non-fallback) keys:
	// - The Estuary control-plane will update collection keys to reflect
	//   the latest discovered keys from the source endpoint.
	// - Users should not change such collection keys (they'll be overwritten).
	//
	// For fallback keys:
	// - The Estuary control-plane will initialize a new collection with the
	//   fallback key.
	// - Users may change the collection key, and it will not be overwritten
	//   by future discoveries.
	IsFallbackKey        bool     `protobuf:"varint,7,opt,name=is_fallback_key,json=isFallbackKey,proto3" json:"is_fallback_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response_Discovered_Binding) Reset()         { *m = Response_Discovered_Binding{} }
func (m *Response_Discovered_Binding) String() string { return proto.CompactTextString(m) }
func (*Response_Discovered_Binding) ProtoMessage()    {}
func (*Response_Discovered_Binding) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{1, 1, 0}
}
func (m *Response_Discovered_Binding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Discovered_Binding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Discovered_Binding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Discovered_Binding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Discovered_Binding.Merge(m, src)
}
func (m *Response_Discovered_Binding) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Discovered_Binding) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Discovered_Binding.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Discovered_Binding proto.InternalMessageInfo

// Validated responds to Request.Validate.
type Response_Validated struct {
	Bindings             []*Response_Validated_Binding `protobuf:"bytes,1,rep,name=bindings,proto3" json:"bindings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *Response_Validated) Reset()         { *m = Response_Validated{} }
func (m *Response_Validated) String() string { return proto.CompactTextString(m) }
func (*Response_Validated) ProtoMessage()    {}
func (*Response_Validated) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{1, 2}
}
func (m *Response_Validated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Validated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Validated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Validated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Validated.Merge(m, src)
}
func (m *Response_Validated) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Validated) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Validated.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Validated proto.InternalMessageInfo

// Validation responses for each binding of the request, and matching the
// request ordering. Each Binding must have a unique resource_path.
type Response_Validated_Binding struct {
	// Components of the resource path which fully qualify the resource
	// identified by this binding.
	// - For an RDBMS, this might be []{dbname, schema, table}.
	// - For Kafka, this might be []{topic}.
	// - For Redis, this might be []{key_prefix}.
	ResourcePath         []string `protobuf:"bytes,1,rep,name=resource_path,json=resourcePath,proto3" json:"resource_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response_Validated_Binding) Reset()         { *m = Response_Validated_Binding{} }
func (m *Response_Validated_Binding) String() string { return proto.CompactTextString(m) }
func (*Response_Validated_Binding) ProtoMessage()    {}
func (*Response_Validated_Binding) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{1, 2, 0}
}
func (m *Response_Validated_Binding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Validated_Binding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Validated_Binding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Validated_Binding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Validated_Binding.Merge(m, src)
}
func (m *Response_Validated_Binding) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Validated_Binding) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Validated_Binding.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Validated_Binding proto.InternalMessageInfo

// Applied responds to Request.Apply.
type Response_Applied struct {
	// Human-readable description of the action that the connector took.
	// If empty, this Apply is to be considered a "no-op".
	ActionDescription    string   `protobuf:"bytes,1,opt,name=action_description,json=actionDescription,proto3" json:"action_description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response_Applied) Reset()         { *m = Response_Applied{} }
func (m *Response_Applied) String() string { return proto.CompactTextString(m) }
func (*Response_Applied) ProtoMessage()    {}
func (*Response_Applied) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{1, 3}
}
func (m *Response_Applied) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Applied) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Applied.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Applied) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Applied.Merge(m, src)
}
func (m *Response_Applied) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Applied) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Applied.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Applied proto.InternalMessageInfo

// Opened responds to Request.Open.
// After Opened, the connector beings sending Captured and Checkpoint.
type Response_Opened struct {
	// If true then the runtime will send one Request.Acknowledge
	// for each Response.Checkpoint sent by the connector,
	// upon that Checkpoint having fully committed.
	ExplicitAcknowledgements bool     `protobuf:"varint,1,opt,name=explicit_acknowledgements,json=explicitAcknowledgements,proto3" json:"explicit_acknowledgements,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *Response_Opened) Reset()         { *m = Response_Opened{} }
func (m *Response_Opened) String() string { return proto.CompactTextString(m) }
func (*Response_Opened) ProtoMessage()    {}
func (*Response_Opened) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{1, 4}
}
func (m *Response_Opened) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Opened) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Opened.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Opened) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Opened.Merge(m, src)
}
func (m *Response_Opened) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Opened) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Opened.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Opened proto.InternalMessageInfo

// Document captured by this connector invocation.
// Emitted documents are pending, and are not committed to their bound collection
// until a following Checkpoint is emitted.
type Response_Captured struct {
	// Index of the Open binding for which this document is captured.
	Binding uint32 `protobuf:"varint,1,opt,name=binding,proto3" json:"binding,omitempty"`
	// Published JSON document.
	DocJson              encoding_json.RawMessage `protobuf:"bytes,2,opt,name=doc_json,json=doc,proto3,casttype=encoding/json.RawMessage" json:"doc_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Response_Captured) Reset()         { *m = Response_Captured{} }
func (m *Response_Captured) String() string { return proto.CompactTextString(m) }
func (*Response_Captured) ProtoMessage()    {}
func (*Response_Captured) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{1, 5}
}
func (m *Response_Captured) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Captured) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Captured.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Captured) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Captured.Merge(m, src)
}
func (m *Response_Captured) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Captured) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Captured.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Captured proto.InternalMessageInfo

// SourcedSchema notifies the runtime of a source-defined schema of the
// indicated binding. It's not required that the connector know that the
// schema has actually changed since a last SourcedSchema.
// It's encouraged for connectors to emit SourcedSchema liberally,
// such as on startup, or periodically, or upon encountering a previously
// unseen column.
//
// SourcedSchema may be a partial schema: it may schematize some
// specific field(s) and not others that are in active use.
//
// SourcedSchema should be maximally restrictive. It should disallow
// `types` and `additionalProperties` which are not explicitly being
// schematized. The platform will union a SourcedSchema with all other
// SourcedSchema messages of the binding, as well as additional inference
// updates required to fit Captured documents.
//
// SourcedSchema is transactional. It may be interleaved with zero or more
// Captured documents, and multiple SourcedSchema messages may be emitted
// for a single binding, but an emitted SourcedSchema has no effect until
// it's followed by a Checkpoint.
type Response_SourcedSchema struct {
	// Index of the Open binding for which the schema applies.
	Binding uint32 `protobuf:"varint,1,opt,name=binding,proto3" json:"binding,omitempty"`
	// JSON schema of documents produced by this binding.
	SchemaJson           encoding_json.RawMessage `protobuf:"bytes,2,opt,name=schema_json,json=documentSchema,proto3,casttype=encoding/json.RawMessage" json:"schema_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Response_SourcedSchema) Reset()         { *m = Response_SourcedSchema{} }
func (m *Response_SourcedSchema) String() string { return proto.CompactTextString(m) }
func (*Response_SourcedSchema) ProtoMessage()    {}
func (*Response_SourcedSchema) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{1, 6}
}
func (m *Response_SourcedSchema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_SourcedSchema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_SourcedSchema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_SourcedSchema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_SourcedSchema.Merge(m, src)
}
func (m *Response_SourcedSchema) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_SourcedSchema) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_SourcedSchema.DiscardUnknown(m)
}

var xxx_messageInfo_Response_SourcedSchema proto.InternalMessageInfo

// Checkpoint all preceding documents of this invocation since the last checkpoint.
// The Flow runtime may begin to commit documents in a transaction.
// Note that the runtime may include more than one checkpoint in a single transaction.
type Response_Checkpoint struct {
	State                *flow.ConnectorState `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Response_Checkpoint) Reset()         { *m = Response_Checkpoint{} }
func (m *Response_Checkpoint) String() string { return proto.CompactTextString(m) }
func (*Response_Checkpoint) ProtoMessage()    {}
func (*Response_Checkpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{1, 7}
}
func (m *Response_Checkpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Checkpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Checkpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Checkpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Checkpoint.Merge(m, src)
}
func (m *Response_Checkpoint) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Checkpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Checkpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Checkpoint proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Request)(nil), "capture.Request")
	proto.RegisterType((*Request_Spec)(nil), "capture.Request.Spec")
	proto.RegisterType((*Request_Discover)(nil), "capture.Request.Discover")
	proto.RegisterType((*Request_Validate)(nil), "capture.Request.Validate")
	proto.RegisterType((*Request_Validate_Binding)(nil), "capture.Request.Validate.Binding")
	proto.RegisterType((*Request_Apply)(nil), "capture.Request.Apply")
	proto.RegisterType((*Request_Open)(nil), "capture.Request.Open")
	proto.RegisterType((*Request_Acknowledge)(nil), "capture.Request.Acknowledge")
	proto.RegisterType((*Response)(nil), "capture.Response")
	proto.RegisterType((*Response_Spec)(nil), "capture.Response.Spec")
	proto.RegisterType((*Response_Discovered)(nil), "capture.Response.Discovered")
	proto.RegisterType((*Response_Discovered_Binding)(nil), "capture.Response.Discovered.Binding")
	proto.RegisterType((*Response_Validated)(nil), "capture.Response.Validated")
	proto.RegisterType((*Response_Validated_Binding)(nil), "capture.Response.Validated.Binding")
	proto.RegisterType((*Response_Applied)(nil), "capture.Response.Applied")
	proto.RegisterType((*Response_Opened)(nil), "capture.Response.Opened")
	proto.RegisterType((*Response_Captured)(nil), "capture.Response.Captured")
	proto.RegisterType((*Response_SourcedSchema)(nil), "capture.Response.SourcedSchema")
	proto.RegisterType((*Response_Checkpoint)(nil), "capture.Response.Checkpoint")
}

func init() {
	proto.RegisterFile("go/protocols/capture/capture.proto", fileDescriptor_841a70e6e6288f13)
}

var fileDescriptor_841a70e6e6288f13 = []byte{
	// 1239 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x56, 0x4d, 0x6f, 0xdc, 0x44,
	0x18, 0xae, 0xb3, 0x5f, 0xde, 0x77, 0x77, 0xd3, 0x64, 0x14, 0x2a, 0xd7, 0x8d, 0x92, 0xf4, 0x03,
	0x94, 0x7e, 0xb0, 0x5b, 0xb6, 0x2d, 0xb4, 0x7c, 0xb4, 0x24, 0x29, 0x95, 0x28, 0x82, 0x56, 0x13,
	0x28, 0x82, 0x8b, 0xe5, 0x8c, 0x27, 0xbb, 0x26, 0x5e, 0x8f, 0xb1, 0xbd, 0x09, 0x2b, 0xf1, 0x07,
	0xf8, 0x03, 0x9c, 0x7b, 0xe3, 0xc4, 0xcf, 0x40, 0xca, 0x81, 0x03, 0x47, 0x24, 0xa4, 0x48, 0x94,
	0x33, 0x7f, 0xa0, 0x27, 0x34, 0x5f, 0x5e, 0x6f, 0x9c, 0x44, 0x9b, 0xaa, 0x27, 0x2e, 0xc9, 0xce,
	0xbc, 0xcf, 0x3b, 0x7e, 0x3f, 0xe6, 0x7d, 0x9e, 0x81, 0x4b, 0x3d, 0xd6, 0x89, 0x62, 0x96, 0x32,
	0xc2, 0x82, 0xa4, 0x43, 0xdc, 0x28, 0x1d, 0xc6, 0x54, 0xff, 0x6f, 0x0b, 0x0b, 0xaa, 0xa9, 0xa5,
	0xbd, 0x38, 0x01, 0xde, 0x0e, 0xd8, 0x9e, 0xf8, 0x23, 0x61, 0xf6, 0x42, 0x8f, 0xf5, 0x98, 0xf8,
	0xd9, 0xe1, 0xbf, 0xe4, 0xee, 0xa5, 0x7f, 0x9b, 0x50, 0xc3, 0xf4, 0xfb, 0x21, 0x4d, 0x52, 0x74,
	0x15, 0xca, 0x49, 0x44, 0x89, 0x65, 0xac, 0x18, 0xab, 0x8d, 0xee, 0x1b, 0x6d, 0xfd, 0x19, 0x65,
	0x6f, 0x6f, 0x46, 0x94, 0x60, 0x01, 0x41, 0x77, 0xc0, 0xf4, 0xfc, 0x84, 0xb0, 0x5d, 0x1a, 0x5b,
	0x33, 0x02, 0x7e, 0xbe, 0x00, 0x7f, 0xa8, 0x00, 0x38, 0x83, 0x72, 0xb7, 0x5d, 0x37, 0xf0, 0x3d,
	0x37, 0xa5, 0x56, 0xe9, 0x18, 0xb7, 0x67, 0x0a, 0x80, 0x33, 0x28, 0xba, 0x01, 0x15, 0x37, 0x8a,
	0x82, 0x91, 0x55, 0x16, 0x3e, 0xe7, 0x0a, 0x3e, 0x6b, 0xdc, 0x8a, 0x25, 0x88, 0xa7, 0xc1, 0x22,
	0x1a, 0x5a, 0x95, 0x63, 0xd2, 0x78, 0x12, 0xd1, 0x10, 0x0b, 0x08, 0xba, 0x0f, 0x0d, 0x97, 0xec,
	0x84, 0x6c, 0x2f, 0xa0, 0x5e, 0x8f, 0x5a, 0x55, 0xe1, 0xb1, 0x58, 0x3c, 0x7e, 0x8c, 0xc1, 0x79,
	0x07, 0x74, 0x01, 0x4c, 0x3f, 0x4c, 0x69, 0x1c, 0xba, 0x81, 0xe5, 0xad, 0x18, 0xab, 0x4d, 0x5c,
	0xbf, 0xa2, 0x37, 0xec, 0x9f, 0x0c, 0x28, 0xf3, 0x92, 0xa1, 0x47, 0x30, 0x4b, 0x58, 0x18, 0x52,
	0x92, 0xb2, 0xd8, 0x49, 0x47, 0x11, 0x15, 0x15, 0x9e, 0xed, 0x2e, 0xb7, 0x45, 0x7b, 0x36, 0xe4,
	0xd7, 0x38, 0xb4, 0xbd, 0xa1, 0x71, 0x5f, 0x8e, 0x22, 0x8a, 0x5b, 0x24, 0xbf, 0x44, 0xf7, 0xa0,
	0x41, 0x58, 0xb8, 0xed, 0xf7, 0x9c, 0xef, 0x12, 0x16, 0x8a, 0xba, 0xd7, 0xd7, 0x17, 0x5f, 0x1e,
	0x2c, 0x5b, 0x34, 0x24, 0xcc, 0xf3, 0xc3, 0x5e, 0x87, 0x1b, 0xda, 0xd8, 0xdd, 0xfb, 0x9c, 0x26,
	0x89, 0xdb, 0xa3, 0xb8, 0x2a, 0x1d, 0xec, 0x3f, 0x0d, 0x30, 0x75, 0x3f, 0xd0, 0xa7, 0x50, 0x0e,
	0xdd, 0x81, 0x8c, 0xa2, 0xbe, 0x7e, 0xe7, 0xe5, 0xc1, 0xf2, 0x3b, 0x3d, 0x3f, 0xed, 0x0f, 0xb7,
	0xda, 0x84, 0x0d, 0x3a, 0x34, 0x49, 0x87, 0x6e, 0x3c, 0x92, 0xf7, 0xa7, 0x70, 0xa3, 0x74, 0xb4,
	0x58, 0x1c, 0x71, 0x44, 0x6a, 0x33, 0xaf, 0x23, 0xb5, 0xd2, 0x29, 0x52, 0x7b, 0x5e, 0x06, 0x53,
	0xdf, 0x99, 0xff, 0x57, 0x6a, 0xe8, 0x23, 0x30, 0xb7, 0xfc, 0x90, 0x43, 0x12, 0xab, 0xbc, 0x52,
	0x5a, 0x6d, 0x74, 0x2f, 0x1e, 0x3b, 0x2e, 0xed, 0x75, 0x89, 0xc4, 0x99, 0x0b, 0xba, 0x0d, 0xcd,
	0xc0, 0x4d, 0x52, 0x47, 0xb9, 0xa8, 0x81, 0x98, 0x2f, 0xc4, 0x8f, 0x1b, 0x1c, 0xa6, 0x36, 0xd0,
	0x45, 0xe5, 0xb5, 0x4b, 0xe3, 0xc4, 0x67, 0xa1, 0x18, 0x8a, 0xba, 0x84, 0x3c, 0x93, 0x5b, 0xf6,
	0xaf, 0x06, 0xd4, 0xd4, 0xe7, 0xd0, 0x63, 0x58, 0x88, 0x69, 0xc2, 0x86, 0x31, 0xa1, 0x4e, 0x3e,
	0x4f, 0x63, 0x8a, 0x3c, 0x67, 0xb5, 0xe7, 0x86, 0xcc, 0xf7, 0x7d, 0x00, 0xc2, 0x82, 0x80, 0x92,
	0xd4, 0x57, 0xf7, 0xbb, 0xd1, 0x5d, 0x50, 0xe1, 0x66, 0xfb, 0x3c, 0xe2, 0xf5, 0xf2, 0xfe, 0xc1,
	0xf2, 0x19, 0x9c, 0x43, 0x23, 0x1b, 0xcc, 0x2d, 0x97, 0xec, 0x6c, 0xfb, 0x41, 0x20, 0x6a, 0xdc,
	0xc2, 0xd9, 0xda, 0xfe, 0xc5, 0x80, 0x8a, 0xa0, 0x08, 0x74, 0x1d, 0x34, 0x5b, 0x2a, 0x96, 0x3b,
	0xa2, 0x1a, 0x1a, 0x81, 0x2c, 0xa8, 0xe9, 0x22, 0x88, 0x59, 0xc3, 0x7a, 0x59, 0xa8, 0x6c, 0xf9,
	0x95, 0x2a, 0x5b, 0x39, 0xb2, 0xb2, 0x65, 0xce, 0x4f, 0xaf, 0x2b, 0xd0, 0x37, 0xa1, 0x12, 0xbb,
	0x61, 0x4f, 0xb3, 0xed, 0x59, 0x79, 0x08, 0xe6, 0x5b, 0xe2, 0x08, 0x69, 0x45, 0xef, 0x01, 0x24,
	0xa9, 0x9b, 0x52, 0xd9, 0xba, 0xf2, 0x14, 0xad, 0xab, 0x08, 0xbc, 0xdd, 0x81, 0x46, 0x8e, 0x1c,
	0xd1, 0x0a, 0x34, 0x48, 0x9f, 0x92, 0x9d, 0x88, 0xf9, 0x61, 0x9a, 0x88, 0xc8, 0x5b, 0x38, 0xbf,
	0x75, 0xe9, 0xaf, 0x16, 0x98, 0x98, 0x26, 0x11, 0x0b, 0x13, 0x8a, 0xae, 0x4d, 0x08, 0x4e, 0x9e,
	0xd6, 0x25, 0x20, 0xaf, 0x38, 0x1f, 0x02, 0x68, 0x19, 0xa1, 0x9e, 0xba, 0x1b, 0x8b, 0x45, 0x8f,
	0x87, 0x19, 0x06, 0xe7, 0xf0, 0xe8, 0x1e, 0xd4, 0xb5, 0x9a, 0x78, 0xaa, 0x16, 0x17, 0x8a, 0xce,
	0x7a, 0x96, 0x3c, 0x3c, 0x46, 0xa3, 0x5b, 0x50, 0xe3, 0xba, 0xe2, 0x53, 0x4f, 0xb5, 0xf9, 0x7c,
	0xd1, 0x71, 0x4d, 0x02, 0xb0, 0x46, 0xa2, 0x9b, 0x50, 0xe5, 0x02, 0x43, 0x3d, 0x35, 0x74, 0x56,
	0xd1, 0xe7, 0x89, 0xb0, 0x63, 0x85, 0x43, 0xef, 0x82, 0xa9, 0x20, 0x9e, 0xd2, 0x21, 0xbb, 0xe8,
	0xa3, 0xba, 0xef, 0xe1, 0x0c, 0xcb, 0x69, 0x4a, 0xce, 0x90, 0xe7, 0x24, 0xa4, 0x4f, 0x07, 0xae,
	0x65, 0x0a, 0xef, 0xe5, 0x23, 0xaa, 0x29, 0x71, 0x9b, 0x02, 0x86, 0x5b, 0x49, 0x7e, 0xc9, 0xeb,
	0x3b, 0xee, 0x93, 0x55, 0x3b, 0xae, 0xbe, 0x1b, 0x19, 0x06, 0xe7, 0xf0, 0x27, 0x0b, 0xe1, 0xef,
	0x33, 0x4a, 0x08, 0x6d, 0x30, 0x35, 0xe5, 0xaa, 0xbb, 0x91, 0xad, 0xd1, 0x23, 0x40, 0x8a, 0x3e,
	0x64, 0x1a, 0xd3, 0x6b, 0x5c, 0x53, 0xfa, 0xa9, 0x3c, 0xbe, 0x86, 0x0b, 0x87, 0xf9, 0x28, 0x7f,
	0xe0, 0x34, 0xf4, 0xbb, 0x30, 0x49, 0x4b, 0xea, 0xe0, 0xeb, 0x30, 0xef, 0x31, 0x32, 0x1c, 0xd0,
	0x30, 0x75, 0x39, 0xe3, 0x38, 0xc3, 0x38, 0x90, 0xa3, 0x82, 0xe7, 0x26, 0x0c, 0x5f, 0xc5, 0x01,
	0xba, 0x02, 0x55, 0xe6, 0x0e, 0xd3, 0x7e, 0x57, 0xf5, 0xbf, 0x29, 0x07, 0xef, 0xc9, 0x1a, 0xdf,
	0xc3, 0xca, 0x86, 0x6e, 0xc3, 0xb9, 0x2c, 0xd6, 0xc8, 0x4d, 0xfb, 0x8e, 0x28, 0x26, 0x8d, 0x13,
	0xab, 0xba, 0x52, 0x5a, 0xad, 0x8f, 0x03, 0x79, 0xea, 0xa6, 0xfd, 0xa7, 0xca, 0x66, 0xff, 0x5c,
	0x02, 0x18, 0x5f, 0x73, 0xf4, 0x71, 0x4e, 0x24, 0x0c, 0x21, 0x12, 0x57, 0x4e, 0x1a, 0x8b, 0xa2,
	0x4e, 0xd8, 0xbf, 0xcd, 0x8c, 0xe9, 0xfc, 0x2a, 0xcc, 0xc5, 0x94, 0xb0, 0xc1, 0x80, 0x86, 0x1e,
	0xf5, 0x9c, 0xb1, 0x98, 0xe2, 0xb3, 0xb9, 0xfd, 0x2f, 0xb8, 0x40, 0x1e, 0xc7, 0xfc, 0x33, 0xaf,
	0xc0, 0xfc, 0x8f, 0x61, 0x41, 0xd7, 0xf0, 0xd4, 0xed, 0x9a, 0xd5, 0x9e, 0xaa, 0x51, 0x73, 0x50,
	0xda, 0xa1, 0x23, 0x21, 0x98, 0x75, 0xcc, 0x7f, 0x72, 0x7e, 0xf4, 0xfc, 0xc4, 0xdd, 0x0a, 0xa4,
	0x06, 0x9a, 0x58, 0x2f, 0xd1, 0x65, 0x68, 0x4d, 0x74, 0x40, 0x15, 0xbe, 0x99, 0x2f, 0x3c, 0x7a,
	0x0b, 0xce, 0xfa, 0x89, 0xb3, 0xed, 0x06, 0x01, 0x57, 0x14, 0x87, 0x1f, 0x5e, 0x13, 0xc7, 0xb4,
	0xfc, 0xe4, 0x91, 0xda, 0xfd, 0x8c, 0x8e, 0xec, 0x1f, 0xa1, 0x9e, 0x31, 0x08, 0x7a, 0x50, 0x68,
	0xcb, 0xe5, 0x13, 0x08, 0xe7, 0x88, 0xae, 0xb4, 0xc7, 0x4d, 0x29, 0x44, 0x69, 0x14, 0xa3, 0xb4,
	0xef, 0x42, 0x4d, 0xd1, 0x10, 0x7a, 0x1b, 0x90, 0x2b, 0x54, 0xd1, 0xf1, 0x68, 0x42, 0x62, 0x3f,
	0x12, 0x7a, 0x2a, 0xdb, 0x38, 0x2f, 0x2d, 0x0f, 0xc7, 0x06, 0xfb, 0x13, 0xa8, 0x4a, 0x32, 0x42,
	0x1f, 0xc0, 0x79, 0xfa, 0x43, 0x14, 0xf8, 0xc4, 0x4f, 0x9d, 0xdc, 0x3b, 0x97, 0x17, 0x57, 0xb2,
	0xb9, 0x89, 0x2d, 0x0d, 0x58, 0x3b, 0x64, 0xb7, 0xbf, 0x01, 0x53, 0xf3, 0x13, 0xaf, 0xb8, 0x4a,
	0x44, 0x0d, 0xba, 0x5e, 0xa2, 0x5b, 0x60, 0x7a, 0x8c, 0x4c, 0x7f, 0x53, 0x4a, 0x1e, 0x23, 0x76,
	0x00, 0xad, 0x09, 0xf2, 0x3a, 0xe1, 0xfc, 0x35, 0x68, 0x9c, 0x96, 0x40, 0x0e, 0x5d, 0x20, 0xfb,
	0x2e, 0xc0, 0x98, 0xe6, 0xd0, 0x35, 0x90, 0x5a, 0xa7, 0x54, 0x2a, 0x7b, 0x8f, 0xa8, 0x37, 0xde,
	0x26, 0xb7, 0x29, 0x39, 0xec, 0x3e, 0x80, 0x7a, 0x66, 0x40, 0x5d, 0xa8, 0x69, 0xe5, 0x9f, 0x3b,
	0xfc, 0x6c, 0xb3, 0xe7, 0x0b, 0x97, 0x61, 0xd5, 0xb8, 0x69, 0xac, 0xdf, 0xdf, 0xff, 0x7b, 0xe9,
	0xcc, 0xfe, 0x8b, 0x25, 0xe3, 0x8f, 0x17, 0x4b, 0xc6, 0xf3, 0x7f, 0x96, 0x8c, 0x6f, 0x6f, 0x4c,
	0xf5, 0x7e, 0x55, 0x87, 0x6d, 0x55, 0xc5, 0xd6, 0xad, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x29,
	0x40, 0x07, 0xee, 0x38, 0x0e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ConnectorClient is the client API for Connector service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ConnectorClient interface {
	Capture(ctx context.Context, opts ...grpc.CallOption) (Connector_CaptureClient, error)
}

type connectorClient struct {
	cc *grpc.ClientConn
}

func NewConnectorClient(cc *grpc.ClientConn) ConnectorClient {
	return &connectorClient{cc}
}

func (c *connectorClient) Capture(ctx context.Context, opts ...grpc.CallOption) (Connector_CaptureClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Connector_serviceDesc.Streams[0], "/capture.Connector/Capture", opts...)
	if err != nil {
		return nil, err
	}
	x := &connectorCaptureClient{stream}
	return x, nil
}

type Connector_CaptureClient interface {
	Send(*Request) error
	Recv() (*Response, error)
	grpc.ClientStream
}

type connectorCaptureClient struct {
	grpc.ClientStream
}

func (x *connectorCaptureClient) Send(m *Request) error {
	return x.ClientStream.SendMsg(m)
}

func (x *connectorCaptureClient) Recv() (*Response, error) {
	m := new(Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ConnectorServer is the server API for Connector service.
type ConnectorServer interface {
	Capture(Connector_CaptureServer) error
}

// UnimplementedConnectorServer can be embedded to have forward compatible implementations.
type UnimplementedConnectorServer struct {
}

func (*UnimplementedConnectorServer) Capture(srv Connector_CaptureServer) error {
	return status.Errorf(codes.Unimplemented, "method Capture not implemented")
}

func RegisterConnectorServer(s *grpc.Server, srv ConnectorServer) {
	s.RegisterService(&_Connector_serviceDesc, srv)
}

func _Connector_Capture_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ConnectorServer).Capture(&connectorCaptureServer{stream})
}

type Connector_CaptureServer interface {
	Send(*Response) error
	Recv() (*Request, error)
	grpc.ServerStream
}

type connectorCaptureServer struct {
	grpc.ServerStream
}

func (x *connectorCaptureServer) Send(m *Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *connectorCaptureServer) Recv() (*Request, error) {
	m := new(Request)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Connector_serviceDesc = grpc.ServiceDesc{
	ServiceName: "capture.Connector",
	HandlerType: (*ConnectorServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Capture",
			Handler:       _Connector_Capture_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "go/protocols/capture/capture.proto",
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Internal) > 0 {
		i -= len(m.Internal)
		copy(dAtA[i:], m.Internal)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.Internal)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if m.Acknowledge != nil {
		{
			size, err := m.Acknowledge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Open != nil {
		{
			size, err := m.Open.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Apply != nil {
		{
			size, err := m.Apply.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Validate != nil {
		{
			size, err := m.Validate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Discover != nil {
		{
			size, err := m.Discover.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request_Spec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Spec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Spec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ConfigJson) > 0 {
		i -= len(m.ConfigJson)
		copy(dAtA[i:], m.ConfigJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.ConfigJson)))
		i--
		dAtA[i] = 0x12
	}
	if m.ConnectorType != 0 {
		i = encodeVarintCapture(dAtA, i, uint64(m.ConnectorType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request_Discover) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Discover) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Discover) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ConfigJson) > 0 {
		i -= len(m.ConfigJson)
		copy(dAtA[i:], m.ConfigJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.ConfigJson)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConnectorType != 0 {
		i = encodeVarintCapture(dAtA, i, uint64(m.ConnectorType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request_Validate) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Validate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Validate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LastVersion) > 0 {
		i -= len(m.LastVersion)
		copy(dAtA[i:], m.LastVersion)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.LastVersion)))
		i--
		dAtA[i] = 0x32
	}
	if m.LastCapture != nil {
		{
			size, err := m.LastCapture.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Bindings) > 0 {
		for iNdEx := len(m.Bindings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bindings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCapture(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ConfigJson) > 0 {
		i -= len(m.ConfigJson)
		copy(dAtA[i:], m.ConfigJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.ConfigJson)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConnectorType != 0 {
		i = encodeVarintCapture(dAtA, i, uint64(m.ConnectorType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request_Validate_Binding) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Validate_Binding) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Validate_Binding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Backfill != 0 {
		i = encodeVarintCapture(dAtA, i, uint64(m.Backfill))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Collection.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCapture(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ResourceConfigJson) > 0 {
		i -= len(m.ResourceConfigJson)
		copy(dAtA[i:], m.ResourceConfigJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.ResourceConfigJson)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request_Apply) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Apply) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Apply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LastVersion) > 0 {
		i -= len(m.LastVersion)
		copy(dAtA[i:], m.LastVersion)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.LastVersion)))
		i--
		dAtA[i] = 0x2a
	}
	if m.LastCapture != nil {
		{
			size, err := m.LastCapture.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if m.Capture != nil {
		{
			size, err := m.Capture.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request_Open) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Open) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Open) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StateJson) > 0 {
		i -= len(m.StateJson)
		copy(dAtA[i:], m.StateJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.StateJson)))
		i--
		dAtA[i] = 0x22
	}
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if m.Capture != nil {
		{
			size, err := m.Capture.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request_Acknowledge) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Acknowledge) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Acknowledge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Checkpoints != 0 {
		i = encodeVarintCapture(dAtA, i, uint64(m.Checkpoints))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Internal) > 0 {
		i -= len(m.Internal)
		copy(dAtA[i:], m.Internal)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.Internal)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if m.SourcedSchema != nil {
		{
			size, err := m.SourcedSchema.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Checkpoint != nil {
		{
			size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Captured != nil {
		{
			size, err := m.Captured.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Opened != nil {
		{
			size, err := m.Opened.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Applied != nil {
		{
			size, err := m.Applied.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Validated != nil {
		{
			size, err := m.Validated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Discovered != nil {
		{
			size, err := m.Discovered.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response_Spec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Spec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Spec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ResourcePathPointers) > 0 {
		for iNdEx := len(m.ResourcePathPointers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResourcePathPointers[iNdEx])
			copy(dAtA[i:], m.ResourcePathPointers[iNdEx])
			i = encodeVarintCapture(dAtA, i, uint64(len(m.ResourcePathPointers[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Oauth2 != nil {
		{
			size, err := m.Oauth2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DocumentationUrl) > 0 {
		i -= len(m.DocumentationUrl)
		copy(dAtA[i:], m.DocumentationUrl)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.DocumentationUrl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ResourceConfigSchemaJson) > 0 {
		i -= len(m.ResourceConfigSchemaJson)
		copy(dAtA[i:], m.ResourceConfigSchemaJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.ResourceConfigSchemaJson)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ConfigSchemaJson) > 0 {
		i -= len(m.ConfigSchemaJson)
		copy(dAtA[i:], m.ConfigSchemaJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.ConfigSchemaJson)))
		i--
		dAtA[i] = 0x12
	}
	if m.Protocol != 0 {
		i = encodeVarintCapture(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Response_Discovered) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Discovered) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Discovered) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Bindings) > 0 {
		for iNdEx := len(m.Bindings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bindings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCapture(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Response_Discovered_Binding) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Discovered_Binding) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Discovered_Binding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsFallbackKey {
		i--
		if m.IsFallbackKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.ResourcePath) > 0 {
		for iNdEx := len(m.ResourcePath) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResourcePath[iNdEx])
			copy(dAtA[i:], m.ResourcePath[iNdEx])
			i = encodeVarintCapture(dAtA, i, uint64(len(m.ResourcePath[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Disable {
		i--
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Key) > 0 {
		for iNdEx := len(m.Key) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Key[iNdEx])
			copy(dAtA[i:], m.Key[iNdEx])
			i = encodeVarintCapture(dAtA, i, uint64(len(m.Key[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DocumentSchemaJson) > 0 {
		i -= len(m.DocumentSchemaJson)
		copy(dAtA[i:], m.DocumentSchemaJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.DocumentSchemaJson)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ResourceConfigJson) > 0 {
		i -= len(m.ResourceConfigJson)
		copy(dAtA[i:], m.ResourceConfigJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.ResourceConfigJson)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RecommendedName) > 0 {
		i -= len(m.RecommendedName)
		copy(dAtA[i:], m.RecommendedName)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.RecommendedName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response_Validated) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Validated) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Validated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Bindings) > 0 {
		for iNdEx := len(m.Bindings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bindings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCapture(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Response_Validated_Binding) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Validated_Binding) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Validated_Binding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ResourcePath) > 0 {
		for iNdEx := len(m.ResourcePath) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResourcePath[iNdEx])
			copy(dAtA[i:], m.ResourcePath[iNdEx])
			i = encodeVarintCapture(dAtA, i, uint64(len(m.ResourcePath[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Response_Applied) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Applied) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Applied) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ActionDescription) > 0 {
		i -= len(m.ActionDescription)
		copy(dAtA[i:], m.ActionDescription)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.ActionDescription)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response_Opened) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Opened) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Opened) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExplicitAcknowledgements {
		i--
		if m.ExplicitAcknowledgements {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Response_Captured) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Captured) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Captured) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DocJson) > 0 {
		i -= len(m.DocJson)
		copy(dAtA[i:], m.DocJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.DocJson)))
		i--
		dAtA[i] = 0x12
	}
	if m.Binding != 0 {
		i = encodeVarintCapture(dAtA, i, uint64(m.Binding))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Response_SourcedSchema) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_SourcedSchema) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_SourcedSchema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SchemaJson) > 0 {
		i -= len(m.SchemaJson)
		copy(dAtA[i:], m.SchemaJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.SchemaJson)))
		i--
		dAtA[i] = 0x12
	}
	if m.Binding != 0 {
		i = encodeVarintCapture(dAtA, i, uint64(m.Binding))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Response_Checkpoint) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Checkpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Checkpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCapture(dAtA []byte, offset int, v uint64) int {
	offset -= sovCapture(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Request) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Discover != nil {
		l = m.Discover.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Validate != nil {
		l = m.Validate.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Apply != nil {
		l = m.Apply.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Open != nil {
		l = m.Open.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Acknowledge != nil {
		l = m.Acknowledge.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.Internal)
	if l > 0 {
		n += 2 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Spec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectorType != 0 {
		n += 1 + sovCapture(uint64(m.ConnectorType))
	}
	l = len(m.ConfigJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Discover) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.ConnectorType != 0 {
		n += 1 + sovCapture(uint64(m.ConnectorType))
	}
	l = len(m.ConfigJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Validate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.ConnectorType != 0 {
		n += 1 + sovCapture(uint64(m.ConnectorType))
	}
	l = len(m.ConfigJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if len(m.Bindings) > 0 {
		for _, e := range m.Bindings {
			l = e.ProtoSize()
			n += 1 + l + sovCapture(uint64(l))
		}
	}
	if m.LastCapture != nil {
		l = m.LastCapture.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.LastVersion)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Validate_Binding) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceConfigJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	l = m.Collection.ProtoSize()
	n += 1 + l + sovCapture(uint64(l))
	if m.Backfill != 0 {
		n += 1 + sovCapture(uint64(m.Backfill))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Apply) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Capture != nil {
		l = m.Capture.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.LastCapture != nil {
		l = m.LastCapture.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.LastVersion)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Open) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Capture != nil {
		l = m.Capture.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Range != nil {
		l = m.Range.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.StateJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Acknowledge) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Checkpoints != 0 {
		n += 1 + sovCapture(uint64(m.Checkpoints))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Discovered != nil {
		l = m.Discovered.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Validated != nil {
		l = m.Validated.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Applied != nil {
		l = m.Applied.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Opened != nil {
		l = m.Opened.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Captured != nil {
		l = m.Captured.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Checkpoint != nil {
		l = m.Checkpoint.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.SourcedSchema != nil {
		l = m.SourcedSchema.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.Internal)
	if l > 0 {
		n += 2 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Spec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Protocol != 0 {
		n += 1 + sovCapture(uint64(m.Protocol))
	}
	l = len(m.ConfigSchemaJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.ResourceConfigSchemaJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.DocumentationUrl)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Oauth2 != nil {
		l = m.Oauth2.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if len(m.ResourcePathPointers) > 0 {
		for _, s := range m.ResourcePathPointers {
			l = len(s)
			n += 1 + l + sovCapture(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Discovered) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Bindings) > 0 {
		for _, e := range m.Bindings {
			l = e.ProtoSize()
			n += 1 + l + sovCapture(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Discovered_Binding) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecommendedName)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.ResourceConfigJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.DocumentSchemaJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if len(m.Key) > 0 {
		for _, s := range m.Key {
			l = len(s)
			n += 1 + l + sovCapture(uint64(l))
		}
	}
	if m.Disable {
		n += 2
	}
	if len(m.ResourcePath) > 0 {
		for _, s := range m.ResourcePath {
			l = len(s)
			n += 1 + l + sovCapture(uint64(l))
		}
	}
	if m.IsFallbackKey {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Validated) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Bindings) > 0 {
		for _, e := range m.Bindings {
			l = e.ProtoSize()
			n += 1 + l + sovCapture(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Validated_Binding) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResourcePath) > 0 {
		for _, s := range m.ResourcePath {
			l = len(s)
			n += 1 + l + sovCapture(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Applied) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionDescription)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Opened) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExplicitAcknowledgements {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Captured) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Binding != 0 {
		n += 1 + sovCapture(uint64(m.Binding))
	}
	l = len(m.DocJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_SourcedSchema) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Binding != 0 {
		n += 1 + sovCapture(uint64(m.Binding))
	}
	l = len(m.SchemaJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Checkpoint) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = m.State.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCapture(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCapture(x uint64) (n int) {
	return sovCapture(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &Request_Spec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discover", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Discover == nil {
				m.Discover = &Request_Discover{}
			}
			if err := m.Discover.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Validate == nil {
				m.Validate = &Request_Validate{}
			}
			if err := m.Validate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Apply == nil {
				m.Apply = &Request_Apply{}
			}
			if err := m.Apply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Open == nil {
				m.Open = &Request_Open{}
			}
			if err := m.Open.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acknowledge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Acknowledge == nil {
				m.Acknowledge = &Request_Acknowledge{}
			}
			if err := m.Acknowledge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Internal = append(m.Internal[:0], dAtA[iNdEx:postIndex]...)
			if m.Internal == nil {
				m.Internal = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Spec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorType", wireType)
			}
			m.ConnectorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectorType |= flow.CaptureSpec_ConnectorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Discover) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Discover: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Discover: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = github_com_estuary_flow_go_protocols_flow.Capture(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorType", wireType)
			}
			m.ConnectorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectorType |= flow.CaptureSpec_ConnectorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Validate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = github_com_estuary_flow_go_protocols_flow.Capture(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorType", wireType)
			}
			m.ConnectorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectorType |= flow.CaptureSpec_ConnectorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bindings = append(m.Bindings, &Request_Validate_Binding{})
			if err := m.Bindings[len(m.Bindings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCapture", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastCapture == nil {
				m.LastCapture = &flow.CaptureSpec{}
			}
			if err := m.LastCapture.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Validate_Binding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Binding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Binding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backfill", wireType)
			}
			m.Backfill = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Backfill |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Apply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Apply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Apply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capture", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Capture == nil {
				m.Capture = &flow.CaptureSpec{}
			}
			if err := m.Capture.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCapture", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastCapture == nil {
				m.LastCapture = &flow.CaptureSpec{}
			}
			if err := m.LastCapture.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Open) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Open: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Open: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capture", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Capture == nil {
				m.Capture = &flow.CaptureSpec{}
			}
			if err := m.Capture.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &flow.RangeSpec{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Acknowledge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Acknowledge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Acknowledge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoints", wireType)
			}
			m.Checkpoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checkpoints |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &Response_Spec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discovered", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Discovered == nil {
				m.Discovered = &Response_Discovered{}
			}
			if err := m.Discovered.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Validated == nil {
				m.Validated = &Response_Validated{}
			}
			if err := m.Validated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applied", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Applied == nil {
				m.Applied = &Response_Applied{}
			}
			if err := m.Applied.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opened", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opened == nil {
				m.Opened = &Response_Opened{}
			}
			if err := m.Opened.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captured", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Captured == nil {
				m.Captured = &Response_Captured{}
			}
			if err := m.Captured.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Checkpoint == nil {
				m.Checkpoint = &Response_Checkpoint{}
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcedSchema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourcedSchema == nil {
				m.SourcedSchema = &Response_SourcedSchema{}
			}
			if err := m.SourcedSchema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Internal = append(m.Internal[:0], dAtA[iNdEx:postIndex]...)
			if m.Internal == nil {
				m.Internal = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Spec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigSchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigSchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceConfigSchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceConfigSchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentationUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocumentationUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oauth2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Oauth2 == nil {
				m.Oauth2 = &flow.OAuth2{}
			}
			if err := m.Oauth2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePathPointers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourcePathPointers = append(m.ResourcePathPointers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Discovered) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Discovered: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Discovered: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bindings = append(m.Bindings, &Response_Discovered_Binding{})
			if err := m.Bindings[len(m.Bindings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Discovered_Binding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Binding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Binding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendedName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecommendedName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentSchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocumentSchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourcePath = append(m.ResourcePath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFallbackKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFallbackKey = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Validated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bindings = append(m.Bindings, &Response_Validated_Binding{})
			if err := m.Bindings[len(m.Bindings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Validated_Binding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Binding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Binding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourcePath = append(m.ResourcePath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Applied) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Applied: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Applied: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Opened) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opened: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opened: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExplicitAcknowledgements", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExplicitAcknowledgements = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Captured) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Captured: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Captured: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binding", wireType)
			}
			m.Binding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Binding |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_SourcedSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourcedSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourcedSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binding", wireType)
			}
			m.Binding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Binding |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Checkpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Checkpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Checkpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &flow.ConnectorState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCapture(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCapture
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCapture
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCapture
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCapture        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCapture          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCapture = fmt.Errorf("proto: unexpected end of group")
)
