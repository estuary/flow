// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go/protocols/capture/capture.proto

package capture

import (
	context "context"
	encoding_binary "encoding/binary"
	encoding_json "encoding/json"
	fmt "fmt"
	flow "github.com/estuary/flow/go/protocols/flow"
	github_com_estuary_flow_go_protocols_flow "github.com/estuary/flow/go/protocols/flow"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	protocol "go.gazette.dev/core/broker/protocol"
	protocol1 "go.gazette.dev/core/consumer/protocol"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SpecRequest is the request type of the Spec RPC.
type SpecRequest struct {
	// Endpoint type addressed by this request.
	EndpointType flow.EndpointType `protobuf:"varint,1,opt,name=endpoint_type,json=endpointType,proto3,enum=flow.EndpointType" json:"endpoint_type,omitempty"`
	// Driver specification, as an encoded JSON object.
	// This may be a partial specification (for example, a Docker image),
	// providing only enough information to fetch the remainder of the
	// specification schema.
	EndpointSpecJson     encoding_json.RawMessage `protobuf:"bytes,2,opt,name=endpoint_spec_json,json=endpointSpec,proto3,casttype=encoding/json.RawMessage" json:"endpoint_spec_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *SpecRequest) Reset()         { *m = SpecRequest{} }
func (m *SpecRequest) String() string { return proto.CompactTextString(m) }
func (*SpecRequest) ProtoMessage()    {}
func (*SpecRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{0}
}
func (m *SpecRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecRequest.Merge(m, src)
}
func (m *SpecRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SpecRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpecRequest proto.InternalMessageInfo

// SpecResponse is the response type of the Spec RPC.
type SpecResponse struct {
	// JSON schema of an endpoint specification.
	EndpointSpecSchemaJson encoding_json.RawMessage `protobuf:"bytes,1,opt,name=endpoint_spec_schema_json,json=endpointSpecSchema,proto3,casttype=encoding/json.RawMessage" json:"endpoint_spec_schema_json,omitempty"`
	// JSON schema of a resource specification.
	ResourceSpecSchemaJson encoding_json.RawMessage `protobuf:"bytes,2,opt,name=resource_spec_schema_json,json=resourceSpecSchema,proto3,casttype=encoding/json.RawMessage" json:"resource_spec_schema_json,omitempty"`
	// URL for connector's documention.
	DocumentationUrl string `protobuf:"bytes,3,opt,name=documentation_url,json=documentationUrl,proto3" json:"documentation_url,omitempty"`
	// OAuth2 spec
	Oauth2Spec           *flow.OAuth2Spec `protobuf:"bytes,4,opt,name=oauth2_spec,json=oauth2Spec,proto3" json:"oauth2_spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SpecResponse) Reset()         { *m = SpecResponse{} }
func (m *SpecResponse) String() string { return proto.CompactTextString(m) }
func (*SpecResponse) ProtoMessage()    {}
func (*SpecResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{1}
}
func (m *SpecResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecResponse.Merge(m, src)
}
func (m *SpecResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SpecResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpecResponse proto.InternalMessageInfo

// DiscoverRequest is the request type of the Discover RPC.
type DiscoverRequest struct {
	// Endpoint type addressed by this request.
	EndpointType flow.EndpointType `protobuf:"varint,1,opt,name=endpoint_type,json=endpointType,proto3,enum=flow.EndpointType" json:"endpoint_type,omitempty"`
	// Driver specification, as an encoded JSON object.
	EndpointSpecJson     encoding_json.RawMessage `protobuf:"bytes,2,opt,name=endpoint_spec_json,json=endpointSpec,proto3,casttype=encoding/json.RawMessage" json:"endpoint_spec_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *DiscoverRequest) Reset()         { *m = DiscoverRequest{} }
func (m *DiscoverRequest) String() string { return proto.CompactTextString(m) }
func (*DiscoverRequest) ProtoMessage()    {}
func (*DiscoverRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{2}
}
func (m *DiscoverRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscoverRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiscoverRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiscoverRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscoverRequest.Merge(m, src)
}
func (m *DiscoverRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DiscoverRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscoverRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DiscoverRequest proto.InternalMessageInfo

// DiscoverResponse is the response type of the Discover RPC.
type DiscoverResponse struct {
	Bindings             []*DiscoverResponse_Binding `protobuf:"bytes,1,rep,name=bindings,proto3" json:"bindings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *DiscoverResponse) Reset()         { *m = DiscoverResponse{} }
func (m *DiscoverResponse) String() string { return proto.CompactTextString(m) }
func (*DiscoverResponse) ProtoMessage()    {}
func (*DiscoverResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{3}
}
func (m *DiscoverResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscoverResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiscoverResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiscoverResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscoverResponse.Merge(m, src)
}
func (m *DiscoverResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DiscoverResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscoverResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DiscoverResponse proto.InternalMessageInfo

// Potential bindings which the capture could provide.
// Bindings may be returned in any order.
type DiscoverResponse_Binding struct {
	// The recommended name for this discovered binding,
	// which is appended to a catalog prefix of the proposed capture
	// to form the name of its recommended collection.
	RecommendedName github_com_estuary_flow_go_protocols_flow.Collection `protobuf:"bytes,1,opt,name=recommended_name,json=recommendedName,proto3,casttype=github.com/estuary/flow/go/protocols/flow.Collection" json:"recommended_name,omitempty"`
	// JSON-encoded object which specifies the endpoint resource to be captured.
	ResourceSpecJson encoding_json.RawMessage `protobuf:"bytes,2,opt,name=resource_spec_json,json=resourceSpec,proto3,casttype=encoding/json.RawMessage" json:"resource_spec_json,omitempty"`
	// JSON schema of documents produced by this binding.
	DocumentSchemaJson encoding_json.RawMessage `protobuf:"bytes,3,opt,name=document_schema_json,json=documentSchema,proto3,casttype=encoding/json.RawMessage" json:"document_schema_json,omitempty"`
	// Composite key of documents (if known), as JSON-Pointers.
	KeyPtrs              []string `protobuf:"bytes,4,rep,name=key_ptrs,json=keyPtrs,proto3" json:"key_ptrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiscoverResponse_Binding) Reset()         { *m = DiscoverResponse_Binding{} }
func (m *DiscoverResponse_Binding) String() string { return proto.CompactTextString(m) }
func (*DiscoverResponse_Binding) ProtoMessage()    {}
func (*DiscoverResponse_Binding) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{3, 0}
}
func (m *DiscoverResponse_Binding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscoverResponse_Binding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiscoverResponse_Binding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiscoverResponse_Binding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscoverResponse_Binding.Merge(m, src)
}
func (m *DiscoverResponse_Binding) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DiscoverResponse_Binding) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscoverResponse_Binding.DiscardUnknown(m)
}

var xxx_messageInfo_DiscoverResponse_Binding proto.InternalMessageInfo

// ValidateRequest is the request type of the Validate RPC.
type ValidateRequest struct {
	// Name of the capture being validated.
	Capture github_com_estuary_flow_go_protocols_flow.Capture `protobuf:"bytes,1,opt,name=capture,proto3,casttype=github.com/estuary/flow/go/protocols/flow.Capture" json:"capture,omitempty"`
	// Endpoint type addressed by this request.
	EndpointType flow.EndpointType `protobuf:"varint,2,opt,name=endpoint_type,json=endpointType,proto3,enum=flow.EndpointType" json:"endpoint_type,omitempty"`
	// Driver specification, as an encoded JSON object.
	EndpointSpecJson     encoding_json.RawMessage   `protobuf:"bytes,3,opt,name=endpoint_spec_json,json=endpointSpec,proto3,casttype=encoding/json.RawMessage" json:"endpoint_spec_json,omitempty"`
	Bindings             []*ValidateRequest_Binding `protobuf:"bytes,4,rep,name=bindings,proto3" json:"bindings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *ValidateRequest) Reset()         { *m = ValidateRequest{} }
func (m *ValidateRequest) String() string { return proto.CompactTextString(m) }
func (*ValidateRequest) ProtoMessage()    {}
func (*ValidateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{4}
}
func (m *ValidateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateRequest.Merge(m, src)
}
func (m *ValidateRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ValidateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateRequest proto.InternalMessageInfo

// Bindings of endpoint resources and collections to which they would be
// captured. Bindings are ordered and unique on the bound collection name.
type ValidateRequest_Binding struct {
	// JSON-encoded object which specifies the endpoint resource to be captured.
	ResourceSpecJson encoding_json.RawMessage `protobuf:"bytes,1,opt,name=resource_spec_json,json=resourceSpec,proto3,casttype=encoding/json.RawMessage" json:"resource_spec_json,omitempty"`
	// Collection to be captured.
	Collection           flow.CollectionSpec `protobuf:"bytes,2,opt,name=collection,proto3" json:"collection"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ValidateRequest_Binding) Reset()         { *m = ValidateRequest_Binding{} }
func (m *ValidateRequest_Binding) String() string { return proto.CompactTextString(m) }
func (*ValidateRequest_Binding) ProtoMessage()    {}
func (*ValidateRequest_Binding) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{4, 0}
}
func (m *ValidateRequest_Binding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateRequest_Binding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateRequest_Binding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateRequest_Binding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateRequest_Binding.Merge(m, src)
}
func (m *ValidateRequest_Binding) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ValidateRequest_Binding) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateRequest_Binding.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateRequest_Binding proto.InternalMessageInfo

// ValidateResponse is the response type of the Validate RPC.
type ValidateResponse struct {
	Bindings             []*ValidateResponse_Binding `protobuf:"bytes,1,rep,name=bindings,proto3" json:"bindings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *ValidateResponse) Reset()         { *m = ValidateResponse{} }
func (m *ValidateResponse) String() string { return proto.CompactTextString(m) }
func (*ValidateResponse) ProtoMessage()    {}
func (*ValidateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{5}
}
func (m *ValidateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateResponse.Merge(m, src)
}
func (m *ValidateResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ValidateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateResponse proto.InternalMessageInfo

// Validation responses for each binding of the request, and matching the
// request ordering. Each Binding must have a unique resource_path.
type ValidateResponse_Binding struct {
	// Components of the resource path which fully qualify the resource
	// identified by this binding.
	// - For an RDBMS, this might be []{dbname, schema, table}.
	// - For Kafka, this might be []{topic}.
	// - For Redis, this might be []{key_prefix}.
	ResourcePath         []string `protobuf:"bytes,1,rep,name=resource_path,json=resourcePath,proto3" json:"resource_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValidateResponse_Binding) Reset()         { *m = ValidateResponse_Binding{} }
func (m *ValidateResponse_Binding) String() string { return proto.CompactTextString(m) }
func (*ValidateResponse_Binding) ProtoMessage()    {}
func (*ValidateResponse_Binding) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{5, 0}
}
func (m *ValidateResponse_Binding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateResponse_Binding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateResponse_Binding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateResponse_Binding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateResponse_Binding.Merge(m, src)
}
func (m *ValidateResponse_Binding) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ValidateResponse_Binding) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateResponse_Binding.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateResponse_Binding proto.InternalMessageInfo

// ApplyRequest is the request type of the ApplyUpsert and ApplyDelete RPCs.
type ApplyRequest struct {
	// Capture to be applied.
	Capture *flow.CaptureSpec `protobuf:"bytes,1,opt,name=capture,proto3" json:"capture,omitempty"`
	// Version of the CaptureSpec being applied.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Is this Apply a dry-run? If so, no action is undertaken and Apply will
	// report only what would have happened.
	DryRun               bool     `protobuf:"varint,3,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ApplyRequest) Reset()         { *m = ApplyRequest{} }
func (m *ApplyRequest) String() string { return proto.CompactTextString(m) }
func (*ApplyRequest) ProtoMessage()    {}
func (*ApplyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{6}
}
func (m *ApplyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyRequest.Merge(m, src)
}
func (m *ApplyRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ApplyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyRequest proto.InternalMessageInfo

// ApplyResponse is the response type of the ApplyUpsert and ApplyDelete RPCs.
type ApplyResponse struct {
	// Human-readable description of the action that the Driver took (or, if
	// dry_run, would have taken). If empty, this Apply is to be considered a
	// "no-op".
	ActionDescription    string   `protobuf:"bytes,1,opt,name=action_description,json=actionDescription,proto3" json:"action_description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ApplyResponse) Reset()         { *m = ApplyResponse{} }
func (m *ApplyResponse) String() string { return proto.CompactTextString(m) }
func (*ApplyResponse) ProtoMessage()    {}
func (*ApplyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{7}
}
func (m *ApplyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyResponse.Merge(m, src)
}
func (m *ApplyResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ApplyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyResponse proto.InternalMessageInfo

// Documents is a set of documents drawn from a binding of the capture.
type Documents struct {
	// The capture binding for documents of this message.
	Binding uint32 `protobuf:"varint,1,opt,name=binding,proto3" json:"binding,omitempty"`
	// Byte arena of the response.
	Arena github_com_estuary_flow_go_protocols_flow.Arena `protobuf:"bytes,2,opt,name=arena,proto3,casttype=github.com/estuary/flow/go/protocols/flow.Arena" json:"arena,omitempty"`
	// Captured JSON documents.
	DocsJson             []flow.Slice `protobuf:"bytes,3,rep,name=docs_json,json=docsJson,proto3" json:"docs_json"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Documents) Reset()         { *m = Documents{} }
func (m *Documents) String() string { return proto.CompactTextString(m) }
func (*Documents) ProtoMessage()    {}
func (*Documents) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{8}
}
func (m *Documents) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Documents) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Documents.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Documents) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Documents.Merge(m, src)
}
func (m *Documents) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Documents) XXX_DiscardUnknown() {
	xxx_messageInfo_Documents.DiscardUnknown(m)
}

var xxx_messageInfo_Documents proto.InternalMessageInfo

// Acknowledge is a notification that a Checkpoint has committed to the
// Flow runtime's recovery log.
type Acknowledge struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Acknowledge) Reset()         { *m = Acknowledge{} }
func (m *Acknowledge) String() string { return proto.CompactTextString(m) }
func (*Acknowledge) ProtoMessage()    {}
func (*Acknowledge) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{9}
}
func (m *Acknowledge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Acknowledge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Acknowledge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Acknowledge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Acknowledge.Merge(m, src)
}
func (m *Acknowledge) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Acknowledge) XXX_DiscardUnknown() {
	xxx_messageInfo_Acknowledge.DiscardUnknown(m)
}

var xxx_messageInfo_Acknowledge proto.InternalMessageInfo

// PullRequest is the request type of a Driver.Pull RPC.
// It will have exactly one top-level field set, which represents its message
// type.
type PullRequest struct {
	Open *PullRequest_Open `protobuf:"bytes,1,opt,name=open,proto3" json:"open,omitempty"`
	// Tell the driver that its Checkpoint has committed to the Flow recovery log.
	// Acknowledgments are sent iff PullResponse.Opened.explicit_acknowledgements is true.
	Acknowledge          *Acknowledge `protobuf:"bytes,2,opt,name=acknowledge,proto3" json:"acknowledge,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *PullRequest) Reset()         { *m = PullRequest{} }
func (m *PullRequest) String() string { return proto.CompactTextString(m) }
func (*PullRequest) ProtoMessage()    {}
func (*PullRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{10}
}
func (m *PullRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PullRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PullRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PullRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PullRequest.Merge(m, src)
}
func (m *PullRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PullRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PullRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PullRequest proto.InternalMessageInfo

// Open opens a Pull of the driver, and is sent exactly once as the first
// message of the stream.
type PullRequest_Open struct {
	// CaptureSpec to be pulled.
	Capture *flow.CaptureSpec `protobuf:"bytes,1,opt,name=capture,proto3" json:"capture,omitempty"`
	// Version of the opened CaptureSpec.
	// The driver may want to require that this match the version last
	// provided to a successful Apply RPC. It's possible that it won't,
	// due to expected propagation races in Flow's distributed runtime.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// [key_begin, key_end] inclusive range of keys processed by this
	// transaction stream. Ranges reflect the disjoint chunks of ownership
	// specific to each instance of a scale-out capture implementation.
	KeyBegin uint32 `protobuf:"fixed32,3,opt,name=key_begin,json=keyBegin,proto3" json:"key_begin,omitempty"`
	KeyEnd   uint32 `protobuf:"fixed32,4,opt,name=key_end,json=keyEnd,proto3" json:"key_end,omitempty"`
	// Last-persisted driver checkpoint from a previous capture stream.
	// Or empty, if the driver has cleared or never set its checkpoint.
	DriverCheckpointJson encoding_json.RawMessage `protobuf:"bytes,5,opt,name=driver_checkpoint_json,json=driverCheckpoint,proto3,casttype=encoding/json.RawMessage" json:"driver_checkpoint_json,omitempty"`
	// If true, perform a blocking tail of the capture.
	// If false, produce all ready output and then close the stream.
	Tail                 bool     `protobuf:"varint,6,opt,name=tail,proto3" json:"tail,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PullRequest_Open) Reset()         { *m = PullRequest_Open{} }
func (m *PullRequest_Open) String() string { return proto.CompactTextString(m) }
func (*PullRequest_Open) ProtoMessage()    {}
func (*PullRequest_Open) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{10, 0}
}
func (m *PullRequest_Open) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PullRequest_Open) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PullRequest_Open.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PullRequest_Open) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PullRequest_Open.Merge(m, src)
}
func (m *PullRequest_Open) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PullRequest_Open) XXX_DiscardUnknown() {
	xxx_messageInfo_PullRequest_Open.DiscardUnknown(m)
}

var xxx_messageInfo_PullRequest_Open proto.InternalMessageInfo

// PullResponse is the response type of a Driver.Pull RPC.
// It will have exactly one top-level field set, which represents its message
// type.
type PullResponse struct {
	Opened *PullResponse_Opened `protobuf:"bytes,1,opt,name=opened,proto3" json:"opened,omitempty"`
	// Captured documents of the stream.
	Documents *Documents `protobuf:"bytes,2,opt,name=documents,proto3" json:"documents,omitempty"`
	// Checkpoint all preceeding Documents of this stream.
	Checkpoint           *flow.DriverCheckpoint `protobuf:"bytes,3,opt,name=checkpoint,proto3" json:"checkpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *PullResponse) Reset()         { *m = PullResponse{} }
func (m *PullResponse) String() string { return proto.CompactTextString(m) }
func (*PullResponse) ProtoMessage()    {}
func (*PullResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{11}
}
func (m *PullResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PullResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PullResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PullResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PullResponse.Merge(m, src)
}
func (m *PullResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PullResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PullResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PullResponse proto.InternalMessageInfo

// Opened responds to PullRequest.Open of the runtime,
// and is sent exactly once as the first message of the stream.
type PullResponse_Opened struct {
	// If true then the runtime will send one PullRequest.Acknowledge
	// for each PullResponse.DriverCheckpoint sent by the connector,
	// upon that DriverCheckpoint having fully committed.
	ExplicitAcknowledgements bool     `protobuf:"varint,1,opt,name=explicit_acknowledgements,json=explicitAcknowledgements,proto3" json:"explicit_acknowledgements,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *PullResponse_Opened) Reset()         { *m = PullResponse_Opened{} }
func (m *PullResponse_Opened) String() string { return proto.CompactTextString(m) }
func (*PullResponse_Opened) ProtoMessage()    {}
func (*PullResponse_Opened) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{11, 0}
}
func (m *PullResponse_Opened) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PullResponse_Opened) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PullResponse_Opened.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PullResponse_Opened) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PullResponse_Opened.Merge(m, src)
}
func (m *PullResponse_Opened) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PullResponse_Opened) XXX_DiscardUnknown() {
	xxx_messageInfo_PullResponse_Opened.DiscardUnknown(m)
}

var xxx_messageInfo_PullResponse_Opened proto.InternalMessageInfo

// PushRequest is the request message of the Runtime.Push RPC.
type PushRequest struct {
	Open *PushRequest_Open `protobuf:"bytes,1,opt,name=open,proto3" json:"open,omitempty"`
	// Captured documents of the stream.
	Documents *Documents `protobuf:"bytes,2,opt,name=documents,proto3" json:"documents,omitempty"`
	// Checkpoint all preceeding Documents of this stream.
	Checkpoint           *flow.DriverCheckpoint `protobuf:"bytes,3,opt,name=checkpoint,proto3" json:"checkpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *PushRequest) Reset()         { *m = PushRequest{} }
func (m *PushRequest) String() string { return proto.CompactTextString(m) }
func (*PushRequest) ProtoMessage()    {}
func (*PushRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{12}
}
func (m *PushRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushRequest.Merge(m, src)
}
func (m *PushRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PushRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PushRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PushRequest proto.InternalMessageInfo

// Open opens a Push of the runtime, and is sent exactly once as the first
// message of the stream.
type PushRequest_Open struct {
	// Header identifies a specific Shard and Route to which this stream is
	// directed. It's optional, and is typically attached by a proxying peer.
	Header *protocol.Header `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// Name of the capture under which we're pushing.
	Capture              github_com_estuary_flow_go_protocols_flow.Capture `protobuf:"bytes,2,opt,name=capture,proto3,casttype=github.com/estuary/flow/go/protocols/flow.Capture" json:"capture,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                          `json:"-"`
	XXX_unrecognized     []byte                                            `json:"-"`
	XXX_sizecache        int32                                             `json:"-"`
}

func (m *PushRequest_Open) Reset()         { *m = PushRequest_Open{} }
func (m *PushRequest_Open) String() string { return proto.CompactTextString(m) }
func (*PushRequest_Open) ProtoMessage()    {}
func (*PushRequest_Open) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{12, 0}
}
func (m *PushRequest_Open) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushRequest_Open) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushRequest_Open.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushRequest_Open) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushRequest_Open.Merge(m, src)
}
func (m *PushRequest_Open) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PushRequest_Open) XXX_DiscardUnknown() {
	xxx_messageInfo_PushRequest_Open.DiscardUnknown(m)
}

var xxx_messageInfo_PushRequest_Open proto.InternalMessageInfo

// PushResponse is the response message of the Runtime.Push RPC.
type PushResponse struct {
	Opened *PushResponse_Opened `protobuf:"bytes,1,opt,name=opened,proto3" json:"opened,omitempty"`
	// Tell the driver that its Checkpoint has committed to the Flow recovery log.
	// Unlike PullRequest.Acknowledge, which is only sent if explicitly opted into,
	// PushResponse.Acknowledge is always sent.
	Acknowledge          *Acknowledge `protobuf:"bytes,2,opt,name=acknowledge,proto3" json:"acknowledge,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *PushResponse) Reset()         { *m = PushResponse{} }
func (m *PushResponse) String() string { return proto.CompactTextString(m) }
func (*PushResponse) ProtoMessage()    {}
func (*PushResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{13}
}
func (m *PushResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushResponse.Merge(m, src)
}
func (m *PushResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PushResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PushResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PushResponse proto.InternalMessageInfo

// Opened responds to PushRequest.Open of the driver,
// and is sent exactly once as the first message of the stream.
type PushResponse_Opened struct {
	// Status of the Push open.
	Status protocol1.Status `protobuf:"varint,1,opt,name=status,proto3,enum=consumer.Status" json:"status,omitempty"`
	// Header of the response.
	Header protocol.Header `protobuf:"bytes,2,opt,name=header,proto3" json:"header"`
	// CaptureSpec to be pushed.
	Capture *flow.CaptureSpec `protobuf:"bytes,3,opt,name=capture,proto3" json:"capture,omitempty"`
	// Version of the opened CaptureSpec.
	// The driver may want to require that this match the version last
	// provided to a successful Apply RPC. It's possible that it won't,
	// due to expected propagation races in Flow's distributed runtime.
	Version string `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	// [key_begin, key_end] inclusive range of keys processed by this
	// transaction stream. Ranges reflect the disjoint chunks of ownership
	// specific to each instance of a scale-out capture implementation.
	KeyBegin uint32 `protobuf:"fixed32,5,opt,name=key_begin,json=keyBegin,proto3" json:"key_begin,omitempty"`
	KeyEnd   uint32 `protobuf:"fixed32,6,opt,name=key_end,json=keyEnd,proto3" json:"key_end,omitempty"`
	// Last-persisted driver checkpoint from a previous capture stream.
	// Or empty, if the driver has cleared or never set its checkpoint.
	DriverCheckpointJson encoding_json.RawMessage `protobuf:"bytes,7,opt,name=driver_checkpoint_json,json=driverCheckpoint,proto3,casttype=encoding/json.RawMessage" json:"driver_checkpoint_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *PushResponse_Opened) Reset()         { *m = PushResponse_Opened{} }
func (m *PushResponse_Opened) String() string { return proto.CompactTextString(m) }
func (*PushResponse_Opened) ProtoMessage()    {}
func (*PushResponse_Opened) Descriptor() ([]byte, []int) {
	return fileDescriptor_841a70e6e6288f13, []int{13, 0}
}
func (m *PushResponse_Opened) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushResponse_Opened) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushResponse_Opened.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushResponse_Opened) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushResponse_Opened.Merge(m, src)
}
func (m *PushResponse_Opened) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PushResponse_Opened) XXX_DiscardUnknown() {
	xxx_messageInfo_PushResponse_Opened.DiscardUnknown(m)
}

var xxx_messageInfo_PushResponse_Opened proto.InternalMessageInfo

func init() {
	proto.RegisterType((*SpecRequest)(nil), "capture.SpecRequest")
	proto.RegisterType((*SpecResponse)(nil), "capture.SpecResponse")
	proto.RegisterType((*DiscoverRequest)(nil), "capture.DiscoverRequest")
	proto.RegisterType((*DiscoverResponse)(nil), "capture.DiscoverResponse")
	proto.RegisterType((*DiscoverResponse_Binding)(nil), "capture.DiscoverResponse.Binding")
	proto.RegisterType((*ValidateRequest)(nil), "capture.ValidateRequest")
	proto.RegisterType((*ValidateRequest_Binding)(nil), "capture.ValidateRequest.Binding")
	proto.RegisterType((*ValidateResponse)(nil), "capture.ValidateResponse")
	proto.RegisterType((*ValidateResponse_Binding)(nil), "capture.ValidateResponse.Binding")
	proto.RegisterType((*ApplyRequest)(nil), "capture.ApplyRequest")
	proto.RegisterType((*ApplyResponse)(nil), "capture.ApplyResponse")
	proto.RegisterType((*Documents)(nil), "capture.Documents")
	proto.RegisterType((*Acknowledge)(nil), "capture.Acknowledge")
	proto.RegisterType((*PullRequest)(nil), "capture.PullRequest")
	proto.RegisterType((*PullRequest_Open)(nil), "capture.PullRequest.Open")
	proto.RegisterType((*PullResponse)(nil), "capture.PullResponse")
	proto.RegisterType((*PullResponse_Opened)(nil), "capture.PullResponse.Opened")
	proto.RegisterType((*PushRequest)(nil), "capture.PushRequest")
	proto.RegisterType((*PushRequest_Open)(nil), "capture.PushRequest.Open")
	proto.RegisterType((*PushResponse)(nil), "capture.PushResponse")
	proto.RegisterType((*PushResponse_Opened)(nil), "capture.PushResponse.Opened")
}

func init() {
	proto.RegisterFile("go/protocols/capture/capture.proto", fileDescriptor_841a70e6e6288f13)
}

var fileDescriptor_841a70e6e6288f13 = []byte{
	// 1264 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x41, 0x8f, 0xdb, 0x44,
	0x14, 0xae, 0x93, 0x34, 0xd9, 0xbc, 0xec, 0xb6, 0xe9, 0xa8, 0x94, 0x6c, 0xa8, 0x76, 0x83, 0xb9,
	0x44, 0x2a, 0xf5, 0xb6, 0x69, 0x69, 0x11, 0x94, 0xa2, 0x4d, 0xb7, 0x08, 0x2a, 0xd1, 0xad, 0x66,
	0x29, 0x07, 0x2e, 0x91, 0xd7, 0x7e, 0x24, 0x66, 0x1d, 0x8f, 0xf1, 0xd8, 0x2d, 0x39, 0xf6, 0x07,
	0xc0, 0x81, 0x13, 0x17, 0xa4, 0x9e, 0x39, 0x80, 0xf8, 0x17, 0x3d, 0xf2, 0x0b, 0x56, 0xa2, 0x1c,
	0x38, 0x23, 0xc1, 0x65, 0x4f, 0x68, 0xc6, 0x63, 0x7b, 0xe2, 0xdd, 0x96, 0x6c, 0xa9, 0x10, 0x97,
	0x5d, 0x7b, 0xde, 0x7b, 0x9f, 0xdf, 0xfb, 0xde, 0xf7, 0x66, 0x26, 0x60, 0x8e, 0xd9, 0x46, 0x18,
	0xb1, 0x98, 0x39, 0xcc, 0xe7, 0x1b, 0x8e, 0x1d, 0xc6, 0x49, 0x84, 0xd9, 0x7f, 0x4b, 0x5a, 0x48,
	0x43, 0xbd, 0x76, 0xd7, 0x76, 0x23, 0xb6, 0x87, 0x51, 0x1e, 0x90, 0x3f, 0xa4, 0x8e, 0xdd, 0x9e,
	0xc3, 0x02, 0x9e, 0x4c, 0x9f, 0xe3, 0x71, 0x7e, 0xee, 0x73, 0x9f, 0xfb, 0xec, 0xa1, 0xfc, 0xa3,
	0xac, 0x67, 0xc7, 0x6c, 0xcc, 0xe4, 0xe3, 0x86, 0x78, 0x4a, 0x57, 0xcd, 0x6f, 0x0c, 0x68, 0xed,
	0x84, 0xe8, 0x50, 0xfc, 0x32, 0x41, 0x1e, 0x93, 0xeb, 0xb0, 0x82, 0x81, 0x1b, 0x32, 0x2f, 0x88,
	0x47, 0xf1, 0x2c, 0xc4, 0x8e, 0xd1, 0x33, 0xfa, 0xa7, 0x06, 0xc4, 0x92, 0x48, 0xb7, 0x95, 0xe9,
	0x93, 0x59, 0x88, 0x74, 0x19, 0xb5, 0x37, 0xf2, 0x01, 0x90, 0x3c, 0x90, 0x87, 0xe8, 0x8c, 0xbe,
	0xe0, 0x2c, 0xe8, 0x54, 0x7a, 0x46, 0xbf, 0x39, 0x3c, 0x7f, 0xb0, 0xbf, 0xde, 0xc1, 0xc0, 0x61,
	0xae, 0x17, 0x8c, 0x37, 0x84, 0xc1, 0xa2, 0xf6, 0xc3, 0x8f, 0x91, 0x73, 0x7b, 0xac, 0xe1, 0x88,
	0x3c, 0xcc, 0xef, 0x2a, 0xb0, 0x9c, 0x26, 0xc4, 0x43, 0x16, 0x70, 0x24, 0x3b, 0xb0, 0x3a, 0x0f,
	0xcc, 0x9d, 0x09, 0x4e, 0xed, 0x14, 0xdf, 0x58, 0x00, 0x9f, 0xe8, 0xf8, 0x3b, 0x32, 0x58, 0x80,
	0x46, 0xc8, 0x59, 0x12, 0x39, 0x78, 0x18, 0x74, 0x91, 0xa4, 0x49, 0x16, 0xae, 0x81, 0x5e, 0x80,
	0x33, 0x2e, 0x73, 0x92, 0x29, 0x06, 0xb1, 0x1d, 0x7b, 0x2c, 0x18, 0x25, 0x91, 0xdf, 0xa9, 0x0a,
	0x30, 0xda, 0x9e, 0x33, 0xdc, 0x8f, 0x7c, 0x72, 0x19, 0x5a, 0xcc, 0x4e, 0xe2, 0xc9, 0x40, 0x7e,
	0xbf, 0x53, 0xeb, 0x19, 0xfd, 0xd6, 0xa0, 0x9d, 0xd2, 0xbc, 0xbd, 0x29, 0x0c, 0x92, 0x05, 0x48,
	0x9d, 0x24, 0x35, 0xdf, 0x1a, 0x70, 0x7a, 0xcb, 0xe3, 0x0e, 0x7b, 0x80, 0xd1, 0xff, 0xa6, 0x5f,
	0x7f, 0x54, 0xa0, 0x5d, 0x24, 0xa5, 0x7a, 0xf6, 0x1e, 0x2c, 0xed, 0x7a, 0x81, 0x88, 0xe6, 0x1d,
	0xa3, 0x57, 0xed, 0xb7, 0x06, 0xaf, 0x5b, 0x99, 0xec, 0xcb, 0xce, 0xd6, 0x30, 0xf5, 0xa4, 0x79,
	0x48, 0xf7, 0xfb, 0x0a, 0x34, 0xd4, 0x2a, 0x71, 0xa0, 0x1d, 0xa1, 0xc3, 0xa6, 0x53, 0x0c, 0x5c,
	0x74, 0x47, 0x81, 0x3d, 0x45, 0xd5, 0xf5, 0xb7, 0x0f, 0xf6, 0xd7, 0xaf, 0x8e, 0xbd, 0x78, 0x92,
	0xec, 0x5a, 0x0e, 0x9b, 0x6e, 0x20, 0x8f, 0x13, 0x3b, 0x9a, 0xa5, 0xc2, 0x3f, 0x34, 0x0a, 0xd6,
	0x2d, 0xe6, 0xfb, 0xe8, 0x08, 0xfa, 0xe9, 0x69, 0x0d, 0xf1, 0xae, 0x3d, 0x95, 0x64, 0xcc, 0xcb,
	0x61, 0x71, 0x32, 0x74, 0x1d, 0x90, 0x3b, 0x70, 0x36, 0x6b, 0xf4, 0x9c, 0xa2, 0xaa, 0x0b, 0x20,
	0x9d, 0xca, 0x22, 0x95, 0x9a, 0x56, 0x61, 0x69, 0x0f, 0x67, 0xa3, 0x30, 0x8e, 0x78, 0xa7, 0xd6,
	0xab, 0xf6, 0x9b, 0xb4, 0xb1, 0x87, 0xb3, 0x7b, 0x71, 0xc4, 0xcd, 0x9f, 0xab, 0x70, 0xfa, 0x53,
	0xdb, 0xf7, 0x5c, 0x3b, 0xc6, 0x4c, 0x08, 0xdb, 0x90, 0xed, 0x24, 0x8a, 0x9e, 0xb7, 0x0e, 0xf6,
	0xd7, 0x2f, 0x1f, 0x83, 0x9e, 0x34, 0x98, 0x66, 0x28, 0x87, 0x95, 0x55, 0xf9, 0x57, 0xca, 0xaa,
	0x1e, 0x57, 0x59, 0xe4, 0x86, 0x26, 0xa2, 0x9a, 0x14, 0x51, 0x2f, 0x17, 0x51, 0xa9, 0xfa, 0x23,
	0x34, 0xf4, 0xb5, 0x51, 0x68, 0xe8, 0xe8, 0xf6, 0x1a, 0xc7, 0x6e, 0xef, 0x3b, 0x00, 0x4e, 0xae,
	0x22, 0xc9, 0x47, 0x6b, 0x70, 0xd6, 0x2a, 0xa9, 0x4b, 0x78, 0x0e, 0x6b, 0x4f, 0xf6, 0xd7, 0x4f,
	0x50, 0xcd, 0xdb, 0x7c, 0x64, 0x40, 0xbb, 0xc8, 0x7a, 0x81, 0x39, 0x29, 0x3b, 0x1f, 0x51, 0xa3,
	0x55, 0x94, 0xf8, 0x06, 0xac, 0xe4, 0x25, 0x86, 0x76, 0x3c, 0x91, 0x70, 0xcd, 0x22, 0xff, 0x7b,
	0x76, 0x3c, 0x31, 0x03, 0x58, 0xde, 0x0c, 0x43, 0x7f, 0x96, 0x69, 0xe6, 0xc2, 0xbc, 0x66, 0x5a,
	0x83, 0x33, 0x96, 0xae, 0x05, 0xb9, 0x01, 0xe5, 0x7a, 0xe8, 0x40, 0xe3, 0x01, 0x46, 0x3c, 0xab,
	0xbc, 0x49, 0xb3, 0x57, 0xf2, 0x2a, 0x34, 0xdc, 0x68, 0x36, 0x8a, 0x92, 0xb4, 0xcb, 0x4b, 0xb4,
	0xee, 0x46, 0x33, 0x9a, 0x04, 0xe6, 0x4d, 0x58, 0x51, 0xdf, 0x53, 0xf5, 0x5e, 0x04, 0x62, 0x4b,
	0x3a, 0x46, 0x2e, 0x72, 0x27, 0xf2, 0x42, 0x49, 0xa4, 0x6c, 0x04, 0x3d, 0x93, 0x5a, 0xb6, 0x0a,
	0x83, 0xf9, 0xd8, 0x80, 0xe6, 0x96, 0x9a, 0x0a, 0x2e, 0x12, 0x50, 0x95, 0xcb, 0x88, 0x15, 0x9a,
	0xbd, 0x92, 0x8f, 0xe0, 0xa4, 0x1d, 0x61, 0x60, 0xcb, 0xc4, 0x96, 0x87, 0x57, 0x0e, 0xf6, 0xd7,
	0x37, 0x16, 0x57, 0xfe, 0xa6, 0x08, 0xa5, 0x29, 0x02, 0xb1, 0xa0, 0xe9, 0x32, 0x87, 0x67, 0x9a,
	0x15, 0x2d, 0x69, 0xa5, 0xa4, 0xec, 0xf8, 0x9e, 0x83, 0xaa, 0xb1, 0x4b, 0xc2, 0xe7, 0x0e, 0x67,
	0x81, 0xb9, 0x02, 0xad, 0x4d, 0x67, 0x2f, 0x60, 0x0f, 0x7d, 0x74, 0xc7, 0x68, 0xee, 0x57, 0xa0,
	0x75, 0x2f, 0xf1, 0xfd, 0x8c, 0xe1, 0x8b, 0x50, 0x63, 0x21, 0x06, 0x8a, 0xde, 0xd5, 0xbc, 0xb9,
	0x9a, 0x8f, 0xb5, 0x1d, 0x62, 0x40, 0xa5, 0x1b, 0xb9, 0x06, 0x2d, 0xbb, 0x40, 0xcb, 0x15, 0x96,
	0x45, 0x69, 0x5f, 0xa2, 0xba, 0x63, 0xf7, 0x77, 0x03, 0x6a, 0x02, 0xe6, 0x65, 0x75, 0xf4, 0x35,
	0x68, 0x8a, 0xbd, 0x67, 0x17, 0xc7, 0x5e, 0xda, 0xd3, 0x06, 0x15, 0x9b, 0xd1, 0x50, 0xbc, 0x8b,
	0x76, 0x0b, 0x23, 0x06, 0xae, 0x3c, 0xb5, 0x1a, 0xb4, 0xbe, 0x87, 0xb3, 0xdb, 0x81, 0x4b, 0xee,
	0xc2, 0x39, 0x37, 0xf2, 0x1e, 0x60, 0x34, 0x72, 0x26, 0xe8, 0xec, 0xa5, 0x3b, 0x80, 0x24, 0xf2,
	0xa4, 0xec, 0xcb, 0xf3, 0x47, 0xad, 0x9d, 0xc6, 0xde, 0xca, 0x43, 0x09, 0x81, 0x5a, 0x6c, 0x7b,
	0x7e, 0xa7, 0x2e, 0x45, 0x25, 0x9f, 0xcd, 0xbf, 0x0c, 0x58, 0x4e, 0xc9, 0x53, 0x92, 0xba, 0x0a,
	0x75, 0x41, 0x1d, 0xba, 0xaa, 0xe0, 0xf3, 0x25, 0x8e, 0xd5, 0xf0, 0x6c, 0x4b, 0x1f, 0xaa, 0x7c,
	0xc9, 0x25, 0xd9, 0xe6, 0x54, 0x58, 0x8a, 0x66, 0x52, 0x9c, 0x50, 0x99, 0x85, 0x16, 0x4e, 0xe4,
	0x1a, 0x40, 0x51, 0x95, 0xe4, 0xa4, 0x35, 0x38, 0x97, 0x92, 0xbb, 0x55, 0x4a, 0x9c, 0x6a, 0x9e,
	0xdd, 0xdb, 0x50, 0x4f, 0xbf, 0x4d, 0xde, 0x85, 0x55, 0xfc, 0x2a, 0xf4, 0x3d, 0xc7, 0x8b, 0x47,
	0x5a, 0xf3, 0xd2, 0x1c, 0x0c, 0x59, 0x63, 0x27, 0x73, 0xd8, 0x2c, 0xd9, 0xcd, 0x1f, 0xa4, 0xb0,
	0xf8, 0xe4, 0x9f, 0x85, 0x95, 0xfb, 0xe8, 0xc2, 0xfa, 0xef, 0xea, 0x7d, 0x94, 0x49, 0xb1, 0x0f,
	0xf5, 0x09, 0xda, 0x2e, 0x46, 0x2a, 0xc7, 0xb6, 0x95, 0x5f, 0x57, 0x3f, 0x94, 0xeb, 0x54, 0xd9,
	0xf5, 0xa3, 0xab, 0xf2, 0x32, 0x8e, 0x2e, 0xf3, 0xc7, 0xaa, 0x10, 0x89, 0x20, 0x62, 0x01, 0x91,
	0x14, 0x6e, 0x65, 0x91, 0xbc, 0xe8, 0x34, 0xfe, 0x54, 0xc9, 0x7b, 0xde, 0x87, 0x3a, 0x8f, 0xed,
	0x38, 0xe1, 0xea, 0x5e, 0xd6, 0xb6, 0xb2, 0x5b, 0xbc, 0xb5, 0x23, 0xd7, 0xa9, 0xb2, 0x13, 0x2b,
	0xa7, 0xab, 0x72, 0x34, 0x5d, 0x6a, 0xeb, 0xc9, 0x48, 0xd3, 0x26, 0xbd, 0x7a, 0x9c, 0x49, 0xaf,
	0x3d, 0x67, 0xd2, 0x4f, 0x3e, 0x7b, 0xd2, 0xeb, 0x0b, 0x4e, 0x7a, 0xe3, 0x45, 0x26, 0x7d, 0xf0,
	0x67, 0x05, 0xea, 0xa9, 0xaa, 0xc8, 0x15, 0xa8, 0xc9, 0xb3, 0xb6, 0xe0, 0x59, 0xfb, 0x79, 0xd2,
	0x7d, 0xa5, 0xb4, 0xaa, 0xfa, 0xfb, 0x3e, 0x2c, 0x65, 0xd7, 0x4a, 0xd2, 0x39, 0xe2, 0xa6, 0x99,
	0x06, 0xaf, 0x3e, 0xf3, 0x0e, 0x2a, 0x00, 0xb2, 0xf3, 0x56, 0x03, 0x28, 0xdd, 0x32, 0x34, 0x80,
	0x43, 0x27, 0xf9, 0x0d, 0x68, 0xc9, 0xa3, 0xee, 0x7e, 0xc8, 0x31, 0x8a, 0x49, 0x91, 0xa7, 0x7e,
	0xe0, 0x76, 0xcf, 0x95, 0x97, 0x4b, 0xd1, 0x5b, 0xe8, 0x63, 0x8c, 0xc7, 0x8d, 0xbe, 0x0e, 0x35,
	0xb1, 0xd7, 0x69, 0x94, 0x69, 0xc7, 0x8b, 0x46, 0x99, 0xbe, 0x21, 0xf6, 0x8d, 0x4b, 0xc6, 0x60,
	0x08, 0x0d, 0x9a, 0x04, 0xb1, 0x37, 0x55, 0x18, 0x7c, 0x32, 0x87, 0x91, 0xef, 0x24, 0x73, 0x18,
	0xc5, 0xbc, 0x08, 0x8c, 0xe1, 0xcd, 0x27, 0xbf, 0xae, 0x9d, 0x78, 0xf2, 0x74, 0xcd, 0xf8, 0xe5,
	0xe9, 0x9a, 0xf1, 0xf8, 0xb7, 0x35, 0xe3, 0xb3, 0x37, 0x17, 0x9a, 0x5c, 0x05, 0xb8, 0x5b, 0x97,
	0x4b, 0x57, 0xfe, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x2e, 0xfd, 0xd6, 0xea, 0x2c, 0x0f, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DriverClient is the client API for Driver service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DriverClient interface {
	// Spec returns the specification definition of this driver.
	// Notably this includes its endpoint and resource configuration JSON schema.
	Spec(ctx context.Context, in *SpecRequest, opts ...grpc.CallOption) (*SpecResponse, error)
	// Discover returns the set of resources available from this Driver.
	Discover(ctx context.Context, in *DiscoverRequest, opts ...grpc.CallOption) (*DiscoverResponse, error)
	// Validate that store resources and proposed collection bindings are
	// compatible.
	Validate(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error)
	// ApplyUpsert applies a new or updated capture to the store.
	ApplyUpsert(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error)
	// ApplyDelete deletes an existing capture from the store.
	ApplyDelete(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error)
	// Pull is a very long lived RPC through which the Flow runtime and a
	// Driver cooperatively execute an unbounded number of transactions.
	//
	// The Pull workflow pulls streams of documents into capturing Flow
	// collections. Streams are incremental and resume-able, with resumption
	// semantics defined by the driver. The Flow Runtime uses a transactional
	// recovery log to support this workflow, and the driver may persist arbitrary
	// driver checkpoints into that log as part of the RPC lifecycle,
	// to power its chosen resumption semantics.
	//
	// Pull tasks are split-able, and many concurrent invocations of the RPC
	// may collectively capture from a source, where each task split has an
	// identified range of keys it's responsible for. The meaning of a "key",
	// and it's application within the remote store being captured from, is up
	// to the driver. The driver might map partitions or shards into the keyspace,
	// and from there to a covering task split. Or, it might map distinct files,
	// or some other unit of scaling.
	//
	// RPC Lifecycle
	// =============
	//
	// :PullRequest.Open:
	//    - The Flow runtime opens the pull stream.
	// :PullResponse.Opened:
	//    - The driver responds with Opened.
	//
	// PullRequest.Open and PullRequest.Opened are sent only once, at the
	// commencement of the stream. Thereafter the protocol loops:
	//
	// :PullResponse.Documents:
	//    - The driver tells the runtime of some documents, which are pending a
	//      future Checkpoint.
	//    - If the driver sends multiple Documents messages without an
	//      interleaving Checkpoint, the Flow runtime MUST commit
	//      documents of all such messages in a single transaction.
	// :PullResponse.Checkpoint:
	//    - The driver tells the runtime of a checkpoint: a watermark in the
	//      captured documents stream which is eligble to be used as a
	//      transaction commit boundary.
	//    - Whether the checkpoint becomes a commit boundary is at the
	//      discretion of the Flow runtime. It may combine multiple checkpoints
	//      into a single transaction.
	// :PullRequest.Acknowledge:
	//    - The Flow runtime tells the driver that its Checkpoint has committed.
	//    - The runtime sends one ordered Acknowledge for each Checkpoint.
	//
	Pull(ctx context.Context, opts ...grpc.CallOption) (Driver_PullClient, error)
}

type driverClient struct {
	cc *grpc.ClientConn
}

func NewDriverClient(cc *grpc.ClientConn) DriverClient {
	return &driverClient{cc}
}

func (c *driverClient) Spec(ctx context.Context, in *SpecRequest, opts ...grpc.CallOption) (*SpecResponse, error) {
	out := new(SpecResponse)
	err := c.cc.Invoke(ctx, "/capture.Driver/Spec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverClient) Discover(ctx context.Context, in *DiscoverRequest, opts ...grpc.CallOption) (*DiscoverResponse, error) {
	out := new(DiscoverResponse)
	err := c.cc.Invoke(ctx, "/capture.Driver/Discover", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverClient) Validate(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error) {
	out := new(ValidateResponse)
	err := c.cc.Invoke(ctx, "/capture.Driver/Validate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverClient) ApplyUpsert(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error) {
	out := new(ApplyResponse)
	err := c.cc.Invoke(ctx, "/capture.Driver/ApplyUpsert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverClient) ApplyDelete(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error) {
	out := new(ApplyResponse)
	err := c.cc.Invoke(ctx, "/capture.Driver/ApplyDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverClient) Pull(ctx context.Context, opts ...grpc.CallOption) (Driver_PullClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Driver_serviceDesc.Streams[0], "/capture.Driver/Pull", opts...)
	if err != nil {
		return nil, err
	}
	x := &driverPullClient{stream}
	return x, nil
}

type Driver_PullClient interface {
	Send(*PullRequest) error
	Recv() (*PullResponse, error)
	grpc.ClientStream
}

type driverPullClient struct {
	grpc.ClientStream
}

func (x *driverPullClient) Send(m *PullRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *driverPullClient) Recv() (*PullResponse, error) {
	m := new(PullResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DriverServer is the server API for Driver service.
type DriverServer interface {
	// Spec returns the specification definition of this driver.
	// Notably this includes its endpoint and resource configuration JSON schema.
	Spec(context.Context, *SpecRequest) (*SpecResponse, error)
	// Discover returns the set of resources available from this Driver.
	Discover(context.Context, *DiscoverRequest) (*DiscoverResponse, error)
	// Validate that store resources and proposed collection bindings are
	// compatible.
	Validate(context.Context, *ValidateRequest) (*ValidateResponse, error)
	// ApplyUpsert applies a new or updated capture to the store.
	ApplyUpsert(context.Context, *ApplyRequest) (*ApplyResponse, error)
	// ApplyDelete deletes an existing capture from the store.
	ApplyDelete(context.Context, *ApplyRequest) (*ApplyResponse, error)
	// Pull is a very long lived RPC through which the Flow runtime and a
	// Driver cooperatively execute an unbounded number of transactions.
	//
	// The Pull workflow pulls streams of documents into capturing Flow
	// collections. Streams are incremental and resume-able, with resumption
	// semantics defined by the driver. The Flow Runtime uses a transactional
	// recovery log to support this workflow, and the driver may persist arbitrary
	// driver checkpoints into that log as part of the RPC lifecycle,
	// to power its chosen resumption semantics.
	//
	// Pull tasks are split-able, and many concurrent invocations of the RPC
	// may collectively capture from a source, where each task split has an
	// identified range of keys it's responsible for. The meaning of a "key",
	// and it's application within the remote store being captured from, is up
	// to the driver. The driver might map partitions or shards into the keyspace,
	// and from there to a covering task split. Or, it might map distinct files,
	// or some other unit of scaling.
	//
	// RPC Lifecycle
	// =============
	//
	// :PullRequest.Open:
	//    - The Flow runtime opens the pull stream.
	// :PullResponse.Opened:
	//    - The driver responds with Opened.
	//
	// PullRequest.Open and PullRequest.Opened are sent only once, at the
	// commencement of the stream. Thereafter the protocol loops:
	//
	// :PullResponse.Documents:
	//    - The driver tells the runtime of some documents, which are pending a
	//      future Checkpoint.
	//    - If the driver sends multiple Documents messages without an
	//      interleaving Checkpoint, the Flow runtime MUST commit
	//      documents of all such messages in a single transaction.
	// :PullResponse.Checkpoint:
	//    - The driver tells the runtime of a checkpoint: a watermark in the
	//      captured documents stream which is eligble to be used as a
	//      transaction commit boundary.
	//    - Whether the checkpoint becomes a commit boundary is at the
	//      discretion of the Flow runtime. It may combine multiple checkpoints
	//      into a single transaction.
	// :PullRequest.Acknowledge:
	//    - The Flow runtime tells the driver that its Checkpoint has committed.
	//    - The runtime sends one ordered Acknowledge for each Checkpoint.
	//
	Pull(Driver_PullServer) error
}

// UnimplementedDriverServer can be embedded to have forward compatible implementations.
type UnimplementedDriverServer struct {
}

func (*UnimplementedDriverServer) Spec(ctx context.Context, req *SpecRequest) (*SpecResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Spec not implemented")
}
func (*UnimplementedDriverServer) Discover(ctx context.Context, req *DiscoverRequest) (*DiscoverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Discover not implemented")
}
func (*UnimplementedDriverServer) Validate(ctx context.Context, req *ValidateRequest) (*ValidateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Validate not implemented")
}
func (*UnimplementedDriverServer) ApplyUpsert(ctx context.Context, req *ApplyRequest) (*ApplyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyUpsert not implemented")
}
func (*UnimplementedDriverServer) ApplyDelete(ctx context.Context, req *ApplyRequest) (*ApplyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyDelete not implemented")
}
func (*UnimplementedDriverServer) Pull(srv Driver_PullServer) error {
	return status.Errorf(codes.Unimplemented, "method Pull not implemented")
}

func RegisterDriverServer(s *grpc.Server, srv DriverServer) {
	s.RegisterService(&_Driver_serviceDesc, srv)
}

func _Driver_Spec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpecRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServer).Spec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/capture.Driver/Spec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServer).Spec(ctx, req.(*SpecRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Driver_Discover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscoverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServer).Discover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/capture.Driver/Discover",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServer).Discover(ctx, req.(*DiscoverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Driver_Validate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServer).Validate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/capture.Driver/Validate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServer).Validate(ctx, req.(*ValidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Driver_ApplyUpsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServer).ApplyUpsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/capture.Driver/ApplyUpsert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServer).ApplyUpsert(ctx, req.(*ApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Driver_ApplyDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServer).ApplyDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/capture.Driver/ApplyDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServer).ApplyDelete(ctx, req.(*ApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Driver_Pull_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DriverServer).Pull(&driverPullServer{stream})
}

type Driver_PullServer interface {
	Send(*PullResponse) error
	Recv() (*PullRequest, error)
	grpc.ServerStream
}

type driverPullServer struct {
	grpc.ServerStream
}

func (x *driverPullServer) Send(m *PullResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *driverPullServer) Recv() (*PullRequest, error) {
	m := new(PullRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Driver_serviceDesc = grpc.ServiceDesc{
	ServiceName: "capture.Driver",
	HandlerType: (*DriverServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Spec",
			Handler:    _Driver_Spec_Handler,
		},
		{
			MethodName: "Discover",
			Handler:    _Driver_Discover_Handler,
		},
		{
			MethodName: "Validate",
			Handler:    _Driver_Validate_Handler,
		},
		{
			MethodName: "ApplyUpsert",
			Handler:    _Driver_ApplyUpsert_Handler,
		},
		{
			MethodName: "ApplyDelete",
			Handler:    _Driver_ApplyDelete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Pull",
			Handler:       _Driver_Pull_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "go/protocols/capture/capture.proto",
}

// RuntimeClient is the client API for Runtime service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RuntimeClient interface {
	// Push may be a short or very long lived RPC through which the Flow runtime
	// and a driver cooperatively execute an unbounded number of transactions.
	//
	// The Push workflow pushes streams of documents into capturing Flow
	// collections. The driver is responsible for initiation and resumption of
	// push streams. The Flow runtime uses a transactional recovery log to support
	// this workflow, and the driver may persist arbitrary driver checkpoints into
	// that log as part of the RPC lifecycle, to power its chosen resumption
	// semantics.
	//
	// A push RPC is evaluated against a specific task shard split, which is
	// encoded in the PushRequest.Open.Header. A driver may perform its own load
	// balancing by obtain a shard listing and embedding a selected shard into
	// that header. Or, it may leave it empty and an arbitary shard will be
	// randomly chosen for it.
	//
	// RPC Lifecycle
	// =============
	//
	// :PushRequest.Open:
	//    - The driver opens the push stream, naming its capture and
	//      optional routing header.
	// :PushResponse.Opened:
	//    - The Flow runtime responds with Opened, which tells the driver
	//      of the specific CaptureSpec and [key_begin, key_end] range of
	//      this RPC, as well as the last driver checkpoint.
	//    - The semantics and treatment of the key range is up to the driver.
	//
	// PushRequest.Open and PushRequest.Opened are sent only once, at the
	// commencement of the stream. Thereafter the protocol loops:
	//
	// :PushRequest.Documents:
	//    - The driver tells the runtime of some documents, which are pending a
	//      future Checkpoint.
	//    - If the driver sends multiple Documents messages without an
	//      interleaving Checkpoint, the Flow runtime MUST commit
	//      documents of all such messages in a single transaction.
	// :PushRequest.Checkpoint:
	//    - The driver tells the runtime of a checkpoint: a watermark in the
	//      captured documents stream which is eligble to be used as a
	//      transaction commit boundary.
	//    - Whether the checkpoint becomes a commit boundary is at the
	//      discretion of the Flow runtime. It may combine multiple checkpoints
	//      into a single transaction.
	// :PushResponse.Acknowledge:
	//    - The Flow runtime tells the driver that its Checkpoint has committed.
	//    - The runtime sends one ordered Acknowledge for each Checkpoint.
	//
	Push(ctx context.Context, opts ...grpc.CallOption) (Runtime_PushClient, error)
}

type runtimeClient struct {
	cc *grpc.ClientConn
}

func NewRuntimeClient(cc *grpc.ClientConn) RuntimeClient {
	return &runtimeClient{cc}
}

func (c *runtimeClient) Push(ctx context.Context, opts ...grpc.CallOption) (Runtime_PushClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Runtime_serviceDesc.Streams[0], "/capture.Runtime/Push", opts...)
	if err != nil {
		return nil, err
	}
	x := &runtimePushClient{stream}
	return x, nil
}

type Runtime_PushClient interface {
	Send(*PushRequest) error
	Recv() (*PushResponse, error)
	grpc.ClientStream
}

type runtimePushClient struct {
	grpc.ClientStream
}

func (x *runtimePushClient) Send(m *PushRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *runtimePushClient) Recv() (*PushResponse, error) {
	m := new(PushResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RuntimeServer is the server API for Runtime service.
type RuntimeServer interface {
	// Push may be a short or very long lived RPC through which the Flow runtime
	// and a driver cooperatively execute an unbounded number of transactions.
	//
	// The Push workflow pushes streams of documents into capturing Flow
	// collections. The driver is responsible for initiation and resumption of
	// push streams. The Flow runtime uses a transactional recovery log to support
	// this workflow, and the driver may persist arbitrary driver checkpoints into
	// that log as part of the RPC lifecycle, to power its chosen resumption
	// semantics.
	//
	// A push RPC is evaluated against a specific task shard split, which is
	// encoded in the PushRequest.Open.Header. A driver may perform its own load
	// balancing by obtain a shard listing and embedding a selected shard into
	// that header. Or, it may leave it empty and an arbitary shard will be
	// randomly chosen for it.
	//
	// RPC Lifecycle
	// =============
	//
	// :PushRequest.Open:
	//    - The driver opens the push stream, naming its capture and
	//      optional routing header.
	// :PushResponse.Opened:
	//    - The Flow runtime responds with Opened, which tells the driver
	//      of the specific CaptureSpec and [key_begin, key_end] range of
	//      this RPC, as well as the last driver checkpoint.
	//    - The semantics and treatment of the key range is up to the driver.
	//
	// PushRequest.Open and PushRequest.Opened are sent only once, at the
	// commencement of the stream. Thereafter the protocol loops:
	//
	// :PushRequest.Documents:
	//    - The driver tells the runtime of some documents, which are pending a
	//      future Checkpoint.
	//    - If the driver sends multiple Documents messages without an
	//      interleaving Checkpoint, the Flow runtime MUST commit
	//      documents of all such messages in a single transaction.
	// :PushRequest.Checkpoint:
	//    - The driver tells the runtime of a checkpoint: a watermark in the
	//      captured documents stream which is eligble to be used as a
	//      transaction commit boundary.
	//    - Whether the checkpoint becomes a commit boundary is at the
	//      discretion of the Flow runtime. It may combine multiple checkpoints
	//      into a single transaction.
	// :PushResponse.Acknowledge:
	//    - The Flow runtime tells the driver that its Checkpoint has committed.
	//    - The runtime sends one ordered Acknowledge for each Checkpoint.
	//
	Push(Runtime_PushServer) error
}

// UnimplementedRuntimeServer can be embedded to have forward compatible implementations.
type UnimplementedRuntimeServer struct {
}

func (*UnimplementedRuntimeServer) Push(srv Runtime_PushServer) error {
	return status.Errorf(codes.Unimplemented, "method Push not implemented")
}

func RegisterRuntimeServer(s *grpc.Server, srv RuntimeServer) {
	s.RegisterService(&_Runtime_serviceDesc, srv)
}

func _Runtime_Push_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RuntimeServer).Push(&runtimePushServer{stream})
}

type Runtime_PushServer interface {
	Send(*PushResponse) error
	Recv() (*PushRequest, error)
	grpc.ServerStream
}

type runtimePushServer struct {
	grpc.ServerStream
}

func (x *runtimePushServer) Send(m *PushResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *runtimePushServer) Recv() (*PushRequest, error) {
	m := new(PushRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Runtime_serviceDesc = grpc.ServiceDesc{
	ServiceName: "capture.Runtime",
	HandlerType: (*RuntimeServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Push",
			Handler:       _Runtime_Push_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "go/protocols/capture/capture.proto",
}

func (m *SpecRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EndpointSpecJson) > 0 {
		i -= len(m.EndpointSpecJson)
		copy(dAtA[i:], m.EndpointSpecJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.EndpointSpecJson)))
		i--
		dAtA[i] = 0x12
	}
	if m.EndpointType != 0 {
		i = encodeVarintCapture(dAtA, i, uint64(m.EndpointType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpecResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Oauth2Spec != nil {
		{
			size, err := m.Oauth2Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.DocumentationUrl) > 0 {
		i -= len(m.DocumentationUrl)
		copy(dAtA[i:], m.DocumentationUrl)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.DocumentationUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ResourceSpecSchemaJson) > 0 {
		i -= len(m.ResourceSpecSchemaJson)
		copy(dAtA[i:], m.ResourceSpecSchemaJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.ResourceSpecSchemaJson)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EndpointSpecSchemaJson) > 0 {
		i -= len(m.EndpointSpecSchemaJson)
		copy(dAtA[i:], m.EndpointSpecSchemaJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.EndpointSpecSchemaJson)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiscoverRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoverRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscoverRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EndpointSpecJson) > 0 {
		i -= len(m.EndpointSpecJson)
		copy(dAtA[i:], m.EndpointSpecJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.EndpointSpecJson)))
		i--
		dAtA[i] = 0x12
	}
	if m.EndpointType != 0 {
		i = encodeVarintCapture(dAtA, i, uint64(m.EndpointType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DiscoverResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoverResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscoverResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Bindings) > 0 {
		for iNdEx := len(m.Bindings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bindings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCapture(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DiscoverResponse_Binding) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoverResponse_Binding) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscoverResponse_Binding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.KeyPtrs) > 0 {
		for iNdEx := len(m.KeyPtrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyPtrs[iNdEx])
			copy(dAtA[i:], m.KeyPtrs[iNdEx])
			i = encodeVarintCapture(dAtA, i, uint64(len(m.KeyPtrs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DocumentSchemaJson) > 0 {
		i -= len(m.DocumentSchemaJson)
		copy(dAtA[i:], m.DocumentSchemaJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.DocumentSchemaJson)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ResourceSpecJson) > 0 {
		i -= len(m.ResourceSpecJson)
		copy(dAtA[i:], m.ResourceSpecJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.ResourceSpecJson)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RecommendedName) > 0 {
		i -= len(m.RecommendedName)
		copy(dAtA[i:], m.RecommendedName)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.RecommendedName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Bindings) > 0 {
		for iNdEx := len(m.Bindings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bindings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCapture(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.EndpointSpecJson) > 0 {
		i -= len(m.EndpointSpecJson)
		copy(dAtA[i:], m.EndpointSpecJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.EndpointSpecJson)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EndpointType != 0 {
		i = encodeVarintCapture(dAtA, i, uint64(m.EndpointType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Capture) > 0 {
		i -= len(m.Capture)
		copy(dAtA[i:], m.Capture)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.Capture)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateRequest_Binding) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateRequest_Binding) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateRequest_Binding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Collection.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCapture(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ResourceSpecJson) > 0 {
		i -= len(m.ResourceSpecJson)
		copy(dAtA[i:], m.ResourceSpecJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.ResourceSpecJson)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Bindings) > 0 {
		for iNdEx := len(m.Bindings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bindings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCapture(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ValidateResponse_Binding) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateResponse_Binding) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateResponse_Binding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ResourcePath) > 0 {
		for iNdEx := len(m.ResourcePath) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResourcePath[iNdEx])
			copy(dAtA[i:], m.ResourcePath[iNdEx])
			i = encodeVarintCapture(dAtA, i, uint64(len(m.ResourcePath[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ApplyRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DryRun {
		i--
		if m.DryRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if m.Capture != nil {
		{
			size, err := m.Capture.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ApplyResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ActionDescription) > 0 {
		i -= len(m.ActionDescription)
		copy(dAtA[i:], m.ActionDescription)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.ActionDescription)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Documents) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Documents) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Documents) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DocsJson) > 0 {
		for iNdEx := len(m.DocsJson) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DocsJson[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCapture(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Arena) > 0 {
		i -= len(m.Arena)
		copy(dAtA[i:], m.Arena)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.Arena)))
		i--
		dAtA[i] = 0x12
	}
	if m.Binding != 0 {
		i = encodeVarintCapture(dAtA, i, uint64(m.Binding))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Acknowledge) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Acknowledge) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Acknowledge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *PullRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PullRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PullRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Acknowledge != nil {
		{
			size, err := m.Acknowledge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Open != nil {
		{
			size, err := m.Open.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PullRequest_Open) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PullRequest_Open) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PullRequest_Open) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Tail {
		i--
		if m.Tail {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.DriverCheckpointJson) > 0 {
		i -= len(m.DriverCheckpointJson)
		copy(dAtA[i:], m.DriverCheckpointJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.DriverCheckpointJson)))
		i--
		dAtA[i] = 0x2a
	}
	if m.KeyEnd != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.KeyEnd))
		i--
		dAtA[i] = 0x25
	}
	if m.KeyBegin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.KeyBegin))
		i--
		dAtA[i] = 0x1d
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if m.Capture != nil {
		{
			size, err := m.Capture.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PullResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PullResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PullResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Checkpoint != nil {
		{
			size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Documents != nil {
		{
			size, err := m.Documents.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Opened != nil {
		{
			size, err := m.Opened.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PullResponse_Opened) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PullResponse_Opened) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PullResponse_Opened) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExplicitAcknowledgements {
		i--
		if m.ExplicitAcknowledgements {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PushRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Checkpoint != nil {
		{
			size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Documents != nil {
		{
			size, err := m.Documents.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Open != nil {
		{
			size, err := m.Open.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PushRequest_Open) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushRequest_Open) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushRequest_Open) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Capture) > 0 {
		i -= len(m.Capture)
		copy(dAtA[i:], m.Capture)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.Capture)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PushResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Acknowledge != nil {
		{
			size, err := m.Acknowledge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Opened != nil {
		{
			size, err := m.Opened.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PushResponse_Opened) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushResponse_Opened) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushResponse_Opened) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DriverCheckpointJson) > 0 {
		i -= len(m.DriverCheckpointJson)
		copy(dAtA[i:], m.DriverCheckpointJson)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.DriverCheckpointJson)))
		i--
		dAtA[i] = 0x3a
	}
	if m.KeyEnd != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.KeyEnd))
		i--
		dAtA[i] = 0x35
	}
	if m.KeyBegin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.KeyBegin))
		i--
		dAtA[i] = 0x2d
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintCapture(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x22
	}
	if m.Capture != nil {
		{
			size, err := m.Capture.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapture(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCapture(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Status != 0 {
		i = encodeVarintCapture(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCapture(dAtA []byte, offset int, v uint64) int {
	offset -= sovCapture(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SpecRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndpointType != 0 {
		n += 1 + sovCapture(uint64(m.EndpointType))
	}
	l = len(m.EndpointSpecJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpecResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EndpointSpecSchemaJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.ResourceSpecSchemaJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.DocumentationUrl)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Oauth2Spec != nil {
		l = m.Oauth2Spec.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiscoverRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndpointType != 0 {
		n += 1 + sovCapture(uint64(m.EndpointType))
	}
	l = len(m.EndpointSpecJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiscoverResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Bindings) > 0 {
		for _, e := range m.Bindings {
			l = e.ProtoSize()
			n += 1 + l + sovCapture(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiscoverResponse_Binding) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecommendedName)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.ResourceSpecJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.DocumentSchemaJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if len(m.KeyPtrs) > 0 {
		for _, s := range m.KeyPtrs {
			l = len(s)
			n += 1 + l + sovCapture(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidateRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Capture)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.EndpointType != 0 {
		n += 1 + sovCapture(uint64(m.EndpointType))
	}
	l = len(m.EndpointSpecJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if len(m.Bindings) > 0 {
		for _, e := range m.Bindings {
			l = e.ProtoSize()
			n += 1 + l + sovCapture(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidateRequest_Binding) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceSpecJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	l = m.Collection.ProtoSize()
	n += 1 + l + sovCapture(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidateResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Bindings) > 0 {
		for _, e := range m.Bindings {
			l = e.ProtoSize()
			n += 1 + l + sovCapture(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidateResponse_Binding) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResourcePath) > 0 {
		for _, s := range m.ResourcePath {
			l = len(s)
			n += 1 + l + sovCapture(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ApplyRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Capture != nil {
		l = m.Capture.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.DryRun {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ApplyResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionDescription)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Documents) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Binding != 0 {
		n += 1 + sovCapture(uint64(m.Binding))
	}
	l = len(m.Arena)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if len(m.DocsJson) > 0 {
		for _, e := range m.DocsJson {
			l = e.ProtoSize()
			n += 1 + l + sovCapture(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Acknowledge) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PullRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Open != nil {
		l = m.Open.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Acknowledge != nil {
		l = m.Acknowledge.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PullRequest_Open) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Capture != nil {
		l = m.Capture.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.KeyBegin != 0 {
		n += 5
	}
	if m.KeyEnd != 0 {
		n += 5
	}
	l = len(m.DriverCheckpointJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Tail {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PullResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opened != nil {
		l = m.Opened.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Documents != nil {
		l = m.Documents.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Checkpoint != nil {
		l = m.Checkpoint.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PullResponse_Opened) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExplicitAcknowledgements {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PushRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Open != nil {
		l = m.Open.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Documents != nil {
		l = m.Documents.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Checkpoint != nil {
		l = m.Checkpoint.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PushRequest_Open) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.Capture)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PushResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opened != nil {
		l = m.Opened.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.Acknowledge != nil {
		l = m.Acknowledge.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PushResponse_Opened) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovCapture(uint64(m.Status))
	}
	l = m.Header.ProtoSize()
	n += 1 + l + sovCapture(uint64(l))
	if m.Capture != nil {
		l = m.Capture.ProtoSize()
		n += 1 + l + sovCapture(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.KeyBegin != 0 {
		n += 5
	}
	if m.KeyEnd != 0 {
		n += 5
	}
	l = len(m.DriverCheckpointJson)
	if l > 0 {
		n += 1 + l + sovCapture(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCapture(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCapture(x uint64) (n int) {
	return sovCapture(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SpecRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointType", wireType)
			}
			m.EndpointType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndpointType |= flow.EndpointType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSpecJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointSpecJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSpecSchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointSpecSchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceSpecSchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceSpecSchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentationUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocumentationUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oauth2Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Oauth2Spec == nil {
				m.Oauth2Spec = &flow.OAuth2Spec{}
			}
			if err := m.Oauth2Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoverRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscoverRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscoverRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointType", wireType)
			}
			m.EndpointType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndpointType |= flow.EndpointType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSpecJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointSpecJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoverResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscoverResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscoverResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bindings = append(m.Bindings, &DiscoverResponse_Binding{})
			if err := m.Bindings[len(m.Bindings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoverResponse_Binding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Binding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Binding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendedName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecommendedName = github_com_estuary_flow_go_protocols_flow.Collection(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceSpecJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceSpecJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentSchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocumentSchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPtrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyPtrs = append(m.KeyPtrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Capture = github_com_estuary_flow_go_protocols_flow.Capture(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointType", wireType)
			}
			m.EndpointType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndpointType |= flow.EndpointType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSpecJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointSpecJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bindings = append(m.Bindings, &ValidateRequest_Binding{})
			if err := m.Bindings[len(m.Bindings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateRequest_Binding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Binding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Binding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceSpecJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceSpecJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bindings = append(m.Bindings, &ValidateResponse_Binding{})
			if err := m.Bindings[len(m.Bindings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateResponse_Binding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Binding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Binding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourcePath = append(m.ResourcePath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capture", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Capture == nil {
				m.Capture = &flow.CaptureSpec{}
			}
			if err := m.Capture.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DryRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DryRun = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Documents) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Documents: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Documents: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binding", wireType)
			}
			m.Binding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Binding |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arena", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arena = append(m.Arena[:0], dAtA[iNdEx:postIndex]...)
			if m.Arena == nil {
				m.Arena = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocsJson", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocsJson = append(m.DocsJson, flow.Slice{})
			if err := m.DocsJson[len(m.DocsJson)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Acknowledge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Acknowledge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Acknowledge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PullRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PullRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PullRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Open == nil {
				m.Open = &PullRequest_Open{}
			}
			if err := m.Open.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acknowledge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Acknowledge == nil {
				m.Acknowledge = &Acknowledge{}
			}
			if err := m.Acknowledge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PullRequest_Open) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Open: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Open: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capture", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Capture == nil {
				m.Capture = &flow.CaptureSpec{}
			}
			if err := m.Capture.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBegin", wireType)
			}
			m.KeyBegin = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyBegin = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyEnd", wireType)
			}
			m.KeyEnd = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyEnd = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriverCheckpointJson", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DriverCheckpointJson = append(m.DriverCheckpointJson[:0], dAtA[iNdEx:postIndex]...)
			if m.DriverCheckpointJson == nil {
				m.DriverCheckpointJson = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tail", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tail = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PullResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PullResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PullResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opened", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opened == nil {
				m.Opened = &PullResponse_Opened{}
			}
			if err := m.Opened.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Documents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Documents == nil {
				m.Documents = &Documents{}
			}
			if err := m.Documents.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Checkpoint == nil {
				m.Checkpoint = &flow.DriverCheckpoint{}
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PullResponse_Opened) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opened: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opened: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExplicitAcknowledgements", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExplicitAcknowledgements = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Open == nil {
				m.Open = &PushRequest_Open{}
			}
			if err := m.Open.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Documents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Documents == nil {
				m.Documents = &Documents{}
			}
			if err := m.Documents.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Checkpoint == nil {
				m.Checkpoint = &flow.DriverCheckpoint{}
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushRequest_Open) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Open: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Open: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &protocol.Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Capture = github_com_estuary_flow_go_protocols_flow.Capture(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opened", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opened == nil {
				m.Opened = &PushResponse_Opened{}
			}
			if err := m.Opened.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acknowledge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Acknowledge == nil {
				m.Acknowledge = &Acknowledge{}
			}
			if err := m.Acknowledge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushResponse_Opened) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opened: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opened: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= protocol1.Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capture", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Capture == nil {
				m.Capture = &flow.CaptureSpec{}
			}
			if err := m.Capture.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBegin", wireType)
			}
			m.KeyBegin = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyBegin = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyEnd", wireType)
			}
			m.KeyEnd = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyEnd = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriverCheckpointJson", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCapture
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCapture
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DriverCheckpointJson = append(m.DriverCheckpointJson[:0], dAtA[iNdEx:postIndex]...)
			if m.DriverCheckpointJson == nil {
				m.DriverCheckpointJson = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapture(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapture
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCapture(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCapture
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCapture
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCapture
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCapture
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCapture
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCapture        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCapture          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCapture = fmt.Errorf("proto: unexpected end of group")
)
