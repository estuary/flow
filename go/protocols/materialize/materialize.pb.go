// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go/protocols/materialize/materialize.proto

package materialize

import (
	context "context"
	encoding_json "encoding/json"
	fmt "fmt"
	flow "github.com/estuary/flow/go/protocols/flow"
	github_com_estuary_flow_go_protocols_flow "github.com/estuary/flow/go/protocols/flow"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	protocol "go.gazette.dev/core/consumer/protocol"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Type encodes a constraint type for this flow.Projection.
type Response_Validated_Constraint_Type int32

const (
	Response_Validated_Constraint_INVALID Response_Validated_Constraint_Type = 0
	// This specific projection must be present.
	Response_Validated_Constraint_FIELD_REQUIRED Response_Validated_Constraint_Type = 1
	// At least one projection with this location pointer must be present.
	Response_Validated_Constraint_LOCATION_REQUIRED Response_Validated_Constraint_Type = 2
	// A projection with this location is recommended, and should be included by
	// default.
	Response_Validated_Constraint_LOCATION_RECOMMENDED Response_Validated_Constraint_Type = 3
	// This projection may be included, but should be omitted by default.
	Response_Validated_Constraint_FIELD_OPTIONAL Response_Validated_Constraint_Type = 4
	// This projection must not be present in the materialization.
	Response_Validated_Constraint_FIELD_FORBIDDEN Response_Validated_Constraint_Type = 5
	// This specific projection is required but is also unacceptable (e.x.,
	// because it uses an incompatible type with a previous applied version).
	Response_Validated_Constraint_UNSATISFIABLE Response_Validated_Constraint_Type = 6
)

var Response_Validated_Constraint_Type_name = map[int32]string{
	0: "INVALID",
	1: "FIELD_REQUIRED",
	2: "LOCATION_REQUIRED",
	3: "LOCATION_RECOMMENDED",
	4: "FIELD_OPTIONAL",
	5: "FIELD_FORBIDDEN",
	6: "UNSATISFIABLE",
}

var Response_Validated_Constraint_Type_value = map[string]int32{
	"INVALID":              0,
	"FIELD_REQUIRED":       1,
	"LOCATION_REQUIRED":    2,
	"LOCATION_RECOMMENDED": 3,
	"FIELD_OPTIONAL":       4,
	"FIELD_FORBIDDEN":      5,
	"UNSATISFIABLE":        6,
}

func (x Response_Validated_Constraint_Type) String() string {
	return proto.EnumName(Response_Validated_Constraint_Type_name, int32(x))
}

func (Response_Validated_Constraint_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{1, 1, 0, 0}
}

type Request struct {
	Spec        *Request_Spec        `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	Validate    *Request_Validate    `protobuf:"bytes,2,opt,name=validate,proto3" json:"validate,omitempty"`
	Apply       *Request_Apply       `protobuf:"bytes,3,opt,name=apply,proto3" json:"apply,omitempty"`
	Open        *Request_Open        `protobuf:"bytes,4,opt,name=open,proto3" json:"open,omitempty"`
	Load        *Request_Load        `protobuf:"bytes,5,opt,name=load,proto3" json:"load,omitempty"`
	Flush       *Request_Flush       `protobuf:"bytes,6,opt,name=flush,proto3" json:"flush,omitempty"`
	Store       *Request_Store       `protobuf:"bytes,7,opt,name=store,proto3" json:"store,omitempty"`
	StartCommit *Request_StartCommit `protobuf:"bytes,8,opt,name=start_commit,json=startCommit,proto3" json:"start_commit,omitempty"`
	Acknowledge *Request_Acknowledge `protobuf:"bytes,9,opt,name=acknowledge,proto3" json:"acknowledge,omitempty"`
	// Reserved for internal use.
	Internal             []byte   `protobuf:"bytes,100,opt,name=internal,json=$internal,proto3" json:"internal,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{0}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

// Spec requests the specification definition of this connector.
// Notably this includes its configuration JSON schemas.
type Request_Spec struct {
	// Connector type addressed by this request.
	ConnectorType flow.MaterializationSpec_ConnectorType `protobuf:"varint,1,opt,name=connector_type,json=connectorType,proto3,enum=flow.MaterializationSpec_ConnectorType" json:"connector_type,omitempty"`
	// Connector configuration, as an encoded JSON object.
	// This may be a partial specification (for example, a Docker image),
	// providing only enough information to fetch the remainder of the
	// specification schema.
	ConfigJson           encoding_json.RawMessage `protobuf:"bytes,2,opt,name=config_json,json=config,proto3,casttype=encoding/json.RawMessage" json:"config_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Request_Spec) Reset()         { *m = Request_Spec{} }
func (m *Request_Spec) String() string { return proto.CompactTextString(m) }
func (*Request_Spec) ProtoMessage()    {}
func (*Request_Spec) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{0, 0}
}
func (m *Request_Spec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Spec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Spec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Spec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Spec.Merge(m, src)
}
func (m *Request_Spec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Spec) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Spec.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Spec proto.InternalMessageInfo

// Validate a materialization configuration and proposed bindings.
// Validate is run out-of-band with ongoing capture invocations.
// It's purpose is to confirm that the proposed configuration
// is likely to succeed if applied and run, or to report any
// potential issues for the user to address.
type Request_Validate struct {
	// Name of the materialization being validated.
	Name github_com_estuary_flow_go_protocols_flow.Materialization `protobuf:"bytes,1,opt,name=name,proto3,casttype=github.com/estuary/flow/go/protocols/flow.Materialization" json:"name,omitempty"`
	// Connector type addressed by this request.
	ConnectorType flow.MaterializationSpec_ConnectorType `protobuf:"varint,2,opt,name=connector_type,json=connectorType,proto3,enum=flow.MaterializationSpec_ConnectorType" json:"connector_type,omitempty"`
	// Connector configuration, as an encoded JSON object.
	ConfigJson encoding_json.RawMessage    `protobuf:"bytes,3,opt,name=config_json,json=config,proto3,casttype=encoding/json.RawMessage" json:"config_json,omitempty"`
	Bindings   []*Request_Validate_Binding `protobuf:"bytes,4,rep,name=bindings,proto3" json:"bindings,omitempty"`
	// Last MaterializationSpec which was validated and published.
	// Note that this MaterializationSpec may not have been applied.
	LastMaterialization *flow.MaterializationSpec `protobuf:"bytes,5,opt,name=last_materialization,json=lastMaterialization,proto3" json:"last_materialization,omitempty"`
	// Version of the last validated MaterializationSpec.
	LastVersion          string   `protobuf:"bytes,6,opt,name=last_version,json=lastVersion,proto3" json:"last_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request_Validate) Reset()         { *m = Request_Validate{} }
func (m *Request_Validate) String() string { return proto.CompactTextString(m) }
func (*Request_Validate) ProtoMessage()    {}
func (*Request_Validate) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{0, 1}
}
func (m *Request_Validate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Validate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Validate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Validate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Validate.Merge(m, src)
}
func (m *Request_Validate) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Validate) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Validate.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Validate proto.InternalMessageInfo

// Bindings of endpoint resources and collections from which they would be
// materialized. Bindings are ordered and unique on the bound collection name.
type Request_Validate_Binding struct {
	// JSON-encoded object which specifies the endpoint resource to be materialized.
	ResourceConfigJson encoding_json.RawMessage `protobuf:"bytes,1,opt,name=resource_config_json,json=resourceConfig,proto3,casttype=encoding/json.RawMessage" json:"resource_config_json,omitempty"`
	// Collection to be materialized.
	Collection flow.CollectionSpec `protobuf:"bytes,2,opt,name=collection,proto3" json:"collection"`
	// Projection configuration, keyed by the projection field name,
	// with JSON-encoded and driver-defined configuration objects.
	FieldConfigJsonMap map[string]encoding_json.RawMessage `protobuf:"bytes,3,rep,name=field_config_json_map,json=fieldConfig,proto3,castvalue=encoding/json.RawMessage" json:"field_config_json_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Backfill counter for this binding.
	Backfill             uint32   `protobuf:"varint,4,opt,name=backfill,proto3" json:"backfill,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request_Validate_Binding) Reset()         { *m = Request_Validate_Binding{} }
func (m *Request_Validate_Binding) String() string { return proto.CompactTextString(m) }
func (*Request_Validate_Binding) ProtoMessage()    {}
func (*Request_Validate_Binding) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{0, 1, 0}
}
func (m *Request_Validate_Binding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Validate_Binding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Validate_Binding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Validate_Binding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Validate_Binding.Merge(m, src)
}
func (m *Request_Validate_Binding) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Validate_Binding) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Validate_Binding.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Validate_Binding proto.InternalMessageInfo

// Apply a materialization configuration and bindings to its endpoint.
// Apply is run out-of-band with ongoing connector invocations,
// and may be run many times for a single materialization name,
// where each invocation has varying bindings, or even no bindings.
// The connector performs any required setup or cleanup.
type Request_Apply struct {
	// Materialization to be applied.
	Materialization *flow.MaterializationSpec `protobuf:"bytes,1,opt,name=materialization,proto3" json:"materialization,omitempty"`
	// Version of the MaterializationSpec being applied.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Last CaptureSpec which was successfully applied.
	LastMaterialization *flow.MaterializationSpec `protobuf:"bytes,4,opt,name=last_materialization,json=lastMaterialization,proto3" json:"last_materialization,omitempty"`
	// Version of the last applied MaterializationSpec.
	LastVersion          string   `protobuf:"bytes,5,opt,name=last_version,json=lastVersion,proto3" json:"last_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request_Apply) Reset()         { *m = Request_Apply{} }
func (m *Request_Apply) String() string { return proto.CompactTextString(m) }
func (*Request_Apply) ProtoMessage()    {}
func (*Request_Apply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{0, 2}
}
func (m *Request_Apply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Apply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Apply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Apply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Apply.Merge(m, src)
}
func (m *Request_Apply) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Apply) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Apply.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Apply proto.InternalMessageInfo

// Open a materialization stream.
//
// If the Flow recovery log is authoritative:
// The driver is given its last committed checkpoint state in this request.
// It MAY return a runtime checkpoint in its opened response -- perhaps an older
// Flow checkpoint which was previously embedded within its driver checkpoint.
//
// If the remote store is authoritative:
// The driver MUST fence off other streams of this materialization that
// overlap the provided [key_begin, key_end) range, such that those streams
// cannot issue further commits. The driver MUST return its stored runtime
// checkpoint for this materialization and range [key_begin, key_end]
// in its Opened response.
//
// After Open, the runtime will send only Load, Flush, Store,
// StartCommit, and Acknowledge.
type Request_Open struct {
	// Materialization to be transacted.
	Materialization *flow.MaterializationSpec `protobuf:"bytes,1,opt,name=materialization,proto3" json:"materialization,omitempty"`
	// Version of the opened MaterializationSpec.
	// The driver may want to require that this match the version last
	// provided to a successful Apply RPC. It's possible that it won't,
	// due to expected propagation races in Flow's distributed runtime.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Range of documents to be processed by this invocation.
	Range *flow.RangeSpec `protobuf:"bytes,3,opt,name=range,proto3" json:"range,omitempty"`
	// Last-persisted connector checkpoint state from a previous invocation.
	StateJson            encoding_json.RawMessage `protobuf:"bytes,4,opt,name=state_json,json=state,proto3,casttype=encoding/json.RawMessage" json:"state_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Request_Open) Reset()         { *m = Request_Open{} }
func (m *Request_Open) String() string { return proto.CompactTextString(m) }
func (*Request_Open) ProtoMessage()    {}
func (*Request_Open) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{0, 3}
}
func (m *Request_Open) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Open) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Open.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Open) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Open.Merge(m, src)
}
func (m *Request_Open) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Open) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Open.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Open proto.InternalMessageInfo

// Load a document identified by its key. The given key may have never before been stored,
// but a given key will be sent in a transaction Load just one time.
type Request_Load struct {
	// Index of the Open binding for which this document is to be loaded.
	Binding uint32 `protobuf:"varint,1,opt,name=binding,proto3" json:"binding,omitempty"`
	// key tuple, as an array of key components.
	// Ordering matches `keys` of the materialization's field selection.
	KeyJson encoding_json.RawMessage `protobuf:"bytes,2,opt,name=key_json,json=key,proto3,casttype=encoding/json.RawMessage" json:"key_json,omitempty"`
	// Packed tuple of the document key to load.
	KeyPacked            []byte   `protobuf:"bytes,3,opt,name=key_packed,json=keyPacked,proto3" json:"key_packed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request_Load) Reset()         { *m = Request_Load{} }
func (m *Request_Load) String() string { return proto.CompactTextString(m) }
func (*Request_Load) ProtoMessage()    {}
func (*Request_Load) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{0, 4}
}
func (m *Request_Load) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Load) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Load.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Load) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Load.Merge(m, src)
}
func (m *Request_Load) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Load) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Load.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Load proto.InternalMessageInfo

// Flush loads. No further Loads will be sent in this transaction,
// and the runtime will await the connectors's remaining Loaded
// responses followed by one Flushed response.
type Request_Flush struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request_Flush) Reset()         { *m = Request_Flush{} }
func (m *Request_Flush) String() string { return proto.CompactTextString(m) }
func (*Request_Flush) ProtoMessage()    {}
func (*Request_Flush) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{0, 5}
}
func (m *Request_Flush) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Flush) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Flush.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Flush) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Flush.Merge(m, src)
}
func (m *Request_Flush) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Flush) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Flush.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Flush proto.InternalMessageInfo

// Store documents updated by the current transaction.
type Request_Store struct {
	// Index of the Open binding for which this document is to be stored.
	Binding uint32 `protobuf:"varint,1,opt,name=binding,proto3" json:"binding,omitempty"`
	// Key tuple, as an array of key components.
	// Ordering matches `keys` of the materialization's field selection.
	KeyJson encoding_json.RawMessage `protobuf:"bytes,2,opt,name=key_json,json=key,proto3,casttype=encoding/json.RawMessage" json:"key_json,omitempty"`
	// Packed FoundationDB tuple of the document key to store.
	KeyPacked []byte `protobuf:"bytes,3,opt,name=key_packed,json=keyPacked,proto3" json:"key_packed,omitempty"`
	// Values tuple, as an array of value components.
	// Ordering matches `values` of the materialization's field selection.
	ValuesJson encoding_json.RawMessage `protobuf:"bytes,4,opt,name=values_json,json=values,proto3,casttype=encoding/json.RawMessage" json:"values_json,omitempty"`
	// Packed FoundationDB tuple of the document values to store.
	ValuesPacked []byte `protobuf:"bytes,5,opt,name=values_packed,json=valuesPacked,proto3" json:"values_packed,omitempty"`
	// JSON document to store.
	DocJson encoding_json.RawMessage `protobuf:"bytes,6,opt,name=doc_json,json=doc,proto3,casttype=encoding/json.RawMessage" json:"doc_json,omitempty"`
	// Exists is true if this document has previously been loaded or stored.
	Exists bool `protobuf:"varint,7,opt,name=exists,proto3" json:"exists,omitempty"`
	// Delete is true if this document is being deleted, which also implies `exists`.
	Delete               bool     `protobuf:"varint,8,opt,name=delete,proto3" json:"delete,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request_Store) Reset()         { *m = Request_Store{} }
func (m *Request_Store) String() string { return proto.CompactTextString(m) }
func (*Request_Store) ProtoMessage()    {}
func (*Request_Store) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{0, 6}
}
func (m *Request_Store) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Store) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Store.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Store) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Store.Merge(m, src)
}
func (m *Request_Store) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Store) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Store.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Store proto.InternalMessageInfo

// Mark the end of the Store phase, and if the remote store is authoritative,
// instruct it to start committing its transaction.
type Request_StartCommit struct {
	// Flow runtime checkpoint to commit with this transaction.
	RuntimeCheckpoint    *protocol.Checkpoint `protobuf:"bytes,1,opt,name=runtime_checkpoint,json=runtimeCheckpoint,proto3" json:"runtime_checkpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Request_StartCommit) Reset()         { *m = Request_StartCommit{} }
func (m *Request_StartCommit) String() string { return proto.CompactTextString(m) }
func (*Request_StartCommit) ProtoMessage()    {}
func (*Request_StartCommit) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{0, 7}
}
func (m *Request_StartCommit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_StartCommit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_StartCommit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_StartCommit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_StartCommit.Merge(m, src)
}
func (m *Request_StartCommit) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_StartCommit) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_StartCommit.DiscardUnknown(m)
}

var xxx_messageInfo_Request_StartCommit proto.InternalMessageInfo

// Acknowledge to the connector that the previous transaction
// has committed to the Flow runtime's recovery log.
type Request_Acknowledge struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request_Acknowledge) Reset()         { *m = Request_Acknowledge{} }
func (m *Request_Acknowledge) String() string { return proto.CompactTextString(m) }
func (*Request_Acknowledge) ProtoMessage()    {}
func (*Request_Acknowledge) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{0, 8}
}
func (m *Request_Acknowledge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request_Acknowledge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request_Acknowledge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request_Acknowledge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Acknowledge.Merge(m, src)
}
func (m *Request_Acknowledge) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Request_Acknowledge) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Acknowledge.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Acknowledge proto.InternalMessageInfo

type Response struct {
	Spec          *Response_Spec          `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	Validated     *Response_Validated     `protobuf:"bytes,2,opt,name=validated,proto3" json:"validated,omitempty"`
	Applied       *Response_Applied       `protobuf:"bytes,3,opt,name=applied,proto3" json:"applied,omitempty"`
	Opened        *Response_Opened        `protobuf:"bytes,4,opt,name=opened,proto3" json:"opened,omitempty"`
	Loaded        *Response_Loaded        `protobuf:"bytes,5,opt,name=loaded,proto3" json:"loaded,omitempty"`
	Flushed       *Response_Flushed       `protobuf:"bytes,6,opt,name=flushed,proto3" json:"flushed,omitempty"`
	StartedCommit *Response_StartedCommit `protobuf:"bytes,7,opt,name=started_commit,json=startedCommit,proto3" json:"started_commit,omitempty"`
	Acknowledged  *Response_Acknowledged  `protobuf:"bytes,8,opt,name=acknowledged,proto3" json:"acknowledged,omitempty"`
	// Reserved for internal use.
	Internal             []byte   `protobuf:"bytes,100,opt,name=internal,json=$internal,proto3" json:"internal,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{1}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

// Spec responds to Request.Spec.
type Response_Spec struct {
	// Protocol version must be 3032023.
	Protocol uint32 `protobuf:"varint,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// JSON schema of the connector's configuration.
	ConfigSchemaJson encoding_json.RawMessage `protobuf:"bytes,2,opt,name=config_schema_json,json=configSchema,proto3,casttype=encoding/json.RawMessage" json:"config_schema_json,omitempty"`
	// JSON schema of the connecor's resource configuration.
	ResourceConfigSchemaJson encoding_json.RawMessage `protobuf:"bytes,3,opt,name=resource_config_schema_json,json=resourceConfigSchema,proto3,casttype=encoding/json.RawMessage" json:"resource_config_schema_json,omitempty"`
	// URL for connector's documention.
	DocumentationUrl string `protobuf:"bytes,4,opt,name=documentation_url,json=documentationUrl,proto3" json:"documentation_url,omitempty"`
	// Optional OAuth2 configuration.
	Oauth2               *flow.OAuth2 `protobuf:"bytes,5,opt,name=oauth2,proto3" json:"oauth2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Response_Spec) Reset()         { *m = Response_Spec{} }
func (m *Response_Spec) String() string { return proto.CompactTextString(m) }
func (*Response_Spec) ProtoMessage()    {}
func (*Response_Spec) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{1, 0}
}
func (m *Response_Spec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Spec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Spec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Spec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Spec.Merge(m, src)
}
func (m *Response_Spec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Spec) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Spec.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Spec proto.InternalMessageInfo

// Validated responds to Request.Validate.
type Response_Validated struct {
	Bindings             []*Response_Validated_Binding `protobuf:"bytes,1,rep,name=bindings,proto3" json:"bindings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *Response_Validated) Reset()         { *m = Response_Validated{} }
func (m *Response_Validated) String() string { return proto.CompactTextString(m) }
func (*Response_Validated) ProtoMessage()    {}
func (*Response_Validated) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{1, 1}
}
func (m *Response_Validated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Validated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Validated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Validated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Validated.Merge(m, src)
}
func (m *Response_Validated) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Validated) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Validated.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Validated proto.InternalMessageInfo

// Constraint constrains the use of a flow.Projection within a materialization.
type Response_Validated_Constraint struct {
	Type Response_Validated_Constraint_Type `protobuf:"varint,2,opt,name=type,proto3,enum=materialize.Response_Validated_Constraint_Type" json:"type,omitempty"`
	// Optional human readable reason for the given constraint.
	// Implementations are strongly encouraged to supply a descriptive message.
	Reason               string   `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response_Validated_Constraint) Reset()         { *m = Response_Validated_Constraint{} }
func (m *Response_Validated_Constraint) String() string { return proto.CompactTextString(m) }
func (*Response_Validated_Constraint) ProtoMessage()    {}
func (*Response_Validated_Constraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{1, 1, 0}
}
func (m *Response_Validated_Constraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Validated_Constraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Validated_Constraint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Validated_Constraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Validated_Constraint.Merge(m, src)
}
func (m *Response_Validated_Constraint) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Validated_Constraint) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Validated_Constraint.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Validated_Constraint proto.InternalMessageInfo

// Validation responses for each binding of the request, and matching the
// request ordering. Each Binding must have a unique resource_path.
type Response_Validated_Binding struct {
	// Constraints over collection projections imposed by the Driver,
	// keyed by the projection field name. Projections of the CollectionSpec
	// which are missing from constraints are implicitly forbidden.
	Constraints map[string]*Response_Validated_Constraint `protobuf:"bytes,1,rep,name=constraints,proto3" json:"constraints,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Components of the resource path which fully qualify the resource
	// identified by this binding.
	// - For an RDBMS, this might be []{dbname, schema, table}.
	// - For Kafka, this might be []{topic}.
	// - For Redis, this might be []{key_prefix}.
	ResourcePath []string `protobuf:"bytes,2,rep,name=resource_path,json=resourcePath,proto3" json:"resource_path,omitempty"`
	// Materialize combined delta updates of documents rather than full
	// reductions.
	//
	// When set, the Flow runtime will not attempt to load documents via
	// Request.Load, and also disables re-use of cached documents
	// stored in prior transactions. Each stored document is exclusively
	// combined from updates processed by the runtime within the current
	// transaction only.
	//
	// This is appropriate for drivers over streams, WebHooks, and append-only
	// files.
	//
	// For example, given a collection which reduces a sum count for each key,
	// its materialization will produce a stream of delta updates to the count,
	// such that a reader of the stream will arrive at the correct total count.
	DeltaUpdates         bool     `protobuf:"varint,3,opt,name=delta_updates,json=deltaUpdates,proto3" json:"delta_updates,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response_Validated_Binding) Reset()         { *m = Response_Validated_Binding{} }
func (m *Response_Validated_Binding) String() string { return proto.CompactTextString(m) }
func (*Response_Validated_Binding) ProtoMessage()    {}
func (*Response_Validated_Binding) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{1, 1, 1}
}
func (m *Response_Validated_Binding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Validated_Binding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Validated_Binding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Validated_Binding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Validated_Binding.Merge(m, src)
}
func (m *Response_Validated_Binding) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Validated_Binding) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Validated_Binding.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Validated_Binding proto.InternalMessageInfo

// Applied responds to Request.Apply.
type Response_Applied struct {
	// Human-readable description of the action that the connector took.
	// If empty, this Apply is to be considered a "no-op".
	ActionDescription    string   `protobuf:"bytes,1,opt,name=action_description,json=actionDescription,proto3" json:"action_description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response_Applied) Reset()         { *m = Response_Applied{} }
func (m *Response_Applied) String() string { return proto.CompactTextString(m) }
func (*Response_Applied) ProtoMessage()    {}
func (*Response_Applied) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{1, 2}
}
func (m *Response_Applied) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Applied) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Applied.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Applied) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Applied.Merge(m, src)
}
func (m *Response_Applied) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Applied) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Applied.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Applied proto.InternalMessageInfo

// Opened responds to Request.Open.
// After Opened, the connector sends only Loaded, Flushed,
// StartedCommit, and Acknowledged as per the materialization
// protocol.
type Response_Opened struct {
	// Flow runtime checkpoint to begin processing from.
	// If empty, the most recent checkpoint of the Flow recovery log is used.
	//
	// Or, a driver may send the value []byte{0xf8, 0xff, 0xff, 0xff, 0xf, 0x1}
	// to explicitly begin processing from a zero-valued checkpoint, effectively
	// rebuilding the materialization from scratch. This sentinel is a trivial
	// encoding of the max-value 2^29-1 protobuf tag with boolean true.
	RuntimeCheckpoint    *protocol.Checkpoint `protobuf:"bytes,1,opt,name=runtime_checkpoint,json=runtimeCheckpoint,proto3" json:"runtime_checkpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Response_Opened) Reset()         { *m = Response_Opened{} }
func (m *Response_Opened) String() string { return proto.CompactTextString(m) }
func (*Response_Opened) ProtoMessage()    {}
func (*Response_Opened) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{1, 3}
}
func (m *Response_Opened) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Opened) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Opened.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Opened) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Opened.Merge(m, src)
}
func (m *Response_Opened) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Opened) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Opened.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Opened proto.InternalMessageInfo

// Loaded responds to Request.Load.
// It returns documents of requested keys which have previously been stored.
// Keys not found in the store MUST be omitted. Documents may be in any order,
// both within and across Loaded response messages, but a document of a given
// key MUST be sent at most one time in a Transaction.
type Response_Loaded struct {
	// Index of the Open binding for which this document was loaded.
	Binding uint32 `protobuf:"varint,1,opt,name=binding,proto3" json:"binding,omitempty"`
	// Loaded JSON document.
	DocJson              encoding_json.RawMessage `protobuf:"bytes,2,opt,name=doc_json,json=doc,proto3,casttype=encoding/json.RawMessage" json:"doc_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Response_Loaded) Reset()         { *m = Response_Loaded{} }
func (m *Response_Loaded) String() string { return proto.CompactTextString(m) }
func (*Response_Loaded) ProtoMessage()    {}
func (*Response_Loaded) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{1, 4}
}
func (m *Response_Loaded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Loaded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Loaded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Loaded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Loaded.Merge(m, src)
}
func (m *Response_Loaded) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Loaded) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Loaded.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Loaded proto.InternalMessageInfo

// Flushed responds to a Request.Flush.
// The driver will send no further Loaded responses.
type Response_Flushed struct {
	// Optional update to ConnectorState.
	// This update is durably written before the connector receives a following
	// Store or StartCommit request.
	State                *flow.ConnectorState `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Response_Flushed) Reset()         { *m = Response_Flushed{} }
func (m *Response_Flushed) String() string { return proto.CompactTextString(m) }
func (*Response_Flushed) ProtoMessage()    {}
func (*Response_Flushed) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{1, 5}
}
func (m *Response_Flushed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Flushed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Flushed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Flushed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Flushed.Merge(m, src)
}
func (m *Response_Flushed) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Flushed) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Flushed.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Flushed proto.InternalMessageInfo

// StartedCommit responds to a Request.StartCommit.
// The driver has processed all Store requests, it has started to commit its
// transaction (if it has one), and it is now ready for the runtime to start
// committing to its own recovery log.
type Response_StartedCommit struct {
	// Optional *transactional* update to ConnectorState.
	// This update commits atomically with the Flow recovery log checkpoint.
	State                *flow.ConnectorState `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Response_StartedCommit) Reset()         { *m = Response_StartedCommit{} }
func (m *Response_StartedCommit) String() string { return proto.CompactTextString(m) }
func (*Response_StartedCommit) ProtoMessage()    {}
func (*Response_StartedCommit) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{1, 6}
}
func (m *Response_StartedCommit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_StartedCommit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_StartedCommit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_StartedCommit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_StartedCommit.Merge(m, src)
}
func (m *Response_StartedCommit) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_StartedCommit) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_StartedCommit.DiscardUnknown(m)
}

var xxx_messageInfo_Response_StartedCommit proto.InternalMessageInfo

// Notify the runtime that the previous transaction has committed.
// On receipt, the runtime may begin to flush, store, and commit a
// next (pipelined) transaction.
//
// Acknowledged is _not_ a direct response to Request.Acknowledge,
// and Acknowledge vs Acknowledged may be written in either order.
type Response_Acknowledged struct {
	// Optional *non-transactional* update to ConnectorState.
	// This update is not transactional and the connector must tolerate a future,
	// duplicate Request.Acknowledge of this same checkpoint and connector state,
	// even after having previously responded with Acknowledged and a (discarded)
	// connector state update.
	State                *flow.ConnectorState `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Response_Acknowledged) Reset()         { *m = Response_Acknowledged{} }
func (m *Response_Acknowledged) String() string { return proto.CompactTextString(m) }
func (*Response_Acknowledged) ProtoMessage()    {}
func (*Response_Acknowledged) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{1, 7}
}
func (m *Response_Acknowledged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response_Acknowledged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response_Acknowledged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response_Acknowledged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response_Acknowledged.Merge(m, src)
}
func (m *Response_Acknowledged) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Response_Acknowledged) XXX_DiscardUnknown() {
	xxx_messageInfo_Response_Acknowledged.DiscardUnknown(m)
}

var xxx_messageInfo_Response_Acknowledged proto.InternalMessageInfo

// Extra messages used by connectors
// TODO(johnny): Do we still need this?
type Extra struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Extra) Reset()         { *m = Extra{} }
func (m *Extra) String() string { return proto.CompactTextString(m) }
func (*Extra) ProtoMessage()    {}
func (*Extra) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{2}
}
func (m *Extra) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Extra) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Extra.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Extra) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Extra.Merge(m, src)
}
func (m *Extra) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Extra) XXX_DiscardUnknown() {
	xxx_messageInfo_Extra.DiscardUnknown(m)
}

var xxx_messageInfo_Extra proto.InternalMessageInfo

type Extra_ValidateExistingProjectionRequest struct {
	ExistingBinding      *flow.MaterializationSpec_Binding `protobuf:"bytes,1,opt,name=existing_binding,json=existingBinding,proto3" json:"existing_binding,omitempty"`
	ProposedBinding      *Request_Validate_Binding         `protobuf:"bytes,2,opt,name=proposed_binding,json=proposedBinding,proto3" json:"proposed_binding,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *Extra_ValidateExistingProjectionRequest) Reset() {
	*m = Extra_ValidateExistingProjectionRequest{}
}
func (m *Extra_ValidateExistingProjectionRequest) String() string { return proto.CompactTextString(m) }
func (*Extra_ValidateExistingProjectionRequest) ProtoMessage()    {}
func (*Extra_ValidateExistingProjectionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{2, 0}
}
func (m *Extra_ValidateExistingProjectionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Extra_ValidateExistingProjectionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Extra_ValidateExistingProjectionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Extra_ValidateExistingProjectionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Extra_ValidateExistingProjectionRequest.Merge(m, src)
}
func (m *Extra_ValidateExistingProjectionRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Extra_ValidateExistingProjectionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_Extra_ValidateExistingProjectionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_Extra_ValidateExistingProjectionRequest proto.InternalMessageInfo

type Extra_ValidateBindingAgainstConstraints struct {
	Binding              *flow.MaterializationSpec_Binding         `protobuf:"bytes,1,opt,name=binding,proto3" json:"binding,omitempty"`
	Constraints          map[string]*Response_Validated_Constraint `protobuf:"bytes,2,rep,name=constraints,proto3" json:"constraints,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                  `json:"-"`
	XXX_unrecognized     []byte                                    `json:"-"`
	XXX_sizecache        int32                                     `json:"-"`
}

func (m *Extra_ValidateBindingAgainstConstraints) Reset() {
	*m = Extra_ValidateBindingAgainstConstraints{}
}
func (m *Extra_ValidateBindingAgainstConstraints) String() string { return proto.CompactTextString(m) }
func (*Extra_ValidateBindingAgainstConstraints) ProtoMessage()    {}
func (*Extra_ValidateBindingAgainstConstraints) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8b62b327f34bc6, []int{2, 1}
}
func (m *Extra_ValidateBindingAgainstConstraints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Extra_ValidateBindingAgainstConstraints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Extra_ValidateBindingAgainstConstraints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Extra_ValidateBindingAgainstConstraints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Extra_ValidateBindingAgainstConstraints.Merge(m, src)
}
func (m *Extra_ValidateBindingAgainstConstraints) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Extra_ValidateBindingAgainstConstraints) XXX_DiscardUnknown() {
	xxx_messageInfo_Extra_ValidateBindingAgainstConstraints.DiscardUnknown(m)
}

var xxx_messageInfo_Extra_ValidateBindingAgainstConstraints proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("materialize.Response_Validated_Constraint_Type", Response_Validated_Constraint_Type_name, Response_Validated_Constraint_Type_value)
	proto.RegisterType((*Request)(nil), "materialize.Request")
	proto.RegisterType((*Request_Spec)(nil), "materialize.Request.Spec")
	proto.RegisterType((*Request_Validate)(nil), "materialize.Request.Validate")
	proto.RegisterType((*Request_Validate_Binding)(nil), "materialize.Request.Validate.Binding")
	proto.RegisterMapType((map[string]encoding_json.RawMessage)(nil), "materialize.Request.Validate.Binding.FieldConfigJsonMapEntry")
	proto.RegisterType((*Request_Apply)(nil), "materialize.Request.Apply")
	proto.RegisterType((*Request_Open)(nil), "materialize.Request.Open")
	proto.RegisterType((*Request_Load)(nil), "materialize.Request.Load")
	proto.RegisterType((*Request_Flush)(nil), "materialize.Request.Flush")
	proto.RegisterType((*Request_Store)(nil), "materialize.Request.Store")
	proto.RegisterType((*Request_StartCommit)(nil), "materialize.Request.StartCommit")
	proto.RegisterType((*Request_Acknowledge)(nil), "materialize.Request.Acknowledge")
	proto.RegisterType((*Response)(nil), "materialize.Response")
	proto.RegisterType((*Response_Spec)(nil), "materialize.Response.Spec")
	proto.RegisterType((*Response_Validated)(nil), "materialize.Response.Validated")
	proto.RegisterType((*Response_Validated_Constraint)(nil), "materialize.Response.Validated.Constraint")
	proto.RegisterType((*Response_Validated_Binding)(nil), "materialize.Response.Validated.Binding")
	proto.RegisterMapType((map[string]*Response_Validated_Constraint)(nil), "materialize.Response.Validated.Binding.ConstraintsEntry")
	proto.RegisterType((*Response_Applied)(nil), "materialize.Response.Applied")
	proto.RegisterType((*Response_Opened)(nil), "materialize.Response.Opened")
	proto.RegisterType((*Response_Loaded)(nil), "materialize.Response.Loaded")
	proto.RegisterType((*Response_Flushed)(nil), "materialize.Response.Flushed")
	proto.RegisterType((*Response_StartedCommit)(nil), "materialize.Response.StartedCommit")
	proto.RegisterType((*Response_Acknowledged)(nil), "materialize.Response.Acknowledged")
	proto.RegisterType((*Extra)(nil), "materialize.Extra")
	proto.RegisterType((*Extra_ValidateExistingProjectionRequest)(nil), "materialize.Extra.ValidateExistingProjectionRequest")
	proto.RegisterType((*Extra_ValidateBindingAgainstConstraints)(nil), "materialize.Extra.ValidateBindingAgainstConstraints")
	proto.RegisterMapType((map[string]*Response_Validated_Constraint)(nil), "materialize.Extra.ValidateBindingAgainstConstraints.ConstraintsEntry")
}

func init() {
	proto.RegisterFile("go/protocols/materialize/materialize.proto", fileDescriptor_3e8b62b327f34bc6)
}

var fileDescriptor_3e8b62b327f34bc6 = []byte{
	// 1699 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xcf, 0x6f, 0xdb, 0xc8,
	0x15, 0x0e, 0x65, 0xfd, 0x7c, 0x92, 0x6d, 0x79, 0xa2, 0xb4, 0x2c, 0x37, 0x9b, 0x38, 0xde, 0x5d,
	0xac, 0x91, 0x62, 0xe5, 0xc0, 0x69, 0xb1, 0x49, 0x16, 0x29, 0x2a, 0xc9, 0x12, 0xa0, 0x54, 0xb6,
	0xbc, 0xe3, 0x24, 0x0b, 0xec, 0x45, 0x98, 0x90, 0x63, 0x99, 0x31, 0xc5, 0x61, 0xc9, 0x51, 0xb2,
	0xea, 0xa9, 0x28, 0x50, 0x14, 0xe8, 0xad, 0x40, 0xd1, 0x4b, 0x51, 0xa0, 0xb7, 0xfe, 0x05, 0xbd,
	0xf4, 0x5a, 0x14, 0xc8, 0xb1, 0xb7, 0xde, 0x52, 0x74, 0xfb, 0x17, 0xf4, 0xba, 0x87, 0xa2, 0x98,
	0x1f, 0xa4, 0x28, 0x47, 0x92, 0xb5, 0x40, 0x9a, 0x8b, 0xc1, 0x79, 0xf3, 0x7d, 0x8f, 0x8f, 0x6f,
	0xde, 0xbc, 0xf7, 0xc9, 0x70, 0x7b, 0xc8, 0xf6, 0x82, 0x90, 0x71, 0x66, 0x33, 0x2f, 0xda, 0x1b,
	0x11, 0x4e, 0x43, 0x97, 0x78, 0xee, 0xcf, 0x68, 0xfa, 0xb9, 0x2e, 0x11, 0xa8, 0x9c, 0x32, 0x59,
	0xdb, 0x36, 0xf3, 0xa3, 0xf1, 0x88, 0x86, 0x09, 0x3d, 0x79, 0x50, 0x70, 0xeb, 0xfa, 0x8c, 0xeb,
	0x53, 0x8f, 0xbd, 0x94, 0x7f, 0xf4, 0x6e, 0x6d, 0xc8, 0x86, 0x4c, 0x3e, 0xee, 0x89, 0x27, 0x65,
	0xdd, 0xf9, 0xc5, 0x55, 0x28, 0x60, 0xfa, 0xd3, 0x31, 0x8d, 0x38, 0xfa, 0x04, 0xb2, 0x51, 0x40,
	0x6d, 0xd3, 0xd8, 0x36, 0x76, 0xcb, 0xfb, 0xdf, 0xab, 0xa7, 0x03, 0xd2, 0x98, 0xfa, 0x49, 0x40,
	0x6d, 0x2c, 0x61, 0xe8, 0x3e, 0x14, 0x5f, 0x10, 0xcf, 0x75, 0x08, 0xa7, 0x66, 0x46, 0x52, 0xde,
	0x9f, 0x4b, 0x79, 0xaa, 0x41, 0x38, 0x81, 0xa3, 0x3b, 0x90, 0x23, 0x41, 0xe0, 0x4d, 0xcc, 0x35,
	0xc9, 0xb3, 0xe6, 0xf2, 0x1a, 0x02, 0x81, 0x15, 0x50, 0xc4, 0xc6, 0x02, 0xea, 0x9b, 0xd9, 0x25,
	0xb1, 0xf5, 0x03, 0xea, 0x63, 0x09, 0x13, 0x70, 0x8f, 0x11, 0xc7, 0xcc, 0x2d, 0x81, 0xf7, 0x18,
	0x71, 0xb0, 0x84, 0x89, 0x78, 0x4e, 0xbd, 0x71, 0x74, 0x66, 0xe6, 0x97, 0xc4, 0xd3, 0x11, 0x08,
	0xac, 0x80, 0x82, 0x11, 0x71, 0x16, 0x52, 0xb3, 0xb0, 0x84, 0x71, 0x22, 0x10, 0x58, 0x01, 0x51,
	0x0b, 0x2a, 0x11, 0x27, 0x21, 0x1f, 0xd8, 0x6c, 0x34, 0x72, 0xb9, 0x59, 0x94, 0xc4, 0xed, 0x05,
	0x44, 0x12, 0xf2, 0x96, 0xc4, 0xe1, 0x72, 0x34, 0x5d, 0xa0, 0x26, 0x94, 0x89, 0x7d, 0xee, 0xb3,
	0x97, 0x1e, 0x75, 0x86, 0xd4, 0x2c, 0x2d, 0xf1, 0xd1, 0x98, 0xe2, 0x70, 0x9a, 0x84, 0xde, 0x83,
	0xa2, 0xeb, 0x73, 0x1a, 0xfa, 0xc4, 0x33, 0x9d, 0x6d, 0x63, 0xb7, 0x82, 0x4b, 0x1f, 0xc6, 0x06,
	0xeb, 0x37, 0x06, 0x64, 0xc5, 0x19, 0xa3, 0x23, 0xd8, 0xb0, 0x99, 0xef, 0x53, 0x9b, 0xb3, 0x70,
	0xc0, 0x27, 0x01, 0x95, 0x65, 0xb1, 0xb1, 0xff, 0x71, 0x5d, 0xd6, 0xd4, 0x61, 0xf2, 0x46, 0xc2,
	0x5d, 0xe6, 0x0b, 0x4a, 0xbd, 0x15, 0xe3, 0x1f, 0x4f, 0x02, 0x8a, 0xd7, 0xed, 0xf4, 0x12, 0xdd,
	0x87, 0xb2, 0xcd, 0xfc, 0x53, 0x77, 0x38, 0x78, 0x1e, 0x31, 0x5f, 0x16, 0x4c, 0xa9, 0x79, 0xfd,
	0x9b, 0xd7, 0x37, 0x4d, 0xea, 0xdb, 0xcc, 0x71, 0xfd, 0xe1, 0x9e, 0xd8, 0xa8, 0x63, 0xf2, 0xf2,
	0x90, 0x46, 0x11, 0x19, 0x52, 0x9c, 0x57, 0x04, 0xeb, 0x0f, 0x79, 0x28, 0xc6, 0x45, 0x84, 0x3e,
	0x87, 0xac, 0x4f, 0x46, 0x2a, 0x9a, 0x52, 0xf3, 0xe1, 0x37, 0xaf, 0x6f, 0xde, 0x1f, 0xba, 0xfc,
	0x6c, 0xfc, 0xac, 0x6e, 0xb3, 0xd1, 0x1e, 0x8d, 0xf8, 0x98, 0x84, 0x13, 0x55, 0xfc, 0x6f, 0x5c,
	0x87, 0x8b, 0x51, 0x63, 0xe9, 0x6a, 0xce, 0xa7, 0x66, 0xde, 0xe6, 0xa7, 0xae, 0xad, 0xfe, 0xa9,
	0xa8, 0x01, 0xc5, 0x67, 0xae, 0x2f, 0x20, 0x91, 0x99, 0xdd, 0x5e, 0xdb, 0x2d, 0xef, 0x7f, 0xb4,
	0xf4, 0x4e, 0xd5, 0x9b, 0x0a, 0x8d, 0x13, 0x1a, 0xea, 0x41, 0xcd, 0x23, 0x11, 0x1f, 0x8c, 0x66,
	0xc3, 0x4e, 0xae, 0xc2, 0xa2, 0x6f, 0xc2, 0x57, 0x05, 0xed, 0xc2, 0x06, 0xba, 0x05, 0x15, 0xe9,
	0xed, 0x05, 0x0d, 0x23, 0xe1, 0x45, 0x5c, 0x90, 0x12, 0x2e, 0x0b, 0xdb, 0x53, 0x65, 0xb2, 0xfe,
	0x9b, 0x81, 0x82, 0x0e, 0x03, 0x3d, 0x82, 0x5a, 0x48, 0x23, 0x36, 0x0e, 0x6d, 0x3a, 0x48, 0xe7,
	0xc0, 0x58, 0x21, 0x07, 0x1b, 0x31, 0xb3, 0xa5, 0x72, 0xf1, 0x00, 0xc0, 0x66, 0x9e, 0x47, 0x6d,
	0x19, 0xbe, 0xea, 0x30, 0x35, 0x15, 0x7e, 0x2b, 0xb1, 0x8b, 0xc8, 0x9b, 0xd9, 0x57, 0xaf, 0x6f,
	0x5e, 0xc1, 0x29, 0x34, 0xfa, 0x95, 0x01, 0xd7, 0x4e, 0x5d, 0xea, 0x39, 0xe9, 0x28, 0x06, 0x23,
	0x12, 0x98, 0x6b, 0x32, 0xab, 0x0f, 0x57, 0xca, 0x6a, 0xbd, 0x23, 0x5c, 0xa8, 0x70, 0x1e, 0x45,
	0xcc, 0x3f, 0x24, 0x41, 0xdb, 0xe7, 0xe1, 0xa4, 0x79, 0xfd, 0xd7, 0xff, 0x5c, 0xf2, 0x21, 0xe5,
	0xd3, 0x29, 0x0d, 0x59, 0x50, 0x7c, 0x46, 0xec, 0xf3, 0x53, 0xd7, 0xf3, 0x64, 0xf3, 0x5a, 0xc7,
	0xc9, 0xda, 0x6a, 0xc3, 0x77, 0x17, 0xbc, 0x01, 0x55, 0x61, 0xed, 0x9c, 0x4e, 0x54, 0xde, 0xb0,
	0x78, 0x44, 0x35, 0xc8, 0xbd, 0x20, 0xde, 0x58, 0x15, 0x67, 0x09, 0xab, 0xc5, 0x83, 0xcc, 0x3d,
	0xc3, 0xfa, 0x87, 0x01, 0x39, 0xd9, 0x2c, 0x51, 0x0b, 0x36, 0x2f, 0x1e, 0xbb, 0x71, 0xd9, 0xb1,
	0x5f, 0x64, 0x20, 0x13, 0x0a, 0xf1, 0x69, 0xab, 0x57, 0xc5, 0xcb, 0x85, 0xa5, 0x95, 0x7d, 0x2b,
	0xa5, 0x95, 0x7b, 0xb3, 0xb4, 0xfe, 0x66, 0x40, 0x56, 0x74, 0xf5, 0xff, 0xf7, 0x87, 0x7d, 0x04,
	0xb9, 0x90, 0xf8, 0x43, 0xaa, 0xe7, 0xd1, 0xa6, 0x72, 0x8a, 0x85, 0x49, 0xba, 0x52, 0xbb, 0xe8,
	0x53, 0x80, 0x88, 0x13, 0x4e, 0x55, 0x4d, 0x67, 0x57, 0xa8, 0xe9, 0x9c, 0xc4, 0x5b, 0x1c, 0xb2,
	0x62, 0xda, 0x88, 0x08, 0xf4, 0x3d, 0x95, 0xe1, 0xaf, 0xe3, 0x78, 0x89, 0xee, 0x42, 0xf1, 0x9c,
	0x4e, 0x56, 0xef, 0x8d, 0xb2, 0x24, 0xde, 0x07, 0x10, 0xa4, 0x80, 0xd8, 0xe7, 0xd4, 0x91, 0xb1,
	0x57, 0x70, 0xe9, 0x9c, 0x4e, 0x8e, 0xa5, 0xc1, 0x2a, 0x40, 0x4e, 0xce, 0x2c, 0xeb, 0x2f, 0x19,
	0xc8, 0xc9, 0x59, 0xf4, 0x6e, 0x03, 0x10, 0x8d, 0x50, 0x56, 0x69, 0xb4, 0x7a, 0xc2, 0xf2, 0x8a,
	0x80, 0x3e, 0x80, 0x75, 0x4d, 0xd5, 0xce, 0x73, 0xd2, 0x79, 0x45, 0x19, 0xb5, 0xff, 0xbb, 0x50,
	0x74, 0x98, 0xad, 0x9c, 0xe7, 0x57, 0x89, 0xd9, 0x61, 0x36, 0xfa, 0x0e, 0xe4, 0xe9, 0x57, 0x6e,
	0xc4, 0x23, 0x39, 0xba, 0x8b, 0x58, 0xaf, 0x84, 0xdd, 0xa1, 0x1e, 0xe5, 0x54, 0x4e, 0xe6, 0x22,
	0xd6, 0x2b, 0x0b, 0x43, 0x39, 0x35, 0x8e, 0x51, 0x0b, 0x50, 0x38, 0xf6, 0xb9, 0x3b, 0xa2, 0x03,
	0xfb, 0x8c, 0xda, 0xe7, 0x01, 0x73, 0x7d, 0xae, 0x8b, 0xb1, 0x56, 0x8f, 0x35, 0x5a, 0xbd, 0x95,
	0xec, 0xe1, 0x2d, 0x8d, 0x9f, 0x9a, 0xac, 0x75, 0x28, 0xa7, 0xc6, 0xf3, 0xce, 0x9f, 0x36, 0xa0,
	0x88, 0x69, 0x14, 0x30, 0x3f, 0xa2, 0xa8, 0x3e, 0xa3, 0xc2, 0x2e, 0x0a, 0x0b, 0x05, 0x4a, 0xcb,
	0xb0, 0x87, 0x50, 0x8a, 0x75, 0x95, 0xa3, 0xbb, 0xe4, 0xcd, 0xf9, 0xa4, 0xb8, 0xbd, 0x39, 0x78,
	0xca, 0x40, 0x9f, 0x42, 0x41, 0x28, 0x2c, 0x57, 0x9f, 0xdf, 0x9b, 0x22, 0x4e, 0x93, 0x1b, 0x0a,
	0x84, 0x63, 0x34, 0xfa, 0x01, 0xe4, 0x85, 0xd4, 0xa2, 0x8e, 0xbe, 0xfe, 0xd7, 0xe7, 0xf3, 0xfa,
	0x12, 0x83, 0x35, 0x56, 0xb0, 0x84, 0xe2, 0xa2, 0xb1, 0x34, 0x5b, 0xc0, 0xea, 0x49, 0x0c, 0xd6,
	0x58, 0x11, 0xa4, 0x94, 0x5d, 0xd4, 0xd1, 0x0a, 0x6d, 0x41, 0x90, 0x1d, 0x05, 0xc2, 0x31, 0x1a,
	0x3d, 0x82, 0x0d, 0x29, 0x9f, 0xa8, 0x13, 0xcb, 0x2e, 0xa5, 0xd7, 0x3e, 0x58, 0x90, 0x56, 0x85,
	0xd5, 0xca, 0x6b, 0x3d, 0x4a, 0x2f, 0x51, 0x07, 0x2a, 0x29, 0x19, 0xe5, 0x68, 0x01, 0xb7, 0xb3,
	0x20, 0x5d, 0x29, 0x24, 0x9e, 0xe1, 0x2d, 0xd7, 0x5f, 0xbf, 0xcb, 0x68, 0xfd, 0x65, 0x41, 0x31,
	0x16, 0x2f, 0xfa, 0xaa, 0x26, 0x6b, 0xd4, 0x01, 0xa4, 0xc7, 0x5a, 0x64, 0x9f, 0xd1, 0x11, 0x59,
	0xfd, 0xd6, 0x56, 0x14, 0xef, 0x44, 0xd2, 0xd0, 0x17, 0xf0, 0xde, 0xc5, 0x69, 0x9d, 0x76, 0xb8,
	0x8a, 0x70, 0xa9, 0xcd, 0x0e, 0x6d, 0xed, 0xf8, 0xfb, 0xb0, 0xe5, 0x30, 0x7b, 0x3c, 0xa2, 0x3e,
	0x97, 0xad, 0x77, 0x30, 0x0e, 0xd5, 0xf4, 0x2b, 0xe1, 0xea, 0xcc, 0xc6, 0x93, 0xd0, 0x43, 0x1f,
	0x42, 0x9e, 0x91, 0x31, 0x3f, 0xdb, 0xd7, 0x25, 0x51, 0x51, 0xdd, 0xb7, 0xdf, 0x10, 0x36, 0xac,
	0xf7, 0xac, 0xff, 0x64, 0xa1, 0x94, 0x14, 0x30, 0x6a, 0xa5, 0x74, 0x92, 0x21, 0x27, 0xfa, 0xc7,
	0x97, 0xd4, 0xfc, 0x9b, 0x4a, 0xc9, 0xfa, 0x79, 0x06, 0xa0, 0xc5, 0xfc, 0x88, 0x87, 0xc4, 0xf5,
	0xc5, 0xcd, 0xce, 0xa6, 0xc4, 0xdf, 0xde, 0x65, 0xfe, 0xa6, 0xcc, 0xba, 0x14, 0x81, 0x92, 0x2c,
	0xba, 0x48, 0x48, 0x49, 0x92, 0x3d, 0xac, 0x57, 0x3b, 0xbf, 0x35, 0x20, 0x2b, 0xc5, 0x61, 0x19,
	0x0a, 0xdd, 0xa3, 0xa7, 0x8d, 0x5e, 0xf7, 0xa0, 0x7a, 0x05, 0x21, 0xd8, 0xe8, 0x74, 0xdb, 0xbd,
	0x83, 0x01, 0x6e, 0x7f, 0xfe, 0xa4, 0x8b, 0xdb, 0x07, 0x55, 0x03, 0x5d, 0x83, 0xad, 0x5e, 0xbf,
	0xd5, 0x78, 0xdc, 0xed, 0x1f, 0x4d, 0xcd, 0x19, 0x64, 0x42, 0x2d, 0x65, 0x6e, 0xf5, 0x0f, 0x0f,
	0xdb, 0x47, 0x07, 0xed, 0x83, 0xea, 0xda, 0xd4, 0x49, 0xff, 0x58, 0xec, 0x36, 0x7a, 0xd5, 0x2c,
	0xba, 0x0a, 0x9b, 0xca, 0xd6, 0xe9, 0xe3, 0x66, 0xf7, 0xe0, 0xa0, 0x7d, 0x54, 0xcd, 0xa1, 0x2d,
	0x58, 0x7f, 0x72, 0x74, 0xd2, 0x78, 0xdc, 0x3d, 0xe9, 0x74, 0x1b, 0xcd, 0x5e, 0xbb, 0x9a, 0xb7,
	0x7e, 0x9f, 0xd2, 0x6e, 0x5f, 0x4a, 0xd9, 0xaa, 0xbf, 0x29, 0x4e, 0xeb, 0xbd, 0x15, 0xd3, 0x9a,
	0x4a, 0x47, 0x24, 0x15, 0x0c, 0x4e, 0x3b, 0x13, 0xed, 0x3c, 0xa9, 0xb4, 0x80, 0xf0, 0x33, 0x33,
	0xb3, 0xbd, 0xb6, 0x5b, 0xc2, 0x95, 0xd8, 0x78, 0x4c, 0xf8, 0x99, 0x00, 0x39, 0xd4, 0xe3, 0x64,
	0x30, 0x0e, 0x84, 0xef, 0x48, 0xa6, 0xb0, 0x88, 0x2b, 0xd2, 0xf8, 0x44, 0xd9, 0xac, 0xe7, 0x50,
	0xbd, 0xf8, 0xaa, 0x39, 0x62, 0xe9, 0xc7, 0x69, 0xb1, 0x54, 0xde, 0xbf, 0xbd, 0xfa, 0x61, 0xa6,
	0x85, 0xd5, 0x3d, 0x28, 0xe8, 0xb6, 0x87, 0x3e, 0x01, 0x44, 0xa4, 0xb4, 0x1c, 0x38, 0x34, 0xb2,
	0x43, 0x37, 0x48, 0x34, 0x48, 0x09, 0x6f, 0xa9, 0x9d, 0x83, 0xe9, 0x86, 0x75, 0x08, 0x79, 0xd5,
	0xf8, 0xde, 0xce, 0xbc, 0xf8, 0x02, 0xf2, 0xaa, 0x23, 0x2e, 0x1f, 0xe0, 0xc9, 0x30, 0xcc, 0xac,
	0x38, 0x0c, 0xad, 0x1f, 0x42, 0x41, 0xf7, 0x4c, 0x74, 0x1b, 0x94, 0x58, 0x49, 0x62, 0xd3, 0x4a,
	0x5b, 0xff, 0xb2, 0x39, 0x11, 0x7b, 0xb1, 0x9e, 0xf9, 0x0c, 0xd6, 0x67, 0x5a, 0xe5, 0xb7, 0x22,
	0x3f, 0x80, 0x4a, 0xba, 0x3b, 0x7e, 0x1b, 0xee, 0xce, 0x2f, 0xb3, 0x90, 0x6b, 0x7f, 0xc5, 0x43,
	0x62, 0xfd, 0xd5, 0x80, 0x5b, 0xf1, 0xf9, 0xb5, 0xc5, 0x04, 0x77, 0xfd, 0xe1, 0x71, 0xc8, 0x9e,
	0xab, 0x1f, 0x00, 0xf1, 0xbf, 0x34, 0x7a, 0x50, 0xa5, 0x7a, 0x73, 0x90, 0xce, 0x5b, 0x79, 0xff,
	0xd6, 0xe2, 0x1f, 0x77, 0x71, 0xa7, 0xd8, 0x8c, 0xa9, 0xf1, 0x0d, 0x39, 0x86, 0x6a, 0x10, 0xb2,
	0x80, 0x45, 0xd4, 0x49, 0xbc, 0xa9, 0x02, 0x5b, 0xf1, 0x57, 0xda, 0x66, 0x4c, 0xd7, 0x06, 0xeb,
	0xcf, 0x99, 0xe9, 0x57, 0x68, 0x5b, 0x63, 0x48, 0x5c, 0x3f, 0xe2, 0xa9, 0x22, 0x47, 0x9f, 0xcd,
	0x1e, 0xfa, 0x4a, 0xc1, 0x27, 0x75, 0x31, 0x9c, 0xbd, 0xd6, 0x19, 0x79, 0xad, 0xdb, 0x33, 0xf1,
	0xca, 0x8c, 0xd6, 0x2f, 0x8d, 0x63, 0xf9, 0x1d, 0x7f, 0x97, 0x37, 0x73, 0xff, 0x27, 0x50, 0x4a,
	0x0a, 0x04, 0xfd, 0x08, 0xca, 0xd3, 0x4c, 0x50, 0x54, 0x9b, 0x77, 0x16, 0xd6, 0xb5, 0xb9, 0x2f,
	0xda, 0x35, 0xee, 0x18, 0xcd, 0xe6, 0xab, 0x7f, 0xdd, 0xb8, 0xf2, 0xea, 0xeb, 0x1b, 0xc6, 0xdf,
	0xbf, 0xbe, 0x61, 0xfc, 0xf1, 0xdf, 0x37, 0x8c, 0x2f, 0xef, 0xac, 0xf4, 0x2f, 0x85, 0x94, 0xc3,
	0x67, 0x79, 0x69, 0xbe, 0xfb, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4b, 0x65, 0x75, 0xc0, 0xdf,
	0x13, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ConnectorClient is the client API for Connector service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ConnectorClient interface {
	Materialize(ctx context.Context, opts ...grpc.CallOption) (Connector_MaterializeClient, error)
}

type connectorClient struct {
	cc *grpc.ClientConn
}

func NewConnectorClient(cc *grpc.ClientConn) ConnectorClient {
	return &connectorClient{cc}
}

func (c *connectorClient) Materialize(ctx context.Context, opts ...grpc.CallOption) (Connector_MaterializeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Connector_serviceDesc.Streams[0], "/materialize.Connector/Materialize", opts...)
	if err != nil {
		return nil, err
	}
	x := &connectorMaterializeClient{stream}
	return x, nil
}

type Connector_MaterializeClient interface {
	Send(*Request) error
	Recv() (*Response, error)
	grpc.ClientStream
}

type connectorMaterializeClient struct {
	grpc.ClientStream
}

func (x *connectorMaterializeClient) Send(m *Request) error {
	return x.ClientStream.SendMsg(m)
}

func (x *connectorMaterializeClient) Recv() (*Response, error) {
	m := new(Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ConnectorServer is the server API for Connector service.
type ConnectorServer interface {
	Materialize(Connector_MaterializeServer) error
}

// UnimplementedConnectorServer can be embedded to have forward compatible implementations.
type UnimplementedConnectorServer struct {
}

func (*UnimplementedConnectorServer) Materialize(srv Connector_MaterializeServer) error {
	return status.Errorf(codes.Unimplemented, "method Materialize not implemented")
}

func RegisterConnectorServer(s *grpc.Server, srv ConnectorServer) {
	s.RegisterService(&_Connector_serviceDesc, srv)
}

func _Connector_Materialize_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ConnectorServer).Materialize(&connectorMaterializeServer{stream})
}

type Connector_MaterializeServer interface {
	Send(*Response) error
	Recv() (*Request, error)
	grpc.ServerStream
}

type connectorMaterializeServer struct {
	grpc.ServerStream
}

func (x *connectorMaterializeServer) Send(m *Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *connectorMaterializeServer) Recv() (*Request, error) {
	m := new(Request)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Connector_serviceDesc = grpc.ServiceDesc{
	ServiceName: "materialize.Connector",
	HandlerType: (*ConnectorServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Materialize",
			Handler:       _Connector_Materialize_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "go/protocols/materialize/materialize.proto",
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Internal) > 0 {
		i -= len(m.Internal)
		copy(dAtA[i:], m.Internal)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.Internal)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if m.Acknowledge != nil {
		{
			size, err := m.Acknowledge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.StartCommit != nil {
		{
			size, err := m.StartCommit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Store != nil {
		{
			size, err := m.Store.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Flush != nil {
		{
			size, err := m.Flush.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Load != nil {
		{
			size, err := m.Load.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Open != nil {
		{
			size, err := m.Open.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Apply != nil {
		{
			size, err := m.Apply.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Validate != nil {
		{
			size, err := m.Validate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request_Spec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Spec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Spec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ConfigJson) > 0 {
		i -= len(m.ConfigJson)
		copy(dAtA[i:], m.ConfigJson)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.ConfigJson)))
		i--
		dAtA[i] = 0x12
	}
	if m.ConnectorType != 0 {
		i = encodeVarintMaterialize(dAtA, i, uint64(m.ConnectorType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request_Validate) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Validate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Validate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LastVersion) > 0 {
		i -= len(m.LastVersion)
		copy(dAtA[i:], m.LastVersion)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.LastVersion)))
		i--
		dAtA[i] = 0x32
	}
	if m.LastMaterialization != nil {
		{
			size, err := m.LastMaterialization.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Bindings) > 0 {
		for iNdEx := len(m.Bindings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bindings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaterialize(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ConfigJson) > 0 {
		i -= len(m.ConfigJson)
		copy(dAtA[i:], m.ConfigJson)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.ConfigJson)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConnectorType != 0 {
		i = encodeVarintMaterialize(dAtA, i, uint64(m.ConnectorType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request_Validate_Binding) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Validate_Binding) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Validate_Binding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Backfill != 0 {
		i = encodeVarintMaterialize(dAtA, i, uint64(m.Backfill))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FieldConfigJsonMap) > 0 {
		for k := range m.FieldConfigJsonMap {
			v := m.FieldConfigJsonMap[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMaterialize(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMaterialize(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMaterialize(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.Collection.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaterialize(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ResourceConfigJson) > 0 {
		i -= len(m.ResourceConfigJson)
		copy(dAtA[i:], m.ResourceConfigJson)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.ResourceConfigJson)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request_Apply) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Apply) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Apply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LastVersion) > 0 {
		i -= len(m.LastVersion)
		copy(dAtA[i:], m.LastVersion)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.LastVersion)))
		i--
		dAtA[i] = 0x2a
	}
	if m.LastMaterialization != nil {
		{
			size, err := m.LastMaterialization.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if m.Materialization != nil {
		{
			size, err := m.Materialization.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request_Open) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Open) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Open) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StateJson) > 0 {
		i -= len(m.StateJson)
		copy(dAtA[i:], m.StateJson)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.StateJson)))
		i--
		dAtA[i] = 0x22
	}
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if m.Materialization != nil {
		{
			size, err := m.Materialization.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request_Load) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Load) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Load) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.KeyPacked) > 0 {
		i -= len(m.KeyPacked)
		copy(dAtA[i:], m.KeyPacked)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.KeyPacked)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.KeyJson) > 0 {
		i -= len(m.KeyJson)
		copy(dAtA[i:], m.KeyJson)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.KeyJson)))
		i--
		dAtA[i] = 0x12
	}
	if m.Binding != 0 {
		i = encodeVarintMaterialize(dAtA, i, uint64(m.Binding))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request_Flush) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Flush) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Flush) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Request_Store) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Store) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Store) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Delete {
		i--
		if m.Delete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Exists {
		i--
		if m.Exists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.DocJson) > 0 {
		i -= len(m.DocJson)
		copy(dAtA[i:], m.DocJson)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.DocJson)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ValuesPacked) > 0 {
		i -= len(m.ValuesPacked)
		copy(dAtA[i:], m.ValuesPacked)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.ValuesPacked)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ValuesJson) > 0 {
		i -= len(m.ValuesJson)
		copy(dAtA[i:], m.ValuesJson)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.ValuesJson)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.KeyPacked) > 0 {
		i -= len(m.KeyPacked)
		copy(dAtA[i:], m.KeyPacked)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.KeyPacked)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.KeyJson) > 0 {
		i -= len(m.KeyJson)
		copy(dAtA[i:], m.KeyJson)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.KeyJson)))
		i--
		dAtA[i] = 0x12
	}
	if m.Binding != 0 {
		i = encodeVarintMaterialize(dAtA, i, uint64(m.Binding))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request_StartCommit) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_StartCommit) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_StartCommit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RuntimeCheckpoint != nil {
		{
			size, err := m.RuntimeCheckpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request_Acknowledge) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request_Acknowledge) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Acknowledge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Internal) > 0 {
		i -= len(m.Internal)
		copy(dAtA[i:], m.Internal)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.Internal)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if m.Acknowledged != nil {
		{
			size, err := m.Acknowledged.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.StartedCommit != nil {
		{
			size, err := m.StartedCommit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Flushed != nil {
		{
			size, err := m.Flushed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Loaded != nil {
		{
			size, err := m.Loaded.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Opened != nil {
		{
			size, err := m.Opened.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Applied != nil {
		{
			size, err := m.Applied.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Validated != nil {
		{
			size, err := m.Validated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response_Spec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Spec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Spec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Oauth2 != nil {
		{
			size, err := m.Oauth2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DocumentationUrl) > 0 {
		i -= len(m.DocumentationUrl)
		copy(dAtA[i:], m.DocumentationUrl)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.DocumentationUrl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ResourceConfigSchemaJson) > 0 {
		i -= len(m.ResourceConfigSchemaJson)
		copy(dAtA[i:], m.ResourceConfigSchemaJson)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.ResourceConfigSchemaJson)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ConfigSchemaJson) > 0 {
		i -= len(m.ConfigSchemaJson)
		copy(dAtA[i:], m.ConfigSchemaJson)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.ConfigSchemaJson)))
		i--
		dAtA[i] = 0x12
	}
	if m.Protocol != 0 {
		i = encodeVarintMaterialize(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Response_Validated) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Validated) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Validated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Bindings) > 0 {
		for iNdEx := len(m.Bindings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bindings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaterialize(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Response_Validated_Constraint) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Validated_Constraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Validated_Constraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintMaterialize(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *Response_Validated_Binding) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Validated_Binding) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Validated_Binding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DeltaUpdates {
		i--
		if m.DeltaUpdates {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ResourcePath) > 0 {
		for iNdEx := len(m.ResourcePath) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResourcePath[iNdEx])
			copy(dAtA[i:], m.ResourcePath[iNdEx])
			i = encodeVarintMaterialize(dAtA, i, uint64(len(m.ResourcePath[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Constraints) > 0 {
		for k := range m.Constraints {
			v := m.Constraints[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMaterialize(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMaterialize(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMaterialize(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Response_Applied) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Applied) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Applied) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ActionDescription) > 0 {
		i -= len(m.ActionDescription)
		copy(dAtA[i:], m.ActionDescription)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.ActionDescription)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response_Opened) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Opened) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Opened) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RuntimeCheckpoint != nil {
		{
			size, err := m.RuntimeCheckpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response_Loaded) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Loaded) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Loaded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DocJson) > 0 {
		i -= len(m.DocJson)
		copy(dAtA[i:], m.DocJson)
		i = encodeVarintMaterialize(dAtA, i, uint64(len(m.DocJson)))
		i--
		dAtA[i] = 0x12
	}
	if m.Binding != 0 {
		i = encodeVarintMaterialize(dAtA, i, uint64(m.Binding))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Response_Flushed) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Flushed) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Flushed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response_StartedCommit) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_StartedCommit) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_StartedCommit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response_Acknowledged) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response_Acknowledged) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Acknowledged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Extra) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Extra) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Extra) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Extra_ValidateExistingProjectionRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Extra_ValidateExistingProjectionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Extra_ValidateExistingProjectionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ProposedBinding != nil {
		{
			size, err := m.ProposedBinding.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ExistingBinding != nil {
		{
			size, err := m.ExistingBinding.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Extra_ValidateBindingAgainstConstraints) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Extra_ValidateBindingAgainstConstraints) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Extra_ValidateBindingAgainstConstraints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Constraints) > 0 {
		for k := range m.Constraints {
			v := m.Constraints[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMaterialize(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMaterialize(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMaterialize(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Binding != nil {
		{
			size, err := m.Binding.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaterialize(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMaterialize(dAtA []byte, offset int, v uint64) int {
	offset -= sovMaterialize(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Request) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.Validate != nil {
		l = m.Validate.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.Apply != nil {
		l = m.Apply.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.Open != nil {
		l = m.Open.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.Load != nil {
		l = m.Load.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.Flush != nil {
		l = m.Flush.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.Store != nil {
		l = m.Store.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.StartCommit != nil {
		l = m.StartCommit.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.Acknowledge != nil {
		l = m.Acknowledge.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	l = len(m.Internal)
	if l > 0 {
		n += 2 + l + sovMaterialize(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Spec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectorType != 0 {
		n += 1 + sovMaterialize(uint64(m.ConnectorType))
	}
	l = len(m.ConfigJson)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Validate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.ConnectorType != 0 {
		n += 1 + sovMaterialize(uint64(m.ConnectorType))
	}
	l = len(m.ConfigJson)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if len(m.Bindings) > 0 {
		for _, e := range m.Bindings {
			l = e.ProtoSize()
			n += 1 + l + sovMaterialize(uint64(l))
		}
	}
	if m.LastMaterialization != nil {
		l = m.LastMaterialization.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	l = len(m.LastVersion)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Validate_Binding) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceConfigJson)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	l = m.Collection.ProtoSize()
	n += 1 + l + sovMaterialize(uint64(l))
	if len(m.FieldConfigJsonMap) > 0 {
		for k, v := range m.FieldConfigJsonMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMaterialize(uint64(len(k))) + 1 + len(v) + sovMaterialize(uint64(len(v)))
			n += mapEntrySize + 1 + sovMaterialize(uint64(mapEntrySize))
		}
	}
	if m.Backfill != 0 {
		n += 1 + sovMaterialize(uint64(m.Backfill))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Apply) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Materialization != nil {
		l = m.Materialization.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.LastMaterialization != nil {
		l = m.LastMaterialization.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	l = len(m.LastVersion)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Open) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Materialization != nil {
		l = m.Materialization.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.Range != nil {
		l = m.Range.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	l = len(m.StateJson)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Load) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Binding != 0 {
		n += 1 + sovMaterialize(uint64(m.Binding))
	}
	l = len(m.KeyJson)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	l = len(m.KeyPacked)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Flush) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Store) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Binding != 0 {
		n += 1 + sovMaterialize(uint64(m.Binding))
	}
	l = len(m.KeyJson)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	l = len(m.KeyPacked)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	l = len(m.ValuesJson)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	l = len(m.ValuesPacked)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	l = len(m.DocJson)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.Exists {
		n += 2
	}
	if m.Delete {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_StartCommit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuntimeCheckpoint != nil {
		l = m.RuntimeCheckpoint.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request_Acknowledge) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.Validated != nil {
		l = m.Validated.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.Applied != nil {
		l = m.Applied.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.Opened != nil {
		l = m.Opened.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.Loaded != nil {
		l = m.Loaded.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.Flushed != nil {
		l = m.Flushed.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.StartedCommit != nil {
		l = m.StartedCommit.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.Acknowledged != nil {
		l = m.Acknowledged.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	l = len(m.Internal)
	if l > 0 {
		n += 2 + l + sovMaterialize(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Spec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Protocol != 0 {
		n += 1 + sovMaterialize(uint64(m.Protocol))
	}
	l = len(m.ConfigSchemaJson)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	l = len(m.ResourceConfigSchemaJson)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	l = len(m.DocumentationUrl)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.Oauth2 != nil {
		l = m.Oauth2.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Validated) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Bindings) > 0 {
		for _, e := range m.Bindings {
			l = e.ProtoSize()
			n += 1 + l + sovMaterialize(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Validated_Constraint) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMaterialize(uint64(m.Type))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Validated_Binding) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Constraints) > 0 {
		for k, v := range m.Constraints {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovMaterialize(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMaterialize(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMaterialize(uint64(mapEntrySize))
		}
	}
	if len(m.ResourcePath) > 0 {
		for _, s := range m.ResourcePath {
			l = len(s)
			n += 1 + l + sovMaterialize(uint64(l))
		}
	}
	if m.DeltaUpdates {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Applied) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionDescription)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Opened) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuntimeCheckpoint != nil {
		l = m.RuntimeCheckpoint.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Loaded) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Binding != 0 {
		n += 1 + sovMaterialize(uint64(m.Binding))
	}
	l = len(m.DocJson)
	if l > 0 {
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Flushed) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = m.State.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_StartedCommit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = m.State.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response_Acknowledged) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = m.State.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Extra) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Extra_ValidateExistingProjectionRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExistingBinding != nil {
		l = m.ExistingBinding.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.ProposedBinding != nil {
		l = m.ProposedBinding.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Extra_ValidateBindingAgainstConstraints) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Binding != nil {
		l = m.Binding.ProtoSize()
		n += 1 + l + sovMaterialize(uint64(l))
	}
	if len(m.Constraints) > 0 {
		for k, v := range m.Constraints {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovMaterialize(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMaterialize(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMaterialize(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMaterialize(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMaterialize(x uint64) (n int) {
	return sovMaterialize(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &Request_Spec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Validate == nil {
				m.Validate = &Request_Validate{}
			}
			if err := m.Validate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Apply == nil {
				m.Apply = &Request_Apply{}
			}
			if err := m.Apply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Open == nil {
				m.Open = &Request_Open{}
			}
			if err := m.Open.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Load == nil {
				m.Load = &Request_Load{}
			}
			if err := m.Load.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flush", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flush == nil {
				m.Flush = &Request_Flush{}
			}
			if err := m.Flush.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Store", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Store == nil {
				m.Store = &Request_Store{}
			}
			if err := m.Store.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartCommit == nil {
				m.StartCommit = &Request_StartCommit{}
			}
			if err := m.StartCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acknowledge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Acknowledge == nil {
				m.Acknowledge = &Request_Acknowledge{}
			}
			if err := m.Acknowledge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Internal = append(m.Internal[:0], dAtA[iNdEx:postIndex]...)
			if m.Internal == nil {
				m.Internal = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Spec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorType", wireType)
			}
			m.ConnectorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectorType |= flow.MaterializationSpec_ConnectorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Validate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = github_com_estuary_flow_go_protocols_flow.Materialization(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorType", wireType)
			}
			m.ConnectorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectorType |= flow.MaterializationSpec_ConnectorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bindings = append(m.Bindings, &Request_Validate_Binding{})
			if err := m.Bindings[len(m.Bindings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMaterialization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastMaterialization == nil {
				m.LastMaterialization = &flow.MaterializationSpec{}
			}
			if err := m.LastMaterialization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Validate_Binding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Binding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Binding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceConfigJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceConfigJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldConfigJsonMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldConfigJsonMap == nil {
				m.FieldConfigJsonMap = make(map[string]encoding_json.RawMessage)
			}
			var mapkey string
			var mapvalue encoding_json.RawMessage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMaterialize
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMaterialize
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMaterialize
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMaterialize
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMaterialize
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMaterialize
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMaterialize
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = encoding_json.RawMessage(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMaterialize(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMaterialize
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FieldConfigJsonMap[mapkey] = ((encoding_json.RawMessage)(mapvalue))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backfill", wireType)
			}
			m.Backfill = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Backfill |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Apply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Apply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Apply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Materialization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Materialization == nil {
				m.Materialization = &flow.MaterializationSpec{}
			}
			if err := m.Materialization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMaterialization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastMaterialization == nil {
				m.LastMaterialization = &flow.MaterializationSpec{}
			}
			if err := m.LastMaterialization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Open) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Open: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Open: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Materialization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Materialization == nil {
				m.Materialization = &flow.MaterializationSpec{}
			}
			if err := m.Materialization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &flow.RangeSpec{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Load) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Load: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Load: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binding", wireType)
			}
			m.Binding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Binding |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPacked", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyPacked = append(m.KeyPacked[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyPacked == nil {
				m.KeyPacked = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Flush) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flush: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flush: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Store) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Store: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Store: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binding", wireType)
			}
			m.Binding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Binding |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPacked", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyPacked = append(m.KeyPacked[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyPacked == nil {
				m.KeyPacked = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValuesJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValuesJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValuesPacked", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValuesPacked = append(m.ValuesPacked[:0], dAtA[iNdEx:postIndex]...)
			if m.ValuesPacked == nil {
				m.ValuesPacked = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exists = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Delete = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_StartCommit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartCommit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartCommit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeCheckpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuntimeCheckpoint == nil {
				m.RuntimeCheckpoint = &protocol.Checkpoint{}
			}
			if err := m.RuntimeCheckpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request_Acknowledge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Acknowledge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Acknowledge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &Response_Spec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Validated == nil {
				m.Validated = &Response_Validated{}
			}
			if err := m.Validated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applied", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Applied == nil {
				m.Applied = &Response_Applied{}
			}
			if err := m.Applied.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opened", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opened == nil {
				m.Opened = &Response_Opened{}
			}
			if err := m.Opened.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loaded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Loaded == nil {
				m.Loaded = &Response_Loaded{}
			}
			if err := m.Loaded.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flushed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flushed == nil {
				m.Flushed = &Response_Flushed{}
			}
			if err := m.Flushed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedCommit == nil {
				m.StartedCommit = &Response_StartedCommit{}
			}
			if err := m.StartedCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acknowledged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Acknowledged == nil {
				m.Acknowledged = &Response_Acknowledged{}
			}
			if err := m.Acknowledged.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Internal = append(m.Internal[:0], dAtA[iNdEx:postIndex]...)
			if m.Internal == nil {
				m.Internal = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Spec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigSchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigSchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceConfigSchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceConfigSchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentationUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocumentationUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oauth2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Oauth2 == nil {
				m.Oauth2 = &flow.OAuth2{}
			}
			if err := m.Oauth2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Validated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bindings = append(m.Bindings, &Response_Validated_Binding{})
			if err := m.Bindings[len(m.Bindings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Validated_Constraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Constraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Constraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Response_Validated_Constraint_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Validated_Binding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Binding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Binding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Constraints == nil {
				m.Constraints = make(map[string]*Response_Validated_Constraint)
			}
			var mapkey string
			var mapvalue *Response_Validated_Constraint
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMaterialize
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMaterialize
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMaterialize
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMaterialize
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMaterialize
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMaterialize
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMaterialize
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Response_Validated_Constraint{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMaterialize(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMaterialize
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Constraints[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourcePath = append(m.ResourcePath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaUpdates", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeltaUpdates = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Applied) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Applied: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Applied: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Opened) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opened: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opened: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeCheckpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuntimeCheckpoint == nil {
				m.RuntimeCheckpoint = &protocol.Checkpoint{}
			}
			if err := m.RuntimeCheckpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Loaded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Loaded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Loaded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binding", wireType)
			}
			m.Binding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Binding |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Flushed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flushed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flushed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &flow.ConnectorState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_StartedCommit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartedCommit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartedCommit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &flow.ConnectorState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response_Acknowledged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Acknowledged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Acknowledged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &flow.ConnectorState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Extra) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Extra: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Extra: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Extra_ValidateExistingProjectionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateExistingProjectionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateExistingProjectionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingBinding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExistingBinding == nil {
				m.ExistingBinding = &flow.MaterializationSpec_Binding{}
			}
			if err := m.ExistingBinding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposedBinding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProposedBinding == nil {
				m.ProposedBinding = &Request_Validate_Binding{}
			}
			if err := m.ProposedBinding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Extra_ValidateBindingAgainstConstraints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateBindingAgainstConstraints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateBindingAgainstConstraints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Binding == nil {
				m.Binding = &flow.MaterializationSpec_Binding{}
			}
			if err := m.Binding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaterialize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaterialize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Constraints == nil {
				m.Constraints = make(map[string]*Response_Validated_Constraint)
			}
			var mapkey string
			var mapvalue *Response_Validated_Constraint
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMaterialize
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMaterialize
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMaterialize
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMaterialize
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMaterialize
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMaterialize
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMaterialize
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Response_Validated_Constraint{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMaterialize(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMaterialize
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Constraints[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaterialize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaterialize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMaterialize(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMaterialize
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMaterialize
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMaterialize
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMaterialize
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMaterialize
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMaterialize        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMaterialize          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMaterialize = fmt.Errorf("proto: unexpected end of group")
)
