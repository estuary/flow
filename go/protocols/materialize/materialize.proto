syntax = "proto3";

package materialize;
option go_package = "github.com/estuary/flow/go/protocols/materialize";

import "go/protocols/flow/flow.proto";
import "gogoproto/gogo.proto";

option (gogoproto.marshaler_all) = true;
option (gogoproto.protosizer_all) = true;
option (gogoproto.unmarshaler_all) = true;
option (gogoproto.goproto_getters_all) = false;


// Constraint constrains the use of a flow.Projection within a materialization.
message Constraint {
  // Type encodes a constraint type for this flow.Projection.
  enum Type {
    // This specific projection must be present.
    FIELD_REQUIRED = 0;
    // At least one projection with this location pointer must be present.
    LOCATION_REQUIRED = 1;
    // A projection with this location is recommended, and should be included by default.
    LOCATION_RECOMMENDED = 2;
    // This projection may be included, but should be omitted by default.
    FIELD_OPTIONAL = 3;
    // This projection must not be present in the materialization.
    FIELD_FORBIDDEN = 4;
    // This specific projection is required but is also unacceptable (e.x.,
    // because it uses an incompatible type with a previous applied version).
    UNSATISFIABLE = 5;
  }
  Type type = 2;
  // Optional human readable reason for the given constraint.
  // Implementations are strongly encouraged to supply a descriptive message.
  string reason = 3;
}

// Driver is the service implemented by a materialization target system.
service Driver {
  // Session begins a scoped interaction with the driver from a single process context.
  // It maps SessionRequest to a handle used with further Driver interactions.
  // Note that at any given time there may be *many* concurrent sessions.
  rpc StartSession(SessionRequest) returns (SessionResponse);
  // Validate that a CollectionSpec is compatible with a materialization target,
  // and return constraints over the projections of the collection.
  rpc Validate(ValidateRequest) returns (ValidateResponse);
  // Apply a CollectionSpec and FieldSelections to a materialization target.
  rpc Apply(ApplyRequest) returns (ApplyResponse);
  // Fence off other sessions of this shard ID from committing transactions
  // against this driver and endpoint.
  //
  // Fence is an *optional* API which is required for materializations that
  // support end-to-end "exactly once" semantics. Stores which support only
  // "at least once" semantics can implement Fence as a no-op, returning a
  // zero-value FenceResponse.
  //
  // Where implemented, drivers  must guarantee that no previous sessions of
  // this shard ID (now a "zombie" session) can commit Transactions. Fence
  // returns the final checkpoint committed by this shard ID in a Transaction.
  rpc Fence(FenceRequest) returns (FenceResponse);
  // Transaction protocol of a store, following the lifecycle:
  //
  // 1. The Flow runtime client sends TransactionRequest.Start.
  // 2. The client sends zero or more TransactionRequest.Load.
  //    - The driver server may immediately send any number of TransactionResponse.Load
  //      in response.
  //    - Or, it may defer responding with some or all loads until later.
  // 3. The client sends TransactionRequest.Prepare.
  //    - At this time, the server must flush remaining TransactionResponse.Loads.
  // 4. The server sends TransactionResponse.Prepare.
  // 5. The client sends zero or more TransactionRequest.Store.
  // 6. The client sends TransactionRequest.Commit, followed by EOF.
  //    - The server commits the prepared Flow checkpoint and all stores.
  // 7. The server sends TransactionResponse.Commit.
  //    - The Flow runtime persists the prepared driver checkpoint.
  //
  // An error of any kind prior to Commit -- including EOF -- is treated as a rollback.
  // Intermediaries / proxies may map a broken transport on one side into a clean shutdown
  // of the other, and explicit Commits distinguish this case.
  rpc Transaction(stream TransactionRequest) returns (stream TransactionResponse);
}

// SessionRequest is the request type of the StartSession RPC.
message SessionRequest {
  // Endpoint type addressed by this request.
  flow.EndpointType endpoint_type = 1;
  // Driver-specific configuration, as an encoded JSON object.
  string endpoint_config_json = 2;
  // Stable ID of the flow consumer shard that this session belongs to. A null or empty value
  // indicates that the caller is not a flow consumer shard, but some other process (e.g. flowctl).
  string shard_id = 3;


  // DEPRECATED - this will be removed.
  // Their semantics are instead carried by endpoint_config_json.

  // Endpoint URL of the materialization system.
  string endpoint_url = 99;
  // Target name within the materialization system, where applicable.
  // This could be a SQL schema & table, or a pub/sub topic, etc.
  string target = 100;
}

// SessionResponse is the response type of the StartSession RPC.
message SessionResponse {
  // Opaque session handle.
  bytes handle = 1;
  // Materialize combined delta updates of documents rather than full reductions.
  //
  // When set, the Flow runtime will not attempt to load documents via
  // TransactionRequest.Load, and disables internal re-use of documents
  // stored in prior transactions. Each stored document is exclusively combined
  // from updates processed by the runtime within the current transaction only.
  //
  // This is appropriate for drivers over streams, WebHooks, and append-only files.
  //
  // For example, given a collection which reduces a sum count for each key,
  // its materialization will produce a stream of delta updates to the count,
  // such that a reader of the stream will arrive at the correct total count.
  bool delta_updates = 2;
}

// ValidateRequest is the request type of the Validate RPC.
message ValidateRequest {
  // Endpoint type addressed by this request.
  flow.EndpointType endpoint_type = 1;
  // Opaque session handle.
  bytes handle = 2;
  // Collection to be materialized.
  flow.CollectionSpec collection = 3;
  // Projection configuration, keyed by the projection field name,
  // with JSON-encoded and driver-defined configuration objects.
  map<string, string> field_config_json = 4;
}

// ValidateResponse is the response type of the Validate RPC.
message ValidateResponse {
  // Constraints over collection projections imposed by the Driver,
  // keyed by the projection field name. Projections of the CollectionSpec
  // which are missing from constraints are implicitly forbidden.
  map<string, Constraint> constraints = 1;
}

// ApplyRequest is the request type of the Apply RPC.
message ApplyRequest {
  // Endpoint type addressed by this request.
  flow.EndpointType endpoint_type = 1;
  // Opaque session handle.
  bytes handle = 2;
  // Collection to be materialized.
  flow.CollectionSpec collection = 3;
  // Selected fields for materialization
  flow.FieldSelection fields = 4;
  // Is this Apply a dry-run? If so, no action is undertaken and Apply will
  // report only what would have happened.
  bool dry_run = 5;
}

// ApplyResponse is the response type of the Apply RPC.
message ApplyResponse {
  // Human-readable description of the action that the Driver took (or, if dry_run, would have taken).
  // If empty, this Apply is to be considered a "no-op".
  string action_description = 1;
}

// FenceRequest is the request type of a Fence RPC.
message FenceRequest {
  // Endpoint type addressed by this request.
  flow.EndpointType endpoint_type = 1;
  // Opaque session handle.
  bytes handle = 2;
  // Driver checkpoint which was last committed from a Store RPC.
  // Or empty, if the Driver has never returned a checkpoint.
  bytes driver_checkpoint = 3;
}

// FenceResponse is the response type of a Fence RPC.
message FenceResponse {
  // Flow checkpoint which was previously committed with this caller ID.
  // Or nil, if unknown or transactional semantics are not supported.
  bytes flow_checkpoint = 1;
}

// TransactionRequest is the request type of a Transaction RPC.
// It will have exactly one top-level field set, which represents its message type.
message TransactionRequest {
  // Start a Transaction.
  message Start {
    // Endpoint type addressed by this request.
    flow.EndpointType endpoint_type = 1;
    // Opaque session handle.
    bytes handle = 2;
    // Fields represents the projection fields to be stored. This repeats the selection and ordering
    // of the last Apply RPC, but is provided here also as a convenience.
    flow.FieldSelection fields = 3;
  }
  Start start = 1;

  // Load one or more documents identified by key.
  // Keys may included documents which have never before been stored,
  // but a given key will be sent in a transaction Load just one time.
  message Load {
    // Byte arena of the request.
    bytes arena = 2 [ (gogoproto.casttype) = "github.com/estuary/flow/go/protocols/flow.Arena" ];
    // Packed tuples of collection keys, enumerating the documents to load.
    repeated flow.Slice packed_keys = 3 [ (gogoproto.nullable) = false ];
  }
  // Load will only be sent during the Loading phase of the transaction rpc.
  Load load = 2;

  // Prepare to commit. No further Loads will be sent.
  message Prepare {
    // Flow checkpoint to commit with this transaction.
    bytes flow_checkpoint = 1;
  }
  Prepare prepare = 3;

  // Store documents of this transaction.
  message Store {
    // Byte arena of the request.
    bytes arena = 1 [ (gogoproto.casttype) = "github.com/estuary/flow/go/protocols/flow.Arena" ];
    // Packed tuples holding keys of each document.
    repeated flow.Slice packed_keys = 2 [ (gogoproto.nullable) = false ];
    // Packed tuples holding values for each document.
    repeated flow.Slice packed_values = 3 [ (gogoproto.nullable) = false ];
    // JSON documents.
    repeated flow.Slice docs_json = 4 [ (gogoproto.nullable) = false ];
    // Exists is true if this document as previously been loaded or stored.
    repeated bool exists = 5;
  }
  Store store = 4;

  // Commit the transaction.
  message Commit {}
  Commit commit = 5;
}

// TransactionResponse is the response type of a Transaction RPC.
// It will have exactly one top-level field set, which represents its message type.
message TransactionResponse {
  // Loaded responds to TransactionRequest.Loads of the client.
  // It returns documents of requested keys which have previously been stored.
  // Keys not found in the store MUST be omitted. Documents may be in any order,
  // both within and across Loaded response messages, but a document of a given
  // key MUST be sent at most one time in a Transaction.
  message Loaded {
    // Byte arena of the request.
    bytes arena = 1 [ (gogoproto.casttype) = "github.com/estuary/flow/go/protocols/flow.Arena" ];
    // Loaded JSON documents.
    repeated flow.Slice docs_json = 2 [ (gogoproto.nullable) = false ];
  }
  Loaded loaded = 1;

  // Prepared responds to a TransactionRequest.Prepare of the client.
  // No further Loaded responses will be sent.
  message Prepared {
    // Optional driver checkpoint of this transaction.
    // If provided, the most recent checkpoint will be persisted by the
    // Flow runtime and returned in a future Fence request.
    bytes driver_checkpoint = 1;
  }
  Prepared prepared = 2;

  // Acknowledge the transaction as committed.
  message Committed {}
  Committed committed = 3;
}