syntax = "proto3";

package materialize;
option go_package = "github.com/estuary/flow/go/protocols/materialize";

import "go/protocols/flow/flow.proto";
import "gogoproto/gogo.proto";

option (gogoproto.marshaler_all) = true;
option (gogoproto.protosizer_all) = true;
option (gogoproto.unmarshaler_all) = true;
option (gogoproto.goproto_getters_all) = false;


// Constraint constrains the use of a flow.Projection within a materialization.
message Constraint {
  // Type encodes a constraint type for this flow.Projection.
  enum Type {
    // This specific projection must be present.
    FIELD_REQUIRED = 0;
    // At least one projection with this location pointer must be present.
    LOCATION_REQUIRED = 1;
    // A projection with this location is recommended, and should be included by default.
    LOCATION_RECOMMENDED = 2;
    // This projection may be included, but should be omitted by default.
    FIELD_OPTIONAL = 3;
    // This projection must not be present in the materialization.
    FIELD_FORBIDDEN = 4;
    // This specific projection is required but is also unacceptable (e.x.,
    // because it uses an incompatible type with a previous applied version).
    UNSATISFIABLE = 5;
  }
  Type type = 2;
  // Optional human readable reason for the given constraint.
  // Implementations are strongly encouraged to supply a descriptive message.
  string reason = 3;
}

// Driver is the service implemented by a materialization target system.
service Driver {
  // Session begins a scoped interaction with the driver from a single process context.
  // It maps an endpoint URL, target, and caller ID to a returned opaque session handle,
  // which is to be used with further Driver interactions. Note that at any given time,
  // there may be *many* concurrent Sessions.
  rpc StartSession(SessionRequest) returns (SessionResponse);
  // Validate that a CollectionSpec is compatible with a materialization target,
  // and return constraints over the projections of the collection.
  rpc Validate(ValidateRequest) returns (ValidateResponse);
  // Apply a CollectionSpec and selected Projections to a materialization target.
  rpc Apply(ApplyRequest) returns (ApplyResponse);
  // Fence inserts a transactional "write fence" boundary by fencing the caller
  // ID encapsulated within a session, to the session's unique handle. Typically this
  // is done by tying the caller ID to a unique session nonce in a transaction,
  // or by increasing a epoch value of the caller ID.
  //
  // For example a RDBMS might use a "writers" table holding a caller ID key,
  // a current session nonce, and a last checkpoint. The Fence RPC would update the
  // nonce to the current session's unique value -- effectively "poisoning" transactions
  // of prior sessions -- and return the checkpoint. Store RPCs must in turn verify
  // their session nonce is still effective before committing a transaction.
  //
  // On return, it's guaranteed that no session previously fenced to the caller ID
  // (now a "zombie" session) can commit transactions as part of Store RPCs which
  // update documents or checkpoints. Fence returns the checkpoint last committed
  // by this caller ID in a Store RPC.
  //
  // Fence is an *optional* API which is required for materialization targets that
  // support end-to-end "exactly once" semantics. Stores which support only "at least once"
  // semantics can implement Fence as a no-op, returning a zero-value FenceResponse.
  rpc Fence(FenceRequest) returns (FenceResponse);
  // Transaction is a bi-directional streaming rpc that corresponds to each transaction within the
  // flow consumer. The Transaction rpc follows a strict lifecycle:
  //
  // 1. Init: The client (flow-consumer) sends a Start message, and then the client immediately
  //    transitions to the Loading state.
  // 2. Loading: 
  //    - The client sends 0 or more LoadRequest messages, terminated by a LoadEOF message.
  //    - The driver may send 0 or more LoadResponse messages, followed by a LoadEOF message. These
  //    responses may be sent asynchronously, and at whatever cadence is most performant for the
  //    driver. Drivers may wait until they receive the LoadEOF from the client before they send any
  //    responses, or they may send responses earlier. Any requested document that is missing from
  //    the set of LoadResponses is presumed to simply not exist.
  // 3. Storing:
  //    - The client sends 0 or more StoreRequest messages, and then closes the send side of its
  //    stream.
  //    - The driver processes each StoreRequest and returns exactly one StoreResponse as the final
  //    message sent to the client. The transaction is now complete.
  // Note that for drivers that do not support loads, they may immediately send a LoadEOF message
  // after the transaction is started. If the `always_empty_hint` is `true`, then the client
  // should (but is not required to) send a LoadEOF message immediately after sending
  // its Start message. Thus, the lifecycle of a Transaction RPC is always the same, regardless of
  // whether a client supports loads or not.
  rpc Transaction(stream TransactionRequest) returns (stream TransactionResponse);
}

// SessionRequest is the request type of the StartSession RPC.
message SessionRequest {
  // Endpoint URL of the materialization system.
  string endpoint_url = 1;
  // Target name within the materialization system, where applicable.
  // This could be a SQL schema & table, or a pub/sub topic, etc.
  string target = 2;
  // Stable ID of the flow consumer shard that this session belongs to. A null or empty value
  // indicates that the caller is not a flow consumer shard, but some other process (e.g. flowctl).
  string shard_id = 3;
}

// SessionResponse is the response type of the StartSession RPC.
message SessionResponse {
  // Opaque session handle.
  bytes handle = 1;
}

// ValidateRequest is the request type of the Validate RPC.
message ValidateRequest {
  // Opaque session handle.
  bytes handle = 1;
  // Collection to be materialized.
  flow.CollectionSpec collection = 2;
  // Projection configuration, keyed by the projection field name,
  // with JSON-encoded and driver-defined configuration objects.
  map<string, string> field_config = 3;
}

// ValidateResponse is the response type of the Validate RPC.
message ValidateResponse {
  // Constraints over collection projections imposed by the Driver,
  // keyed by the projection field name. Projections of the CollectionSpec
  // which are missing from constraints are implicitly forbidden.
  map<string, Constraint> constraints = 1;
}

// ApplyRequest is the request type of the Apply RPC.
message ApplyRequest {
  // Opaque session handle.
  bytes handle = 1;
  // Collection to be materialized.
  flow.CollectionSpec collection = 2;
  // Selected fields for materialization
  flow.FieldSelection fields = 3;
  // Is this Apply a dry-run? If so, no action is undertaken and Apply will
  // report only what would have happened.
  bool dry_run = 4;
}

// ApplyResponse is the response type of the Apply RPC.
message ApplyResponse {
  // Human-readable description of the action that the Driver took (or, if dry_run, would have taken).
  // If empty, this Apply is to be considered a "no-op".
  string action_description = 1;
}

// FenceRequest is the request type of a Fence RPC.
message FenceRequest {
  // Opaque session handle.
  bytes handle = 1;
  // Driver checkpoint which was last committed from a Store RPC.
  // Or empty, if the Driver has never returned a checkpoint.
  bytes driver_checkpoint = 2;
}

// FenceResponse is the response type of a Fence RPC.
message FenceResponse {
  // Flow checkpoint which was previously committed with this caller ID.
  // Or nil, if unknown or transactional semantics are not supported.
  bytes flow_checkpoint = 1;
}


// LoadEOF indicates the end of a stream of LoadRequest or LoadResponse messages.
message LoadEOF {
  // Always empty hint which, when set true, hints to Flow that it may skip future
  // LoadRequests for this handle, as they will never return any documents.
  bool always_empty_hint = 1;
}

// TransactionRequest is sent from the client to the driver as part of the Transaction streaming
// rpc. Each TransactionRequest message will have exactly one non-null top-level field, which
// represents its message type. The client must always send exactly one Start message as the very first
// message of a Transaction. This may be followed by 0 or more LoadRequests, followed by exactly one
// LoadEOF message. Then it will send 0 or more StoreRequests before closing the send stream.
message TransactionRequest {
  // Start represents the initial payload of transaction metadata.
  message Start {
    // Opaque session handle.
    bytes handle = 1;
    // Fields represents the projection fields to be stored. This repeats the selection and ordering
    // of the last Apply RPC, but is provided here also as a convenience.
    flow.FieldSelection fields = 2;
    // Checkpoint to write with this Store transaction, to be associated with
    // the session's caller ID and to be returned by a future Fence RPC.
    // This may be ignored if the Driver doesn't support exactly-once semantics.
    bytes flow_checkpoint = 3;
  }
  // Start is sent as the first message in a Transaction, and never sent again during the same
  // transaction.
  Start start = 1;

  // LoadRequest represents a request to Load one or more documents.
  message LoadRequest {
    // Byte arena of the request.
    bytes arena = 2 [ (gogoproto.casttype) = "github.com/estuary/flow/go/protocols/flow.Arena" ];
    // Packed tuples of collection keys, enumerating the documents to load.
    repeated flow.Slice packed_keys = 3 [ (gogoproto.nullable) = false ];
  }
  // Load will only be sent during the Loading phase of the transaction rpc.
  LoadRequest load = 2;

  // LoadEOF indicates that no more LoadRequests will be sent during this transaction. Upon
  // receiving a LoadEOF, a driver should return any pending LoadResponse messages before sending
  // its own LoadEOF.
  LoadEOF loadEOF = 3;

  // StoreRequest represents a batch of 1 or more documents to store, along with their associated
  // keys and extracted values. Many StoreRequest messages may be sent during the life of a
  // Transaction.
  message StoreRequest {
    // Byte arena of the request.
    bytes arena = 1 [ (gogoproto.casttype) = "github.com/estuary/flow/go/protocols/flow.Arena" ];
    repeated flow.Slice packed_keys = 2 [ (gogoproto.nullable) = false ];
    // Packed tuples holding projection values for each document.
    repeated flow.Slice packed_values = 3 [ (gogoproto.nullable) = false ];
    // JSON documents.
    repeated flow.Slice docs_json = 4 [ (gogoproto.nullable) = false ];
    // Exists is true if this document previously been loaded or stored.
    repeated bool exists = 5; // [ (gogoproto.nullable) = false, (gogoproto.embed) = true ];
  }
  // Store will only be sent during the Storing phase fo the transaction rpc.
  StoreRequest store = 4;
}

// TransactionResponse is streamed back from a Transaction streaming rpc.
// Similar to TransactionRequest, each TransactionResponse message must include exactly one non-null top
// level field. For each Transaction RPC, the driver should send 0 or more LoadResponse messages,
// followed by exactly one LoadEOF message, followed by exactly one StoreResponse.
message TransactionResponse {
  // LoadResponse is sent to return documents requested by a LoadRequest. The driver may send
  // LoadResponse messages at any time before it sends a LoadEOF message. This is designed to allow
  // for maximum flexibility to allow all types of drivers to load documents in whatever way is most
  // efficient for each system. For example, a driver could send a LoadResponse after receiving each
  // LoadRequest, or it could wait until it receives a LoadEOF from the client and then send all the
  // documents in a single LoadResponse, or batches of LoadResponses.
  message LoadResponse {
    // Byte arena of the request.
    bytes arena = 1 [ (gogoproto.casttype) = "github.com/estuary/flow/go/protocols/flow.Arena" ];
    // Loaded JSON documents.
    repeated flow.Slice docs_json = 2 [ (gogoproto.nullable) = false ];
  }
  // LoadResponse should only be sent during the Loading phase of the transaction rpc.
  LoadResponse loadResponse = 1;

  // LoadEOF is sent after all LoadResponse have been sent. After this is sent, no more LoadResponse
  // messages may be sent by the driver, and any documents that have not been returned in a
  // LoadResponse will be presumed to not exist in storage.
  LoadEOF loadEOF = 2;

  // StoreResponse is sent exactly once at the end of a successful Transaction. Successful Transactions
  // must send a single StoreResponse as their final message, though it is perfectly acceptable to
  // leave the driver_checkpoint undefined.
  message StoreResponse {
    // Arbitrary driver defined checkpoint. Flow persists the provided checkpoint
    // within the same internal transaction which triggered this Store RPC,
    // and will present the latest checkpoint to a future Fence RPC.
    // This may be ignored if the Driver has no checkpoints.
    bytes driver_checkpoint = 1;
  }
  // StoreResponse is sent by the driver as the final message in a Transaction to indicate that it
  // has committed.
  StoreResponse storeResponse = 3;
}

