// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go/protocols/runtime/runtime.proto

package runtime

import (
	context "context"
	encoding_binary "encoding/binary"
	encoding_json "encoding/json"
	fmt "fmt"
	flow "github.com/estuary/flow/go/protocols/flow"
	github_com_estuary_flow_go_protocols_flow "github.com/estuary/flow/go/protocols/flow"
	ops "github.com/estuary/flow/go/protocols/ops"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	go_gazette_dev_core_broker_protocol "go.gazette.dev/core/broker/protocol"
	protocol "go.gazette.dev/core/broker/protocol"
	go_gazette_dev_core_consumer_protocol "go.gazette.dev/core/consumer/protocol"
	protocol1 "go.gazette.dev/core/consumer/protocol"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CaptureResponseExt_PollResult int32

const (
	CaptureResponseExt_INVALID CaptureResponseExt_PollResult = 0
	// The poll succeeded and a transaction will be drained.
	CaptureResponseExt_READY CaptureResponseExt_PollResult = 1
	// The connector is running but has produced no data.
	CaptureResponseExt_NOT_READY CaptureResponseExt_PollResult = 2
	// The connector has exited, but cannot be restarted yet.
	CaptureResponseExt_COOL_OFF CaptureResponseExt_PollResult = 3
	// The connector has exited and new session should be started.
	CaptureResponseExt_RESTART CaptureResponseExt_PollResult = 4
)

var CaptureResponseExt_PollResult_name = map[int32]string{
	0: "INVALID",
	1: "READY",
	2: "NOT_READY",
	3: "COOL_OFF",
	4: "RESTART",
}

var CaptureResponseExt_PollResult_value = map[string]int32{
	"INVALID":   0,
	"READY":     1,
	"NOT_READY": 2,
	"COOL_OFF":  3,
	"RESTART":   4,
}

func (x CaptureResponseExt_PollResult) String() string {
	return proto.EnumName(CaptureResponseExt_PollResult_name, int32(x))
}

func (CaptureResponseExt_PollResult) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{6, 0}
}

type TaskServiceConfig struct {
	LogFileFd            int32    `protobuf:"varint,1,opt,name=log_file_fd,json=logFileFd,proto3" json:"log_file_fd,omitempty"`
	TaskName             string   `protobuf:"bytes,2,opt,name=task_name,json=taskName,proto3" json:"task_name,omitempty"`
	UdsPath              string   `protobuf:"bytes,3,opt,name=uds_path,json=udsPath,proto3" json:"uds_path,omitempty"`
	ContainerNetwork     string   `protobuf:"bytes,4,opt,name=container_network,json=containerNetwork,proto3" json:"container_network,omitempty"`
	AllowLocal           bool     `protobuf:"varint,5,opt,name=allow_local,json=allowLocal,proto3" json:"allow_local,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TaskServiceConfig) Reset()         { *m = TaskServiceConfig{} }
func (m *TaskServiceConfig) String() string { return proto.CompactTextString(m) }
func (*TaskServiceConfig) ProtoMessage()    {}
func (*TaskServiceConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{0}
}
func (m *TaskServiceConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskServiceConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskServiceConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskServiceConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskServiceConfig.Merge(m, src)
}
func (m *TaskServiceConfig) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TaskServiceConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskServiceConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TaskServiceConfig proto.InternalMessageInfo

// ShuffleRequest is the request message of a Shuffle RPC.
// It's a description of a document shuffle,
// where a journal is read and each document is mapped into:
//   - An extracted, packed, and hashed composite key (a "shuffle key").
//   - A rotated Clock value (an "r-clock").
//
// The packed key and r-clock can then be compared to individual reader
// RangeSpec's.
//
// ShuffleRequest instances are keyed and compared on (`journal`, `replay`, `build_id`),
// in order to identify and group related reads. Note that `journal` has a metadata path
// segment which uniquely identifies its particular derivation transform
// or materialization binding. Reads with equivalent shuffles are placed into
// common "read rings" which consolidate their underlying journal reads.
type ShuffleRequest struct {
	// Journal to be shuffled.
	Journal go_gazette_dev_core_broker_protocol.Journal `protobuf:"bytes,1,opt,name=journal,proto3,casttype=go.gazette.dev/core/broker/protocol.Journal" json:"journal,omitempty"`
	// Is this a reply of the journal's content? We separate ongoing vs replayed
	// reads of a journal's content into distinct rings.
	Replay bool `protobuf:"varint,2,opt,name=replay,proto3" json:"replay,omitempty"`
	// Build ID of the task which requested this JournalShuffle.
	BuildId string `protobuf:"bytes,3,opt,name=build_id,json=buildId,proto3" json:"build_id,omitempty"`
	// Offset to begin reading the journal from.
	Offset go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,4,opt,name=offset,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"offset,omitempty"`
	// Offset to stop reading the journal at, or zero if unbounded.
	EndOffset go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,5,opt,name=end_offset,json=endOffset,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"end_offset,omitempty"`
	// Ranges of responsibility which are unique to this reader,
	// against which document shuffle outcomes are matched to determine
	// read eligibility.
	Range flow.RangeSpec `protobuf:"bytes,6,opt,name=range,proto3" json:"range"`
	// Coordinator is the Shard ID which is responsible for reads of this journal.
	Coordinator go_gazette_dev_core_consumer_protocol.ShardID `protobuf:"bytes,7,opt,name=coordinator,proto3,casttype=go.gazette.dev/core/consumer/protocol.ShardID" json:"coordinator,omitempty"`
	// Resolution header of the |shuffle.coordinator| shard.
	Resolution *protocol.Header `protobuf:"bytes,8,opt,name=resolution,proto3" json:"resolution,omitempty"`
	// Index of the derivation transform or materialization
	// binding on whose behalf we're reading.
	ShuffleIndex uint32 `protobuf:"varint,9,opt,name=shuffle_index,json=shuffleIndex,proto3" json:"shuffle_index,omitempty"`
	// Derivation which is requesting the shuffle.
	Derivation *flow.CollectionSpec `protobuf:"bytes,10,opt,name=derivation,proto3" json:"derivation,omitempty"`
	// Materialization which is requesting the shuffle.
	Materialization      *flow.MaterializationSpec `protobuf:"bytes,11,opt,name=materialization,proto3" json:"materialization,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ShuffleRequest) Reset()         { *m = ShuffleRequest{} }
func (m *ShuffleRequest) String() string { return proto.CompactTextString(m) }
func (*ShuffleRequest) ProtoMessage()    {}
func (*ShuffleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{1}
}
func (m *ShuffleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShuffleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShuffleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShuffleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShuffleRequest.Merge(m, src)
}
func (m *ShuffleRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShuffleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ShuffleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ShuffleRequest proto.InternalMessageInfo

// ShuffleResponse is the streamed response message of a Shuffle RPC.
type ShuffleResponse struct {
	// Status of the Shuffle RPC.
	Status protocol1.Status `protobuf:"varint,1,opt,name=status,proto3,enum=consumer.Status" json:"status,omitempty"`
	// Header of the response.
	Header *protocol.Header `protobuf:"bytes,2,opt,name=header,proto3" json:"header,omitempty"`
	// Terminal error encountered while serving this ShuffleRequest. A terminal
	// error is only sent if a future ShuffleRequest of this same configuration
	// and offset will fail in the exact same way, and operator intervention is
	// required to properly recover. Such errors are returned so that the caller
	// can also abort with a useful, contextual error message.
	//
	// Examples of terminal errors include the requested journal not existing,
	// or data corruption. Errors *not* returned as |terminal_error| include
	// network errors, process failures, and other conditions which can be
	// retried.
	TerminalError string `protobuf:"bytes,3,opt,name=terminal_error,json=terminalError,proto3" json:"terminal_error,omitempty"`
	// Offset which was read through to produce this ShuffleResponse.
	ReadThrough go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,4,opt,name=read_through,json=readThrough,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"read_through,omitempty"`
	// WriteHead of the journal as reported by the broker, as of the creation of
	// this ShuffleResponse.
	WriteHead go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,5,opt,name=write_head,json=writeHead,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"write_head,omitempty"`
	// Memory arena of this message.
	Arena github_com_estuary_flow_go_protocols_flow.Arena `protobuf:"bytes,6,opt,name=arena,proto3,casttype=github.com/estuary/flow/go/protocols/flow.Arena" json:"arena,omitempty"`
	// Shuffled documents, each encoded in the 'application/json'
	// media-type.
	Docs []flow.Slice `protobuf:"bytes,7,rep,name=docs,proto3" json:"docs"`
	// The journal offsets of each document within the requested journal.
	// For a document at index i, its offsets are [ offsets[2*i], offsets[2*i+1]
	// ).
	Offsets []go_gazette_dev_core_broker_protocol.Offset `protobuf:"varint,8,rep,packed,name=offsets,proto3,casttype=go.gazette.dev/core/broker/protocol.Offset" json:"offsets,omitempty"`
	// UUIDParts of each document.
	UuidParts []flow.UUIDParts `protobuf:"bytes,9,rep,name=uuid_parts,json=uuidParts,proto3" json:"uuid_parts"`
	// Packed, embedded encoding of the shuffle key into a byte string.
	// If the Shuffle specified a Hash to use, it's applied as well.
	PackedKey            []flow.Slice `protobuf:"bytes,10,rep,name=packed_key,json=packedKey,proto3" json:"packed_key"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ShuffleResponse) Reset()         { *m = ShuffleResponse{} }
func (m *ShuffleResponse) String() string { return proto.CompactTextString(m) }
func (*ShuffleResponse) ProtoMessage()    {}
func (*ShuffleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{2}
}
func (m *ShuffleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShuffleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShuffleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShuffleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShuffleResponse.Merge(m, src)
}
func (m *ShuffleResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShuffleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ShuffleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ShuffleResponse proto.InternalMessageInfo

type RocksDBDescriptor struct {
	// Instrumented RocksDB environment which should be opened.
	RocksdbEnvMemptr uint64 `protobuf:"fixed64,1,opt,name=rocksdb_env_memptr,json=rocksdbEnvMemptr,proto3" json:"rocksdb_env_memptr,omitempty"`
	// Path to the RocksDB directory to be opened.
	RocksdbPath          string   `protobuf:"bytes,2,opt,name=rocksdb_path,json=rocksdbPath,proto3" json:"rocksdb_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RocksDBDescriptor) Reset()         { *m = RocksDBDescriptor{} }
func (m *RocksDBDescriptor) String() string { return proto.CompactTextString(m) }
func (*RocksDBDescriptor) ProtoMessage()    {}
func (*RocksDBDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{3}
}
func (m *RocksDBDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RocksDBDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RocksDBDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RocksDBDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RocksDBDescriptor.Merge(m, src)
}
func (m *RocksDBDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RocksDBDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_RocksDBDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_RocksDBDescriptor proto.InternalMessageInfo

// Container is a description of a running connector container.
type Container struct {
	// IP Address of the running container.
	// If this IP is accessible (it may not be, in contexts like Docker Desktop for Mac),
	// then it is *only* accessible from the hosting server.
	IpAddr string `protobuf:"bytes,1,opt,name=ip_addr,json=ipAddr,proto3" json:"ip_addr,omitempty"`
	// Network ports which are available for this container.
	NetworkPorts []*flow.NetworkPort `protobuf:"bytes,2,rep,name=network_ports,json=networkPorts,proto3" json:"network_ports,omitempty"`
	// Mapping of ports from `network_ports` to a corresponding "host-ip:port" address,
	// as either IPv4 or IPv6, through which the port can be accessed. If empty,
	// then the container `ip_addr` should be used directly.
	MappedHostPorts map[uint32]string `protobuf:"bytes,3,rep,name=mapped_host_ports,json=mappedHostPorts,proto3" json:"mapped_host_ports,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// The usage rate of a container is the number of connector credits per second that
	// are consumed by the connector.
	UsageRate            float32  `protobuf:"fixed32,4,opt,name=usage_rate,json=usageRate,proto3" json:"usage_rate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Container) Reset()         { *m = Container{} }
func (m *Container) String() string { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()    {}
func (*Container) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{4}
}
func (m *Container) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Container) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Container.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Container) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Container.Merge(m, src)
}
func (m *Container) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Container) XXX_DiscardUnknown() {
	xxx_messageInfo_Container.DiscardUnknown(m)
}

var xxx_messageInfo_Container proto.InternalMessageInfo

type CaptureRequestExt struct {
	// Log.Level of this Request.
	LogLevel ops.Log_Level `protobuf:"varint,1,opt,name=log_level,json=logLevel,proto3,enum=ops.Log_Level" json:"log_level,omitempty"`
	// RocksDB descriptor which should be opened. Sent (only) with the first Request.
	RocksdbDescriptor    *RocksDBDescriptor             `protobuf:"bytes,2,opt,name=rocksdb_descriptor,json=rocksdbDescriptor,proto3" json:"rocksdb_descriptor,omitempty"`
	StartCommit          *CaptureRequestExt_StartCommit `protobuf:"bytes,3,opt,name=start_commit,json=startCommit,proto3" json:"start_commit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *CaptureRequestExt) Reset()         { *m = CaptureRequestExt{} }
func (m *CaptureRequestExt) String() string { return proto.CompactTextString(m) }
func (*CaptureRequestExt) ProtoMessage()    {}
func (*CaptureRequestExt) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{5}
}
func (m *CaptureRequestExt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CaptureRequestExt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CaptureRequestExt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CaptureRequestExt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CaptureRequestExt.Merge(m, src)
}
func (m *CaptureRequestExt) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CaptureRequestExt) XXX_DiscardUnknown() {
	xxx_messageInfo_CaptureRequestExt.DiscardUnknown(m)
}

var xxx_messageInfo_CaptureRequestExt proto.InternalMessageInfo

type CaptureRequestExt_StartCommit struct {
	// Flow runtime checkpoint associated with this transaction.
	RuntimeCheckpoint    *protocol1.Checkpoint `protobuf:"bytes,1,opt,name=runtime_checkpoint,json=runtimeCheckpoint,proto3" json:"runtime_checkpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *CaptureRequestExt_StartCommit) Reset()         { *m = CaptureRequestExt_StartCommit{} }
func (m *CaptureRequestExt_StartCommit) String() string { return proto.CompactTextString(m) }
func (*CaptureRequestExt_StartCommit) ProtoMessage()    {}
func (*CaptureRequestExt_StartCommit) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{5, 0}
}
func (m *CaptureRequestExt_StartCommit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CaptureRequestExt_StartCommit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CaptureRequestExt_StartCommit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CaptureRequestExt_StartCommit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CaptureRequestExt_StartCommit.Merge(m, src)
}
func (m *CaptureRequestExt_StartCommit) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CaptureRequestExt_StartCommit) XXX_DiscardUnknown() {
	xxx_messageInfo_CaptureRequestExt_StartCommit.DiscardUnknown(m)
}

var xxx_messageInfo_CaptureRequestExt_StartCommit proto.InternalMessageInfo

type CaptureResponseExt struct {
	Container            *Container                     `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty"`
	Opened               *CaptureResponseExt_Opened     `protobuf:"bytes,2,opt,name=opened,proto3" json:"opened,omitempty"`
	Captured             *CaptureResponseExt_Captured   `protobuf:"bytes,3,opt,name=captured,proto3" json:"captured,omitempty"`
	Checkpoint           *CaptureResponseExt_Checkpoint `protobuf:"bytes,4,opt,name=checkpoint,proto3" json:"checkpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *CaptureResponseExt) Reset()         { *m = CaptureResponseExt{} }
func (m *CaptureResponseExt) String() string { return proto.CompactTextString(m) }
func (*CaptureResponseExt) ProtoMessage()    {}
func (*CaptureResponseExt) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{6}
}
func (m *CaptureResponseExt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CaptureResponseExt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CaptureResponseExt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CaptureResponseExt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CaptureResponseExt.Merge(m, src)
}
func (m *CaptureResponseExt) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CaptureResponseExt) XXX_DiscardUnknown() {
	xxx_messageInfo_CaptureResponseExt.DiscardUnknown(m)
}

var xxx_messageInfo_CaptureResponseExt proto.InternalMessageInfo

type CaptureResponseExt_Opened struct {
	RuntimeCheckpoint    *protocol1.Checkpoint `protobuf:"bytes,1,opt,name=runtime_checkpoint,json=runtimeCheckpoint,proto3" json:"runtime_checkpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *CaptureResponseExt_Opened) Reset()         { *m = CaptureResponseExt_Opened{} }
func (m *CaptureResponseExt_Opened) String() string { return proto.CompactTextString(m) }
func (*CaptureResponseExt_Opened) ProtoMessage()    {}
func (*CaptureResponseExt_Opened) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{6, 0}
}
func (m *CaptureResponseExt_Opened) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CaptureResponseExt_Opened) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CaptureResponseExt_Opened.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CaptureResponseExt_Opened) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CaptureResponseExt_Opened.Merge(m, src)
}
func (m *CaptureResponseExt_Opened) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CaptureResponseExt_Opened) XXX_DiscardUnknown() {
	xxx_messageInfo_CaptureResponseExt_Opened.DiscardUnknown(m)
}

var xxx_messageInfo_CaptureResponseExt_Opened proto.InternalMessageInfo

type CaptureResponseExt_Captured struct {
	// Packed key extracted from the captured document.
	KeyPacked []byte `protobuf:"bytes,1,opt,name=key_packed,json=keyPacked,proto3" json:"key_packed,omitempty"`
	// Packed partition values extracted from the captured document.
	PartitionsPacked     []byte   `protobuf:"bytes,2,opt,name=partitions_packed,json=partitionsPacked,proto3" json:"partitions_packed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CaptureResponseExt_Captured) Reset()         { *m = CaptureResponseExt_Captured{} }
func (m *CaptureResponseExt_Captured) String() string { return proto.CompactTextString(m) }
func (*CaptureResponseExt_Captured) ProtoMessage()    {}
func (*CaptureResponseExt_Captured) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{6, 1}
}
func (m *CaptureResponseExt_Captured) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CaptureResponseExt_Captured) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CaptureResponseExt_Captured.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CaptureResponseExt_Captured) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CaptureResponseExt_Captured.Merge(m, src)
}
func (m *CaptureResponseExt_Captured) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CaptureResponseExt_Captured) XXX_DiscardUnknown() {
	xxx_messageInfo_CaptureResponseExt_Captured.DiscardUnknown(m)
}

var xxx_messageInfo_CaptureResponseExt_Captured proto.InternalMessageInfo

type CaptureResponseExt_Checkpoint struct {
	Stats                *ops.Stats                    `protobuf:"bytes,1,opt,name=stats,proto3" json:"stats,omitempty"`
	PollResult           CaptureResponseExt_PollResult `protobuf:"varint,2,opt,name=poll_result,json=pollResult,proto3,enum=runtime.CaptureResponseExt_PollResult" json:"poll_result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *CaptureResponseExt_Checkpoint) Reset()         { *m = CaptureResponseExt_Checkpoint{} }
func (m *CaptureResponseExt_Checkpoint) String() string { return proto.CompactTextString(m) }
func (*CaptureResponseExt_Checkpoint) ProtoMessage()    {}
func (*CaptureResponseExt_Checkpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{6, 2}
}
func (m *CaptureResponseExt_Checkpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CaptureResponseExt_Checkpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CaptureResponseExt_Checkpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CaptureResponseExt_Checkpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CaptureResponseExt_Checkpoint.Merge(m, src)
}
func (m *CaptureResponseExt_Checkpoint) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CaptureResponseExt_Checkpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_CaptureResponseExt_Checkpoint.DiscardUnknown(m)
}

var xxx_messageInfo_CaptureResponseExt_Checkpoint proto.InternalMessageInfo

type DeriveRequestExt struct {
	// Log.Level of this Request.
	LogLevel ops.Log_Level `protobuf:"varint,1,opt,name=log_level,json=logLevel,proto3,enum=ops.Log_Level" json:"log_level,omitempty"`
	// RocksDB descriptor which should be opened. Sent (only) with the first Request.
	// Ommitted if this is a SQLite derivation.
	RocksdbDescriptor    *RocksDBDescriptor     `protobuf:"bytes,2,opt,name=rocksdb_descriptor,json=rocksdbDescriptor,proto3" json:"rocksdb_descriptor,omitempty"`
	Open                 *DeriveRequestExt_Open `protobuf:"bytes,3,opt,name=open,proto3" json:"open,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *DeriveRequestExt) Reset()         { *m = DeriveRequestExt{} }
func (m *DeriveRequestExt) String() string { return proto.CompactTextString(m) }
func (*DeriveRequestExt) ProtoMessage()    {}
func (*DeriveRequestExt) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{7}
}
func (m *DeriveRequestExt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveRequestExt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveRequestExt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveRequestExt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveRequestExt.Merge(m, src)
}
func (m *DeriveRequestExt) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveRequestExt) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveRequestExt.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveRequestExt proto.InternalMessageInfo

type DeriveRequestExt_Open struct {
	// URL with a registered SQLite VFS which should be opened.
	SqliteVfsUri         string   `protobuf:"bytes,1,opt,name=sqlite_vfs_uri,json=sqliteVfsUri,proto3" json:"sqlite_vfs_uri,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveRequestExt_Open) Reset()         { *m = DeriveRequestExt_Open{} }
func (m *DeriveRequestExt_Open) String() string { return proto.CompactTextString(m) }
func (*DeriveRequestExt_Open) ProtoMessage()    {}
func (*DeriveRequestExt_Open) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{7, 0}
}
func (m *DeriveRequestExt_Open) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveRequestExt_Open) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveRequestExt_Open.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveRequestExt_Open) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveRequestExt_Open.Merge(m, src)
}
func (m *DeriveRequestExt_Open) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveRequestExt_Open) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveRequestExt_Open.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveRequestExt_Open proto.InternalMessageInfo

type DeriveResponseExt struct {
	Container            *Container                   `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty"`
	Opened               *DeriveResponseExt_Opened    `protobuf:"bytes,2,opt,name=opened,proto3" json:"opened,omitempty"`
	Published            *DeriveResponseExt_Published `protobuf:"bytes,3,opt,name=published,proto3" json:"published,omitempty"`
	Flushed              *DeriveResponseExt_Flushed   `protobuf:"bytes,4,opt,name=flushed,proto3" json:"flushed,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *DeriveResponseExt) Reset()         { *m = DeriveResponseExt{} }
func (m *DeriveResponseExt) String() string { return proto.CompactTextString(m) }
func (*DeriveResponseExt) ProtoMessage()    {}
func (*DeriveResponseExt) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{8}
}
func (m *DeriveResponseExt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveResponseExt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveResponseExt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveResponseExt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveResponseExt.Merge(m, src)
}
func (m *DeriveResponseExt) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveResponseExt) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveResponseExt.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveResponseExt proto.InternalMessageInfo

type DeriveResponseExt_Opened struct {
	RuntimeCheckpoint    *protocol1.Checkpoint `protobuf:"bytes,1,opt,name=runtime_checkpoint,json=runtimeCheckpoint,proto3" json:"runtime_checkpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *DeriveResponseExt_Opened) Reset()         { *m = DeriveResponseExt_Opened{} }
func (m *DeriveResponseExt_Opened) String() string { return proto.CompactTextString(m) }
func (*DeriveResponseExt_Opened) ProtoMessage()    {}
func (*DeriveResponseExt_Opened) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{8, 0}
}
func (m *DeriveResponseExt_Opened) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveResponseExt_Opened) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveResponseExt_Opened.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveResponseExt_Opened) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveResponseExt_Opened.Merge(m, src)
}
func (m *DeriveResponseExt_Opened) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveResponseExt_Opened) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveResponseExt_Opened.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveResponseExt_Opened proto.InternalMessageInfo

type DeriveResponseExt_Published struct {
	// Maximum UUID Clock of sourced document clocks which lead to this published document.
	MaxClock uint64 `protobuf:"fixed64,1,opt,name=max_clock,json=maxClock,proto3" json:"max_clock,omitempty"`
	// Packed key extracted from the published document.
	KeyPacked []byte `protobuf:"bytes,2,opt,name=key_packed,json=keyPacked,proto3" json:"key_packed,omitempty"`
	// Packed partition values extracted from the published document.
	PartitionsPacked     []byte   `protobuf:"bytes,3,opt,name=partitions_packed,json=partitionsPacked,proto3" json:"partitions_packed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveResponseExt_Published) Reset()         { *m = DeriveResponseExt_Published{} }
func (m *DeriveResponseExt_Published) String() string { return proto.CompactTextString(m) }
func (*DeriveResponseExt_Published) ProtoMessage()    {}
func (*DeriveResponseExt_Published) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{8, 1}
}
func (m *DeriveResponseExt_Published) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveResponseExt_Published) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveResponseExt_Published.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveResponseExt_Published) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveResponseExt_Published.Merge(m, src)
}
func (m *DeriveResponseExt_Published) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveResponseExt_Published) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveResponseExt_Published.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveResponseExt_Published proto.InternalMessageInfo

type DeriveResponseExt_Flushed struct {
	Stats                *ops.Stats `protobuf:"bytes,1,opt,name=stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DeriveResponseExt_Flushed) Reset()         { *m = DeriveResponseExt_Flushed{} }
func (m *DeriveResponseExt_Flushed) String() string { return proto.CompactTextString(m) }
func (*DeriveResponseExt_Flushed) ProtoMessage()    {}
func (*DeriveResponseExt_Flushed) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{8, 2}
}
func (m *DeriveResponseExt_Flushed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveResponseExt_Flushed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveResponseExt_Flushed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveResponseExt_Flushed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveResponseExt_Flushed.Merge(m, src)
}
func (m *DeriveResponseExt_Flushed) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveResponseExt_Flushed) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveResponseExt_Flushed.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveResponseExt_Flushed proto.InternalMessageInfo

type MaterializeRequestExt struct {
	// Log.Level of this Request.
	LogLevel ops.Log_Level `protobuf:"varint,1,opt,name=log_level,json=logLevel,proto3,enum=ops.Log_Level" json:"log_level,omitempty"`
	// RocksDB descriptor which should be opened. Sent (only) with the first Request.
	RocksdbDescriptor    *RocksDBDescriptor `protobuf:"bytes,2,opt,name=rocksdb_descriptor,json=rocksdbDescriptor,proto3" json:"rocksdb_descriptor,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *MaterializeRequestExt) Reset()         { *m = MaterializeRequestExt{} }
func (m *MaterializeRequestExt) String() string { return proto.CompactTextString(m) }
func (*MaterializeRequestExt) ProtoMessage()    {}
func (*MaterializeRequestExt) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{9}
}
func (m *MaterializeRequestExt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaterializeRequestExt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaterializeRequestExt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaterializeRequestExt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaterializeRequestExt.Merge(m, src)
}
func (m *MaterializeRequestExt) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MaterializeRequestExt) XXX_DiscardUnknown() {
	xxx_messageInfo_MaterializeRequestExt.DiscardUnknown(m)
}

var xxx_messageInfo_MaterializeRequestExt proto.InternalMessageInfo

type MaterializeResponseExt struct {
	Container            *Container                      `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty"`
	Flushed              *MaterializeResponseExt_Flushed `protobuf:"bytes,2,opt,name=flushed,proto3" json:"flushed,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *MaterializeResponseExt) Reset()         { *m = MaterializeResponseExt{} }
func (m *MaterializeResponseExt) String() string { return proto.CompactTextString(m) }
func (*MaterializeResponseExt) ProtoMessage()    {}
func (*MaterializeResponseExt) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{10}
}
func (m *MaterializeResponseExt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaterializeResponseExt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaterializeResponseExt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaterializeResponseExt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaterializeResponseExt.Merge(m, src)
}
func (m *MaterializeResponseExt) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MaterializeResponseExt) XXX_DiscardUnknown() {
	xxx_messageInfo_MaterializeResponseExt.DiscardUnknown(m)
}

var xxx_messageInfo_MaterializeResponseExt proto.InternalMessageInfo

type MaterializeResponseExt_Flushed struct {
	Stats                *ops.Stats `protobuf:"bytes,1,opt,name=stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MaterializeResponseExt_Flushed) Reset()         { *m = MaterializeResponseExt_Flushed{} }
func (m *MaterializeResponseExt_Flushed) String() string { return proto.CompactTextString(m) }
func (*MaterializeResponseExt_Flushed) ProtoMessage()    {}
func (*MaterializeResponseExt_Flushed) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{10, 0}
}
func (m *MaterializeResponseExt_Flushed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaterializeResponseExt_Flushed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaterializeResponseExt_Flushed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaterializeResponseExt_Flushed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaterializeResponseExt_Flushed.Merge(m, src)
}
func (m *MaterializeResponseExt_Flushed) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MaterializeResponseExt_Flushed) XXX_DiscardUnknown() {
	xxx_messageInfo_MaterializeResponseExt_Flushed.DiscardUnknown(m)
}

var xxx_messageInfo_MaterializeResponseExt_Flushed proto.InternalMessageInfo

type CombineRequest struct {
	Open                 *CombineRequest_Open `protobuf:"bytes,1,opt,name=open,proto3" json:"open,omitempty"`
	Add                  *CombineRequest_Add  `protobuf:"bytes,2,opt,name=add,proto3" json:"add,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *CombineRequest) Reset()         { *m = CombineRequest{} }
func (m *CombineRequest) String() string { return proto.CompactTextString(m) }
func (*CombineRequest) ProtoMessage()    {}
func (*CombineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{11}
}
func (m *CombineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombineRequest.Merge(m, src)
}
func (m *CombineRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CombineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CombineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CombineRequest proto.InternalMessageInfo

type CombineRequest_Open struct {
	Bindings             []*CombineRequest_Open_Binding `protobuf:"bytes,1,rep,name=bindings,proto3" json:"bindings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *CombineRequest_Open) Reset()         { *m = CombineRequest_Open{} }
func (m *CombineRequest_Open) String() string { return proto.CompactTextString(m) }
func (*CombineRequest_Open) ProtoMessage()    {}
func (*CombineRequest_Open) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{11, 0}
}
func (m *CombineRequest_Open) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombineRequest_Open) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombineRequest_Open.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombineRequest_Open) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombineRequest_Open.Merge(m, src)
}
func (m *CombineRequest_Open) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CombineRequest_Open) XXX_DiscardUnknown() {
	xxx_messageInfo_CombineRequest_Open.DiscardUnknown(m)
}

var xxx_messageInfo_CombineRequest_Open proto.InternalMessageInfo

type CombineRequest_Open_Binding struct {
	// Perform full reduction (true), or only associative combines (false)?
	Full bool `protobuf:"varint,1,opt,name=full,proto3" json:"full,omitempty"`
	// Composite key to combine over, as JSON-Pointers.
	Key []string `protobuf:"bytes,2,rep,name=key,proto3" json:"key,omitempty"`
	// Projections of the collection, which must include all `key` and `values` pointers.
	Projections []flow.Projection `protobuf:"bytes,3,rep,name=projections,proto3" json:"projections"`
	// Collection JSON-Schema to reduce over.
	SchemaJson encoding_json.RawMessage `protobuf:"bytes,4,opt,name=schema_json,json=schemaJson,proto3,casttype=encoding/json.RawMessage" json:"schema_json,omitempty"`
	// Optional SerPolicy to use for extracted fields and the document.
	SerPolicy *flow.SerPolicy `protobuf:"bytes,5,opt,name=ser_policy,json=serPolicy,proto3" json:"ser_policy,omitempty"`
	// JSON pointer at which a UUID placeholder should be added on drain.
	// Leave empty to disable.
	UuidPtr string `protobuf:"bytes,6,opt,name=uuid_ptr,json=uuidPtr,proto3" json:"uuid_ptr,omitempty"`
	// Values to extract and return.
	Values               []string `protobuf:"bytes,7,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CombineRequest_Open_Binding) Reset()         { *m = CombineRequest_Open_Binding{} }
func (m *CombineRequest_Open_Binding) String() string { return proto.CompactTextString(m) }
func (*CombineRequest_Open_Binding) ProtoMessage()    {}
func (*CombineRequest_Open_Binding) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{11, 0, 0}
}
func (m *CombineRequest_Open_Binding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombineRequest_Open_Binding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombineRequest_Open_Binding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombineRequest_Open_Binding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombineRequest_Open_Binding.Merge(m, src)
}
func (m *CombineRequest_Open_Binding) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CombineRequest_Open_Binding) XXX_DiscardUnknown() {
	xxx_messageInfo_CombineRequest_Open_Binding.DiscardUnknown(m)
}

var xxx_messageInfo_CombineRequest_Open_Binding proto.InternalMessageInfo

type CombineRequest_Add struct {
	// Binding of the added document.
	Binding uint32 `protobuf:"varint,1,opt,name=binding,proto3" json:"binding,omitempty"`
	// Document to add to the combiner.
	DocJson encoding_json.RawMessage `protobuf:"bytes,2,opt,name=doc_json,json=docJson,proto3,casttype=encoding/json.RawMessage" json:"doc_json,omitempty"`
	// Add document to the front (true), or back (false) of the combiner?
	Front                bool     `protobuf:"varint,3,opt,name=front,proto3" json:"front,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CombineRequest_Add) Reset()         { *m = CombineRequest_Add{} }
func (m *CombineRequest_Add) String() string { return proto.CompactTextString(m) }
func (*CombineRequest_Add) ProtoMessage()    {}
func (*CombineRequest_Add) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{11, 1}
}
func (m *CombineRequest_Add) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombineRequest_Add) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombineRequest_Add.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombineRequest_Add) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombineRequest_Add.Merge(m, src)
}
func (m *CombineRequest_Add) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CombineRequest_Add) XXX_DiscardUnknown() {
	xxx_messageInfo_CombineRequest_Add.DiscardUnknown(m)
}

var xxx_messageInfo_CombineRequest_Add proto.InternalMessageInfo

type CombineResponse struct {
	// Binding of this document.
	Binding uint32 `protobuf:"varint,1,opt,name=binding,proto3" json:"binding,omitempty"`
	// Is this document marked as deleted?
	Deleted bool `protobuf:"varint,2,opt,name=deleted,proto3" json:"deleted,omitempty"`
	// Full JSON document.
	DocJson encoding_json.RawMessage `protobuf:"bytes,3,opt,name=doc_json,json=docJson,proto3,casttype=encoding/json.RawMessage" json:"doc_json,omitempty"`
	// Was this document at the front, or back of the combiner?
	Front bool `protobuf:"varint,4,opt,name=front,proto3" json:"front,omitempty"`
	// Packed key extracted from the captured document.
	KeyPacked []byte `protobuf:"bytes,5,opt,name=key_packed,json=keyPacked,proto3" json:"key_packed,omitempty"`
	// Packed values extracted from the captured document.
	ValuesPacked         []byte   `protobuf:"bytes,6,opt,name=values_packed,json=valuesPacked,proto3" json:"values_packed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CombineResponse) Reset()         { *m = CombineResponse{} }
func (m *CombineResponse) String() string { return proto.CompactTextString(m) }
func (*CombineResponse) ProtoMessage()    {}
func (*CombineResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{12}
}
func (m *CombineResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombineResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombineResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombineResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombineResponse.Merge(m, src)
}
func (m *CombineResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CombineResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CombineResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CombineResponse proto.InternalMessageInfo

type ConnectorProxyRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectorProxyRequest) Reset()         { *m = ConnectorProxyRequest{} }
func (m *ConnectorProxyRequest) String() string { return proto.CompactTextString(m) }
func (*ConnectorProxyRequest) ProtoMessage()    {}
func (*ConnectorProxyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{13}
}
func (m *ConnectorProxyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorProxyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorProxyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorProxyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorProxyRequest.Merge(m, src)
}
func (m *ConnectorProxyRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ConnectorProxyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorProxyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorProxyRequest proto.InternalMessageInfo

type ConnectorProxyResponse struct {
	// Address to dial for invoking connector RPCs.
	// Sent with the first response.
	Address go_gazette_dev_core_broker_protocol.Endpoint `protobuf:"bytes,1,opt,name=address,proto3,casttype=go.gazette.dev/core/broker/protocol.Endpoint" json:"address,omitempty"`
	// Proxy ID to be attached as metadata key "proxy-id" to connector RPCs.
	// Sent with the first response.
	ProxyId string `protobuf:"bytes,2,opt,name=proxy_id,json=proxyId,proto3" json:"proxy_id,omitempty"`
	// Log emitted by connectors invoked using `proxy_id`.
	// All messages following the first are logs.
	Log                  *ops.Log `protobuf:"bytes,3,opt,name=log,proto3" json:"log,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectorProxyResponse) Reset()         { *m = ConnectorProxyResponse{} }
func (m *ConnectorProxyResponse) String() string { return proto.CompactTextString(m) }
func (*ConnectorProxyResponse) ProtoMessage()    {}
func (*ConnectorProxyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{14}
}
func (m *ConnectorProxyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorProxyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorProxyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorProxyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorProxyResponse.Merge(m, src)
}
func (m *ConnectorProxyResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ConnectorProxyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorProxyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorProxyResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("runtime.CaptureResponseExt_PollResult", CaptureResponseExt_PollResult_name, CaptureResponseExt_PollResult_value)
	proto.RegisterType((*TaskServiceConfig)(nil), "runtime.TaskServiceConfig")
	proto.RegisterType((*ShuffleRequest)(nil), "runtime.ShuffleRequest")
	proto.RegisterType((*ShuffleResponse)(nil), "runtime.ShuffleResponse")
	proto.RegisterType((*RocksDBDescriptor)(nil), "runtime.RocksDBDescriptor")
	proto.RegisterType((*Container)(nil), "runtime.Container")
	proto.RegisterMapType((map[uint32]string)(nil), "runtime.Container.MappedHostPortsEntry")
	proto.RegisterType((*CaptureRequestExt)(nil), "runtime.CaptureRequestExt")
	proto.RegisterType((*CaptureRequestExt_StartCommit)(nil), "runtime.CaptureRequestExt.StartCommit")
	proto.RegisterType((*CaptureResponseExt)(nil), "runtime.CaptureResponseExt")
	proto.RegisterType((*CaptureResponseExt_Opened)(nil), "runtime.CaptureResponseExt.Opened")
	proto.RegisterType((*CaptureResponseExt_Captured)(nil), "runtime.CaptureResponseExt.Captured")
	proto.RegisterType((*CaptureResponseExt_Checkpoint)(nil), "runtime.CaptureResponseExt.Checkpoint")
	proto.RegisterType((*DeriveRequestExt)(nil), "runtime.DeriveRequestExt")
	proto.RegisterType((*DeriveRequestExt_Open)(nil), "runtime.DeriveRequestExt.Open")
	proto.RegisterType((*DeriveResponseExt)(nil), "runtime.DeriveResponseExt")
	proto.RegisterType((*DeriveResponseExt_Opened)(nil), "runtime.DeriveResponseExt.Opened")
	proto.RegisterType((*DeriveResponseExt_Published)(nil), "runtime.DeriveResponseExt.Published")
	proto.RegisterType((*DeriveResponseExt_Flushed)(nil), "runtime.DeriveResponseExt.Flushed")
	proto.RegisterType((*MaterializeRequestExt)(nil), "runtime.MaterializeRequestExt")
	proto.RegisterType((*MaterializeResponseExt)(nil), "runtime.MaterializeResponseExt")
	proto.RegisterType((*MaterializeResponseExt_Flushed)(nil), "runtime.MaterializeResponseExt.Flushed")
	proto.RegisterType((*CombineRequest)(nil), "runtime.CombineRequest")
	proto.RegisterType((*CombineRequest_Open)(nil), "runtime.CombineRequest.Open")
	proto.RegisterType((*CombineRequest_Open_Binding)(nil), "runtime.CombineRequest.Open.Binding")
	proto.RegisterType((*CombineRequest_Add)(nil), "runtime.CombineRequest.Add")
	proto.RegisterType((*CombineResponse)(nil), "runtime.CombineResponse")
	proto.RegisterType((*ConnectorProxyRequest)(nil), "runtime.ConnectorProxyRequest")
	proto.RegisterType((*ConnectorProxyResponse)(nil), "runtime.ConnectorProxyResponse")
}

func init() {
	proto.RegisterFile("go/protocols/runtime/runtime.proto", fileDescriptor_73af6e0737ce390c)
}

var fileDescriptor_73af6e0737ce390c = []byte{
	// 2026 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x18, 0x4d, 0x73, 0x1b, 0x49,
	0x75, 0x47, 0x92, 0x2d, 0xcd, 0x93, 0xed, 0xc8, 0x5d, 0xd9, 0x44, 0xab, 0x0d, 0xb6, 0x57, 0xbb,
	0x0b, 0x2e, 0x92, 0x95, 0x8d, 0x97, 0x82, 0x65, 0x0b, 0xb6, 0x62, 0xcb, 0x36, 0x51, 0xb0, 0x63,
	0xd3, 0x4a, 0x52, 0x05, 0x97, 0xa9, 0xf1, 0x74, 0x4b, 0x9a, 0x68, 0x34, 0x3d, 0xdb, 0xdd, 0x63,
	0xc7, 0xfb, 0x17, 0x38, 0x70, 0xe1, 0xc6, 0x85, 0x33, 0xff, 0x80, 0xfd, 0x05, 0x39, 0x52, 0x1c,
	0x28, 0x4e, 0xae, 0x62, 0xb9, 0x72, 0xe4, 0x82, 0x8b, 0x03, 0xd5, 0x1f, 0x33, 0x92, 0xa5, 0x38,
	0x84, 0xec, 0x1e, 0xf6, 0x60, 0xab, 0xfb, 0x7d, 0xf5, 0x7b, 0xaf, 0xdf, 0x57, 0x0f, 0x34, 0xfb,
	0x6c, 0x23, 0xe1, 0x4c, 0xb2, 0x80, 0x45, 0x62, 0x83, 0xa7, 0xb1, 0x0c, 0x47, 0x34, 0xfb, 0x6d,
	0x69, 0x0c, 0x2a, 0xdb, 0x6d, 0x63, 0xe5, 0x84, 0xb3, 0x21, 0xe5, 0x39, 0x43, 0xbe, 0x30, 0x84,
	0x8d, 0xb5, 0x80, 0xc5, 0x22, 0x1d, 0xbd, 0x82, 0xe2, 0xce, 0x95, 0xe3, 0x7a, 0x11, 0x3b, 0xd3,
	0xff, 0x2c, 0xb6, 0x71, 0x05, 0xcb, 0x12, 0xfd, 0x67, 0x71, 0x37, 0xfb, 0xac, 0xcf, 0xf4, 0x72,
	0x43, 0xad, 0x0c, 0xb4, 0xf9, 0x27, 0x07, 0x96, 0x1f, 0xfb, 0x62, 0xd8, 0xa5, 0xfc, 0x34, 0x0c,
	0x68, 0x9b, 0xc5, 0xbd, 0xb0, 0x8f, 0x56, 0xa0, 0x1a, 0xb1, 0xbe, 0xd7, 0x0b, 0x23, 0xea, 0xf5,
	0x48, 0xdd, 0x59, 0x73, 0xd6, 0xe7, 0xb0, 0x1b, 0xb1, 0xfe, 0x7e, 0x18, 0xd1, 0x7d, 0x82, 0xde,
	0x05, 0x57, 0xfa, 0x62, 0xe8, 0xc5, 0xfe, 0x88, 0xd6, 0x0b, 0x6b, 0xce, 0xba, 0x8b, 0x2b, 0x0a,
	0xf0, 0xc8, 0x1f, 0x51, 0xf4, 0x0e, 0x54, 0x52, 0x22, 0xbc, 0xc4, 0x97, 0x83, 0x7a, 0x51, 0xe3,
	0xca, 0x29, 0x11, 0xc7, 0xbe, 0x1c, 0xa0, 0xbb, 0xb0, 0x1c, 0xb0, 0x58, 0xfa, 0x61, 0x4c, 0xb9,
	0x17, 0x53, 0x79, 0xc6, 0xf8, 0xb0, 0x5e, 0xd2, 0x34, 0xb5, 0x1c, 0xf1, 0xc8, 0xc0, 0xd1, 0x2a,
	0x54, 0xfd, 0x28, 0x62, 0x67, 0x5e, 0xc4, 0x02, 0x3f, 0xaa, 0xcf, 0xad, 0x39, 0xeb, 0x15, 0x0c,
	0x1a, 0x74, 0xa0, 0x20, 0xcd, 0x7f, 0x97, 0x60, 0xa9, 0x3b, 0x48, 0x7b, 0xbd, 0x88, 0x62, 0xfa,
	0x79, 0x4a, 0x85, 0x44, 0x1d, 0x28, 0x3f, 0x63, 0x29, 0x8f, 0xfd, 0x48, 0x2b, 0xed, 0xee, 0x6c,
	0x5c, 0x5e, 0xac, 0xde, 0xed, 0xb3, 0x56, 0xdf, 0xff, 0x82, 0x4a, 0x49, 0x5b, 0x84, 0x9e, 0x6e,
	0x04, 0x8c, 0xd3, 0x8d, 0xa9, 0x9b, 0x68, 0x3d, 0x34, 0x6c, 0x38, 0xe3, 0x47, 0xb7, 0x60, 0x9e,
	0xd3, 0x24, 0xf2, 0xcf, 0xb5, 0x81, 0x15, 0x6c, 0x77, 0xca, 0xbc, 0x93, 0x34, 0x8c, 0x88, 0x17,
	0x92, 0xcc, 0x3c, 0xbd, 0xef, 0x10, 0xb4, 0x0f, 0xf3, 0xac, 0xd7, 0x13, 0x54, 0x6a, 0x9b, 0x8a,
	0x3b, 0xad, 0xcb, 0x8b, 0xd5, 0xef, 0xbf, 0xce, 0xe1, 0x47, 0x9a, 0x0b, 0x5b, 0x6e, 0x74, 0x08,
	0x40, 0x63, 0xe2, 0x59, 0x59, 0x73, 0x6f, 0x24, 0xcb, 0xa5, 0x31, 0x31, 0x4b, 0x74, 0x17, 0xe6,
	0xb8, 0x1f, 0xf7, 0x69, 0x7d, 0x7e, 0xcd, 0x59, 0xaf, 0x6e, 0xdd, 0x68, 0xe9, 0x88, 0xc1, 0x0a,
	0xd4, 0x4d, 0x68, 0xb0, 0x53, 0x7a, 0x71, 0xb1, 0xfa, 0x16, 0x36, 0x34, 0xa8, 0x0b, 0xd5, 0x80,
	0x31, 0x4e, 0xc2, 0xd8, 0x97, 0x8c, 0xd7, 0xcb, 0xda, 0x8b, 0x3f, 0xb8, 0xbc, 0x58, 0xfd, 0xe8,
	0x65, 0x87, 0xcf, 0xc4, 0x6b, 0xab, 0x3b, 0xf0, 0x39, 0xe9, 0xec, 0xe2, 0x49, 0x29, 0x68, 0x13,
	0x80, 0x53, 0xc1, 0xa2, 0x54, 0x86, 0x2c, 0xae, 0x57, 0xb4, 0x1a, 0xb5, 0x56, 0xce, 0xf3, 0x80,
	0xfa, 0x84, 0x72, 0x3c, 0x41, 0x83, 0xde, 0x87, 0x45, 0x61, 0xae, 0xd6, 0x0b, 0x63, 0x42, 0x9f,
	0xd7, 0xdd, 0x35, 0x67, 0x7d, 0x11, 0x2f, 0x58, 0x60, 0x47, 0xc1, 0xd0, 0x0f, 0x01, 0x08, 0xe5,
	0xe1, 0xa9, 0xaf, 0xc5, 0x82, 0x16, 0x7b, 0xd3, 0x58, 0xd7, 0x66, 0x51, 0x44, 0x03, 0x05, 0x57,
	0x26, 0xe2, 0x09, 0x3a, 0xd4, 0x86, 0x1b, 0x23, 0x5f, 0x52, 0x1e, 0xfa, 0x51, 0xf8, 0x85, 0x61,
	0xad, 0x6a, 0xd6, 0x77, 0x0c, 0xeb, 0xe1, 0x55, 0xa4, 0xe6, 0x9f, 0xe6, 0x68, 0xfe, 0xa5, 0x04,
	0x37, 0xf2, 0xd8, 0x13, 0x09, 0x8b, 0x05, 0x45, 0xeb, 0x30, 0x2f, 0xa4, 0x2f, 0x53, 0xa1, 0x63,
	0x6f, 0x69, 0xab, 0xd6, 0xca, 0xdc, 0xd3, 0xea, 0x6a, 0x38, 0xb6, 0x78, 0x45, 0x39, 0xd0, 0x36,
	0xeb, 0xd8, 0x7a, 0x99, 0x2f, 0x2c, 0x1e, 0x7d, 0x08, 0x4b, 0x92, 0xf2, 0x51, 0x18, 0xfb, 0x91,
	0x47, 0x39, 0x67, 0xdc, 0xc6, 0xdc, 0x62, 0x06, 0xdd, 0x53, 0x40, 0xf4, 0x4b, 0x58, 0xe0, 0xd4,
	0x27, 0x9e, 0x1c, 0x70, 0x96, 0xf6, 0x07, 0x6f, 0x18, 0x7f, 0x55, 0x25, 0xe3, 0xb1, 0x11, 0xa1,
	0x82, 0xf0, 0x8c, 0x87, 0x92, 0x7a, 0x4a, 0x93, 0x37, 0x0d, 0x42, 0x2d, 0x41, 0x99, 0x84, 0x3a,
	0x30, 0xe7, 0x73, 0x1a, 0xfb, 0x3a, 0x08, 0x17, 0x76, 0x3e, 0xbe, 0xbc, 0x58, 0xdd, 0xe8, 0x87,
	0x72, 0x90, 0x9e, 0xb4, 0x02, 0x36, 0xda, 0xa0, 0x42, 0xa6, 0x3e, 0x3f, 0x37, 0x15, 0x6d, 0xa6,
	0xc6, 0xb5, 0xb6, 0x15, 0x2b, 0x36, 0x12, 0xd0, 0x87, 0x50, 0x22, 0x2c, 0x10, 0xf5, 0xf2, 0x5a,
	0x71, 0xbd, 0xba, 0x55, 0x35, 0xb7, 0xd6, 0x8d, 0xc2, 0x80, 0xda, 0x50, 0xd6, 0x68, 0xf4, 0x00,
	0xca, 0x26, 0x83, 0x44, 0xbd, 0xb2, 0x56, 0x7c, 0x03, 0xed, 0x33, 0x76, 0x15, 0x67, 0x69, 0x1a,
	0x12, 0x2f, 0xf1, 0xb9, 0x14, 0x75, 0x57, 0x1f, 0x6b, 0xb3, 0xe8, 0xc9, 0x93, 0xce, 0xee, 0xb1,
	0x02, 0xdb, 0xa3, 0x5d, 0x45, 0xa8, 0x01, 0x2a, 0xe8, 0x13, 0x3f, 0x18, 0x52, 0xe2, 0x0d, 0xe9,
	0x79, 0x1d, 0xae, 0x53, 0xd6, 0x35, 0x44, 0xbf, 0xa0, 0xe7, 0x4d, 0x02, 0xcb, 0x98, 0x05, 0x43,
	0xb1, 0xbb, 0xb3, 0x4b, 0x45, 0xc0, 0xc3, 0x44, 0xe5, 0xce, 0x3d, 0x40, 0x5c, 0x01, 0xc9, 0x89,
	0x47, 0xe3, 0x53, 0x6f, 0x44, 0x47, 0x89, 0xe4, 0x3a, 0xc2, 0xe6, 0x71, 0xcd, 0x62, 0xf6, 0xe2,
	0xd3, 0x43, 0x0d, 0x47, 0xef, 0xc1, 0x42, 0x46, 0xad, 0x0b, 0xb0, 0x29, 0xce, 0x55, 0x0b, 0x53,
	0x45, 0xb8, 0xf9, 0xbb, 0x02, 0xb8, 0xed, 0xac, 0xd8, 0xa2, 0xdb, 0x50, 0x0e, 0x13, 0xcf, 0x27,
	0xc4, 0xc8, 0x74, 0xf1, 0x7c, 0x98, 0x6c, 0x13, 0xc2, 0xd1, 0x8f, 0x60, 0xd1, 0x56, 0x68, 0x2f,
	0x61, 0xca, 0xee, 0x82, 0xb6, 0x60, 0xd9, 0x58, 0x60, 0x8b, 0xf4, 0x31, 0xe3, 0x12, 0x2f, 0xc4,
	0xe3, 0x8d, 0x40, 0x5d, 0x58, 0x1e, 0xf9, 0x49, 0x42, 0x89, 0x37, 0x60, 0x42, 0x5a, 0xde, 0xa2,
	0xe6, 0xfd, 0x5e, 0x2b, 0xeb, 0x8b, 0xf9, 0xf9, 0xad, 0x43, 0x4d, 0xfb, 0x80, 0x09, 0xa9, 0xd9,
	0xf7, 0x62, 0xc9, 0xcf, 0x55, 0xba, 0x5d, 0x81, 0xa2, 0xef, 0x00, 0xa4, 0xc2, 0xef, 0x53, 0x8f,
	0xfb, 0x92, 0xea, 0xe8, 0x2e, 0x60, 0x57, 0x43, 0xb0, 0x2f, 0x69, 0x63, 0x07, 0x6e, 0xbe, 0x4c,
	0x0e, 0xaa, 0x41, 0x51, 0xf9, 0xde, 0xd1, 0xb5, 0x43, 0x2d, 0xd1, 0x4d, 0x98, 0x3b, 0xf5, 0xa3,
	0x34, 0xeb, 0x5a, 0x66, 0xf3, 0x69, 0xe1, 0x13, 0xa7, 0xf9, 0xc7, 0x02, 0x2c, 0xb7, 0xfd, 0x44,
	0xa6, 0x3c, 0xeb, 0x26, 0x7b, 0xcf, 0x55, 0xed, 0x54, 0x6d, 0xcf, 0x8b, 0xe8, 0x29, 0x8d, 0x6c,
	0x5a, 0x2f, 0xb5, 0x54, 0x53, 0x3d, 0x60, 0xfd, 0xd6, 0x81, 0x82, 0xe2, 0x4a, 0xc4, 0xfa, 0x7a,
	0x85, 0x3a, 0xe3, 0xab, 0x22, 0xf9, 0x05, 0xda, 0x14, 0x6f, 0xe4, 0xb6, 0xcf, 0x5c, 0x31, 0x5e,
	0xb6, 0x5c, 0x13, 0xb7, 0xde, 0x81, 0x05, 0x21, 0x7d, 0x2e, 0xbd, 0x80, 0x8d, 0x46, 0xa1, 0xd4,
	0x59, 0x5f, 0xdd, 0xfa, 0xee, 0xd8, 0x81, 0xd3, 0x9a, 0xaa, 0x12, 0xc3, 0x65, 0x5b, 0x53, 0xe3,
	0xaa, 0x18, 0x6f, 0x1a, 0x18, 0xaa, 0x13, 0x38, 0xd4, 0x06, 0x64, 0x85, 0x78, 0xc1, 0x80, 0x06,
	0xc3, 0x84, 0x85, 0xb1, 0xd4, 0xa6, 0xa9, 0xe2, 0x99, 0x57, 0xac, 0x76, 0x8e, 0xc3, 0xcb, 0x96,
	0x7e, 0x0c, 0x6a, 0xfe, 0xa7, 0x04, 0x28, 0x57, 0xc1, 0x94, 0x3f, 0xe5, 0xad, 0x4d, 0x70, 0xf3,
	0x36, 0x6e, 0x45, 0xa2, 0xd9, 0x3b, 0xc7, 0x63, 0x22, 0xf4, 0x29, 0xcc, 0xb3, 0x84, 0xc6, 0x94,
	0x58, 0x37, 0x35, 0x67, 0x2d, 0xcc, 0xc5, 0xb7, 0x8e, 0x34, 0x25, 0xb6, 0x1c, 0xe8, 0x3e, 0x54,
	0x02, 0x43, 0x44, 0xac, 0x7f, 0x3e, 0x78, 0x15, 0xb7, 0x05, 0x11, 0x9c, 0x73, 0xa1, 0x7d, 0x80,
	0x09, 0x1f, 0x94, 0xae, 0xf3, 0xf1, 0x84, 0x8c, 0xb1, 0x57, 0x26, 0x38, 0x1b, 0x87, 0x30, 0x6f,
	0x74, 0xfb, 0x46, 0xbc, 0xdb, 0x78, 0x0a, 0x95, 0x4c, 0x59, 0x15, 0xf9, 0x43, 0x7a, 0xee, 0x99,
	0x22, 0xa1, 0x05, 0x2d, 0x60, 0x77, 0x48, 0xcf, 0x8f, 0x35, 0x40, 0x4d, 0x54, 0xaa, 0x2a, 0x85,
	0xaa, 0x29, 0x89, 0x8c, 0xaa, 0xa0, 0xa9, 0x6a, 0x63, 0x84, 0x21, 0x6e, 0x9c, 0x01, 0x8c, 0x4f,
	0x41, 0x6b, 0x30, 0xa7, 0xda, 0x91, 0xb0, 0xda, 0x81, 0x0e, 0x6b, 0xd5, 0xa8, 0x04, 0x36, 0x08,
	0xf4, 0x73, 0xa8, 0x26, 0x2c, 0x8a, 0x3c, 0x4e, 0x45, 0x1a, 0x49, 0x2d, 0x76, 0xe9, 0xd5, 0xfe,
	0x39, 0x66, 0x51, 0x84, 0x35, 0x35, 0x86, 0x24, 0x5f, 0x37, 0x1f, 0x01, 0x8c, 0x31, 0xa8, 0x0a,
	0xe5, 0xce, 0xa3, 0xa7, 0xdb, 0x07, 0x9d, 0xdd, 0xda, 0x5b, 0xc8, 0x85, 0x39, 0xbc, 0xb7, 0xbd,
	0xfb, 0xab, 0x9a, 0x83, 0x16, 0xc1, 0x7d, 0x74, 0xf4, 0xd8, 0x33, 0xdb, 0x02, 0x5a, 0x80, 0x4a,
	0xfb, 0xe8, 0xe8, 0xc0, 0x3b, 0xda, 0xdf, 0xaf, 0x15, 0x15, 0x13, 0xde, 0xeb, 0x3e, 0xde, 0xc6,
	0x8f, 0x6b, 0xa5, 0xe6, 0x3f, 0x1d, 0xa8, 0xed, 0xaa, 0x8e, 0xfe, 0x6d, 0x48, 0xd5, 0x2d, 0x28,
	0xa9, 0x80, 0xb4, 0x21, 0xb8, 0x92, 0x33, 0x4f, 0x2b, 0xa8, 0xc3, 0x17, 0x6b, 0xda, 0xc6, 0x3d,
	0x28, 0xa9, 0x1d, 0xfa, 0x00, 0x96, 0xc4, 0xe7, 0x91, 0xea, 0xb2, 0xa7, 0x3d, 0xe1, 0xa5, 0x3c,
	0xb4, 0x45, 0x78, 0xc1, 0x40, 0x9f, 0xf6, 0xc4, 0x13, 0x1e, 0x36, 0xff, 0x55, 0x84, 0xe5, 0x4c,
	0xda, 0xd7, 0x49, 0xb6, 0x9f, 0x4c, 0x25, 0xdb, 0x7b, 0x33, 0xba, 0x5e, 0x9b, 0x6b, 0x3b, 0xe0,
	0x26, 0xe9, 0x49, 0x14, 0x8a, 0xc1, 0x4b, 0x92, 0x6d, 0x96, 0xfb, 0x38, 0xa3, 0xc5, 0x63, 0x36,
	0xf4, 0x53, 0x28, 0xf7, 0xa2, 0x54, 0x4b, 0x28, 0x4d, 0x25, 0xfb, 0xac, 0x84, 0x7d, 0x43, 0x89,
	0x33, 0x96, 0x6f, 0x3a, 0xc7, 0x24, 0xb8, 0xb9, 0x92, 0xea, 0x3d, 0x33, 0xf2, 0x9f, 0x7b, 0x41,
	0xc4, 0x82, 0xa1, 0x6d, 0xad, 0x95, 0x91, 0xff, 0xbc, 0xad, 0xf6, 0x53, 0x19, 0x58, 0x78, 0xad,
	0x0c, 0x2c, 0x5e, 0x93, 0x81, 0x77, 0xa1, 0x6c, 0x0d, 0xfb, 0xdf, 0xe9, 0xd7, 0xfc, 0xad, 0x03,
	0x6f, 0x8f, 0x87, 0xd1, 0x6f, 0x41, 0xa8, 0x37, 0xbf, 0x74, 0xe0, 0xd6, 0x15, 0x8d, 0xbe, 0x4e,
	0x34, 0x6e, 0x8f, 0xc3, 0xc1, 0x28, 0x33, 0x1e, 0x0f, 0x5e, 0x7e, 0xc6, 0x6c, 0x4c, 0xfc, 0x5f,
	0xee, 0xfc, 0xb2, 0x04, 0x4b, 0x6d, 0x36, 0x3a, 0x09, 0xe3, 0xfc, 0xb9, 0xb8, 0x69, 0x53, 0xd7,
	0xf0, 0xdc, 0x99, 0xd0, 0x77, 0x92, 0x6c, 0x22, 0x71, 0xd1, 0x47, 0x50, 0xf4, 0x49, 0xa6, 0xf0,
	0xbb, 0xd7, 0x31, 0x6c, 0x13, 0x82, 0x15, 0x5d, 0xe3, 0xaf, 0x05, 0x9b, 0xe8, 0xf7, 0xa1, 0x72,
	0x12, 0xc6, 0x24, 0x8c, 0xfb, 0x4a, 0xc3, 0xe2, 0xd5, 0x5e, 0x35, 0x7b, 0x5a, 0x6b, 0xc7, 0x10,
	0xe3, 0x9c, 0xab, 0xf1, 0x9b, 0x02, 0x94, 0x2d, 0x14, 0x21, 0x28, 0xf5, 0xd2, 0xc8, 0x5c, 0x7d,
	0x05, 0xeb, 0x75, 0x36, 0xeb, 0xa8, 0x29, 0xcd, 0x35, 0xb3, 0xce, 0x27, 0x50, 0x4d, 0x38, 0x7b,
	0x66, 0x9e, 0x41, 0xd9, 0x0c, 0x56, 0x33, 0xf3, 0xdb, 0x71, 0x8e, 0xb0, 0x63, 0xe8, 0x24, 0x29,
	0xfa, 0x19, 0x54, 0x45, 0x30, 0xa0, 0x23, 0xdf, 0x7b, 0x26, 0x58, 0x6c, 0x5e, 0xe8, 0x3b, 0x77,
	0x2e, 0x2f, 0x56, 0xeb, 0x34, 0x0e, 0x98, 0x52, 0x61, 0x43, 0x21, 0x5a, 0xd8, 0x3f, 0x3b, 0xa4,
	0x42, 0x8f, 0x61, 0x60, 0x18, 0x1e, 0x0a, 0x16, 0xa3, 0x16, 0x80, 0xa0, 0xdc, 0x4b, 0x58, 0x14,
	0x06, 0xe7, 0xfa, 0xe9, 0x90, 0xcf, 0xcb, 0x5d, 0xca, 0x8f, 0x35, 0x18, 0xbb, 0x22, 0x5b, 0xea,
	0x2f, 0x06, 0x7a, 0xbe, 0x96, 0x5c, 0x3f, 0x0f, 0x5c, 0x5c, 0xd6, 0x63, 0xb4, 0xe4, 0xea, 0x15,
	0xae, 0x47, 0x34, 0x33, 0xed, 0xbb, 0xd8, 0xee, 0x1a, 0x31, 0x14, 0xb7, 0x09, 0x41, 0x75, 0x28,
	0x5b, 0x07, 0xd9, 0x21, 0x2f, 0xdb, 0xa2, 0x1f, 0x43, 0x85, 0xb0, 0xc0, 0xe8, 0x5f, 0x78, 0x0d,
	0xfd, 0xcb, 0x84, 0x05, 0x5a, 0xf9, 0x9b, 0x30, 0xd7, 0xe3, 0x2c, 0x36, 0x23, 0x57, 0x05, 0x9b,
	0x4d, 0xf3, 0x6f, 0x0e, 0xdc, 0xc8, 0xef, 0xc9, 0xbe, 0xf7, 0xae, 0x3f, 0xbc, 0x0e, 0x65, 0x42,
	0x23, 0x2a, 0x6d, 0x68, 0x57, 0x70, 0xb6, 0xbd, 0xa2, 0x56, 0xf1, 0x8d, 0xd4, 0x2a, 0x4d, 0xa8,
	0x35, 0x55, 0x9b, 0xe6, 0xa6, 0x6b, 0xd3, 0xfb, 0xb0, 0x68, 0xfc, 0x95, 0x51, 0xe8, 0xc7, 0x17,
	0x5e, 0x30, 0x40, 0x43, 0xd4, 0xbc, 0x0d, 0x6f, 0xb7, 0x59, 0x1c, 0xd3, 0x40, 0x32, 0x7e, 0xcc,
	0xd9, 0xf3, 0x73, 0x1b, 0x88, 0xcd, 0xdf, 0x3b, 0x70, 0x6b, 0x1a, 0x63, 0x4d, 0x7f, 0x08, 0x65,
	0xf5, 0x64, 0xa0, 0x42, 0xd8, 0xef, 0x2c, 0x9b, 0x97, 0x17, 0xab, 0xf7, 0x5e, 0xe7, 0x6d, 0xb5,
	0x17, 0x13, 0x53, 0x93, 0x33, 0x01, 0xea, 0xf6, 0x13, 0x25, 0xdc, 0x0b, 0x89, 0x9d, 0xca, 0xcb,
	0x7a, 0xdf, 0x21, 0xa8, 0x01, 0xc5, 0x88, 0xf5, 0x6d, 0xbf, 0xa9, 0x64, 0x15, 0x0e, 0x2b, 0xe0,
	0xd6, 0x43, 0xa8, 0xd8, 0x07, 0x38, 0x47, 0x9f, 0x41, 0xd9, 0xae, 0xd1, 0xed, 0x3c, 0xad, 0xae,
	0x7e, 0x1a, 0x6a, 0xd4, 0x67, 0x11, 0xc6, 0x98, 0x4d, 0x67, 0xeb, 0x00, 0x2a, 0xf6, 0x72, 0x39,
	0xba, 0x0f, 0x65, 0xbb, 0x9e, 0x90, 0x75, 0x35, 0x45, 0x27, 0x64, 0x4d, 0xc5, 0xc4, 0xba, 0xb3,
	0xe9, 0x6c, 0x0d, 0x54, 0x9d, 0x99, 0x74, 0x1b, 0x7a, 0x0a, 0x37, 0xf4, 0x22, 0x07, 0x0b, 0xb4,
	0x32, 0x59, 0x1c, 0x67, 0x9d, 0xdf, 0x58, 0xbd, 0x16, 0x3f, 0x3e, 0x69, 0xe7, 0xb3, 0x17, 0x7f,
	0x5f, 0x79, 0xeb, 0xc5, 0x57, 0x2b, 0xce, 0x9f, 0xbf, 0x5a, 0x71, 0xfe, 0xf0, 0x8f, 0x15, 0xe7,
	0xd7, 0xf7, 0x5e, 0xeb, 0x4d, 0x6d, 0x45, 0x9f, 0xcc, 0x6b, 0xd0, 0xc7, 0xff, 0x0d, 0x00, 0x00,
	0xff, 0xff, 0x40, 0x1e, 0x42, 0xa3, 0xc5, 0x14, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ShufflerClient is the client API for Shuffler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ShufflerClient interface {
	Shuffle(ctx context.Context, in *ShuffleRequest, opts ...grpc.CallOption) (Shuffler_ShuffleClient, error)
}

type shufflerClient struct {
	cc *grpc.ClientConn
}

func NewShufflerClient(cc *grpc.ClientConn) ShufflerClient {
	return &shufflerClient{cc}
}

func (c *shufflerClient) Shuffle(ctx context.Context, in *ShuffleRequest, opts ...grpc.CallOption) (Shuffler_ShuffleClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Shuffler_serviceDesc.Streams[0], "/runtime.Shuffler/Shuffle", opts...)
	if err != nil {
		return nil, err
	}
	x := &shufflerShuffleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Shuffler_ShuffleClient interface {
	Recv() (*ShuffleResponse, error)
	grpc.ClientStream
}

type shufflerShuffleClient struct {
	grpc.ClientStream
}

func (x *shufflerShuffleClient) Recv() (*ShuffleResponse, error) {
	m := new(ShuffleResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ShufflerServer is the server API for Shuffler service.
type ShufflerServer interface {
	Shuffle(*ShuffleRequest, Shuffler_ShuffleServer) error
}

// UnimplementedShufflerServer can be embedded to have forward compatible implementations.
type UnimplementedShufflerServer struct {
}

func (*UnimplementedShufflerServer) Shuffle(req *ShuffleRequest, srv Shuffler_ShuffleServer) error {
	return status.Errorf(codes.Unimplemented, "method Shuffle not implemented")
}

func RegisterShufflerServer(s *grpc.Server, srv ShufflerServer) {
	s.RegisterService(&_Shuffler_serviceDesc, srv)
}

func _Shuffler_Shuffle_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ShuffleRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ShufflerServer).Shuffle(m, &shufflerShuffleServer{stream})
}

type Shuffler_ShuffleServer interface {
	Send(*ShuffleResponse) error
	grpc.ServerStream
}

type shufflerShuffleServer struct {
	grpc.ServerStream
}

func (x *shufflerShuffleServer) Send(m *ShuffleResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Shuffler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "runtime.Shuffler",
	HandlerType: (*ShufflerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Shuffle",
			Handler:       _Shuffler_Shuffle_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "go/protocols/runtime/runtime.proto",
}

// CombinerClient is the client API for Combiner service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CombinerClient interface {
	Combine(ctx context.Context, opts ...grpc.CallOption) (Combiner_CombineClient, error)
}

type combinerClient struct {
	cc *grpc.ClientConn
}

func NewCombinerClient(cc *grpc.ClientConn) CombinerClient {
	return &combinerClient{cc}
}

func (c *combinerClient) Combine(ctx context.Context, opts ...grpc.CallOption) (Combiner_CombineClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Combiner_serviceDesc.Streams[0], "/runtime.Combiner/Combine", opts...)
	if err != nil {
		return nil, err
	}
	x := &combinerCombineClient{stream}
	return x, nil
}

type Combiner_CombineClient interface {
	Send(*CombineRequest) error
	Recv() (*CombineResponse, error)
	grpc.ClientStream
}

type combinerCombineClient struct {
	grpc.ClientStream
}

func (x *combinerCombineClient) Send(m *CombineRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *combinerCombineClient) Recv() (*CombineResponse, error) {
	m := new(CombineResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CombinerServer is the server API for Combiner service.
type CombinerServer interface {
	Combine(Combiner_CombineServer) error
}

// UnimplementedCombinerServer can be embedded to have forward compatible implementations.
type UnimplementedCombinerServer struct {
}

func (*UnimplementedCombinerServer) Combine(srv Combiner_CombineServer) error {
	return status.Errorf(codes.Unimplemented, "method Combine not implemented")
}

func RegisterCombinerServer(s *grpc.Server, srv CombinerServer) {
	s.RegisterService(&_Combiner_serviceDesc, srv)
}

func _Combiner_Combine_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CombinerServer).Combine(&combinerCombineServer{stream})
}

type Combiner_CombineServer interface {
	Send(*CombineResponse) error
	Recv() (*CombineRequest, error)
	grpc.ServerStream
}

type combinerCombineServer struct {
	grpc.ServerStream
}

func (x *combinerCombineServer) Send(m *CombineResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *combinerCombineServer) Recv() (*CombineRequest, error) {
	m := new(CombineRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Combiner_serviceDesc = grpc.ServiceDesc{
	ServiceName: "runtime.Combiner",
	HandlerType: (*CombinerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Combine",
			Handler:       _Combiner_Combine_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "go/protocols/runtime/runtime.proto",
}

// ConnectorProxyClient is the client API for ConnectorProxy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ConnectorProxyClient interface {
	ProxyConnectors(ctx context.Context, opts ...grpc.CallOption) (ConnectorProxy_ProxyConnectorsClient, error)
}

type connectorProxyClient struct {
	cc *grpc.ClientConn
}

func NewConnectorProxyClient(cc *grpc.ClientConn) ConnectorProxyClient {
	return &connectorProxyClient{cc}
}

func (c *connectorProxyClient) ProxyConnectors(ctx context.Context, opts ...grpc.CallOption) (ConnectorProxy_ProxyConnectorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ConnectorProxy_serviceDesc.Streams[0], "/runtime.ConnectorProxy/ProxyConnectors", opts...)
	if err != nil {
		return nil, err
	}
	x := &connectorProxyProxyConnectorsClient{stream}
	return x, nil
}

type ConnectorProxy_ProxyConnectorsClient interface {
	Send(*ConnectorProxyRequest) error
	Recv() (*ConnectorProxyResponse, error)
	grpc.ClientStream
}

type connectorProxyProxyConnectorsClient struct {
	grpc.ClientStream
}

func (x *connectorProxyProxyConnectorsClient) Send(m *ConnectorProxyRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *connectorProxyProxyConnectorsClient) Recv() (*ConnectorProxyResponse, error) {
	m := new(ConnectorProxyResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ConnectorProxyServer is the server API for ConnectorProxy service.
type ConnectorProxyServer interface {
	ProxyConnectors(ConnectorProxy_ProxyConnectorsServer) error
}

// UnimplementedConnectorProxyServer can be embedded to have forward compatible implementations.
type UnimplementedConnectorProxyServer struct {
}

func (*UnimplementedConnectorProxyServer) ProxyConnectors(srv ConnectorProxy_ProxyConnectorsServer) error {
	return status.Errorf(codes.Unimplemented, "method ProxyConnectors not implemented")
}

func RegisterConnectorProxyServer(s *grpc.Server, srv ConnectorProxyServer) {
	s.RegisterService(&_ConnectorProxy_serviceDesc, srv)
}

func _ConnectorProxy_ProxyConnectors_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ConnectorProxyServer).ProxyConnectors(&connectorProxyProxyConnectorsServer{stream})
}

type ConnectorProxy_ProxyConnectorsServer interface {
	Send(*ConnectorProxyResponse) error
	Recv() (*ConnectorProxyRequest, error)
	grpc.ServerStream
}

type connectorProxyProxyConnectorsServer struct {
	grpc.ServerStream
}

func (x *connectorProxyProxyConnectorsServer) Send(m *ConnectorProxyResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *connectorProxyProxyConnectorsServer) Recv() (*ConnectorProxyRequest, error) {
	m := new(ConnectorProxyRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ConnectorProxy_serviceDesc = grpc.ServiceDesc{
	ServiceName: "runtime.ConnectorProxy",
	HandlerType: (*ConnectorProxyServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ProxyConnectors",
			Handler:       _ConnectorProxy_ProxyConnectors_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "go/protocols/runtime/runtime.proto",
}

func (m *TaskServiceConfig) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskServiceConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskServiceConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllowLocal {
		i--
		if m.AllowLocal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.ContainerNetwork) > 0 {
		i -= len(m.ContainerNetwork)
		copy(dAtA[i:], m.ContainerNetwork)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.ContainerNetwork)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.UdsPath) > 0 {
		i -= len(m.UdsPath)
		copy(dAtA[i:], m.UdsPath)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.UdsPath)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TaskName) > 0 {
		i -= len(m.TaskName)
		copy(dAtA[i:], m.TaskName)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.TaskName)))
		i--
		dAtA[i] = 0x12
	}
	if m.LogFileFd != 0 {
		i = encodeVarintRuntime(dAtA, i, uint64(m.LogFileFd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShuffleRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShuffleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShuffleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Materialization != nil {
		{
			size, err := m.Materialization.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Derivation != nil {
		{
			size, err := m.Derivation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ShuffleIndex != 0 {
		i = encodeVarintRuntime(dAtA, i, uint64(m.ShuffleIndex))
		i--
		dAtA[i] = 0x48
	}
	if m.Resolution != nil {
		{
			size, err := m.Resolution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Coordinator) > 0 {
		i -= len(m.Coordinator)
		copy(dAtA[i:], m.Coordinator)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.Coordinator)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRuntime(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.EndOffset != 0 {
		i = encodeVarintRuntime(dAtA, i, uint64(m.EndOffset))
		i--
		dAtA[i] = 0x28
	}
	if m.Offset != 0 {
		i = encodeVarintRuntime(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x20
	}
	if len(m.BuildId) > 0 {
		i -= len(m.BuildId)
		copy(dAtA[i:], m.BuildId)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.BuildId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Replay {
		i--
		if m.Replay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Journal) > 0 {
		i -= len(m.Journal)
		copy(dAtA[i:], m.Journal)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.Journal)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShuffleResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShuffleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShuffleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PackedKey) > 0 {
		for iNdEx := len(m.PackedKey) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PackedKey[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRuntime(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.UuidParts) > 0 {
		for iNdEx := len(m.UuidParts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UuidParts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRuntime(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Offsets) > 0 {
		dAtA6 := make([]byte, len(m.Offsets)*10)
		var j5 int
		for _, num1 := range m.Offsets {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintRuntime(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Docs) > 0 {
		for iNdEx := len(m.Docs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Docs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRuntime(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Arena) > 0 {
		i -= len(m.Arena)
		copy(dAtA[i:], m.Arena)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.Arena)))
		i--
		dAtA[i] = 0x32
	}
	if m.WriteHead != 0 {
		i = encodeVarintRuntime(dAtA, i, uint64(m.WriteHead))
		i--
		dAtA[i] = 0x28
	}
	if m.ReadThrough != 0 {
		i = encodeVarintRuntime(dAtA, i, uint64(m.ReadThrough))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TerminalError) > 0 {
		i -= len(m.TerminalError)
		copy(dAtA[i:], m.TerminalError)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.TerminalError)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintRuntime(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RocksDBDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RocksDBDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RocksDBDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RocksdbPath) > 0 {
		i -= len(m.RocksdbPath)
		copy(dAtA[i:], m.RocksdbPath)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.RocksdbPath)))
		i--
		dAtA[i] = 0x12
	}
	if m.RocksdbEnvMemptr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RocksdbEnvMemptr))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Container) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Container) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Container) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UsageRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UsageRate))))
		i--
		dAtA[i] = 0x25
	}
	if len(m.MappedHostPorts) > 0 {
		for k := range m.MappedHostPorts {
			v := m.MappedHostPorts[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintRuntime(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintRuntime(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintRuntime(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.NetworkPorts) > 0 {
		for iNdEx := len(m.NetworkPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetworkPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRuntime(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.IpAddr) > 0 {
		i -= len(m.IpAddr)
		copy(dAtA[i:], m.IpAddr)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.IpAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CaptureRequestExt) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptureRequestExt) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CaptureRequestExt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StartCommit != nil {
		{
			size, err := m.StartCommit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RocksdbDescriptor != nil {
		{
			size, err := m.RocksdbDescriptor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LogLevel != 0 {
		i = encodeVarintRuntime(dAtA, i, uint64(m.LogLevel))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CaptureRequestExt_StartCommit) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptureRequestExt_StartCommit) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CaptureRequestExt_StartCommit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RuntimeCheckpoint != nil {
		{
			size, err := m.RuntimeCheckpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CaptureResponseExt) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptureResponseExt) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CaptureResponseExt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Checkpoint != nil {
		{
			size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Captured != nil {
		{
			size, err := m.Captured.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Opened != nil {
		{
			size, err := m.Opened.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Container != nil {
		{
			size, err := m.Container.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CaptureResponseExt_Opened) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptureResponseExt_Opened) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CaptureResponseExt_Opened) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RuntimeCheckpoint != nil {
		{
			size, err := m.RuntimeCheckpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CaptureResponseExt_Captured) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptureResponseExt_Captured) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CaptureResponseExt_Captured) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartitionsPacked) > 0 {
		i -= len(m.PartitionsPacked)
		copy(dAtA[i:], m.PartitionsPacked)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.PartitionsPacked)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KeyPacked) > 0 {
		i -= len(m.KeyPacked)
		copy(dAtA[i:], m.KeyPacked)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.KeyPacked)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CaptureResponseExt_Checkpoint) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptureResponseExt_Checkpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CaptureResponseExt_Checkpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PollResult != 0 {
		i = encodeVarintRuntime(dAtA, i, uint64(m.PollResult))
		i--
		dAtA[i] = 0x10
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveRequestExt) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveRequestExt) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveRequestExt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Open != nil {
		{
			size, err := m.Open.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RocksdbDescriptor != nil {
		{
			size, err := m.RocksdbDescriptor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LogLevel != 0 {
		i = encodeVarintRuntime(dAtA, i, uint64(m.LogLevel))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeriveRequestExt_Open) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveRequestExt_Open) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveRequestExt_Open) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SqliteVfsUri) > 0 {
		i -= len(m.SqliteVfsUri)
		copy(dAtA[i:], m.SqliteVfsUri)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.SqliteVfsUri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveResponseExt) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveResponseExt) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveResponseExt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flushed != nil {
		{
			size, err := m.Flushed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Published != nil {
		{
			size, err := m.Published.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Opened != nil {
		{
			size, err := m.Opened.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Container != nil {
		{
			size, err := m.Container.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveResponseExt_Opened) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveResponseExt_Opened) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveResponseExt_Opened) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RuntimeCheckpoint != nil {
		{
			size, err := m.RuntimeCheckpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveResponseExt_Published) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveResponseExt_Published) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveResponseExt_Published) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartitionsPacked) > 0 {
		i -= len(m.PartitionsPacked)
		copy(dAtA[i:], m.PartitionsPacked)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.PartitionsPacked)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.KeyPacked) > 0 {
		i -= len(m.KeyPacked)
		copy(dAtA[i:], m.KeyPacked)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.KeyPacked)))
		i--
		dAtA[i] = 0x12
	}
	if m.MaxClock != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.MaxClock))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *DeriveResponseExt_Flushed) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveResponseExt_Flushed) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveResponseExt_Flushed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MaterializeRequestExt) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaterializeRequestExt) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaterializeRequestExt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RocksdbDescriptor != nil {
		{
			size, err := m.RocksdbDescriptor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LogLevel != 0 {
		i = encodeVarintRuntime(dAtA, i, uint64(m.LogLevel))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MaterializeResponseExt) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaterializeResponseExt) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaterializeResponseExt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flushed != nil {
		{
			size, err := m.Flushed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Container != nil {
		{
			size, err := m.Container.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MaterializeResponseExt_Flushed) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaterializeResponseExt_Flushed) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaterializeResponseExt_Flushed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CombineRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombineRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Add != nil {
		{
			size, err := m.Add.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Open != nil {
		{
			size, err := m.Open.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CombineRequest_Open) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineRequest_Open) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombineRequest_Open) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Bindings) > 0 {
		for iNdEx := len(m.Bindings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bindings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRuntime(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CombineRequest_Open_Binding) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineRequest_Open_Binding) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombineRequest_Open_Binding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintRuntime(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.UuidPtr) > 0 {
		i -= len(m.UuidPtr)
		copy(dAtA[i:], m.UuidPtr)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.UuidPtr)))
		i--
		dAtA[i] = 0x32
	}
	if m.SerPolicy != nil {
		{
			size, err := m.SerPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SchemaJson) > 0 {
		i -= len(m.SchemaJson)
		copy(dAtA[i:], m.SchemaJson)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.SchemaJson)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Projections) > 0 {
		for iNdEx := len(m.Projections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Projections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRuntime(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Key) > 0 {
		for iNdEx := len(m.Key) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Key[iNdEx])
			copy(dAtA[i:], m.Key[iNdEx])
			i = encodeVarintRuntime(dAtA, i, uint64(len(m.Key[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Full {
		i--
		if m.Full {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CombineRequest_Add) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineRequest_Add) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombineRequest_Add) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Front {
		i--
		if m.Front {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.DocJson) > 0 {
		i -= len(m.DocJson)
		copy(dAtA[i:], m.DocJson)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.DocJson)))
		i--
		dAtA[i] = 0x12
	}
	if m.Binding != 0 {
		i = encodeVarintRuntime(dAtA, i, uint64(m.Binding))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CombineResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombineResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ValuesPacked) > 0 {
		i -= len(m.ValuesPacked)
		copy(dAtA[i:], m.ValuesPacked)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.ValuesPacked)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.KeyPacked) > 0 {
		i -= len(m.KeyPacked)
		copy(dAtA[i:], m.KeyPacked)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.KeyPacked)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Front {
		i--
		if m.Front {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.DocJson) > 0 {
		i -= len(m.DocJson)
		copy(dAtA[i:], m.DocJson)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.DocJson)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Deleted {
		i--
		if m.Deleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Binding != 0 {
		i = encodeVarintRuntime(dAtA, i, uint64(m.Binding))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConnectorProxyRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorProxyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectorProxyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ConnectorProxyResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorProxyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectorProxyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Log != nil {
		{
			size, err := m.Log.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProxyId) > 0 {
		i -= len(m.ProxyId)
		copy(dAtA[i:], m.ProxyId)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.ProxyId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintRuntime(dAtA []byte, offset int, v uint64) int {
	offset -= sovRuntime(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TaskServiceConfig) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogFileFd != 0 {
		n += 1 + sovRuntime(uint64(m.LogFileFd))
	}
	l = len(m.TaskName)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	l = len(m.UdsPath)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	l = len(m.ContainerNetwork)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.AllowLocal {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShuffleRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Replay {
		n += 2
	}
	l = len(m.BuildId)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovRuntime(uint64(m.Offset))
	}
	if m.EndOffset != 0 {
		n += 1 + sovRuntime(uint64(m.EndOffset))
	}
	l = m.Range.ProtoSize()
	n += 1 + l + sovRuntime(uint64(l))
	l = len(m.Coordinator)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Resolution != nil {
		l = m.Resolution.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.ShuffleIndex != 0 {
		n += 1 + sovRuntime(uint64(m.ShuffleIndex))
	}
	if m.Derivation != nil {
		l = m.Derivation.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Materialization != nil {
		l = m.Materialization.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShuffleResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRuntime(uint64(m.Status))
	}
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	l = len(m.TerminalError)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.ReadThrough != 0 {
		n += 1 + sovRuntime(uint64(m.ReadThrough))
	}
	if m.WriteHead != 0 {
		n += 1 + sovRuntime(uint64(m.WriteHead))
	}
	l = len(m.Arena)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if len(m.Docs) > 0 {
		for _, e := range m.Docs {
			l = e.ProtoSize()
			n += 1 + l + sovRuntime(uint64(l))
		}
	}
	if len(m.Offsets) > 0 {
		l = 0
		for _, e := range m.Offsets {
			l += sovRuntime(uint64(e))
		}
		n += 1 + sovRuntime(uint64(l)) + l
	}
	if len(m.UuidParts) > 0 {
		for _, e := range m.UuidParts {
			l = e.ProtoSize()
			n += 1 + l + sovRuntime(uint64(l))
		}
	}
	if len(m.PackedKey) > 0 {
		for _, e := range m.PackedKey {
			l = e.ProtoSize()
			n += 1 + l + sovRuntime(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RocksDBDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RocksdbEnvMemptr != 0 {
		n += 9
	}
	l = len(m.RocksdbPath)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Container) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IpAddr)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if len(m.NetworkPorts) > 0 {
		for _, e := range m.NetworkPorts {
			l = e.ProtoSize()
			n += 1 + l + sovRuntime(uint64(l))
		}
	}
	if len(m.MappedHostPorts) > 0 {
		for k, v := range m.MappedHostPorts {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRuntime(uint64(k)) + 1 + len(v) + sovRuntime(uint64(len(v)))
			n += mapEntrySize + 1 + sovRuntime(uint64(mapEntrySize))
		}
	}
	if m.UsageRate != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CaptureRequestExt) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogLevel != 0 {
		n += 1 + sovRuntime(uint64(m.LogLevel))
	}
	if m.RocksdbDescriptor != nil {
		l = m.RocksdbDescriptor.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.StartCommit != nil {
		l = m.StartCommit.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CaptureRequestExt_StartCommit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuntimeCheckpoint != nil {
		l = m.RuntimeCheckpoint.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CaptureResponseExt) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Container != nil {
		l = m.Container.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Opened != nil {
		l = m.Opened.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Captured != nil {
		l = m.Captured.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Checkpoint != nil {
		l = m.Checkpoint.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CaptureResponseExt_Opened) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuntimeCheckpoint != nil {
		l = m.RuntimeCheckpoint.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CaptureResponseExt_Captured) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyPacked)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	l = len(m.PartitionsPacked)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CaptureResponseExt_Checkpoint) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Stats != nil {
		l = m.Stats.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.PollResult != 0 {
		n += 1 + sovRuntime(uint64(m.PollResult))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveRequestExt) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogLevel != 0 {
		n += 1 + sovRuntime(uint64(m.LogLevel))
	}
	if m.RocksdbDescriptor != nil {
		l = m.RocksdbDescriptor.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Open != nil {
		l = m.Open.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveRequestExt_Open) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SqliteVfsUri)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveResponseExt) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Container != nil {
		l = m.Container.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Opened != nil {
		l = m.Opened.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Published != nil {
		l = m.Published.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Flushed != nil {
		l = m.Flushed.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveResponseExt_Opened) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuntimeCheckpoint != nil {
		l = m.RuntimeCheckpoint.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveResponseExt_Published) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxClock != 0 {
		n += 9
	}
	l = len(m.KeyPacked)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	l = len(m.PartitionsPacked)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveResponseExt_Flushed) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Stats != nil {
		l = m.Stats.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaterializeRequestExt) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogLevel != 0 {
		n += 1 + sovRuntime(uint64(m.LogLevel))
	}
	if m.RocksdbDescriptor != nil {
		l = m.RocksdbDescriptor.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaterializeResponseExt) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Container != nil {
		l = m.Container.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Flushed != nil {
		l = m.Flushed.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaterializeResponseExt_Flushed) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Stats != nil {
		l = m.Stats.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CombineRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Open != nil {
		l = m.Open.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Add != nil {
		l = m.Add.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CombineRequest_Open) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Bindings) > 0 {
		for _, e := range m.Bindings {
			l = e.ProtoSize()
			n += 1 + l + sovRuntime(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CombineRequest_Open_Binding) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Full {
		n += 2
	}
	if len(m.Key) > 0 {
		for _, s := range m.Key {
			l = len(s)
			n += 1 + l + sovRuntime(uint64(l))
		}
	}
	if len(m.Projections) > 0 {
		for _, e := range m.Projections {
			l = e.ProtoSize()
			n += 1 + l + sovRuntime(uint64(l))
		}
	}
	l = len(m.SchemaJson)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.SerPolicy != nil {
		l = m.SerPolicy.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	l = len(m.UuidPtr)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovRuntime(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CombineRequest_Add) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Binding != 0 {
		n += 1 + sovRuntime(uint64(m.Binding))
	}
	l = len(m.DocJson)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Front {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CombineResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Binding != 0 {
		n += 1 + sovRuntime(uint64(m.Binding))
	}
	if m.Deleted {
		n += 2
	}
	l = len(m.DocJson)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Front {
		n += 2
	}
	l = len(m.KeyPacked)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	l = len(m.ValuesPacked)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorProxyRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorProxyResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	l = len(m.ProxyId)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Log != nil {
		l = m.Log.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRuntime(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRuntime(x uint64) (n int) {
	return sovRuntime(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TaskServiceConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskServiceConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskServiceConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogFileFd", wireType)
			}
			m.LogFileFd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogFileFd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UdsPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerNetwork", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerNetwork = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowLocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowLocal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShuffleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShuffleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShuffleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = go_gazette_dev_core_broker_protocol.Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Replay = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndOffset", wireType)
			}
			m.EndOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndOffset |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coordinator = go_gazette_dev_core_consumer_protocol.ShardID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resolution == nil {
				m.Resolution = &protocol.Header{}
			}
			if err := m.Resolution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleIndex", wireType)
			}
			m.ShuffleIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Derivation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Derivation == nil {
				m.Derivation = &flow.CollectionSpec{}
			}
			if err := m.Derivation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Materialization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Materialization == nil {
				m.Materialization = &flow.MaterializationSpec{}
			}
			if err := m.Materialization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShuffleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShuffleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShuffleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= protocol1.Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &protocol.Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TerminalError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TerminalError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadThrough", wireType)
			}
			m.ReadThrough = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadThrough |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteHead", wireType)
			}
			m.WriteHead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteHead |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arena", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arena = append(m.Arena[:0], dAtA[iNdEx:postIndex]...)
			if m.Arena == nil {
				m.Arena = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Docs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Docs = append(m.Docs, flow.Slice{})
			if err := m.Docs[len(m.Docs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v go_gazette_dev_core_broker_protocol.Offset
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRuntime
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Offsets = append(m.Offsets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRuntime
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRuntime
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRuntime
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Offsets) == 0 {
					m.Offsets = make([]go_gazette_dev_core_broker_protocol.Offset, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v go_gazette_dev_core_broker_protocol.Offset
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRuntime
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= go_gazette_dev_core_broker_protocol.Offset(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Offsets = append(m.Offsets, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Offsets", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidParts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidParts = append(m.UuidParts, flow.UUIDParts{})
			if err := m.UuidParts[len(m.UuidParts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackedKey = append(m.PackedKey, flow.Slice{})
			if err := m.PackedKey[len(m.PackedKey)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RocksDBDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RocksDBDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RocksDBDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksdbEnvMemptr", wireType)
			}
			m.RocksdbEnvMemptr = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.RocksdbEnvMemptr = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksdbPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RocksdbPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Container) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Container: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Container: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkPorts = append(m.NetworkPorts, &flow.NetworkPort{})
			if err := m.NetworkPorts[len(m.NetworkPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappedHostPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MappedHostPorts == nil {
				m.MappedHostPorts = make(map[uint32]string)
			}
			var mapkey uint32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRuntime
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRuntime
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRuntime
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRuntime
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthRuntime
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRuntime(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthRuntime
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MappedHostPorts[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UsageRate = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptureRequestExt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptureRequestExt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptureRequestExt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogLevel", wireType)
			}
			m.LogLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogLevel |= ops.Log_Level(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksdbDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RocksdbDescriptor == nil {
				m.RocksdbDescriptor = &RocksDBDescriptor{}
			}
			if err := m.RocksdbDescriptor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartCommit == nil {
				m.StartCommit = &CaptureRequestExt_StartCommit{}
			}
			if err := m.StartCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptureRequestExt_StartCommit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartCommit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartCommit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeCheckpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuntimeCheckpoint == nil {
				m.RuntimeCheckpoint = &protocol1.Checkpoint{}
			}
			if err := m.RuntimeCheckpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptureResponseExt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptureResponseExt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptureResponseExt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &Container{}
			}
			if err := m.Container.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opened", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opened == nil {
				m.Opened = &CaptureResponseExt_Opened{}
			}
			if err := m.Opened.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captured", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Captured == nil {
				m.Captured = &CaptureResponseExt_Captured{}
			}
			if err := m.Captured.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Checkpoint == nil {
				m.Checkpoint = &CaptureResponseExt_Checkpoint{}
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptureResponseExt_Opened) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opened: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opened: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeCheckpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuntimeCheckpoint == nil {
				m.RuntimeCheckpoint = &protocol1.Checkpoint{}
			}
			if err := m.RuntimeCheckpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptureResponseExt_Captured) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Captured: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Captured: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPacked", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyPacked = append(m.KeyPacked[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyPacked == nil {
				m.KeyPacked = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionsPacked", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionsPacked = append(m.PartitionsPacked[:0], dAtA[iNdEx:postIndex]...)
			if m.PartitionsPacked == nil {
				m.PartitionsPacked = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptureResponseExt_Checkpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Checkpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Checkpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ops.Stats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PollResult", wireType)
			}
			m.PollResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PollResult |= CaptureResponseExt_PollResult(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveRequestExt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeriveRequestExt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeriveRequestExt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogLevel", wireType)
			}
			m.LogLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogLevel |= ops.Log_Level(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksdbDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RocksdbDescriptor == nil {
				m.RocksdbDescriptor = &RocksDBDescriptor{}
			}
			if err := m.RocksdbDescriptor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Open == nil {
				m.Open = &DeriveRequestExt_Open{}
			}
			if err := m.Open.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveRequestExt_Open) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Open: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Open: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqliteVfsUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SqliteVfsUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveResponseExt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeriveResponseExt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeriveResponseExt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &Container{}
			}
			if err := m.Container.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opened", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opened == nil {
				m.Opened = &DeriveResponseExt_Opened{}
			}
			if err := m.Opened.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Published", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Published == nil {
				m.Published = &DeriveResponseExt_Published{}
			}
			if err := m.Published.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flushed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flushed == nil {
				m.Flushed = &DeriveResponseExt_Flushed{}
			}
			if err := m.Flushed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveResponseExt_Opened) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opened: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opened: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeCheckpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuntimeCheckpoint == nil {
				m.RuntimeCheckpoint = &protocol1.Checkpoint{}
			}
			if err := m.RuntimeCheckpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveResponseExt_Published) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Published: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Published: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxClock", wireType)
			}
			m.MaxClock = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxClock = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPacked", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyPacked = append(m.KeyPacked[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyPacked == nil {
				m.KeyPacked = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionsPacked", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionsPacked = append(m.PartitionsPacked[:0], dAtA[iNdEx:postIndex]...)
			if m.PartitionsPacked == nil {
				m.PartitionsPacked = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveResponseExt_Flushed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flushed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flushed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ops.Stats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaterializeRequestExt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaterializeRequestExt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaterializeRequestExt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogLevel", wireType)
			}
			m.LogLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogLevel |= ops.Log_Level(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksdbDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RocksdbDescriptor == nil {
				m.RocksdbDescriptor = &RocksDBDescriptor{}
			}
			if err := m.RocksdbDescriptor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaterializeResponseExt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaterializeResponseExt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaterializeResponseExt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &Container{}
			}
			if err := m.Container.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flushed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flushed == nil {
				m.Flushed = &MaterializeResponseExt_Flushed{}
			}
			if err := m.Flushed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaterializeResponseExt_Flushed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flushed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flushed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ops.Stats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Open == nil {
				m.Open = &CombineRequest_Open{}
			}
			if err := m.Open.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Add", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Add == nil {
				m.Add = &CombineRequest_Add{}
			}
			if err := m.Add.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineRequest_Open) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Open: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Open: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bindings = append(m.Bindings, &CombineRequest_Open_Binding{})
			if err := m.Bindings[len(m.Bindings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineRequest_Open_Binding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Binding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Binding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Full", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Full = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Projections = append(m.Projections, flow.Projection{})
			if err := m.Projections[len(m.Projections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SerPolicy == nil {
				m.SerPolicy = &flow.SerPolicy{}
			}
			if err := m.SerPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidPtr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidPtr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineRequest_Add) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Add: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Add: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binding", wireType)
			}
			m.Binding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Binding |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Front", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Front = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombineResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombineResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binding", wireType)
			}
			m.Binding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Binding |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deleted = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocJson = encoding_json.RawMessage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Front", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Front = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPacked", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyPacked = append(m.KeyPacked[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyPacked == nil {
				m.KeyPacked = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValuesPacked", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValuesPacked = append(m.ValuesPacked[:0], dAtA[iNdEx:postIndex]...)
			if m.ValuesPacked == nil {
				m.ValuesPacked = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorProxyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorProxyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorProxyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorProxyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorProxyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorProxyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = go_gazette_dev_core_broker_protocol.Endpoint(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Log == nil {
				m.Log = &ops.Log{}
			}
			if err := m.Log.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRuntime(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRuntime
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRuntime
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRuntime
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRuntime        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRuntime          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRuntime = fmt.Errorf("proto: unexpected end of group")
)
