// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go/protocols/runtime/runtime.proto

package runtime

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	ops "github.com/estuary/flow/go/protocols/ops"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	protocol "go.gazette.dev/core/consumer/protocol"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TaskServiceConfig struct {
	LogFileFd            int32    `protobuf:"varint,1,opt,name=log_file_fd,json=logFileFd,proto3" json:"log_file_fd,omitempty"`
	TaskName             string   `protobuf:"bytes,2,opt,name=task_name,json=taskName,proto3" json:"task_name,omitempty"`
	UdsPath              string   `protobuf:"bytes,3,opt,name=uds_path,json=udsPath,proto3" json:"uds_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TaskServiceConfig) Reset()         { *m = TaskServiceConfig{} }
func (m *TaskServiceConfig) String() string { return proto.CompactTextString(m) }
func (*TaskServiceConfig) ProtoMessage()    {}
func (*TaskServiceConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{0}
}
func (m *TaskServiceConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskServiceConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskServiceConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskServiceConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskServiceConfig.Merge(m, src)
}
func (m *TaskServiceConfig) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TaskServiceConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskServiceConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TaskServiceConfig proto.InternalMessageInfo

type RocksDBDescriptor struct {
	// Instrumented RocksDB environment which should be opened.
	RocksdbEnvMemptr uint64 `protobuf:"fixed64,1,opt,name=rocksdb_env_memptr,json=rocksdbEnvMemptr,proto3" json:"rocksdb_env_memptr,omitempty"`
	// Path to the RocksDB directory to be opened.
	RocksdbPath          string   `protobuf:"bytes,2,opt,name=rocksdb_path,json=rocksdbPath,proto3" json:"rocksdb_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RocksDBDescriptor) Reset()         { *m = RocksDBDescriptor{} }
func (m *RocksDBDescriptor) String() string { return proto.CompactTextString(m) }
func (*RocksDBDescriptor) ProtoMessage()    {}
func (*RocksDBDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{1}
}
func (m *RocksDBDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RocksDBDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RocksDBDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RocksDBDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RocksDBDescriptor.Merge(m, src)
}
func (m *RocksDBDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RocksDBDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_RocksDBDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_RocksDBDescriptor proto.InternalMessageInfo

type DeriveRequestExt struct {
	Open                 *DeriveRequestExt_Open `protobuf:"bytes,1,opt,name=open,proto3" json:"open,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *DeriveRequestExt) Reset()         { *m = DeriveRequestExt{} }
func (m *DeriveRequestExt) String() string { return proto.CompactTextString(m) }
func (*DeriveRequestExt) ProtoMessage()    {}
func (*DeriveRequestExt) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{2}
}
func (m *DeriveRequestExt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveRequestExt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveRequestExt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveRequestExt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveRequestExt.Merge(m, src)
}
func (m *DeriveRequestExt) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveRequestExt) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveRequestExt.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveRequestExt proto.InternalMessageInfo

type DeriveRequestExt_Open struct {
	// Configured log level.
	LogLevel ops.Log_Level `protobuf:"varint,1,opt,name=log_level,json=logLevel,proto3,enum=ops.Log_Level" json:"log_level,omitempty"`
	// URL with a registered SQLite VFS which should be opened.
	SqliteVfsUri string `protobuf:"bytes,2,opt,name=sqlite_vfs_uri,json=sqliteVfsUri,proto3" json:"sqlite_vfs_uri,omitempty"`
	// RocksDB descriptor which should be opened.
	RocksdbDescriptor    *RocksDBDescriptor `protobuf:"bytes,3,opt,name=rocksdb_descriptor,json=rocksdbDescriptor,proto3" json:"rocksdb_descriptor,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *DeriveRequestExt_Open) Reset()         { *m = DeriveRequestExt_Open{} }
func (m *DeriveRequestExt_Open) String() string { return proto.CompactTextString(m) }
func (*DeriveRequestExt_Open) ProtoMessage()    {}
func (*DeriveRequestExt_Open) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{2, 0}
}
func (m *DeriveRequestExt_Open) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveRequestExt_Open) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveRequestExt_Open.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveRequestExt_Open) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveRequestExt_Open.Merge(m, src)
}
func (m *DeriveRequestExt_Open) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveRequestExt_Open) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveRequestExt_Open.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveRequestExt_Open proto.InternalMessageInfo

type DeriveResponseExt struct {
	Opened               *DeriveResponseExt_Opened    `protobuf:"bytes,1,opt,name=opened,proto3" json:"opened,omitempty"`
	Published            *DeriveResponseExt_Published `protobuf:"bytes,2,opt,name=published,proto3" json:"published,omitempty"`
	Flushed              *DeriveResponseExt_Flushed   `protobuf:"bytes,3,opt,name=flushed,proto3" json:"flushed,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *DeriveResponseExt) Reset()         { *m = DeriveResponseExt{} }
func (m *DeriveResponseExt) String() string { return proto.CompactTextString(m) }
func (*DeriveResponseExt) ProtoMessage()    {}
func (*DeriveResponseExt) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{3}
}
func (m *DeriveResponseExt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveResponseExt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveResponseExt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveResponseExt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveResponseExt.Merge(m, src)
}
func (m *DeriveResponseExt) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveResponseExt) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveResponseExt.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveResponseExt proto.InternalMessageInfo

type DeriveResponseExt_Opened struct {
	RuntimeCheckpoint    *protocol.Checkpoint `protobuf:"bytes,1,opt,name=runtime_checkpoint,json=runtimeCheckpoint,proto3" json:"runtime_checkpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *DeriveResponseExt_Opened) Reset()         { *m = DeriveResponseExt_Opened{} }
func (m *DeriveResponseExt_Opened) String() string { return proto.CompactTextString(m) }
func (*DeriveResponseExt_Opened) ProtoMessage()    {}
func (*DeriveResponseExt_Opened) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{3, 0}
}
func (m *DeriveResponseExt_Opened) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveResponseExt_Opened) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveResponseExt_Opened.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveResponseExt_Opened) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveResponseExt_Opened.Merge(m, src)
}
func (m *DeriveResponseExt_Opened) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveResponseExt_Opened) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveResponseExt_Opened.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveResponseExt_Opened proto.InternalMessageInfo

type DeriveResponseExt_Published struct {
	// Maximum UUID Clock of sourced document clocks which lead to this published document.
	MaxClock uint64 `protobuf:"fixed64,1,opt,name=max_clock,json=maxClock,proto3" json:"max_clock,omitempty"`
	// Packed key extracted from the published document.
	KeyPacked []byte `protobuf:"bytes,2,opt,name=key_packed,json=keyPacked,proto3" json:"key_packed,omitempty"`
	// Packed partition values extracted from the published document.
	PartitionsPacked     []byte   `protobuf:"bytes,3,opt,name=partitions_packed,json=partitionsPacked,proto3" json:"partitions_packed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveResponseExt_Published) Reset()         { *m = DeriveResponseExt_Published{} }
func (m *DeriveResponseExt_Published) String() string { return proto.CompactTextString(m) }
func (*DeriveResponseExt_Published) ProtoMessage()    {}
func (*DeriveResponseExt_Published) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{3, 1}
}
func (m *DeriveResponseExt_Published) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveResponseExt_Published) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveResponseExt_Published.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveResponseExt_Published) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveResponseExt_Published.Merge(m, src)
}
func (m *DeriveResponseExt_Published) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveResponseExt_Published) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveResponseExt_Published.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveResponseExt_Published proto.InternalMessageInfo

type DeriveResponseExt_Flushed struct {
	Stats                *ops.Stats `protobuf:"bytes,1,opt,name=stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DeriveResponseExt_Flushed) Reset()         { *m = DeriveResponseExt_Flushed{} }
func (m *DeriveResponseExt_Flushed) String() string { return proto.CompactTextString(m) }
func (*DeriveResponseExt_Flushed) ProtoMessage()    {}
func (*DeriveResponseExt_Flushed) Descriptor() ([]byte, []int) {
	return fileDescriptor_73af6e0737ce390c, []int{3, 2}
}
func (m *DeriveResponseExt_Flushed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveResponseExt_Flushed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveResponseExt_Flushed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveResponseExt_Flushed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveResponseExt_Flushed.Merge(m, src)
}
func (m *DeriveResponseExt_Flushed) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeriveResponseExt_Flushed) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveResponseExt_Flushed.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveResponseExt_Flushed proto.InternalMessageInfo

func init() {
	proto.RegisterType((*TaskServiceConfig)(nil), "runtime.TaskServiceConfig")
	proto.RegisterType((*RocksDBDescriptor)(nil), "runtime.RocksDBDescriptor")
	proto.RegisterType((*DeriveRequestExt)(nil), "runtime.DeriveRequestExt")
	proto.RegisterType((*DeriveRequestExt_Open)(nil), "runtime.DeriveRequestExt.Open")
	proto.RegisterType((*DeriveResponseExt)(nil), "runtime.DeriveResponseExt")
	proto.RegisterType((*DeriveResponseExt_Opened)(nil), "runtime.DeriveResponseExt.Opened")
	proto.RegisterType((*DeriveResponseExt_Published)(nil), "runtime.DeriveResponseExt.Published")
	proto.RegisterType((*DeriveResponseExt_Flushed)(nil), "runtime.DeriveResponseExt.Flushed")
}

func init() {
	proto.RegisterFile("go/protocols/runtime/runtime.proto", fileDescriptor_73af6e0737ce390c)
}

var fileDescriptor_73af6e0737ce390c = []byte{
	// 616 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0xb4, 0xcd, 0xcf, 0xa4, 0xaa, 0x9a, 0x55, 0x0f, 0xc5, 0x88, 0x28, 0x8d, 0x7a, 0xa8,
	0xd4, 0xca, 0x91, 0xc2, 0x09, 0x09, 0x71, 0x68, 0xda, 0x4a, 0x48, 0x2d, 0x54, 0x5b, 0xe0, 0xc0,
	0xc5, 0x72, 0xec, 0x89, 0xb3, 0xf2, 0xda, 0xeb, 0xee, 0xae, 0x43, 0xfb, 0x36, 0x1c, 0x78, 0x12,
	0x4e, 0x3d, 0xf2, 0x0a, 0x94, 0x33, 0xef, 0x80, 0xbc, 0x5e, 0x3b, 0x82, 0xa2, 0x1e, 0x2c, 0xcf,
	0x7e, 0xf3, 0x7d, 0x33, 0xf3, 0x8d, 0xd6, 0x86, 0x51, 0x2c, 0xc6, 0xb9, 0x14, 0x5a, 0x84, 0x82,
	0xab, 0xb1, 0x2c, 0x32, 0xcd, 0x52, 0xac, 0xdf, 0x9e, 0xc9, 0x90, 0xb6, 0x3d, 0xba, 0xc3, 0x50,
	0x64, 0xaa, 0x48, 0x51, 0x36, 0x92, 0x26, 0xa8, 0xa8, 0xae, 0xfb, 0x57, 0x39, 0x91, 0x9b, 0xc7,
	0xe6, 0x76, 0x62, 0x11, 0x0b, 0x13, 0x8e, 0xcb, 0xa8, 0x42, 0x47, 0x09, 0xf4, 0x3f, 0x04, 0x2a,
	0xb9, 0x42, 0xb9, 0x64, 0x21, 0x4e, 0x45, 0x36, 0x67, 0x31, 0x19, 0x40, 0x8f, 0x8b, 0xd8, 0x9f,
	0x33, 0x8e, 0xfe, 0x3c, 0xda, 0x75, 0x86, 0xce, 0xc1, 0x06, 0xed, 0x72, 0x11, 0x9f, 0x31, 0x8e,
	0x67, 0x11, 0x79, 0x0e, 0x5d, 0x1d, 0xa8, 0xc4, 0xcf, 0x82, 0x14, 0x77, 0x9f, 0x0e, 0x9d, 0x83,
	0x2e, 0xed, 0x94, 0xc0, 0xbb, 0x20, 0x45, 0xf2, 0x0c, 0x3a, 0x45, 0xa4, 0xfc, 0x3c, 0xd0, 0x8b,
	0xdd, 0x35, 0x93, 0x6b, 0x17, 0x91, 0xba, 0x0c, 0xf4, 0x62, 0x14, 0x41, 0x9f, 0x8a, 0x30, 0x51,
	0x27, 0xc7, 0x27, 0xa8, 0x42, 0xc9, 0x72, 0x2d, 0x24, 0x39, 0x02, 0x22, 0x4b, 0x30, 0x9a, 0xf9,
	0x98, 0x2d, 0xfd, 0x14, 0xd3, 0x5c, 0x4b, 0xd3, 0xb3, 0x45, 0xb7, 0x6d, 0xe6, 0x34, 0x5b, 0x5e,
	0x18, 0x9c, 0xec, 0xc1, 0x66, 0xcd, 0x36, 0x1d, 0xaa, 0xee, 0x3d, 0x8b, 0x99, 0x2e, 0xbf, 0x1d,
	0xd8, 0x3e, 0x41, 0xc9, 0x96, 0x48, 0xf1, 0xba, 0x40, 0xa5, 0x4f, 0x6f, 0x34, 0x99, 0xc0, 0xba,
	0xc8, 0x31, 0x33, 0x75, 0x7b, 0x93, 0x81, 0x57, 0xaf, 0xf8, 0x5f, 0xa2, 0xf7, 0x3e, 0xc7, 0x8c,
	0x1a, 0xae, 0xfb, 0xcd, 0x81, 0xf5, 0xf2, 0x48, 0x0e, 0xa1, 0x34, 0xef, 0x73, 0x5c, 0x22, 0x37,
	0x15, 0xb6, 0x26, 0x5b, 0x5e, 0xb9, 0xd9, 0x73, 0x11, 0x7b, 0xe7, 0x25, 0x4a, 0x3b, 0x5c, 0xc4,
	0x26, 0x22, 0xfb, 0xb0, 0xa5, 0xae, 0x39, 0xd3, 0xe8, 0x2f, 0xe7, 0xca, 0x2f, 0x24, 0xb3, 0x33,
	0x6e, 0x56, 0xe8, 0xa7, 0xb9, 0xfa, 0x28, 0x19, 0x79, 0xbb, 0x72, 0x1d, 0x35, 0xbb, 0x30, 0xfb,
	0xea, 0x4d, 0xdc, 0x66, 0xba, 0x07, 0xdb, 0xa2, 0x7d, 0xab, 0x5a, 0x41, 0xa3, 0xef, 0x6b, 0xd0,
	0xaf, 0x6d, 0xa8, 0x5c, 0x64, 0x0a, 0x4b, 0xc3, 0xaf, 0xa0, 0x55, 0x9a, 0xc0, 0xc8, 0x5a, 0xde,
	0x7b, 0x60, 0xb9, 0xe1, 0x1a, 0xcf, 0x18, 0x51, 0x2b, 0x20, 0xc7, 0xd0, 0xcd, 0x8b, 0x19, 0x67,
	0x6a, 0x81, 0x91, 0x19, 0xbe, 0x37, 0xd9, 0x7f, 0x44, 0x7d, 0x59, 0x73, 0xe9, 0x4a, 0x46, 0x5e,
	0x43, 0x7b, 0xce, 0x0b, 0x53, 0xa1, 0x32, 0x35, 0x7a, 0xa4, 0xc2, 0x59, 0xc5, 0xa4, 0xb5, 0xc4,
	0xbd, 0x80, 0x56, 0x35, 0x13, 0x99, 0x02, 0xb1, 0x3a, 0x3f, 0x5c, 0x60, 0x98, 0xe4, 0x82, 0x65,
	0xda, 0x5a, 0xda, 0xf1, 0xea, 0x0f, 0xc2, 0x9b, 0x36, 0x39, 0xda, 0xb7, 0xfc, 0x15, 0xe4, 0x6a,
	0xe8, 0x36, 0x43, 0x96, 0x97, 0x37, 0x0d, 0x6e, 0xfc, 0x90, 0x8b, 0x30, 0xb1, 0xd7, 0xac, 0x93,
	0x06, 0x37, 0xd3, 0xf2, 0x4c, 0x5e, 0x00, 0x24, 0x78, 0xeb, 0xe7, 0x41, 0x98, 0x58, 0xef, 0x9b,
	0xb4, 0x9b, 0xe0, 0xed, 0xa5, 0x01, 0xc8, 0x21, 0xf4, 0xf3, 0x40, 0x6a, 0xa6, 0x99, 0xc8, 0x54,
	0xcd, 0x5a, 0x33, 0xac, 0xed, 0x55, 0xa2, 0x22, 0xbb, 0x87, 0xd0, 0xb6, 0xc6, 0xc8, 0x10, 0x36,
	0x94, 0x0e, 0xb4, 0xb2, 0x83, 0x83, 0xb9, 0x3c, 0x57, 0x25, 0x42, 0xab, 0xc4, 0xf1, 0x9b, 0xbb,
	0x9f, 0x83, 0x27, 0x77, 0xf7, 0x03, 0xe7, 0xc7, 0xfd, 0xc0, 0xf9, 0xfa, 0x6b, 0xe0, 0x7c, 0x3e,
	0x8a, 0x99, 0x5e, 0x14, 0x33, 0x2f, 0x14, 0xe9, 0x18, 0x95, 0x2e, 0x02, 0x79, 0x3b, 0x9e, 0x73,
	0xf1, 0x65, 0xfc, 0xbf, 0x5f, 0xc6, 0xac, 0x65, 0xa0, 0x97, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff,
	0x12, 0xe7, 0xed, 0x7e, 0x51, 0x04, 0x00, 0x00,
}

func (m *TaskServiceConfig) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskServiceConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskServiceConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UdsPath) > 0 {
		i -= len(m.UdsPath)
		copy(dAtA[i:], m.UdsPath)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.UdsPath)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TaskName) > 0 {
		i -= len(m.TaskName)
		copy(dAtA[i:], m.TaskName)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.TaskName)))
		i--
		dAtA[i] = 0x12
	}
	if m.LogFileFd != 0 {
		i = encodeVarintRuntime(dAtA, i, uint64(m.LogFileFd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RocksDBDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RocksDBDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RocksDBDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RocksdbPath) > 0 {
		i -= len(m.RocksdbPath)
		copy(dAtA[i:], m.RocksdbPath)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.RocksdbPath)))
		i--
		dAtA[i] = 0x12
	}
	if m.RocksdbEnvMemptr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RocksdbEnvMemptr))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *DeriveRequestExt) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveRequestExt) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveRequestExt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Open != nil {
		{
			size, err := m.Open.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveRequestExt_Open) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveRequestExt_Open) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveRequestExt_Open) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RocksdbDescriptor != nil {
		{
			size, err := m.RocksdbDescriptor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SqliteVfsUri) > 0 {
		i -= len(m.SqliteVfsUri)
		copy(dAtA[i:], m.SqliteVfsUri)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.SqliteVfsUri)))
		i--
		dAtA[i] = 0x12
	}
	if m.LogLevel != 0 {
		i = encodeVarintRuntime(dAtA, i, uint64(m.LogLevel))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeriveResponseExt) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveResponseExt) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveResponseExt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flushed != nil {
		{
			size, err := m.Flushed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Published != nil {
		{
			size, err := m.Published.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Opened != nil {
		{
			size, err := m.Opened.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveResponseExt_Opened) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveResponseExt_Opened) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveResponseExt_Opened) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RuntimeCheckpoint != nil {
		{
			size, err := m.RuntimeCheckpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveResponseExt_Published) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveResponseExt_Published) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveResponseExt_Published) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartitionsPacked) > 0 {
		i -= len(m.PartitionsPacked)
		copy(dAtA[i:], m.PartitionsPacked)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.PartitionsPacked)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.KeyPacked) > 0 {
		i -= len(m.KeyPacked)
		copy(dAtA[i:], m.KeyPacked)
		i = encodeVarintRuntime(dAtA, i, uint64(len(m.KeyPacked)))
		i--
		dAtA[i] = 0x12
	}
	if m.MaxClock != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.MaxClock))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *DeriveResponseExt_Flushed) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveResponseExt_Flushed) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveResponseExt_Flushed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRuntime(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintRuntime(dAtA []byte, offset int, v uint64) int {
	offset -= sovRuntime(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TaskServiceConfig) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogFileFd != 0 {
		n += 1 + sovRuntime(uint64(m.LogFileFd))
	}
	l = len(m.TaskName)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	l = len(m.UdsPath)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RocksDBDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RocksdbEnvMemptr != 0 {
		n += 9
	}
	l = len(m.RocksdbPath)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveRequestExt) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Open != nil {
		l = m.Open.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveRequestExt_Open) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogLevel != 0 {
		n += 1 + sovRuntime(uint64(m.LogLevel))
	}
	l = len(m.SqliteVfsUri)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.RocksdbDescriptor != nil {
		l = m.RocksdbDescriptor.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveResponseExt) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opened != nil {
		l = m.Opened.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Published != nil {
		l = m.Published.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.Flushed != nil {
		l = m.Flushed.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveResponseExt_Opened) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuntimeCheckpoint != nil {
		l = m.RuntimeCheckpoint.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveResponseExt_Published) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxClock != 0 {
		n += 9
	}
	l = len(m.KeyPacked)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	l = len(m.PartitionsPacked)
	if l > 0 {
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveResponseExt_Flushed) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Stats != nil {
		l = m.Stats.ProtoSize()
		n += 1 + l + sovRuntime(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRuntime(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRuntime(x uint64) (n int) {
	return sovRuntime(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TaskServiceConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskServiceConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskServiceConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogFileFd", wireType)
			}
			m.LogFileFd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogFileFd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UdsPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RocksDBDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RocksDBDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RocksDBDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksdbEnvMemptr", wireType)
			}
			m.RocksdbEnvMemptr = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.RocksdbEnvMemptr = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksdbPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RocksdbPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveRequestExt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeriveRequestExt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeriveRequestExt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Open == nil {
				m.Open = &DeriveRequestExt_Open{}
			}
			if err := m.Open.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveRequestExt_Open) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Open: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Open: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogLevel", wireType)
			}
			m.LogLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogLevel |= ops.Log_Level(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqliteVfsUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SqliteVfsUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksdbDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RocksdbDescriptor == nil {
				m.RocksdbDescriptor = &RocksDBDescriptor{}
			}
			if err := m.RocksdbDescriptor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveResponseExt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeriveResponseExt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeriveResponseExt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opened", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opened == nil {
				m.Opened = &DeriveResponseExt_Opened{}
			}
			if err := m.Opened.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Published", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Published == nil {
				m.Published = &DeriveResponseExt_Published{}
			}
			if err := m.Published.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flushed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flushed == nil {
				m.Flushed = &DeriveResponseExt_Flushed{}
			}
			if err := m.Flushed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveResponseExt_Opened) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opened: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opened: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeCheckpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuntimeCheckpoint == nil {
				m.RuntimeCheckpoint = &protocol.Checkpoint{}
			}
			if err := m.RuntimeCheckpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveResponseExt_Published) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Published: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Published: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxClock", wireType)
			}
			m.MaxClock = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxClock = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPacked", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyPacked = append(m.KeyPacked[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyPacked == nil {
				m.KeyPacked = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionsPacked", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionsPacked = append(m.PartitionsPacked[:0], dAtA[iNdEx:postIndex]...)
			if m.PartitionsPacked == nil {
				m.PartitionsPacked = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveResponseExt_Flushed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flushed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flushed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRuntime
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRuntime
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ops.Stats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRuntime(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRuntime
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRuntime(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRuntime
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRuntime
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRuntime
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRuntime
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRuntime
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRuntime        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRuntime          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRuntime = fmt.Errorf("proto: unexpected end of group")
)
