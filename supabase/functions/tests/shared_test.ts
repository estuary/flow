import { beforeEach, describe, it } from "jsr:@std/testing/bdd";
import { expect } from "jsr:@std/expect";

import { base64URLSafe, hashStrBase64 } from "../_shared/helpers.ts";

describe("helpers", () => {
  describe("hashStrBase64", () => {
    // Only keeping these hardcoded here to show how close they are in value
    // `newHash` - generate with the new function hashStrBase64
    // `oldHash` - generated by calling the previous package we used (sha256 from https://denopkg.com/chiefbiiko/sha256@v1.0.0/mod.ts)
    const testData = [
      {
        "inputString": '0gy/b/#0c,v%Jy$LhPkf-Zm!Tjf2wX%T]$[adQaKz-PPR*9j@!',

        "oldHash": 'laMV3qLCc1VkuvUfOY+Gwd16hgN2tgnTHnhFYQOmykk=',
        "newHash": 'laMV3qLCc1VkuvUfOY-Gwd16hgN2tgnTHnhFYQOmykk=',
      },
      {
        "inputString": 'kTvNX5e3WuYwfyx0Sq4YCxqwmkx3MBzqdiDUcphEEUjgVgdbhY',

        "oldHash": 'gabQV2uuZ4nq6VWXry5cVqPXjRKHsfklXydFm0gsB+s=',
        "newHash": 'gabQV2uuZ4nq6VWXry5cVqPXjRKHsfklXydFm0gsB-s=',
      },
      {
        "inputString": '41587268402056036309012946162859695295680615967612',

        "oldHash": 'BwcilUqEZUfxRBorCQB/saNwi6akfH8VeHMtqszQ18g=',
        "newHash": 'BwcilUqEZUfxRBorCQB_saNwi6akfH8VeHMtqszQ18g=',
      }
    ]

    let randomStringHashed = ''; 
    let randomKeyHashed = '';
    let randomNumberHashed = '';

    beforeEach(async () => {
      randomStringHashed = await hashStrBase64(testData[0].inputString);
      randomKeyHashed = await hashStrBase64(testData[1].inputString);
      randomNumberHashed = await hashStrBase64(testData[2].inputString);
    })

    it("can base64 hash any string passed to it", async () => {
      expect(randomStringHashed).toBe(testData[0].newHash);
      expect(randomKeyHashed).toBe(testData[1].newHash);
      expect(randomNumberHashed).toBe(testData[2].newHash);
    });

    it("still hashes the same as before but with different separators", () => {
      expect(randomStringHashed.split("-")).toEqual(testData[0].oldHash.split('+'))
      expect(randomKeyHashed.split("-")).toEqual(testData[1].oldHash.split('+'))
      expect(randomNumberHashed.split("_")).toEqual(testData[2].oldHash.split('/'))
    });

    it("and the output will be the same when the output is passed through base64URLSafe", () => {
      expect(base64URLSafe(randomStringHashed)).toEqual(base64URLSafe(testData[0].oldHash))
      expect(base64URLSafe(randomKeyHashed)).toEqual(base64URLSafe(testData[1].oldHash))
      expect(base64URLSafe(randomNumberHashed)).toEqual(base64URLSafe(testData[2].oldHash))
    });
  });
});