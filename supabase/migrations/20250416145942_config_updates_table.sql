begin;

create table public.config_updates (
    catalog_name public.catalog_name not null primary key,
    build public.flowid not null,
    ts timestamptz not null,
    flow_document json not null
);
alter table public.config_updates owner to stats_loader;
-- Index to support controllers deleting old config updates by name and build.
create index on public.config_updates (catalog_name, build);
-- Index to support the cleanup cron job, and maybe also controllers deleting
-- config updates by time.
create index on public.config_updates (ts);

comment on table public.config_updates is
'Records of task config updates, which are materialized by the ops catalog.
An insert into this table will trigger a run of the corresponding live spec
controller, which will respond to the config update.';
comment on column public.config_updates.catalog_name is
'The name of the task that the updated config is for.';
comment on column public.config_updates.build is
'The id of the build that the shard was running when the updated config was created.';
comment on column public.config_updates.ts is
'The timestamp of when the config update event was generated by the connector';
comment on column public.config_updates.flow_document is
'The contents of the `flow_document` column are serialized instances of the
`ConfigUpdate` struct defined in `crates/models/src/status/activation.rs`.';


create function internal.on_config_update() returns trigger
LANGUAGE plpgsql SECURITY DEFINER
AS $$
declare
    controller_task_id public.flowid;
begin

    select ls.controller_task_id into controller_task_id
    from live_specs ls
    where ls.catalog_name = new.catalog_name;

    -- It is possible for config updates to be observed after the task has been deleted.
    -- In that case, we just ignore the update.
    if controller_task_id is not null then
        perform internal.send_to_task(
            controller_task_id,
            '00:00:00:00:00:00:00:00'::flowid,
            '{"type":"config_updated"}'
            );
    end if;
return null;
end;
$$;

create function internal.delete_old_config_updates() returns integer
LANGUAGE sql SECURITY DEFINER
as $$
    with deleted as (
        delete from public.config_updates
        where ts < (now() - '48h'::interval)
        returning ts
    )
    select count(*) from deleted;
$$;

-- Run every weekday at 5pm. Controllers are supposed to clean up these config updates
-- after they're included in a successful publication. But controllers cannot do so for
-- config updates that are materialized after the live spec (along with the controller) has been
-- deleted, if the controller is failing, or the config update can't be successfully published.
-- So this is a catch-all to clean up any config updates that don't get deleted by the normal process.
-- Config updates are deleted after 48 hours, to give us time to investigate any potential issues that
-- may have prevented their deletion.
select cron.schedule('delete_old_config_updates', '0 17 * * 1-5', 'internal.delete_old_config_updates');

create trigger on_config_update after insert or update on public.config_updates
for each row
execute function internal.on_config_update();


commit;
