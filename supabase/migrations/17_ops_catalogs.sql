-- Adds the ops_catalog_template table and functions for publishing ops catalogs for new tenants.

create table ops_catalog_template (
	template_type text not null primary key
		check (template_type in ('tenant', 'l1_derivation', 'l2_derivation', 'materialization')),

	bundled_catalog json not null
);
insert into ops_catalog_template (template_type, bundled_catalog) values
	('tenant', '{}'),
	('l1_derivation', '{}'),
	('l2_derivation', '{}'),
	('materialization', '{}');

comment on table ops_catalog_template is
'This table contains a fixed set of values for templates used in the ops reporting catalog';

comment on column ops_catalog_template.template_type is
'The template_type is one of tenant, l1_derivation, l2_derivation, materialization, depending on the type of template it is';

comment on column ops_catalog_template.bundled_catalog is
'The bundled Flow catalog that will be used as a template for generating the ops catalog for each tenant.
The value for this is generated by running `flowctl raw bundle` on the catalog specs in the `ops-catalog/`
directory. Typically, this will actually get updated by using ops-catalog/generate-migration.sh';

create function internal.create_ops_publication(tenant_prefix catalog_tenant, ops_user_id uuid)
returns flowid as $$
declare
	new_draft_id flowid := internal.id_generator();
	publication_id flowid := internal.id_generator();
	l1_stat_rollup_selected integer;
	tenant_spec jsonb;
	l1_derivation_spec jsonb;
	l2_derivation_spec jsonb;
	materialization_spec jsonb;
begin
	-- Fetch the current tenant-specific catalog template, instantiated for `tenant_prefix`.
	select replace(bundled_catalog::text, 'TENANT', rtrim(tenant_prefix, '/'))::jsonb
	into strict tenant_spec
	from ops_catalog_template
	where template_type = 'tenant';

	-- Compute the level 1 reporting derivation spec for this tenant's publication. The new spec
	-- will include transforms for all tenants assigned to the same l1_stat_rollup as the new tenant
	-- and will include the new tenant. The new tenant must be available to query in the tenants
	-- table.
	select l1_stat_rollup
	into strict l1_stat_rollup_selected
	from tenants where
	tenants.tenant = tenant_prefix;
	l1_derivation_spec := internal.create_l1_derivation_spec(l1_stat_rollup_selected);

	-- Compute the level 2 reporting derivation spec for this tenant's publication. In most cases it
	-- will be a re-publication of a spec identical to the existing live spec unless this new tenant
	-- is assigned to a new l1_stat_rollup.
	l2_derivation_spec := internal.create_l2_derivation_spec();

	-- Compute the reporting materialization. This will always be the same for every tenant. It is
	-- re-published for every tenant as a simplification for the case where the first tenant is
	-- being published and the materialiation does not yet exist.
	select bundled_catalog::jsonb -> 'materializations'
	into strict materialization_spec
	from ops_catalog_template
	where template_type = 'materialization';

	-- Create a draft of ops changes.
	insert into drafts (id, user_id, detail) values
	(new_draft_id, ops_user_id, 'creating ops catalog for new tenant');

	-- Queue a publication of the draft.
	insert into publications (id, user_id, draft_id) values
	(publication_id, ops_user_id, new_draft_id);

	-- Upsert drafts for the level 1 and 2 derivations. Live specifications for these tasks will
	-- usually already exist, so an expect_pub_id is provided to fail the publication on races that
	-- may result from concurrent agents processing nearly-simultaneous tenant creations.
	with l1_expect_pub_id as (
		select last_pub_id as id
		from live_specs
		where catalog_name = (select * from jsonb_object_keys(l1_derivation_spec) limit 1)
	),
	l2_expect_pub_id as (
		select last_pub_id as id
		from live_specs
		where catalog_name = (select * from jsonb_object_keys(l2_derivation_spec) limit 1)
	)
	insert into draft_specs (draft_id, catalog_name, spec_type, spec, expect_pub_id)
	select new_draft_id, "key", 'collection'::catalog_spec_type, "value", (select id from l1_expect_pub_id)
	from jsonb_each(l1_derivation_spec)
	union all
	select new_draft_id, "key", 'collection'::catalog_spec_type, "value", (select id from l2_expect_pub_id)
	from jsonb_each(l2_derivation_spec)
	on conflict (draft_id, catalog_name)
	do update set spec_type = excluded.spec_type, spec = excluded.spec;

	-- Now upsert drafts for all remaining specs. This will include any and all specs from the
	-- tenant spec, plus the final reporting materialization.
	insert into draft_specs (draft_id, catalog_name, spec_type, spec)
	select new_draft_id, "key", 'capture'::catalog_spec_type, "value"
	from jsonb_each(jsonb_extract_path(tenant_spec, 'captures'))
	union all
	select new_draft_id, "key", 'collection'::catalog_spec_type, "value"
	from jsonb_each(jsonb_extract_path(tenant_spec, 'collections'))
	union all
	select new_draft_id, "key", 'materialization'::catalog_spec_type, "value"
	from jsonb_each(jsonb_extract_path(tenant_spec, 'materializations'))
	union all
	select new_draft_id, "key", 'materialization'::catalog_spec_type, "value"
	from jsonb_each(materialization_spec)
	on conflict (draft_id, catalog_name)
	do update set spec_type = excluded.spec_type, spec = excluded.spec;

	return publication_id;
end;
$$ language plpgsql
security definer;

comment on function internal.create_ops_publication is '
Creates a new publication of the ops catalog template for a specific tenant.
This publication will include the tenant-specific specs for the tenant,
the re-calculated level 1 and level 2 reporting derivations applicable to
the tenant, and the single reporting materialization.
';

create function internal.create_l1_derivation_spec(l1_stat_rollup_arg integer)
returns json as $$
declare
	l1_derivation_template jsonb;
	l1_transform_template jsonb;
	l1_transforms_complete jsonb := '{}';
	current_tenant tenants;
begin
	select bundled_catalog::jsonb
	into strict l1_derivation_template
	from ops_catalog_template
	where template_type = 'l1_derivation';

	l1_transform_template := l1_derivation_template #> '{collections,ops/catalog-stats-L1/L1ID,derivation,transform}';

	for current_tenant in
		select * from tenants where tenants.l1_stat_rollup = l1_stat_rollup_arg
	loop
		l1_transforms_complete := l1_transforms_complete || replace(l1_transform_template::text, 'TENANT', rtrim(current_tenant.tenant, '/'))::jsonb;
	end loop;

	l1_derivation_template := jsonb_set(l1_derivation_template, '{collections,ops/catalog-stats-L1/L1ID,derivation,transform}', l1_transforms_complete);
	l1_derivation_template := internal.extend_l1_lambdas(l1_derivation_template, l1_stat_rollup_arg);
	l1_derivation_template := replace(l1_derivation_template::text, 'L1ID', l1_stat_rollup_arg::text)::jsonb;

	return l1_derivation_template -> 'collections';
end;
$$ language plpgsql
security definer;

comment on function internal.create_l1_derivation_spec is'
Helper function to build a complete level 1 reporting derivation spec
including all tenants having a specified l1_stat_rollup value.
';

create function internal.create_l2_derivation_spec()
returns json as $$
declare
	l2_derivation_template jsonb;
	l2_transform_template jsonb;
	l2_transforms_complete jsonb := '{}';
	current_l1_transform_id integer;
begin
	select bundled_catalog::jsonb
	into strict l2_derivation_template
	from ops_catalog_template
	where template_type = 'l2_derivation';

	l2_transform_template := l2_derivation_template #> '{collections,ops/catalog-stats-L2/0,derivation,transform}';

	for current_l1_transform_id in
		select distinct l1_stat_rollup from tenants
	loop
		l2_transforms_complete := l2_transforms_complete || replace(l2_transform_template::text, 'L1ID', current_l1_transform_id::text)::jsonb;
	end loop;

	l2_derivation_template := jsonb_set(l2_derivation_template, '{collections,ops/catalog-stats-L2/0,derivation,transform}', l2_transforms_complete);
	l2_derivation_template := internal.extend_l2_lambdas(l2_derivation_template);

	return l2_derivation_template -> 'collections';
end;
$$ language plpgsql
security definer;

comment on function internal.create_l2_derivation_spec is '
Helper function to build a complete level 2 reporting derivation spec
including all level 1 derivations in the system.
';

create function internal.extend_l1_lambdas(l1_derivation_template jsonb, l1_stat_rollup_arg integer)
returns jsonb as $$
declare
	logs_template text := 'fromTENANTLogsPublish(source: LogsSource, _register: Register, _previous: Register): Document[] { return logsPublish(source) };\n';
	stats_template text := 'fromTENANTStatsPublish(source: StatsSource, _register: Register, _previous: Register): Document[] { return statsPublish(source) };\n';
	insert_placeholder text := '// transformsInsertPoint\n';
	base_ts text;
	current_tenant tenants;
begin
	base_ts := l1_derivation_template #> '{collections,ops/catalog-stats-L1/L1ID,derivation,typescript,module}';
	base_ts := REGEXP_REPLACE(base_ts, '\/\/ transformsBegin[\s\S]*transformsEnd', insert_placeholder);

	for current_tenant in
		select * from tenants where tenants.l1_stat_rollup = l1_stat_rollup_arg
	loop
		base_ts := REPLACE(base_ts, insert_placeholder, logs_template || insert_placeholder);
		base_ts := REPLACE(base_ts, insert_placeholder, stats_template || insert_placeholder);
		-- This is a little weird, but necessary. The "imports" section will end up importing from
		-- the type from the last tenant processed, and that type will be extended from as an
		-- interface for all the publish lambdas.
		base_ts := REPLACE(base_ts, 'TENANT', rtrim(current_tenant.tenant, '/'));
	end loop;

	base_ts := REPLACE(base_ts, 'L1ID', l1_stat_rollup_arg::text);

	return jsonb_set(l1_derivation_template, '{collections,ops/catalog-stats-L1/L1ID,derivation,typescript,module}', base_ts::jsonb);
end;
$$ language plpgsql
security definer;

comment on function internal.extend_l1_lambdas is '
Helper function to populate the typescript lambdas for a level 1 reporting
derivation for all tenants with a specified l1_stat_rollup value.
';

create function internal.extend_l2_lambdas(l2_derivation_template jsonb)
returns jsonb as $$
declare
	source_template text := 'fromL1IDPublish(source: AggregateSouce, _register: Register, _previous: Register): OutputDocument[] { return [source] };\n';
	insert_placeholder text := '// transformsInsertPoint\n';
	base_ts text;
	current_l1_transform_id integer;
begin
	base_ts := l2_derivation_template #> '{collections,ops/catalog-stats-L2/0,derivation,typescript,module}';
	base_ts := REGEXP_REPLACE(base_ts, '\/\/ transformsBegin[\s\S]*transformsEnd', insert_placeholder);

	for current_l1_transform_id in
		select distinct l1_stat_rollup from tenants order by l1_stat_rollup
	loop
		base_ts := REPLACE(base_ts, insert_placeholder, source_template || insert_placeholder);
		base_ts := REPLACE(base_ts, 'L1ID', current_l1_transform_id::text);
	end loop;

	return jsonb_set(l2_derivation_template, '{collections,ops/catalog-stats-L2/0,derivation,typescript,module}', base_ts::jsonb);
end;
$$ language plpgsql
security definer;

comment on function internal.extend_l2_lambdas is '
Helper function to populate the typescript lambdas for a level 2 reporting
derivation for all level 1 derivations in the system.
';
