-- Adds the ops_catalog_template and functions for publishing ops catalogs for each tenant.

create table ops_catalog_template (
	id flowid not null primary key check (id = '00:00:00:00:00:00:00:00'::flowid),

	bundled_catalog json not null
);
insert into ops_catalog_template (id, bundled_catalog) values
('00:00:00:00:00:00:00:00', '{}');

comment on table ops_catalog_template is
'This table contains a single value, which is the template that is used to publish ops catalogs for each tenant';

comment on column ops_catalog_template.id is
'The id is always the constant 00:00:00:00:00:00:00:00, which is just used to ensure that there is always at most one row';

comment on column ops_catalog_template.bundled_catalog is
'The bundled Flow catalog that will be used as a template for generating the ops catalog for each tenant.
This will contain the placeholder TENANT, which will be replaced by the actual tenant name prior to publication.
The value for this is generated by running `flowctl raw bundle` on the catalog specs in the `ops-catalog/` directory.
Typically, this will actually get updated by using ops-catalog/generate-migration.sh';

create function internal.create_ops_publication(tenant_prefix catalog_tenant, ops_user_id uuid)
returns flowid as $$
declare
	new_draft_id flowid := internal.id_generator();
	publication_id flowid := internal.id_generator();
	ops_template json;

begin
	-- Fetch the current ops catalog template, instantiated for `tenant_prefix`.
	select replace(bundled_catalog::text, 'TENANT', rtrim(tenant_prefix, '/'))::json
	into strict ops_template
	from ops_catalog_template
	where id = '00:00:00:00:00:00:00:00';

	-- Create a draft of ops changes.
	insert into drafts (id, user_id, detail) values
	(new_draft_id, ops_user_id, 're-publishing ops catalog');

	-- Queue a publication of the draft.
	insert into publications (id, user_id, draft_id) values
	(publication_id, ops_user_id, new_draft_id);

	-- Draft a deletion for all currently-live ops catalog specs.
	insert into draft_specs (draft_id, catalog_name, spec_type, spec)
	select new_draft_id, catalog_name, null, null
	from live_specs
	where catalog_name like ('ops/' || tenant_prefix || '%');

	-- Now upsert drafts for all specs of the template.
	-- Skip tests for the `ops/` tenant (only), as these fail.
	insert into draft_specs (draft_id, catalog_name, spec_type, spec)
	select new_draft_id, "key", 'capture'::catalog_spec_type, "value"
	from json_each(json_extract_path(ops_template, 'captures'))
	union all
	select new_draft_id, "key", 'collection'::catalog_spec_type, "value"
	from json_each(json_extract_path(ops_template, 'collections'))
	union all
	select new_draft_id, "key", 'materialization'::catalog_spec_type, "value"
	from json_each(json_extract_path(ops_template, 'materializations'))
	union all
	select new_draft_id, "key", 'test'::catalog_spec_type, "value"
	from json_each(json_extract_path(ops_template, 'tests'))
	where tenant_prefix != 'ops/'
	on conflict (draft_id, catalog_name)
	do update set spec_type = excluded.spec_type, spec = excluded.spec;

	return publication_id;
end;
$$ language plpgsql
security definer;

comment on function internal.create_ops_publication is '
Creates a new publication of the ops catalog template for a specific tenant.
This publication will include all specs from the bundled_catalog in ops_catalog_template.
Any _other_ specs under the ops/<tenant>/ prefix will be deleted by this publication.
';