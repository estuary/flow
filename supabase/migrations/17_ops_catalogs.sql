-- Adds the ops_catalog_template and functions for publishing ops catalogs for each tenant.

create table ops_catalog_template (
	id flowid not null primary key check (id = '00:00:00:00:00:00:00:00'::flowid),

	bundled_catalog json not null
);

comment on table ops_catalog_template is
'This table contains a single value, which is the template that is used to publish ops catalogs for each tenant';

comment on column ops_catalog_template.id is
'The id is always the constant 00:00:00:00:00:00:00:00, which is just used to ensure that there is always at most one row';

comment on column ops_catalog_template.bundled_catalog is
'The bundled Flow catalog that will be used as a template for generating the ops catalog for each tenant.
This will contain the placeholder TENANT, which will be replaced by the actual tenant name prior to publication.
The value for this is generated by running `flowctl raw bundle` on the catalog specs in the `ops-catalog/` directory.
Typically, this will actually get updated by using ops-catalog/generate-migration.sh';

create function internal.create_ops_publication(tenant_prefix text, ops_user_id uuid)
returns flowid as $$
declare
	new_draft_id flowid := internal.id_generator();
	publication_id flowid := internal.id_generator();
	ops_template json;
	
begin
	select replace(bundled_catalog::text, 'TENANT', rtrim(tenant_prefix, '/'))::json into ops_template from ops_catalog_template where id =  '00:00:00:00:00:00:00:00';

	insert into drafts (id, user_id, detail) values (new_draft_id, ops_user_id, 're-publishing ops catalog');
	
	-- Start by adding a deletion for all currently live ops catalog items.
	insert into draft_specs (id, draft_id, catalog_name, spec_type, spec)
		select
			internal.id_generator() as id,
			new_draft_id as draft_id,
			catalog_name,
			null as spec_type,
			null as spec
		from live_specs
		where catalog_name like ('ops/' || tenant_prefix || '%');

	insert into draft_specs (id, draft_id, catalog_name, spec_type, spec)
		(
		select
			internal.id_generator() as id,
			new_draft_id as draft_id,
			"key" as catalog_name,
			'capture'::catalog_spec_type as spec_type,
			value as spec
		from json_each(json_extract_path(ops_template, 'captures'))
		union all select
			internal.id_generator() as id,
			new_draft_id as draft_id,
			"key" as catalog_name,
			'collection'::catalog_spec_type as spec_type,
			value as spec
		from json_each(json_extract_path(ops_template, 'collections'))
		union all select
			internal.id_generator() as id,
			new_draft_id as draft_id,
			"key" as catalog_name,
			'materialization'::catalog_spec_type as spec_type,
			value as spec
		from json_each(json_extract_path(ops_template, 'materializations'))
		union all select
			internal.id_generator() as id,
			new_draft_id as draft_id,
			"key" as catalog_name,
			'test'::catalog_spec_type as spec_type,
			value as spec
		from json_each(json_extract_path(ops_template, 'tests'))
		)
		on conflict (draft_id, catalog_name) do update
			set spec_type = excluded.spec_type, spec = excluded.spec;

	insert into publications (id, user_id, draft_id) values (publication_id, ops_user_id, new_draft_id);
	return publication_id;
end;
$$ language plpgsql
security definer;

comment on function internal.create_ops_publication is '
Creates a new publication of the ops catalog template for a specific tenant.
This publication will include all specs from the bundled_catalog in ops_catalog_template.
Any _other_ specs under the ops/<tenant>/ prefix will be deleted by this publication.
';


create function internal.update_ops_catalog_template(bundled_catalog_arg json)
returns void as $$
begin
	insert into ops_catalog_template (id, bundled_catalog) 
		values ('00:00:00:00:00:00:00:00', bundled_catalog_arg)
		on conflict (id) do update set bundled_catalog = bundled_catalog_arg;
	return;
end;
$$ language plpgsql
security definer;

comment on function internal.update_ops_catalog_template is '
This function just makes migrations which update the ops catalog template look a little cleaner.
It just upserts the bundled catalog into ops_catalog_template.
';

create function internal.republish_all_ops_catalogs(ops_user_id uuid)
returns setof flowid as $$
declare
	current_tenant tenants;
	ops_pub_id flowid;
begin
	for current_tenant in
		select * from tenants
	loop
		ops_pub_id = internal.create_ops_publication(current_tenant.tenant, ops_user_id);
		return next ops_pub_id;
	end loop;
	return;
end;
$$ language plpgsql
security definer;

comment on function internal.republish_all_ops_catalogs is '
Creates a new publication of the most recent ops catalog template for every existing tenant in the system.
This does not wait for any of the publications to complete.
';

